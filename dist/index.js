/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 17);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/*!\n * Vue.js v2.5.13\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value e.g. [object Object]\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if a attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var options = typeof vm === 'function' && vm.cid != null\n      ? vm.options\n      : vm._isVue\n        ? vm.$options || vm.constructor.options\n        : vm || {};\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode, deep) {\n  var componentOptions = vnode.componentOptions;\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.isCloned = true;\n  if (deep) {\n    if (vnode.children) {\n      cloned.children = cloneVNodes(vnode.children, true);\n    }\n    if (componentOptions && componentOptions.children) {\n      componentOptions.children = cloneVNodes(componentOptions.children, true);\n    }\n  }\n  return cloned\n}\n\nfunction cloneVNodes (vnodes, deep) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i], deep);\n  }\n  return res\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n].forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src, keys) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n    process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'can only contain alphanumeric characters and the hyphen, ' +\n      'and must start with a letter.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\n      \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(props)) + \".\",\n      vm\n    );\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\n      \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(inject)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    // skip validation for weex recycle-list child component props\n    !(false && isObject(value) && ('@binding' in value))\n  ) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n      \" Expected \" + (expectedTypes.map(capitalize).join(', ')) +\n      \", got \" + (toRawType(value)) + \".\",\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (vm) {\n    var cur = vm;\n    while ((cur = cur.$parent)) {\n      var hooks = cur.$options.errorCaptured;\n      if (hooks) {\n        for (var i = 0; i < hooks.length; i++) {\n          try {\n            var capture = hooks[i].call(cur, err, vm, info) === false;\n            if (capture) { return }\n          } catch (e) {\n            globalHandleError(e, cur, 'errorCaptured hook');\n          }\n        }\n      }\n    }\n  }\n  globalHandleError(err, vm, info);\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      logError(e, null, 'config.errorHandler');\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  if (process.env.NODE_ENV !== 'production') {\n    warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n  }\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n/* globals MessageChannel */\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using both micro and macro tasks.\n// In < 2.4 we used micro tasks everywhere, but there are some scenarios where\n// micro tasks have too high a priority and fires in between supposedly\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\n// event (#6566). However, using macro tasks everywhere also has subtle problems\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\n// Here we use micro task by default, but expose a way to force macro task when\n// needed (e.g. in event handlers attached by v-on).\nvar microTimerFunc;\nvar macroTimerFunc;\nvar useMacroTask = false;\n\n// Determine (macro) Task defer implementation.\n// Technically setImmediate should be the ideal choice, but it's only available\n// in IE. The only polyfill that consistently queues the callback after all DOM\n// events triggered in the same loop is by using MessageChannel.\n/* istanbul ignore if */\nif (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  macroTimerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else if (typeof MessageChannel !== 'undefined' && (\n  isNative(MessageChannel) ||\n  // PhantomJS\n  MessageChannel.toString() === '[object MessageChannelConstructor]'\n)) {\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = flushCallbacks;\n  macroTimerFunc = function () {\n    port.postMessage(1);\n  };\n} else {\n  /* istanbul ignore next */\n  macroTimerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\n// Determine MicroTask defer implementation.\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  microTimerFunc = function () {\n    p.then(flushCallbacks);\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n} else {\n  // fallback to macro\n  microTimerFunc = macroTimerFunc;\n}\n\n/**\n * Wrap a function so that if any code inside triggers state change,\n * the changes are queued using a Task instead of a MicroTask.\n */\nfunction withMacroTask (fn) {\n  return fn._withTask || (fn._withTask = function () {\n    useMacroTask = true;\n    var res = fn.apply(null, arguments);\n    useMacroTask = false;\n    return res\n  })\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    if (useMacroTask) {\n      macroTimerFunc();\n    } else {\n      microTimerFunc();\n    }\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      'referenced during render. Make sure that this property is reactive, ' +\n      'either in the data option, or for class-based components, by ' +\n      'initializing the property. ' +\n      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        cloned[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, def, cur, old, event;\n  for (name in on) {\n    def = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    /* istanbul ignore if */\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                process.env.NODE_ENV !== 'production'\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once) {\n  if (once) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$off(event[i], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    if (fn) {\n      // specific handler\n      var cb;\n      var i$1 = cbs.length;\n      while (i$1--) {\n        cb = cbs[i$1];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i$1, 1);\n          break\n        }\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        try {\n          cbs[i].apply(vm, args);\n        } catch (e) {\n          handleError(e, vm, (\"event handler for \\\"\" + event + \"\\\"\"));\n        }\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n      // no need for the ref nodes after initial patch\n      // this prevents keeping a detached DOM tree in memory (#5851)\n      vm.$options._parentElm = vm.$options._refElm = null;\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((\"vue \" + name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = (parentVnode.data && parentVnode.data.attrs) || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      var hyphenatedKey = hyphenate(key);\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive(props, key, value, function () {\n        if (vm.$parent && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : userDef;\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  keyOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(keyOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    observerState.shouldConvert = false;\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive(vm, key, result[key]);\n      }\n    });\n    observerState.shouldConvert = true;\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject).filter(function (key) {\n        /* istanbul ignore next */\n        return Object.getOwnPropertyDescriptor(inject, key).enumerable\n      })\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else if (process.env.NODE_ENV !== 'production') {\n          warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n        }\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {\n        warn(\n          'slot v-bind without argument expects an Object',\n          this\n        );\n      }\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes) {\n      if (process.env.NODE_ENV !== 'production' && slotNodes._rendered) {\n        warn(\n          \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n          \"- this will likely cause render errors.\",\n          this\n        );\n      }\n      slotNodes._rendered = true;\n    }\n    nodes = slotNodes || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias,\n  eventKeyName\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (keyCodes) {\n    if (Array.isArray(keyCodes)) {\n      return keyCodes.indexOf(eventKeyCode) === -1\n    } else {\n      return keyCodes !== eventKeyCode\n    }\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var options = Ctor.options;\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () { return resolveSlots(children, parent); };\n\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm = Object.create(parent);\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = data.scopedSlots || emptyObject;\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    vnode.fnContext = contextVm;\n    vnode.fnOptions = options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n\n\n\n// Register the component hook to weex native render engine.\n// The hook will be triggered by native, not javascript.\n\n\n// Updates the state of the component to weex native render engine.\n\n/*  */\n\n// https://github.com/Hanks10100/weex-native-directive/tree/master/component\n\n// listening on native callback\n\n/*  */\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  // Weex specific: invoke recycle-list optimized @render function for\n  // extracting cell-slot template.\n  // https://github.com/Hanks10100/weex-native-directive/tree/master/component\n  /* istanbul ignore if */\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    _parentVnode: vnode,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (process.env.NODE_ENV !== 'production' &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    {\n      warn(\n        'Avoid using non-primitive value as key, ' +\n        'use string/number value instead.',\n        context\n      );\n    }\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\n    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);\n  }\n}\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // if the parent didn't update, the slot nodes will be the ones from\n      // last render. They need to be cloned to ensure \"freshness\" for this render.\n      for (var key in vm.$slots) {\n        var slot = vm.$slots[key];\n        // _rendered is a flag added by renderSlot, but may not be present\n        // if the slot is passed from manually written render functions\n        if (slot._rendered || (slot[0] && slot[0].elm)) {\n          vm.$slots[key] = cloneVNodes(slot, true /* deep */);\n        }\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production' && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && type === 'component') {\n          validateComponentName(id);\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache, key, this$1.keys);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.5.13';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove () {\n      if (--remove.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove.listeners = listeners;\n    return remove\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (ref$$1.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (process.env.NODE_ENV !== 'production') {\n        checkDuplicateKeys(children);\n      }\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setAttribute(vnode.elm, i, '');\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false\n      }\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n      /* istanbul ignore if */\n      if (\n        isIE && !isIE9 &&\n        el.tagName === 'TEXTAREA' &&\n        key === 'placeholder' && !el.__ieph\n      ) {\n        var blocker = function (e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n        el.addEventListener('input', blocker);\n        // $flow-disable-line\n        el.__ieph = true; /* IE placeholder patched */\n      }\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n  el.plain = false;\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n  el.plain = false;\n}\n\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr (el, name, value) {\n  el.attrsMap[name] = value;\n  el.attrsList.push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n  el.plain = false;\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  modifiers = modifiers || emptyObject;\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    process.env.NODE_ENV !== 'production' && warn &&\n    modifiers.prevent && modifiers.passive\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.'\n    );\n  }\n\n  // check capture modifier\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n\n  // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n  if (name === 'click') {\n    if (modifiers.right) {\n      name = 'contextmenu';\n      delete modifiers.right;\n    } else if (modifiers.middle) {\n      name = 'mouseup';\n    }\n  }\n\n  var events;\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = { value: value };\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr (\n  el,\n  name,\n  removeFromMap\n) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var res = parseModel(value);\n  if (res.key === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\n\n\nfunction parseModel (val) {\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      }\n    } else {\n      return {\n        exp: val,\n        key: null\n      }\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n    \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n      trueValueBinding === 'true'\n        ? (\":(\" + value + \")\")\n        : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n    )\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + value + \"=$$a.concat([$$v]))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n\n  // warn if v-bind:value conflicts with v-model\n  if (process.env.NODE_ENV !== 'production') {\n    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n    if (value$1) {\n      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n      warn$1(\n        binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n        'because the latter already expands to a value binding internally'\n      );\n    }\n  }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler (handler, event, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  handler = withMacroTask(handler);\n  if (once$$1) { handler = createOnceHandler(handler, event, capture); }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    event,\n    handler._withTask || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.lazy) {\n      // inputs with lazy should only be updated when not in focus\n      return false\n    }\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def) {\n  if (!def) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def === 'object') {\n    var res = {};\n    if (def.css !== false) {\n      extend(res, autoCssTransition(def.name || 'v'));\n    }\n    extend(res, def);\n    return res\n  } else if (typeof def === 'string') {\n    return autoCssTransition(def)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nVue$3.nextTick(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n    config.productionTip !== false &&\n    inBrowser && typeof console !== 'undefined'\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\n\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    rawTokens.push({ '@binding': exp });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var res = parseText(staticClass, options.delimiters);\n    if (res) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var res = parseText(staticStyle, options.delimiters);\n      if (res) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp((\"^<\" + qnameCapture));\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n          (i > pos || !tagName) &&\n          options.warn\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(he.decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n\n\nfunction createASTElement (\n  tag,\n  attrs,\n  parent\n) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    parent: parent,\n    children: []\n  }\n}\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function closeElement (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n    // apply post-transforms\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        // element-scope stuff\n        processElement(element, options);\n      }\n\n      function checkRootConstraints (el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production') {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      closeElement(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var res;\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    },\n    comment: function comment (text) {\n      currentParent.children.push({\n        type: 3,\n        text: text,\n        isComment: true\n      });\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement (element, options) {\n  processKey(element);\n\n  // determine whether this is a plain element after\n  // removing structural attributes\n  element.plain = !element.key && !element.attrsList.length;\n\n  processRef(element);\n  processSlot(element);\n  processComponent(element);\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n  processAttrs(element);\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var res = parseFor(exp);\n    if (res) {\n      extend(el, res);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n    }\n  }\n}\n\nfunction parseFor (exp) {\n  var inMatch = exp.match(forAliasRE);\n  if (!inMatch) { return }\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '');\n    res.iterator1 = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n  return res\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotScope;\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && slotScope) {\n        warn$2(\n          \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n          \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n          \"can also be used on plain elements in addition to <template> to \" +\n          \"denote scoped slots.\",\n          true\n        );\n      }\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && el.attrsMap['v-for']) {\n        warn$2(\n          \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n          \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n          \"scoped slot to make it clearer.\",\n          true\n        );\n      }\n      el.slotScope = slotScope;\n    }\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget);\n      }\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var res = parseText(value, delimiters);\n        if (res) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n      // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n      if (!el.component &&\n          name === 'muted' &&\n          platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true');\n      }\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      map[attrs[i].name] && !isIE && !isEdge\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\n/**\n * Expand input[v-model] with dyanmic type bindings into v-if-else chains\n * Turn this:\n *   <input v-model=\"data[type]\" :type=\"type\">\n * into this:\n *   <input v-if=\"type === 'checkbox'\" type=\"checkbox\" v-model=\"data[type]\">\n *   <input v-else-if=\"type === 'radio'\" type=\"radio\" v-model=\"data[type]\">\n *   <input v-else :type=\"type\" v-model=\"data[type]\">\n */\n\nfunction preTransformNode (el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n    if (map['v-model'] && (map['v-bind:type'] || map[':type'])) {\n      var typeBinding = getBindingAttr(el, 'type');\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n      // 1. checkbox\n      var branch0 = cloneASTElement(el);\n      // process for on the main node\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      });\n      // 2. add radio else-if condition\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      });\n      // 3. other\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0\n    }\n  }\n}\n\nfunction cloneASTElement (el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n}\n\nvar model$2 = {\n  preTransformNode: preTransformNode\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1,\n  model$2\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value\n    }\n    /* istanbul ignore if */\n    return (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = (handler.modifiers);\n        genModifierCode += genGuard(\n          ['ctrl', 'shift', 'alt', 'meta']\n            .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n            .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n            .join('||')\n        );\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    /* istanbul ignore if */\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var code = keyCodes[key];\n  return (\n    \"_k($event.keyCode,\" +\n    (JSON.stringify(key)) + \",\" +\n    (JSON.stringify(code)) + \",\" +\n    \"$event.key)\"\n  )\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data = el.plain ? undefined : genData$2(el, state);\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && state.warn(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (process.env.NODE_ENV !== 'production' &&\n    state.maybeComponent(el) &&\n    el.tag !== 'slot' &&\n    el.tag !== 'template' &&\n    !el.key\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, state.warn)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, state.warn)) + \",\";\n  }\n  // slot target\n  // only for non-scoped slots\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length !== 1 || ast.type !== 1\n  )) {\n    state.warn('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  slots,\n  state\n) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) {\n      return genScopedSlot(key, slots[key], state)\n    }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (\n  key,\n  el,\n  state\n) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el, state)\n  }\n  var fn = \"function(\" + (String(el.slotScope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? el.if\n        ? ((el.if) + \"?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n        : genChildren(el, state) || 'undefined'\n      : genElement(el, state)) + \"}\";\n  return (\"{key:\" + key + \",fn:\" + fn + \"}\")\n}\n\nfunction genForScopedSlot (\n  key,\n  el,\n  state\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el, state)) +\n    '})'\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return (altGenElement || genElement)(el$1, state)\n    }\n    var normalizationType = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    /* istanbul ignore if */\n    {\n      res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n    }\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (\n  ident,\n  type,\n  text,\n  errors\n) {\n  if (typeof ident === 'string') {\n    try {\n      new Function((\"var \" + ident + \"=_\"));\n    } catch (e) {\n      errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n    }\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim())\n      );\n    } else {\n      errors.push(\n        \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n        \"    \" + exp + \"\\n\\n\" +\n        \"  Raw expression: \" + (text.trim()) + \"\\n\"\n      );\n    }\n  }\n}\n\n/*  */\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn$$1(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn$$1(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn$$1(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n      finalOptions.warn = function (msg, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      var compiled = baseCompile(template, finalOptions);\n      if (process.env.NODE_ENV !== 'production') {\n        errors.push.apply(errors, detectErrors(compiled.ast));\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nvar div;\nfunction getShouldDecode (href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0\n}\n\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vue$3);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(15).setImmediate))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanM/NjVkNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQsc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpQ0FBaUMsRUFBRTtBQUNyRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjOztBQUUzQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pELGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEMsK0JBQStCO0FBQy9CO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCLFdBQVc7QUFDWDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0IsRUFBRTs7QUFFcEQ7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUMscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QjtBQUN6QjtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx3Q0FBd0MsMkJBQTJCLEVBQUU7QUFDckUsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLDRCQUE0QixFQUFFO0FBQ3RFO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLHNCQUFzQjs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQsNEJBQTRCLGdDQUFnQztBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUI7QUFDM0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEMsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCLEVBQUU7QUFDM0UsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsK0JBQStCLEVBQUU7QUFDOUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhOztBQUUzRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHFDQUFxQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1Q0FBdUMsRUFBRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkNBQTJDLEVBQUU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLDhCQUE4QixFQUFFO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLHVDQUF1QyxFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhCQUE4QjtBQUN2QztBQUNBLHVEQUF1RCw2REFBNkQ7QUFDcEgsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTyw0QkFBNEI7QUFDbkM7QUFDQTtBQUNBLE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0IsRUFBRTtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuNS4xM1xuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlIGUuZy4gW29iamVjdCBPYmplY3RdXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqL1xuZnVuY3Rpb24gYmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCBmbiBsZW5ndGhcbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKVxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCcsXG4gICdlcnJvckNhcHR1cmVkJ1xuXTtcblxuLyogICovXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICA/IHZtLm9wdGlvbnNcbiAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xuICAgICAgICA6IHZtIHx8IHt9O1xuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSwgZGVlcCkge1xuICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICBjb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIGlmIChkZWVwKSB7XG4gICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICBjbG9uZWQuY2hpbGRyZW4gPSBjbG9uZVZOb2Rlcyh2bm9kZS5jaGlsZHJlbiwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPcHRpb25zICYmIGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4pIHtcbiAgICAgIGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4gPSBjbG9uZVZOb2Rlcyhjb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzLCBkZWVwKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSwgZGVlcCk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1tcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG4gKi9cbnZhciBvYnNlcnZlclN0YXRlID0ge1xuICBzaG91bGRDb252ZXJ0OiB0cnVlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbFxufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgLy8gc2tpcCB2YWxpZGF0aW9uIGZvciB3ZWV4IHJlY3ljbGUtbGlzdCBjaGlsZCBjb21wb25lbnQgcHJvcHNcbiAgICAhKGZhbHNlICYmIGlzT2JqZWN0KHZhbHVlKSAmJiAoJ0BiaW5kaW5nJyBpbiB2YWx1ZSkpXG4gICkge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKSArXG4gICAgICBcIiwgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmICh2bSkge1xuICAgIHZhciBjdXIgPSB2bTtcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTWVzc2FnZUNoYW5uZWwgKi9cblxudmFyIGNhbGxiYWNrcyA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgYm90aCBtaWNybyBhbmQgbWFjcm8gdGFza3MuXG4vLyBJbiA8IDIuNCB3ZSB1c2VkIG1pY3JvIHRhc2tzIGV2ZXJ5d2hlcmUsIGJ1dCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Mgd2hlcmVcbi8vIG1pY3JvIHRhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZXMgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTApIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZVxuLy8gZXZlbnQgKCM2NTY2KS4gSG93ZXZlciwgdXNpbmcgbWFjcm8gdGFza3MgZXZlcnl3aGVyZSBhbHNvIGhhcyBzdWJ0bGUgcHJvYmxlbXNcbi8vIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludCAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEhlcmUgd2UgdXNlIG1pY3JvIHRhc2sgYnkgZGVmYXVsdCwgYnV0IGV4cG9zZSBhIHdheSB0byBmb3JjZSBtYWNybyB0YXNrIHdoZW5cbi8vIG5lZWRlZCAoZS5nLiBpbiBldmVudCBoYW5kbGVycyBhdHRhY2hlZCBieSB2LW9uKS5cbnZhciBtaWNyb1RpbWVyRnVuYztcbnZhciBtYWNyb1RpbWVyRnVuYztcbnZhciB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcblxuLy8gRGV0ZXJtaW5lIChtYWNybykgVGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cbi8vIFRlY2huaWNhbGx5IHNldEltbWVkaWF0ZSBzaG91bGQgYmUgdGhlIGlkZWFsIGNob2ljZSwgYnV0IGl0J3Mgb25seSBhdmFpbGFibGVcbi8vIGluIElFLiBUaGUgb25seSBwb2x5ZmlsbCB0aGF0IGNvbnNpc3RlbnRseSBxdWV1ZXMgdGhlIGNhbGxiYWNrIGFmdGVyIGFsbCBET01cbi8vIGV2ZW50cyB0cmlnZ2VyZWQgaW4gdGhlIHNhbWUgbG9vcCBpcyBieSB1c2luZyBNZXNzYWdlQ2hhbm5lbC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE1lc3NhZ2VDaGFubmVsKSB8fFxuICAvLyBQaGFudG9tSlNcbiAgTWVzc2FnZUNoYW5uZWwudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTWVzc2FnZUNoYW5uZWxDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaENhbGxiYWNrcztcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZSgxKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xuICB9O1xufVxuXG4vLyBEZXRlcm1pbmUgTWljcm9UYXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBtaWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIGZhbGxiYWNrIHRvIG1hY3JvXG4gIG1pY3JvVGltZXJGdW5jID0gbWFjcm9UaW1lckZ1bmM7XG59XG5cbi8qKlxuICogV3JhcCBhIGZ1bmN0aW9uIHNvIHRoYXQgaWYgYW55IGNvZGUgaW5zaWRlIHRyaWdnZXJzIHN0YXRlIGNoYW5nZSxcbiAqIHRoZSBjaGFuZ2VzIGFyZSBxdWV1ZWQgdXNpbmcgYSBUYXNrIGluc3RlYWQgb2YgYSBNaWNyb1Rhc2suXG4gKi9cbmZ1bmN0aW9uIHdpdGhNYWNyb1Rhc2sgKGZuKSB7XG4gIHJldHVybiBmbi5fd2l0aFRhc2sgfHwgKGZuLl93aXRoVGFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICB1c2VNYWNyb1Rhc2sgPSB0cnVlO1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuICAgIHJldHVybiByZXNcbiAgfSlcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgdmFyIF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICBpZiAodXNlTWFjcm9UYXNrKSB7XG4gICAgICBtYWNyb1RpbWVyRnVuYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWNyb1RpbWVyRnVuYygpO1xuICAgIH1cbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsb25lZFtpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkuY29udGV4dHMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZXh0cyA9IGZhY3RvcnkuY29udGV4dHMgPSBbY29udGV4dF07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29udGV4dHNbaV0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgZm9yICh2YXIgbmFtZSQxIGluIHNsb3RzKSB7XG4gICAgaWYgKHNsb3RzW25hbWUkMV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1tmbnNbaV0ua2V5XSA9IGZuc1tpXS5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwgbnVsbCwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IChwYXJlbnRWbm9kZS5kYXRhICYmIHBhcmVudFZub2RlLmRhdGEuYXR0cnMpIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuICB9XG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zLFxuICBpc1JlbmRlcldhdGNoZXJcbikge1xuICB0aGlzLnZtID0gdm07XG4gIGlmIChpc1JlbmRlcldhdGNoZXIpIHtcbiAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gIH1cbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcbiAgdGFyZ2V0LFxuICBrZXksXG4gIHVzZXJEZWZcbikge1xuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgIDogdXNlckRlZjtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGtleU9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGtleU9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluamVjdCwga2V5KS5lbnVtZXJhYmxlXG4gICAgICB9KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3ROb2Rlcy5fcmVuZGVyZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIG5vZGVzID0gc2xvdE5vZGVzIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5BbGlhcyxcbiAgZXZlbnRLZXlOYW1lXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoa2V5Q29kZXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gICAgfVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpOyB9O1xuXG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBkYXRhLnNjb3BlZFNsb3RzIHx8IGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICAgIHZub2RlLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgKHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cblxuXG5cbi8vIFJlZ2lzdGVyIHRoZSBjb21wb25lbnQgaG9vayB0byB3ZWV4IG5hdGl2ZSByZW5kZXIgZW5naW5lLlxuLy8gVGhlIGhvb2sgd2lsbCBiZSB0cmlnZ2VyZWQgYnkgbmF0aXZlLCBub3QgamF2YXNjcmlwdC5cblxuXG4vLyBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50IHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXG5cbi8qICAqL1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vSGFua3MxMDEwMC93ZWV4LW5hdGl2ZS1kaXJlY3RpdmUvdHJlZS9tYXN0ZXIvY29tcG9uZW50XG5cbi8vIGxpc3RlbmluZyBvbiBuYXRpdmUgY2FsbGJhY2tcblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICAvLyBXZWV4IHNwZWNpZmljOiBpbnZva2UgcmVjeWNsZS1saXN0IG9wdGltaXplZCBAcmVuZGVyIGZ1bmN0aW9uIGZvclxuICAvLyBleHRyYWN0aW5nIGNlbGwtc2xvdCB0ZW1wbGF0ZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0hhbmtzMTAxMDAvd2VleC1uYXRpdmUtZGlyZWN0aXZlL3RyZWUvbWFzdGVyL2NvbXBvbmVudFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoaXNVbmRlZihjaGlsZC5ucykgfHwgaXNUcnVlKGZvcmNlKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBpZiB0aGUgcGFyZW50IGRpZG4ndCB1cGRhdGUsIHRoZSBzbG90IG5vZGVzIHdpbGwgYmUgdGhlIG9uZXMgZnJvbVxuICAgICAgLy8gbGFzdCByZW5kZXIuIFRoZXkgbmVlZCB0byBiZSBjbG9uZWQgdG8gZW5zdXJlIFwiZnJlc2huZXNzXCIgZm9yIHRoaXMgcmVuZGVyLlxuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2YXIgc2xvdCA9IHZtLiRzbG90c1trZXldO1xuICAgICAgICAvLyBfcmVuZGVyZWQgaXMgYSBmbGFnIGFkZGVkIGJ5IHJlbmRlclNsb3QsIGJ1dCBtYXkgbm90IGJlIHByZXNlbnRcbiAgICAgICAgLy8gaWYgdGhlIHNsb3QgaXMgcGFzc2VkIGZyb20gbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zXG4gICAgICAgIGlmIChzbG90Ll9yZW5kZXJlZCB8fCAoc2xvdFswXSAmJiBzbG90WzBdLmVsbSkpIHtcbiAgICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHNsb3QsIHRydWUgLyogZGVlcCAqLyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDEgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQxKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgdmFyIHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSQzKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSQzKTtcbnN0YXRlTWl4aW4oVnVlJDMpO1xuZXZlbnRzTWl4aW4oVnVlJDMpO1xubGlmZWN5Y2xlTWl4aW4oVnVlJDMpO1xucmVuZGVyTWl4aW4oVnVlJDMpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgdmFyIGNhY2hlID0ga2VlcEFsaXZlSW5zdGFuY2UuY2FjaGU7XG4gIHZhciBrZXlzID0ga2VlcEFsaXZlSW5zdGFuY2Uua2V5cztcbiAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAoXG4gIGNhY2hlLFxuICBrZXksXG4gIGtleXMsXG4gIGN1cnJlbnRcbikge1xuICB2YXIgY2FjaGVkJCQxID0gY2FjaGVba2V5XTtcbiAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGUsIGtleSwgdGhpcyQxLmtleXMpO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlJDMpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuVnVlJDMudmVyc2lvbiA9ICcyLjUuMTMnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobm9kZSwga2V5LCB2YWwpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgbmVzdGVkKSB7XG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChyZWYkJDEucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFxuICAgICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiAhZWwuX19pZXBoXG4gICAgICApIHtcbiAgICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICAgIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG5mdW5jdGlvbiBhZGRSYXdBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcbiAgZWwuYXR0cnNMaXN0LnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBtb2RpZmllcnNcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FyblxuKSB7XG4gIG1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBlbXB0eU9iamVjdDtcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuICYmXG4gICAgbW9kaWZpZXJzLnByZXZlbnQgJiYgbW9kaWZpZXJzLnBhc3NpdmVcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdwYXNzaXZlIGFuZCBwcmV2ZW50IGNhblxcJ3QgYmUgdXNlZCB0b2dldGhlci4gJyArXG4gICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gIH1cbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSAnficgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBvbmNlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gJyYnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgcGFzc2l2ZVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgIGlmIChtb2RpZmllcnMucmlnaHQpIHtcbiAgICAgIG5hbWUgPSAnY29udGV4dG1lbnUnO1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5yaWdodDtcbiAgICB9IGVsc2UgaWYgKG1vZGlmaWVycy5taWRkbGUpIHtcbiAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUgfTtcbiAgaWYgKG1vZGlmaWVycyAhPT0gZW1wdHlPYmplY3QpIHtcbiAgICBuZXdIYW5kbGVyLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgfVxuXG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxuXG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG4vLyBub3RlOiB0aGlzIG9ubHkgcmVtb3ZlcyB0aGUgYXR0ciBmcm9tIHRoZSBBcnJheSAoYXR0cnNMaXN0KSBzbyB0aGF0IGl0XG4vLyBkb2Vzbid0IGdldCBwcm9jZXNzZWQgYnkgcHJvY2Vzc0F0dHJzLlxuLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4vLyBuZWVkZWQgZHVyaW5nIGNvZGVnZW4uXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJlbW92ZUZyb21NYXBcbikge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZUZyb21NYXApIHtcbiAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAocmVzLmV4cCkgKyBcIiwgXCIgKyAocmVzLmtleSkgKyBcIiwgXCIgKyBhc3NpZ25tZW50ICsgXCIpXCIpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogUG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3Rba2V5XVxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gKlxuICovXG5cbnZhciBsZW47XG52YXIgc3RyO1xudmFyIGNocjtcbnZhciBpbmRleCQxO1xudmFyIGV4cHJlc3Npb25Qb3M7XG52YXIgZXhwcmVzc2lvbkVuZFBvcztcblxuXG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5jb25jYXQoWyQkdl0pKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgaWYgKHZhbHVlJDEpIHtcbiAgICAgIHZhciBiaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddID8gJ3YtYmluZDp2YWx1ZScgOiAnOnZhbHVlJztcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYmluZGluZyArIFwiPVxcXCJcIiArIHZhbHVlJDEgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggdi1tb2RlbCBvbiB0aGUgc2FtZSBlbGVtZW50IFwiICtcbiAgICAgICAgJ2JlY2F1c2UgdGhlIGxhdHRlciBhbHJlYWR5IGV4cGFuZHMgdG8gYSB2YWx1ZSBiaW5kaW5nIGludGVybmFsbHknXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlcikge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChoYW5kbGVyLCBldmVudCwgY2FwdHVyZSkge1xuICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSQkMSxcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIGhhbmRsZXIgPSB3aXRoTWFjcm9UYXNrKGhhbmRsZXIpO1xuICBpZiAob25jZSQkMSkgeyBoYW5kbGVyID0gY3JlYXRlT25jZUhhbmRsZXIoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpOyB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlci5fd2l0aFRhc2sgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICBpZiAobW9kaWZpZXJzLmxhenkpIHtcbiAgICAgIC8vIGlucHV0cyB3aXRoIGxhenkgc2hvdWxkIG9ubHkgYmUgdXBkYXRlZCB3aGVuIG5vdCBpbiBmb2N1c1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciBlbXB0eVN0eWxlO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZikge1xuICBpZiAoIWRlZikge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZi5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlclxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgOiBzZXRUaW1lb3V0XG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIGlmICghaXNBbmRyb2lkKSB7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50IGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUkMy5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlJDMuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUkMy5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlJDMub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUkMy5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5WdWUkMy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICApIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXG4pKz8pXFx9XFx9L2c7XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciByYXdUb2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgcmF3VG9rZW5zLnB1c2goeyAnQGJpbmRpbmcnOiBleHAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSk7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICB0b2tlbnM6IHJhd1Rva2Vuc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LidcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxudmFyIGhlID0ge1xuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xuICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcbi8vIGJ1dCBmb3IgVnVlIHRlbXBsYXRlcyB3ZSBjYW4gZW5mb3JjZSBhIHNpbXBsZSBjaGFyc2V0XG52YXIgbmNuYW1lID0gJ1thLXpBLVpfXVtcXFxcd1xcXFwtXFxcXC5dKic7XG52YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoKFwiXjxcIiArIHFuYW1lQ2FwdHVyZSkpO1xudmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG52YXIgY29tbWVudCA9IC9ePCEtLS87XG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbnZhciBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZmFsc2U7XG4neCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGcgPT09ICcnO1xufSk7XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHJlQ2FjaGUgPSB7fTtcblxudmFyIGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nLFxuICAnJiM5Oyc6ICdcXHQnXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcCk7L2c7XG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMxMHwjOSk7L2c7XG5cbi8vICM1OTkyXG52YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gZnVuY3Rpb24gKHRhZywgaHRtbCkgeyByZXR1cm4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nOyB9O1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUobGFzdFRhZywgaHRtbCkpIHtcbiAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgaHRtbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgcmVzdCQxID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0JDE7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgLy8gaGFja2lzaCB3b3JrIGFyb3VuZCBGRiBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY5Nzc4XG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG4gICAgICAgIGlmIChhcmdzWzRdID09PSAnJykgeyBkZWxldGUgYXJnc1s0XTsgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKC4qPylcXHMrKD86aW58b2YpXFxzKyguKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG52YXIgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF52LWJpbmQ6LztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5cblxuXG5mdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50IChcbiAgdGFnLFxuICBhdHRycyxcbiAgcGFyZW50XG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxLFxuICAgIHRhZzogdGFnLFxuICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG5cbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2cpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlRWxlbWVudCAoZWxlbWVudCkge1xuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIC8vIGVsZW1lbnQtc2NvcGUgc3R1ZmZcbiAgICAgICAgcHJvY2Vzc0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgfSBlbHNlIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAocmVzID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHJlcy5leHByZXNzaW9uLFxuICAgICAgICAgICAgdG9rZW5zOiByZXMudG9rZW5zLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCkge1xuICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdHlwZTogMyxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbCA9IGVsLmF0dHJzTGlzdC5sZW5ndGg7XG4gIGlmIChsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGVsLmF0dHJzTGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChlbGVtZW50LCBvcHRpb25zKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWVsZW1lbnQuYXR0cnNMaXN0Lmxlbmd0aDtcblxuICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGV4dGVuZChlbCwgcmVzKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cClcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHJlcy5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJyk7XG4gICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICByZXMuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDIoXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzbG90U2NvcGU7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3RTY29wZSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0aGUgXFxcInNjb3BlXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXCIgK1xuICAgICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcbiAgICAgICAgICBcImNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBcIiArXG4gICAgICAgICAgXCJkZW5vdGUgc2NvcGVkIHNsb3RzLlwiLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICAgIH0gZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgICB9XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpc1Byb3A7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wKSB7XG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3AgfHwgKFxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIEV4cGFuZCBpbnB1dFt2LW1vZGVsXSB3aXRoIGR5YW5taWMgdHlwZSBiaW5kaW5ncyBpbnRvIHYtaWYtZWxzZSBjaGFpbnNcbiAqIFR1cm4gdGhpczpcbiAqICAgPGlucHV0IHYtbW9kZWw9XCJkYXRhW3R5cGVdXCIgOnR5cGU9XCJ0eXBlXCI+XG4gKiBpbnRvIHRoaXM6XG4gKiAgIDxpbnB1dCB2LWlmPVwidHlwZSA9PT0gJ2NoZWNrYm94J1wiIHR5cGU9XCJjaGVja2JveFwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKiAgIDxpbnB1dCB2LWVsc2UtaWY9XCJ0eXBlID09PSAncmFkaW8nXCIgdHlwZT1cInJhZGlvXCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqICAgPGlucHV0IHYtZWxzZSA6dHlwZT1cInR5cGVcIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICovXG5cbmZ1bmN0aW9uIHByZVRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcbiAgICB2YXIgbWFwID0gZWwuYXR0cnNNYXA7XG4gICAgaWYgKG1hcFsndi1tb2RlbCddICYmIChtYXBbJ3YtYmluZDp0eXBlJ10gfHwgbWFwWyc6dHlwZSddKSkge1xuICAgICAgdmFyIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDIgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDJcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsOiBtb2RlbCxcbiAgdGV4dDogdGV4dCxcbiAgaHRtbDogaHRtbFxufTtcblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eXFxzKltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPyddfFxcW1wiLio/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqXFxzKiQvO1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcbiAgZXZlbnRzLFxuICBpc05hdGl2ZSxcbiAgd2FyblxuKSB7XG4gIHZhciByZXMgPSBpc05hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgZXZlbnRzW25hbWVdKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcbiAgbmFtZSxcbiAgaGFuZGxlclxuKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIudmFsdWVcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gZ2VuR3VhcmQoXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAhbW9kaWZpZXJzW2tleU1vZGlmaWVyXTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAoXCIkZXZlbnQuXCIgKyBrZXlNb2RpZmllciArIFwiS2V5XCIpOyB9KVxuICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gaGFuZGxlci52YWx1ZSArICcoJGV2ZW50KSdcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCIoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBjb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgcmV0dXJuIChcbiAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcIixcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGNvZGUpKSArIFwiLFwiICtcbiAgICBcIiRldmVudC5rZXkpXCJcbiAgKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xuICAgIHdhcm4oXCJ2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuXCIpO1xuICB9XG4gIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbjogb24sXG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn07XG5cbi8qICAqL1xuXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICB0aGlzLm9uY2VJZCA9IDA7XG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG59O1xuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgdmFyIGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIikpO1xuICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUud2FybihcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCIsXCIgKyAoc3RhdGUub25jZUlkKyspICsgXCIsXCIgKyBrZXkgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxuICBjb25kaXRpb25zLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBhbHRHZW5cbiAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgIDogZWwub25jZVxuICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxuICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRIZWxwZXJcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICFlbC5rZXlcbiAgKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczp7XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBcImRvbVByb3BzOntcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChlbC5ldmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIC8vIHYtb24gZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgZGF0YSA9IGVsLndyYXBMaXN0ZW5lcnMoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsLCBzdGF0ZSkge1xuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHN0YXRlLndhcm4oJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xuICB9XG4gIGlmIChhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgc3RhdGVcbikge1xuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldLCBzdGF0ZSlcbiAgICB9KS5qb2luKCcsJykpICsgXCJdKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSlcbiAgfVxuICB2YXIgZm4gPSBcImZ1bmN0aW9uKFwiICsgKFN0cmluZyhlbC5zbG90U2NvcGUpKSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmXG4gICAgICAgID8gKChlbC5pZikgKyBcIj9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICByZXR1cm4gKFwie2tleTpcIiArIGtleSArIFwiLGZuOlwiICsgZm4gKyBcIn1cIilcbn1cblxuZnVuY3Rpb24gZ2VuRm9yU2NvcGVkU2xvdCAoXG4gIGtleSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgZWwkMS5mb3IgJiZcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgKSB7XG4gICAgICByZXR1cm4gKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpXG4gICAgfVxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgdmFyIGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUpIDogJycpKVxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gIGNoaWxkcmVuLFxuICBtYXliZUNvbXBvbmVudFxuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gIH0gaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgcmV0dXJuIChcIl9lKFwiICsgKEpTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyAmJiAoXCJ7XCIgKyAoZWwuYXR0cnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiAoKGNhbWVsaXplKGEubmFtZSkpICsgXCI6XCIgKyAoYS52YWx1ZSkpOyB9KS5qb2luKCcsJykpICsgXCJ9XCIpO1xuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICByZXMgKz0gXCIsbnVsbFwiO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBcIixcIiArIGF0dHJzO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICBjb21wb25lbnROYW1lLFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YSQyKGVsLCBzdGF0ZSkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCkge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCBlcnJvcnMpO1xuICB9XG4gIHJldHVybiBlcnJvcnNcbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCBlcnJvcnMpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgZXJyb3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIGVycm9ycykge1xuICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgdmFyIGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXG4gIGlkZW50LFxuICB0eXBlLFxuICB0ZXh0LFxuICBlcnJvcnNcbikge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiXFxuICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgICAgXCIgIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkgKyBcIlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbnZhciBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG59XG5cbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZSQzLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZSQzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzP2RhMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYzs7QUFFbEU7QUFDQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(6);\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(13)(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {\n\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./index.scss\", function() {\n\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./index.scss\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguc2Nzcz9kOWNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBLEVBQUU7O0FBRUYsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vaW5kZXguc2Nzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9pbmRleC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9pbmRleC5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW5kZXguc2Nzc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nfunction injectStyle (ssrContext) {\n  if (disposed) return\n  __webpack_require__(24)\n}\nvar Component = __webpack_require__(21)(\n  /* script */\n  __webpack_require__(16),\n  /* template */\n  __webpack_require__(22),\n  /* styles */\n  injectStyle,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"C:\\\\Users\\\\israel\\\\Documents\\\\GitHub\\\\draggable-demo\\\\src\\\\components\\\\app\\\\app.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] app.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-29ca5193\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-29ca5193\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9hcHAvYXBwLnZ1ZT83MTU1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1TDtBQUN2TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQTBIO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0RBQXNELElBQUk7QUFDekksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMjljYTUxOTNcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzYXNzLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2FwcC52dWVcIilcbn1cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIXRzLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2FwcC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTI5Y2E1MTkzXFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2FwcC52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBpbmplY3RTdHlsZSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJDOlxcXFxVc2Vyc1xcXFxpc3JhZWxcXFxcRG9jdW1lbnRzXFxcXEdpdEh1YlxcXFxkcmFnZ2FibGUtZGVtb1xcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxhcHBcXFxcYXBwLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gYXBwLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yOWNhNTE5M1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTI5Y2E1MTkzXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9hcHAvYXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

eval("var escape = __webpack_require__(8);\nexports = module.exports = __webpack_require__(3)(false);\n// imports\n\n\n// module\nexports.push([module.i, \"html, body {\\n  height: 100%;\\n  width: 100%; }\\n\\nbody {\\n  background-image: url(\" + escape(__webpack_require__(18)) + \");\\n  background-repeat: no-repeat;\\n  background-size: cover;\\n  margin: 0;\\n  overflow: hidden; }\\n\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguc2Nzcz9mOThiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxxQ0FBc0MsaUJBQWlCLGdCQUFnQixFQUFFLFVBQVUsbUVBQStFLGlDQUFpQywyQkFBMkIsY0FBYyxxQkFBcUIsRUFBRTs7QUFFblEiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBlc2NhcGUgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanNcIik7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImh0bWwsIGJvZHkge1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgd2lkdGg6IDEwMCU7IH1cXG5cXG5ib2R5IHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi9hc3NldHMvaW1hZ2VzL2NpdHkuZ2lmXCIpKSArIFwiKTtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgbWFyZ2luOiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vc3JjL2luZGV4LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(3)(false);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n.main {\\n  display: flex;\\n  justify-content: space-around;\\n  height: 100%;\\n  width: 100%;\\n}\\n.control-group {\\n  display: flex;\\n  flex-direction: column;\\n  margin-top: 25px;\\n}\\n.control-btn {\\n  border-radius: 3px;\\n  background-color: #42b883;\\n  color: #35495e;\\n  cursor: pointer;\\n  padding: 15px;\\n  margin: 15px;\\n}\\n.draggable-container {\\n  width: 150px;\\n  height: 150px;\\n  background: white;\\n  border: 3px solid #42b883;\\n  border-radius: 3px;\\n  text-align: center;\\n  font-size: 25px;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n.container-for-draggable {\\n  background: white;\\n  border: 3px solid #42b883;\\n  border-radius: 3px;\\n  text-align: center;\\n  font-size: 25px;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  position: absolute;\\n  align-self: flex-end;\\n  width: 300px;\\n  height: 200px;\\n  bottom: 20px;\\n}\\n.draggable-with-handler {\\n  background: white;\\n  border: 3px solid #42b883;\\n  border-radius: 3px;\\n  text-align: center;\\n  font-size: 25px;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  position: absolute;\\n  align-self: flex-end;\\n  width: 300px;\\n  height: 200px;\\n  bottom: 20px;\\n  left: 20px;\\n}\\n.handler {\\n  padding: 5px;\\n  position: absolute;\\n  top: 0;\\n  left: 70px;\\n  margin-top: -45px;\\n  background: white;\\n  border: 3px solid #42b883;\\n  border-radius: 3px;\\n  text-align: center;\\n  font-size: 25px;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n.draggable-with-reset {\\n  background: white;\\n  border: 3px solid #42b883;\\n  border-radius: 3px;\\n  text-align: center;\\n  font-size: 25px;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  position: absolute;\\n  align-self: flex-end;\\n  width: 300px;\\n  height: 200px;\\n  bottom: 20px;\\n  right: 20px;\\n}\\n.autor {\\n  align-self: flex-start;\\n  margin-top: 25px;\\n  margin-bottom: 20px;\\n  padding: 10px;\\n  border-radius: 3px;\\n  color: #42b883;\\n  background-color: #35495e;\\n  font-size: 25px;\\n  font-weight: bolder;\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9hcHAvYXBwLnZ1ZT81YzgwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0Esa0NBQW1DLGtCQUFrQixrQ0FBa0MsaUJBQWlCLGdCQUFnQixHQUFHLGtCQUFrQixrQkFBa0IsMkJBQTJCLHFCQUFxQixHQUFHLGdCQUFnQix1QkFBdUIsOEJBQThCLG1CQUFtQixvQkFBb0Isa0JBQWtCLGlCQUFpQixHQUFHLHdCQUF3QixpQkFBaUIsa0JBQWtCLHNCQUFzQiw4QkFBOEIsdUJBQXVCLHVCQUF1QixvQkFBb0Isa0JBQWtCLDRCQUE0Qix3QkFBd0IsR0FBRyw0QkFBNEIsc0JBQXNCLDhCQUE4Qix1QkFBdUIsdUJBQXVCLG9CQUFvQixrQkFBa0IsNEJBQTRCLHdCQUF3Qix1QkFBdUIseUJBQXlCLGlCQUFpQixrQkFBa0IsaUJBQWlCLEdBQUcsMkJBQTJCLHNCQUFzQiw4QkFBOEIsdUJBQXVCLHVCQUF1QixvQkFBb0Isa0JBQWtCLDRCQUE0Qix3QkFBd0IsdUJBQXVCLHlCQUF5QixpQkFBaUIsa0JBQWtCLGlCQUFpQixlQUFlLEdBQUcsWUFBWSxpQkFBaUIsdUJBQXVCLFdBQVcsZUFBZSxzQkFBc0Isc0JBQXNCLDhCQUE4Qix1QkFBdUIsdUJBQXVCLG9CQUFvQixrQkFBa0IsNEJBQTRCLHdCQUF3QixHQUFHLHlCQUF5QixzQkFBc0IsOEJBQThCLHVCQUF1Qix1QkFBdUIsb0JBQW9CLGtCQUFrQiw0QkFBNEIsd0JBQXdCLHVCQUF1Qix5QkFBeUIsaUJBQWlCLGtCQUFrQixpQkFBaUIsZ0JBQWdCLEdBQUcsVUFBVSwyQkFBMkIscUJBQXFCLHdCQUF3QixrQkFBa0IsdUJBQXVCLG1CQUFtQiw4QkFBOEIsb0JBQW9CLHdCQUF3QixrQkFBa0IsMkJBQTJCLDRCQUE0Qix3QkFBd0IsR0FBRzs7QUFFcnBFIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5tYWluIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG4uY29udHJvbC1ncm91cCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIG1hcmdpbi10b3A6IDI1cHg7XFxufVxcbi5jb250cm9sLWJ0biB7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDJiODgzO1xcbiAgY29sb3I6ICMzNTQ5NWU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBwYWRkaW5nOiAxNXB4O1xcbiAgbWFyZ2luOiAxNXB4O1xcbn1cXG4uZHJhZ2dhYmxlLWNvbnRhaW5lciB7XFxuICB3aWR0aDogMTUwcHg7XFxuICBoZWlnaHQ6IDE1MHB4O1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxuICBib3JkZXI6IDNweCBzb2xpZCAjNDJiODgzO1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgZm9udC1zaXplOiAyNXB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuLmNvbnRhaW5lci1mb3ItZHJhZ2dhYmxlIHtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgYm9yZGVyOiAzcHggc29saWQgIzQyYjg4MztcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGZvbnQtc2l6ZTogMjVweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcXG4gIHdpZHRoOiAzMDBweDtcXG4gIGhlaWdodDogMjAwcHg7XFxuICBib3R0b206IDIwcHg7XFxufVxcbi5kcmFnZ2FibGUtd2l0aC1oYW5kbGVyIHtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgYm9yZGVyOiAzcHggc29saWQgIzQyYjg4MztcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGZvbnQtc2l6ZTogMjVweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcXG4gIHdpZHRoOiAzMDBweDtcXG4gIGhlaWdodDogMjAwcHg7XFxuICBib3R0b206IDIwcHg7XFxuICBsZWZ0OiAyMHB4O1xcbn1cXG4uaGFuZGxlciB7XFxuICBwYWRkaW5nOiA1cHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiA3MHB4O1xcbiAgbWFyZ2luLXRvcDogLTQ1cHg7XFxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gIGJvcmRlcjogM3B4IHNvbGlkICM0MmI4ODM7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBmb250LXNpemU6IDI1cHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG4uZHJhZ2dhYmxlLXdpdGgtcmVzZXQge1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxuICBib3JkZXI6IDNweCBzb2xpZCAjNDJiODgzO1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgZm9udC1zaXplOiAyNXB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xcbiAgd2lkdGg6IDMwMHB4O1xcbiAgaGVpZ2h0OiAyMDBweDtcXG4gIGJvdHRvbTogMjBweDtcXG4gIHJpZ2h0OiAyMHB4O1xcbn1cXG4uYXV0b3Ige1xcbiAgYWxpZ24tc2VsZjogZmxleC1zdGFydDtcXG4gIG1hcmdpbi10b3A6IDI1cHg7XFxuICBtYXJnaW4tYm90dG9tOiAyMHB4O1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGNvbG9yOiAjNDJiODgzO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzM1NDk1ZTtcXG4gIGZvbnQtc2l6ZTogMjVweDtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTI5Y2E1MTkzXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL2FwcC9hcHAudnVlXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanM/NWI5OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZSh1cmwpIHtcbiAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgICAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cbiAgICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAgICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAgIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG4gICAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgdXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgKyAnXCInXG4gICAgfVxuXG4gICAgcmV0dXJuIHVybFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction extractHandle(handle) {\r\n    return handle && handle.$el || handle;\r\n}\r\nfunction getPosWithBoundaries(elementRect, boundingRect, left, top, boundingRectMargin) {\r\n    if (boundingRectMargin === void 0) { boundingRectMargin = {}; }\r\n    var adjustedPos = { left: left, top: top };\r\n    var height = elementRect.height, width = elementRect.width;\r\n    var topRect = top, bottomRect = top + height, leftRect = left, rightRect = left + width;\r\n    var marginTop = boundingRectMargin.top || 0, marginBottom = boundingRectMargin.bottom || 0, marginLeft = boundingRectMargin.left || 0, marginRight = boundingRectMargin.right || 0;\r\n    var topBoundary = boundingRect.top + marginTop, bottomBoundary = boundingRect.bottom - marginBottom, leftBoundary = boundingRect.left + marginLeft, rightBoundary = boundingRect.right - marginRight;\r\n    if (topRect < topBoundary) {\r\n        adjustedPos.top = topBoundary;\r\n    }\r\n    else if (bottomRect > bottomBoundary) {\r\n        adjustedPos.top = bottomBoundary - height;\r\n    }\r\n    if (leftRect < leftBoundary) {\r\n        adjustedPos.left = leftBoundary;\r\n    }\r\n    else if (rightRect > rightBoundary) {\r\n        adjustedPos.left = rightBoundary - width;\r\n    }\r\n    return adjustedPos;\r\n}\r\nexports.Draggable = {\r\n    bind: function (el, binding) {\r\n        exports.Draggable.update(el, binding);\r\n    },\r\n    update: function (el, binding) {\r\n        if (binding.value && binding.value.stopDragging) {\r\n            return;\r\n        }\r\n        var handler = (binding.value && binding.value.handle && extractHandle(binding.value.handle)) || el;\r\n        if (binding && binding.value && binding.value.resetInitialPos) {\r\n            initializeState();\r\n            handlePositionChanged();\r\n        }\r\n        if (!handler.getAttribute(\"draggable\")) {\r\n            el.removeEventListener(\"mousedown\", el[\"listener\"]);\r\n            handler.addEventListener(\"mousedown\", mouseDown);\r\n            handler.setAttribute(\"draggable\", \"true\");\r\n            el[\"listener\"] = mouseDown;\r\n            initializeState();\r\n            handlePositionChanged();\r\n        }\r\n        function mouseMove(event) {\r\n            event.preventDefault();\r\n            var stopDragging = binding.value && binding.value.stopDragging;\r\n            if (stopDragging) {\r\n                return;\r\n            }\r\n            var state = getState();\r\n            if (!state.startDragPosition || !state.initialMousePos) {\r\n                initializeState(event);\r\n                state = getState();\r\n            }\r\n            var dx = event.clientX - state.initialMousePos.left;\r\n            var dy = event.clientY - state.initialMousePos.top;\r\n            var currentDragPosition = {\r\n                left: state.startDragPosition.left + dx,\r\n                top: state.startDragPosition.top + dy\r\n            };\r\n            var boundingRect = getBoundingRect();\r\n            var elementRect = el.getBoundingClientRect();\r\n            if (boundingRect && elementRect) {\r\n                currentDragPosition = getPosWithBoundaries(elementRect, boundingRect, currentDragPosition.left, currentDragPosition.top, binding.value.boundingRectMargin);\r\n            }\r\n            setState({ currentDragPosition: currentDragPosition });\r\n            updateElementStyle();\r\n            handlePositionChanged(event);\r\n        }\r\n        function getBoundingRect() {\r\n            if (!binding.value) {\r\n                return;\r\n            }\r\n            return binding.value.boundingRect\r\n                || binding.value.boundingElement\r\n                    && binding.value.boundingElement.getBoundingClientRect();\r\n        }\r\n        function updateElementStyle() {\r\n            var state = getState();\r\n            if (!state.currentDragPosition) {\r\n                return;\r\n            }\r\n            el.style.position = \"fixed\";\r\n            el.style.left = state.currentDragPosition.left + \"px\";\r\n            el.style.top = state.currentDragPosition.top + \"px\";\r\n        }\r\n        function mouseUp() {\r\n            var currentRectPosition = getRectPosition();\r\n            setState({\r\n                initialMousePos: undefined,\r\n                startDragPosition: currentRectPosition,\r\n                currentDragPosition: currentRectPosition\r\n            });\r\n            document.removeEventListener(\"mousemove\", mouseMove);\r\n            document.removeEventListener(\"mouseup\", mouseUp);\r\n        }\r\n        function mouseDown(event) {\r\n            setState({ initialMousePos: getInitialMousePosition(event) });\r\n            handlePositionChanged(event);\r\n            document.addEventListener(\"mousemove\", mouseMove);\r\n            document.addEventListener(\"mouseup\", mouseUp);\r\n        }\r\n        function getInitialMousePosition(event) {\r\n            return event && {\r\n                left: event.clientX,\r\n                top: event.clientY\r\n            };\r\n        }\r\n        function getRectPosition() {\r\n            var clientRect = el.getBoundingClientRect();\r\n            if (!clientRect.height || !clientRect.width) {\r\n                return;\r\n            }\r\n            return { left: clientRect.left, top: clientRect.top };\r\n        }\r\n        function initializeState(event) {\r\n            var state = getState();\r\n            var initialRectPositionFromBinding = binding && binding.value && binding.value.initialPosition;\r\n            var initialRectPositionFromState = state.initialPosition;\r\n            var startingDragPosition = getRectPosition();\r\n            var initialPosition = initialRectPositionFromBinding || initialRectPositionFromState || startingDragPosition;\r\n            setState({\r\n                initialPosition: initialPosition,\r\n                startDragPosition: initialPosition,\r\n                currentDragPosition: initialPosition,\r\n                initialMousePos: getInitialMousePosition(event)\r\n            });\r\n            updateElementStyle();\r\n        }\r\n        function setState(partialState) {\r\n            var prevState = getState();\r\n            var state = __assign({}, prevState, partialState);\r\n            handler.setAttribute(\"draggable-state\", JSON.stringify(state));\r\n        }\r\n        function handlePositionChanged(event) {\r\n            var state = getState();\r\n            var posDiff = { x: 0, y: 0 };\r\n            if (state.currentDragPosition && state.startDragPosition) {\r\n                posDiff.x = state.currentDragPosition.left - state.startDragPosition.left;\r\n                posDiff.y = state.currentDragPosition.top - state.startDragPosition.top;\r\n            }\r\n            var currentPosition = state.currentDragPosition && __assign({}, state.currentDragPosition);\r\n            binding.value && binding.value.onPositionChange && state && binding.value.onPositionChange(posDiff, currentPosition, event);\r\n        }\r\n        function getState() {\r\n            return JSON.parse(handler.getAttribute(\"draggable-state\")) || {};\r\n        }\r\n    }\r\n};\r\n//# sourceMappingURL=draggable.js.map\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2RyYWdnYWJsZS12dWUtZGlyZWN0aXZlL2Rpc3QvZHJhZ2dhYmxlLmpzPzc3MGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHlCQUF5QjtBQUNqRSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQ0FBMkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrREFBa0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5mdW5jdGlvbiBleHRyYWN0SGFuZGxlKGhhbmRsZSkge1xyXG4gICAgcmV0dXJuIGhhbmRsZSAmJiBoYW5kbGUuJGVsIHx8IGhhbmRsZTtcclxufVxyXG5mdW5jdGlvbiBnZXRQb3NXaXRoQm91bmRhcmllcyhlbGVtZW50UmVjdCwgYm91bmRpbmdSZWN0LCBsZWZ0LCB0b3AsIGJvdW5kaW5nUmVjdE1hcmdpbikge1xyXG4gICAgaWYgKGJvdW5kaW5nUmVjdE1hcmdpbiA9PT0gdm9pZCAwKSB7IGJvdW5kaW5nUmVjdE1hcmdpbiA9IHt9OyB9XHJcbiAgICB2YXIgYWRqdXN0ZWRQb3MgPSB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wIH07XHJcbiAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudFJlY3QuaGVpZ2h0LCB3aWR0aCA9IGVsZW1lbnRSZWN0LndpZHRoO1xyXG4gICAgdmFyIHRvcFJlY3QgPSB0b3AsIGJvdHRvbVJlY3QgPSB0b3AgKyBoZWlnaHQsIGxlZnRSZWN0ID0gbGVmdCwgcmlnaHRSZWN0ID0gbGVmdCArIHdpZHRoO1xyXG4gICAgdmFyIG1hcmdpblRvcCA9IGJvdW5kaW5nUmVjdE1hcmdpbi50b3AgfHwgMCwgbWFyZ2luQm90dG9tID0gYm91bmRpbmdSZWN0TWFyZ2luLmJvdHRvbSB8fCAwLCBtYXJnaW5MZWZ0ID0gYm91bmRpbmdSZWN0TWFyZ2luLmxlZnQgfHwgMCwgbWFyZ2luUmlnaHQgPSBib3VuZGluZ1JlY3RNYXJnaW4ucmlnaHQgfHwgMDtcclxuICAgIHZhciB0b3BCb3VuZGFyeSA9IGJvdW5kaW5nUmVjdC50b3AgKyBtYXJnaW5Ub3AsIGJvdHRvbUJvdW5kYXJ5ID0gYm91bmRpbmdSZWN0LmJvdHRvbSAtIG1hcmdpbkJvdHRvbSwgbGVmdEJvdW5kYXJ5ID0gYm91bmRpbmdSZWN0LmxlZnQgKyBtYXJnaW5MZWZ0LCByaWdodEJvdW5kYXJ5ID0gYm91bmRpbmdSZWN0LnJpZ2h0IC0gbWFyZ2luUmlnaHQ7XHJcbiAgICBpZiAodG9wUmVjdCA8IHRvcEJvdW5kYXJ5KSB7XHJcbiAgICAgICAgYWRqdXN0ZWRQb3MudG9wID0gdG9wQm91bmRhcnk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChib3R0b21SZWN0ID4gYm90dG9tQm91bmRhcnkpIHtcclxuICAgICAgICBhZGp1c3RlZFBvcy50b3AgPSBib3R0b21Cb3VuZGFyeSAtIGhlaWdodDtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0UmVjdCA8IGxlZnRCb3VuZGFyeSkge1xyXG4gICAgICAgIGFkanVzdGVkUG9zLmxlZnQgPSBsZWZ0Qm91bmRhcnk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyaWdodFJlY3QgPiByaWdodEJvdW5kYXJ5KSB7XHJcbiAgICAgICAgYWRqdXN0ZWRQb3MubGVmdCA9IHJpZ2h0Qm91bmRhcnkgLSB3aWR0aDtcclxuICAgIH1cclxuICAgIHJldHVybiBhZGp1c3RlZFBvcztcclxufVxyXG5leHBvcnRzLkRyYWdnYWJsZSA9IHtcclxuICAgIGJpbmQ6IGZ1bmN0aW9uIChlbCwgYmluZGluZykge1xyXG4gICAgICAgIGV4cG9ydHMuRHJhZ2dhYmxlLnVwZGF0ZShlbCwgYmluZGluZyk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZWwsIGJpbmRpbmcpIHtcclxuICAgICAgICBpZiAoYmluZGluZy52YWx1ZSAmJiBiaW5kaW5nLnZhbHVlLnN0b3BEcmFnZ2luZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoYW5kbGVyID0gKGJpbmRpbmcudmFsdWUgJiYgYmluZGluZy52YWx1ZS5oYW5kbGUgJiYgZXh0cmFjdEhhbmRsZShiaW5kaW5nLnZhbHVlLmhhbmRsZSkpIHx8IGVsO1xyXG4gICAgICAgIGlmIChiaW5kaW5nICYmIGJpbmRpbmcudmFsdWUgJiYgYmluZGluZy52YWx1ZS5yZXNldEluaXRpYWxQb3MpIHtcclxuICAgICAgICAgICAgaW5pdGlhbGl6ZVN0YXRlKCk7XHJcbiAgICAgICAgICAgIGhhbmRsZVBvc2l0aW9uQ2hhbmdlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWhhbmRsZXIuZ2V0QXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZWxbXCJsaXN0ZW5lclwiXSk7XHJcbiAgICAgICAgICAgIGhhbmRsZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBtb3VzZURvd24pO1xyXG4gICAgICAgICAgICBoYW5kbGVyLnNldEF0dHJpYnV0ZShcImRyYWdnYWJsZVwiLCBcInRydWVcIik7XHJcbiAgICAgICAgICAgIGVsW1wibGlzdGVuZXJcIl0gPSBtb3VzZURvd247XHJcbiAgICAgICAgICAgIGluaXRpYWxpemVTdGF0ZSgpO1xyXG4gICAgICAgICAgICBoYW5kbGVQb3NpdGlvbkNoYW5nZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gbW91c2VNb3ZlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHZhciBzdG9wRHJhZ2dpbmcgPSBiaW5kaW5nLnZhbHVlICYmIGJpbmRpbmcudmFsdWUuc3RvcERyYWdnaW5nO1xyXG4gICAgICAgICAgICBpZiAoc3RvcERyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5zdGFydERyYWdQb3NpdGlvbiB8fCAhc3RhdGUuaW5pdGlhbE1vdXNlUG9zKSB7XHJcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplU3RhdGUoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkeCA9IGV2ZW50LmNsaWVudFggLSBzdGF0ZS5pbml0aWFsTW91c2VQb3MubGVmdDtcclxuICAgICAgICAgICAgdmFyIGR5ID0gZXZlbnQuY2xpZW50WSAtIHN0YXRlLmluaXRpYWxNb3VzZVBvcy50b3A7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RHJhZ1Bvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogc3RhdGUuc3RhcnREcmFnUG9zaXRpb24ubGVmdCArIGR4LFxyXG4gICAgICAgICAgICAgICAgdG9wOiBzdGF0ZS5zdGFydERyYWdQb3NpdGlvbi50b3AgKyBkeVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50UmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICBpZiAoYm91bmRpbmdSZWN0ICYmIGVsZW1lbnRSZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RHJhZ1Bvc2l0aW9uID0gZ2V0UG9zV2l0aEJvdW5kYXJpZXMoZWxlbWVudFJlY3QsIGJvdW5kaW5nUmVjdCwgY3VycmVudERyYWdQb3NpdGlvbi5sZWZ0LCBjdXJyZW50RHJhZ1Bvc2l0aW9uLnRvcCwgYmluZGluZy52YWx1ZS5ib3VuZGluZ1JlY3RNYXJnaW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHsgY3VycmVudERyYWdQb3NpdGlvbjogY3VycmVudERyYWdQb3NpdGlvbiB9KTtcclxuICAgICAgICAgICAgdXBkYXRlRWxlbWVudFN0eWxlKCk7XHJcbiAgICAgICAgICAgIGhhbmRsZVBvc2l0aW9uQ2hhbmdlZChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdCgpIHtcclxuICAgICAgICAgICAgaWYgKCFiaW5kaW5nLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmcudmFsdWUuYm91bmRpbmdSZWN0XHJcbiAgICAgICAgICAgICAgICB8fCBiaW5kaW5nLnZhbHVlLmJvdW5kaW5nRWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICYmIGJpbmRpbmcudmFsdWUuYm91bmRpbmdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50U3R5bGUoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUuY3VycmVudERyYWdQb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xyXG4gICAgICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gc3RhdGUuY3VycmVudERyYWdQb3NpdGlvbi5sZWZ0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICBlbC5zdHlsZS50b3AgPSBzdGF0ZS5jdXJyZW50RHJhZ1Bvc2l0aW9uLnRvcCArIFwicHhcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gbW91c2VVcCgpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRSZWN0UG9zaXRpb24gPSBnZXRSZWN0UG9zaXRpb24oKTtcclxuICAgICAgICAgICAgc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgaW5pdGlhbE1vdXNlUG9zOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBzdGFydERyYWdQb3NpdGlvbjogY3VycmVudFJlY3RQb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIGN1cnJlbnREcmFnUG9zaXRpb246IGN1cnJlbnRSZWN0UG9zaXRpb25cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgbW91c2VVcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIG1vdXNlRG93bihldmVudCkge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZSh7IGluaXRpYWxNb3VzZVBvczogZ2V0SW5pdGlhbE1vdXNlUG9zaXRpb24oZXZlbnQpIH0pO1xyXG4gICAgICAgICAgICBoYW5kbGVQb3NpdGlvbkNoYW5nZWQoZXZlbnQpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG1vdXNlVXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBnZXRJbml0aWFsTW91c2VQb3NpdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQgJiYge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgICAgICAgICAgIHRvcDogZXZlbnQuY2xpZW50WVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBnZXRSZWN0UG9zaXRpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGllbnRSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIGlmICghY2xpZW50UmVjdC5oZWlnaHQgfHwgIWNsaWVudFJlY3Qud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyBsZWZ0OiBjbGllbnRSZWN0LmxlZnQsIHRvcDogY2xpZW50UmVjdC50b3AgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgIHZhciBpbml0aWFsUmVjdFBvc2l0aW9uRnJvbUJpbmRpbmcgPSBiaW5kaW5nICYmIGJpbmRpbmcudmFsdWUgJiYgYmluZGluZy52YWx1ZS5pbml0aWFsUG9zaXRpb247XHJcbiAgICAgICAgICAgIHZhciBpbml0aWFsUmVjdFBvc2l0aW9uRnJvbVN0YXRlID0gc3RhdGUuaW5pdGlhbFBvc2l0aW9uO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRpbmdEcmFnUG9zaXRpb24gPSBnZXRSZWN0UG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdmFyIGluaXRpYWxQb3NpdGlvbiA9IGluaXRpYWxSZWN0UG9zaXRpb25Gcm9tQmluZGluZyB8fCBpbml0aWFsUmVjdFBvc2l0aW9uRnJvbVN0YXRlIHx8IHN0YXJ0aW5nRHJhZ1Bvc2l0aW9uO1xyXG4gICAgICAgICAgICBzZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBpbml0aWFsUG9zaXRpb246IGluaXRpYWxQb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIHN0YXJ0RHJhZ1Bvc2l0aW9uOiBpbml0aWFsUG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RHJhZ1Bvc2l0aW9uOiBpbml0aWFsUG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICBpbml0aWFsTW91c2VQb3M6IGdldEluaXRpYWxNb3VzZVBvc2l0aW9uKGV2ZW50KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdXBkYXRlRWxlbWVudFN0eWxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldFN0YXRlKHBhcnRpYWxTdGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gX19hc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcclxuICAgICAgICAgICAgaGFuZGxlci5zZXRBdHRyaWJ1dGUoXCJkcmFnZ2FibGUtc3RhdGVcIiwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUG9zaXRpb25DaGFuZ2VkKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgIHZhciBwb3NEaWZmID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5jdXJyZW50RHJhZ1Bvc2l0aW9uICYmIHN0YXRlLnN0YXJ0RHJhZ1Bvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NEaWZmLnggPSBzdGF0ZS5jdXJyZW50RHJhZ1Bvc2l0aW9uLmxlZnQgLSBzdGF0ZS5zdGFydERyYWdQb3NpdGlvbi5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgcG9zRGlmZi55ID0gc3RhdGUuY3VycmVudERyYWdQb3NpdGlvbi50b3AgLSBzdGF0ZS5zdGFydERyYWdQb3NpdGlvbi50b3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IHN0YXRlLmN1cnJlbnREcmFnUG9zaXRpb24gJiYgX19hc3NpZ24oe30sIHN0YXRlLmN1cnJlbnREcmFnUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBiaW5kaW5nLnZhbHVlICYmIGJpbmRpbmcudmFsdWUub25Qb3NpdGlvbkNoYW5nZSAmJiBzdGF0ZSAmJiBiaW5kaW5nLnZhbHVlLm9uUG9zaXRpb25DaGFuZ2UocG9zRGlmZiwgY3VycmVudFBvc2l0aW9uLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShoYW5kbGVyLmdldEF0dHJpYnV0ZShcImRyYWdnYWJsZS1zdGF0ZVwiKSkgfHwge307XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmFnZ2FibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RyYWdnYWJsZS12dWUtZGlyZWN0aXZlL2Rpc3QvZHJhZ2dhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar draggable_1 = __webpack_require__(9);\r\nexports.Draggable = draggable_1.Draggable;\r\n//# sourceMappingURL=index.js.map\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2RyYWdnYWJsZS12dWUtZGlyZWN0aXZlL2Rpc3QvaW5kZXguanM/NzZhNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQSIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBkcmFnZ2FibGVfMSA9IHJlcXVpcmUoXCIuL2RyYWdnYWJsZVwiKTtcclxuZXhwb3J0cy5EcmFnZ2FibGUgPSBkcmFnZ2FibGVfMS5EcmFnZ2FibGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kcmFnZ2FibGUtdnVlLWRpcmVjdGl2ZS9kaXN0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*! *****************************************************************************\r\nCopyright (C) Microsoft. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\nvar Reflect;\r\n(function (Reflect) {\r\n    // Metadata Proposal\r\n    // https://rbuckton.github.io/reflect-metadata/\r\n    (function (factory) {\r\n        var root = typeof global === \"object\" ? global :\r\n            typeof self === \"object\" ? self :\r\n                typeof this === \"object\" ? this :\r\n                    Function(\"return this;\")();\r\n        var exporter = makeExporter(Reflect);\r\n        if (typeof root.Reflect === \"undefined\") {\r\n            root.Reflect = Reflect;\r\n        }\r\n        else {\r\n            exporter = makeExporter(root.Reflect, exporter);\r\n        }\r\n        factory(exporter);\r\n        function makeExporter(target, previous) {\r\n            return function (key, value) {\r\n                if (typeof target[key] !== \"function\") {\r\n                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });\r\n                }\r\n                if (previous)\r\n                    previous(key, value);\r\n            };\r\n        }\r\n    })(function (exporter) {\r\n        var hasOwn = Object.prototype.hasOwnProperty;\r\n        // feature test for Symbol support\r\n        var supportsSymbol = typeof Symbol === \"function\";\r\n        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== \"undefined\" ? Symbol.toPrimitive : \"@@toPrimitive\";\r\n        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\r\n        var supportsCreate = typeof Object.create === \"function\"; // feature test for Object.create support\r\n        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support\r\n        var downLevel = !supportsCreate && !supportsProto;\r\n        var HashMap = {\r\n            // create an object in dictionary mode (a.k.a. \"slow\" mode in v8)\r\n            create: supportsCreate\r\n                ? function () { return MakeDictionary(Object.create(null)); }\r\n                : supportsProto\r\n                    ? function () { return MakeDictionary({ __proto__: null }); }\r\n                    : function () { return MakeDictionary({}); },\r\n            has: downLevel\r\n                ? function (map, key) { return hasOwn.call(map, key); }\r\n                : function (map, key) { return key in map; },\r\n            get: downLevel\r\n                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }\r\n                : function (map, key) { return map[key]; },\r\n        };\r\n        // Load global or shim versions of Map, Set, and WeakMap\r\n        var functionPrototype = Object.getPrototypeOf(Function);\r\n        var usePolyfill = typeof process === \"object\" && process.env && process.env[\"REFLECT_METADATA_USE_MAP_POLYFILL\"] === \"true\";\r\n        var _Map = !usePolyfill && typeof Map === \"function\" && typeof Map.prototype.entries === \"function\" ? Map : CreateMapPolyfill();\r\n        var _Set = !usePolyfill && typeof Set === \"function\" && typeof Set.prototype.entries === \"function\" ? Set : CreateSetPolyfill();\r\n        var _WeakMap = !usePolyfill && typeof WeakMap === \"function\" ? WeakMap : CreateWeakMapPolyfill();\r\n        // [[Metadata]] internal slot\r\n        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots\r\n        var Metadata = new _WeakMap();\r\n        /**\r\n         * Applies a set of decorators to a property of a target object.\r\n         * @param decorators An array of decorators.\r\n         * @param target The target object.\r\n         * @param propertyKey (Optional) The property key to decorate.\r\n         * @param attributes (Optional) The property descriptor for the target key.\r\n         * @remarks Decorators are applied in reverse order.\r\n         * @example\r\n         *\r\n         *     class Example {\r\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n         *         // static staticProperty;\r\n         *         // property;\r\n         *\r\n         *         constructor(p) { }\r\n         *         static staticMethod(p) { }\r\n         *         method(p) { }\r\n         *     }\r\n         *\r\n         *     // constructor\r\n         *     Example = Reflect.decorate(decoratorsArray, Example);\r\n         *\r\n         *     // property (on constructor)\r\n         *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\r\n         *\r\n         *     // property (on prototype)\r\n         *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\r\n         *\r\n         *     // method (on constructor)\r\n         *     Object.defineProperty(Example, \"staticMethod\",\r\n         *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\r\n         *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\r\n         *\r\n         *     // method (on prototype)\r\n         *     Object.defineProperty(Example.prototype, \"method\",\r\n         *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\r\n         *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\r\n         *\r\n         */\r\n        function decorate(decorators, target, propertyKey, attributes) {\r\n            if (!IsUndefined(propertyKey)) {\r\n                if (!IsArray(decorators))\r\n                    throw new TypeError();\r\n                if (!IsObject(target))\r\n                    throw new TypeError();\r\n                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))\r\n                    throw new TypeError();\r\n                if (IsNull(attributes))\r\n                    attributes = undefined;\r\n                propertyKey = ToPropertyKey(propertyKey);\r\n                return DecorateProperty(decorators, target, propertyKey, attributes);\r\n            }\r\n            else {\r\n                if (!IsArray(decorators))\r\n                    throw new TypeError();\r\n                if (!IsConstructor(target))\r\n                    throw new TypeError();\r\n                return DecorateConstructor(decorators, target);\r\n            }\r\n        }\r\n        exporter(\"decorate\", decorate);\r\n        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)\r\n        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata\r\n        /**\r\n         * A default metadata decorator factory that can be used on a class, class member, or parameter.\r\n         * @param metadataKey The key for the metadata entry.\r\n         * @param metadataValue The value for the metadata entry.\r\n         * @returns A decorator function.\r\n         * @remarks\r\n         * If `metadataKey` is already defined for the target and target key, the\r\n         * metadataValue for that key will be overwritten.\r\n         * @example\r\n         *\r\n         *     // constructor\r\n         *     @Reflect.metadata(key, value)\r\n         *     class Example {\r\n         *     }\r\n         *\r\n         *     // property (on constructor, TypeScript only)\r\n         *     class Example {\r\n         *         @Reflect.metadata(key, value)\r\n         *         static staticProperty;\r\n         *     }\r\n         *\r\n         *     // property (on prototype, TypeScript only)\r\n         *     class Example {\r\n         *         @Reflect.metadata(key, value)\r\n         *         property;\r\n         *     }\r\n         *\r\n         *     // method (on constructor)\r\n         *     class Example {\r\n         *         @Reflect.metadata(key, value)\r\n         *         static staticMethod() { }\r\n         *     }\r\n         *\r\n         *     // method (on prototype)\r\n         *     class Example {\r\n         *         @Reflect.metadata(key, value)\r\n         *         method() { }\r\n         *     }\r\n         *\r\n         */\r\n        function metadata(metadataKey, metadataValue) {\r\n            function decorator(target, propertyKey) {\r\n                if (!IsObject(target))\r\n                    throw new TypeError();\r\n                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))\r\n                    throw new TypeError();\r\n                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\r\n            }\r\n            return decorator;\r\n        }\r\n        exporter(\"metadata\", metadata);\r\n        /**\r\n         * Define a unique metadata entry on the target.\r\n         * @param metadataKey A key used to store and retrieve metadata.\r\n         * @param metadataValue A value that contains attached metadata.\r\n         * @param target The target object on which to define metadata.\r\n         * @param propertyKey (Optional) The property key for the target.\r\n         * @example\r\n         *\r\n         *     class Example {\r\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n         *         // static staticProperty;\r\n         *         // property;\r\n         *\r\n         *         constructor(p) { }\r\n         *         static staticMethod(p) { }\r\n         *         method(p) { }\r\n         *     }\r\n         *\r\n         *     // constructor\r\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example);\r\n         *\r\n         *     // property (on constructor)\r\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticProperty\");\r\n         *\r\n         *     // property (on prototype)\r\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"property\");\r\n         *\r\n         *     // method (on constructor)\r\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticMethod\");\r\n         *\r\n         *     // method (on prototype)\r\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"method\");\r\n         *\r\n         *     // decorator factory as metadata-producing annotation.\r\n         *     function MyAnnotation(options): Decorator {\r\n         *         return (target, key?) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\r\n         *     }\r\n         *\r\n         */\r\n        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {\r\n            if (!IsObject(target))\r\n                throw new TypeError();\r\n            if (!IsUndefined(propertyKey))\r\n                propertyKey = ToPropertyKey(propertyKey);\r\n            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\r\n        }\r\n        exporter(\"defineMetadata\", defineMetadata);\r\n        /**\r\n         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\r\n         * @param metadataKey A key used to store and retrieve metadata.\r\n         * @param target The target object on which the metadata is defined.\r\n         * @param propertyKey (Optional) The property key for the target.\r\n         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\r\n         * @example\r\n         *\r\n         *     class Example {\r\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n         *         // static staticProperty;\r\n         *         // property;\r\n         *\r\n         *         constructor(p) { }\r\n         *         static staticMethod(p) { }\r\n         *         method(p) { }\r\n         *     }\r\n         *\r\n         *     // constructor\r\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example);\r\n         *\r\n         *     // property (on constructor)\r\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n         *\r\n         *     // property (on prototype)\r\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n         *\r\n         *     // method (on constructor)\r\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n         *\r\n         *     // method (on prototype)\r\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n         *\r\n         */\r\n        function hasMetadata(metadataKey, target, propertyKey) {\r\n            if (!IsObject(target))\r\n                throw new TypeError();\r\n            if (!IsUndefined(propertyKey))\r\n                propertyKey = ToPropertyKey(propertyKey);\r\n            return OrdinaryHasMetadata(metadataKey, target, propertyKey);\r\n        }\r\n        exporter(\"hasMetadata\", hasMetadata);\r\n        /**\r\n         * Gets a value indicating whether the target object has the provided metadata key defined.\r\n         * @param metadataKey A key used to store and retrieve metadata.\r\n         * @param target The target object on which the metadata is defined.\r\n         * @param propertyKey (Optional) The property key for the target.\r\n         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\r\n         * @example\r\n         *\r\n         *     class Example {\r\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n         *         // static staticProperty;\r\n         *         // property;\r\n         *\r\n         *         constructor(p) { }\r\n         *         static staticMethod(p) { }\r\n         *         method(p) { }\r\n         *     }\r\n         *\r\n         *     // constructor\r\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\r\n         *\r\n         *     // property (on constructor)\r\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n         *\r\n         *     // property (on prototype)\r\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n         *\r\n         *     // method (on constructor)\r\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n         *\r\n         *     // method (on prototype)\r\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n         *\r\n         */\r\n        function hasOwnMetadata(metadataKey, target, propertyKey) {\r\n            if (!IsObject(target))\r\n                throw new TypeError();\r\n            if (!IsUndefined(propertyKey))\r\n                propertyKey = ToPropertyKey(propertyKey);\r\n            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);\r\n        }\r\n        exporter(\"hasOwnMetadata\", hasOwnMetadata);\r\n        /**\r\n         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\r\n         * @param metadataKey A key used to store and retrieve metadata.\r\n         * @param target The target object on which the metadata is defined.\r\n         * @param propertyKey (Optional) The property key for the target.\r\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n         * @example\r\n         *\r\n         *     class Example {\r\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n         *         // static staticProperty;\r\n         *         // property;\r\n         *\r\n         *         constructor(p) { }\r\n         *         static staticMethod(p) { }\r\n         *         method(p) { }\r\n         *     }\r\n         *\r\n         *     // constructor\r\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example);\r\n         *\r\n         *     // property (on constructor)\r\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n         *\r\n         *     // property (on prototype)\r\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n         *\r\n         *     // method (on constructor)\r\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n         *\r\n         *     // method (on prototype)\r\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n         *\r\n         */\r\n        function getMetadata(metadataKey, target, propertyKey) {\r\n            if (!IsObject(target))\r\n                throw new TypeError();\r\n            if (!IsUndefined(propertyKey))\r\n                propertyKey = ToPropertyKey(propertyKey);\r\n            return OrdinaryGetMetadata(metadataKey, target, propertyKey);\r\n        }\r\n        exporter(\"getMetadata\", getMetadata);\r\n        /**\r\n         * Gets the metadata value for the provided metadata key on the target object.\r\n         * @param metadataKey A key used to store and retrieve metadata.\r\n         * @param target The target object on which the metadata is defined.\r\n         * @param propertyKey (Optional) The property key for the target.\r\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n         * @example\r\n         *\r\n         *     class Example {\r\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n         *         // static staticProperty;\r\n         *         // property;\r\n         *\r\n         *         constructor(p) { }\r\n         *         static staticMethod(p) { }\r\n         *         method(p) { }\r\n         *     }\r\n         *\r\n         *     // constructor\r\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\r\n         *\r\n         *     // property (on constructor)\r\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n         *\r\n         *     // property (on prototype)\r\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n         *\r\n         *     // method (on constructor)\r\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n         *\r\n         *     // method (on prototype)\r\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n         *\r\n         */\r\n        function getOwnMetadata(metadataKey, target, propertyKey) {\r\n            if (!IsObject(target))\r\n                throw new TypeError();\r\n            if (!IsUndefined(propertyKey))\r\n                propertyKey = ToPropertyKey(propertyKey);\r\n            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);\r\n        }\r\n        exporter(\"getOwnMetadata\", getOwnMetadata);\r\n        /**\r\n         * Gets the metadata keys defined on the target object or its prototype chain.\r\n         * @param target The target object on which the metadata is defined.\r\n         * @param propertyKey (Optional) The property key for the target.\r\n         * @returns An array of unique metadata keys.\r\n         * @example\r\n         *\r\n         *     class Example {\r\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n         *         // static staticProperty;\r\n         *         // property;\r\n         *\r\n         *         constructor(p) { }\r\n         *         static staticMethod(p) { }\r\n         *         method(p) { }\r\n         *     }\r\n         *\r\n         *     // constructor\r\n         *     result = Reflect.getMetadataKeys(Example);\r\n         *\r\n         *     // property (on constructor)\r\n         *     result = Reflect.getMetadataKeys(Example, \"staticProperty\");\r\n         *\r\n         *     // property (on prototype)\r\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"property\");\r\n         *\r\n         *     // method (on constructor)\r\n         *     result = Reflect.getMetadataKeys(Example, \"staticMethod\");\r\n         *\r\n         *     // method (on prototype)\r\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"method\");\r\n         *\r\n         */\r\n        function getMetadataKeys(target, propertyKey) {\r\n            if (!IsObject(target))\r\n                throw new TypeError();\r\n            if (!IsUndefined(propertyKey))\r\n                propertyKey = ToPropertyKey(propertyKey);\r\n            return OrdinaryMetadataKeys(target, propertyKey);\r\n        }\r\n        exporter(\"getMetadataKeys\", getMetadataKeys);\r\n        /**\r\n         * Gets the unique metadata keys defined on the target object.\r\n         * @param target The target object on which the metadata is defined.\r\n         * @param propertyKey (Optional) The property key for the target.\r\n         * @returns An array of unique metadata keys.\r\n         * @example\r\n         *\r\n         *     class Example {\r\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n         *         // static staticProperty;\r\n         *         // property;\r\n         *\r\n         *         constructor(p) { }\r\n         *         static staticMethod(p) { }\r\n         *         method(p) { }\r\n         *     }\r\n         *\r\n         *     // constructor\r\n         *     result = Reflect.getOwnMetadataKeys(Example);\r\n         *\r\n         *     // property (on constructor)\r\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticProperty\");\r\n         *\r\n         *     // property (on prototype)\r\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"property\");\r\n         *\r\n         *     // method (on constructor)\r\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticMethod\");\r\n         *\r\n         *     // method (on prototype)\r\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"method\");\r\n         *\r\n         */\r\n        function getOwnMetadataKeys(target, propertyKey) {\r\n            if (!IsObject(target))\r\n                throw new TypeError();\r\n            if (!IsUndefined(propertyKey))\r\n                propertyKey = ToPropertyKey(propertyKey);\r\n            return OrdinaryOwnMetadataKeys(target, propertyKey);\r\n        }\r\n        exporter(\"getOwnMetadataKeys\", getOwnMetadataKeys);\r\n        /**\r\n         * Deletes the metadata entry from the target object with the provided key.\r\n         * @param metadataKey A key used to store and retrieve metadata.\r\n         * @param target The target object on which the metadata is defined.\r\n         * @param propertyKey (Optional) The property key for the target.\r\n         * @returns `true` if the metadata entry was found and deleted; otherwise, false.\r\n         * @example\r\n         *\r\n         *     class Example {\r\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n         *         // static staticProperty;\r\n         *         // property;\r\n         *\r\n         *         constructor(p) { }\r\n         *         static staticMethod(p) { }\r\n         *         method(p) { }\r\n         *     }\r\n         *\r\n         *     // constructor\r\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example);\r\n         *\r\n         *     // property (on constructor)\r\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n         *\r\n         *     // property (on prototype)\r\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n         *\r\n         *     // method (on constructor)\r\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n         *\r\n         *     // method (on prototype)\r\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n         *\r\n         */\r\n        function deleteMetadata(metadataKey, target, propertyKey) {\r\n            if (!IsObject(target))\r\n                throw new TypeError();\r\n            if (!IsUndefined(propertyKey))\r\n                propertyKey = ToPropertyKey(propertyKey);\r\n            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);\r\n            if (IsUndefined(metadataMap))\r\n                return false;\r\n            if (!metadataMap.delete(metadataKey))\r\n                return false;\r\n            if (metadataMap.size > 0)\r\n                return true;\r\n            var targetMetadata = Metadata.get(target);\r\n            targetMetadata.delete(propertyKey);\r\n            if (targetMetadata.size > 0)\r\n                return true;\r\n            Metadata.delete(target);\r\n            return true;\r\n        }\r\n        exporter(\"deleteMetadata\", deleteMetadata);\r\n        function DecorateConstructor(decorators, target) {\r\n            for (var i = decorators.length - 1; i >= 0; --i) {\r\n                var decorator = decorators[i];\r\n                var decorated = decorator(target);\r\n                if (!IsUndefined(decorated) && !IsNull(decorated)) {\r\n                    if (!IsConstructor(decorated))\r\n                        throw new TypeError();\r\n                    target = decorated;\r\n                }\r\n            }\r\n            return target;\r\n        }\r\n        function DecorateProperty(decorators, target, propertyKey, descriptor) {\r\n            for (var i = decorators.length - 1; i >= 0; --i) {\r\n                var decorator = decorators[i];\r\n                var decorated = decorator(target, propertyKey, descriptor);\r\n                if (!IsUndefined(decorated) && !IsNull(decorated)) {\r\n                    if (!IsObject(decorated))\r\n                        throw new TypeError();\r\n                    descriptor = decorated;\r\n                }\r\n            }\r\n            return descriptor;\r\n        }\r\n        function GetOrCreateMetadataMap(O, P, Create) {\r\n            var targetMetadata = Metadata.get(O);\r\n            if (IsUndefined(targetMetadata)) {\r\n                if (!Create)\r\n                    return undefined;\r\n                targetMetadata = new _Map();\r\n                Metadata.set(O, targetMetadata);\r\n            }\r\n            var metadataMap = targetMetadata.get(P);\r\n            if (IsUndefined(metadataMap)) {\r\n                if (!Create)\r\n                    return undefined;\r\n                metadataMap = new _Map();\r\n                targetMetadata.set(P, metadataMap);\r\n            }\r\n            return metadataMap;\r\n        }\r\n        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)\r\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata\r\n        function OrdinaryHasMetadata(MetadataKey, O, P) {\r\n            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\r\n            if (hasOwn)\r\n                return true;\r\n            var parent = OrdinaryGetPrototypeOf(O);\r\n            if (!IsNull(parent))\r\n                return OrdinaryHasMetadata(MetadataKey, parent, P);\r\n            return false;\r\n        }\r\n        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)\r\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata\r\n        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {\r\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\r\n            if (IsUndefined(metadataMap))\r\n                return false;\r\n            return ToBoolean(metadataMap.has(MetadataKey));\r\n        }\r\n        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)\r\n        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata\r\n        function OrdinaryGetMetadata(MetadataKey, O, P) {\r\n            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\r\n            if (hasOwn)\r\n                return OrdinaryGetOwnMetadata(MetadataKey, O, P);\r\n            var parent = OrdinaryGetPrototypeOf(O);\r\n            if (!IsNull(parent))\r\n                return OrdinaryGetMetadata(MetadataKey, parent, P);\r\n            return undefined;\r\n        }\r\n        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)\r\n        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata\r\n        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {\r\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\r\n            if (IsUndefined(metadataMap))\r\n                return undefined;\r\n            return metadataMap.get(MetadataKey);\r\n        }\r\n        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)\r\n        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata\r\n        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {\r\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);\r\n            metadataMap.set(MetadataKey, MetadataValue);\r\n        }\r\n        // 3.1.6.1 OrdinaryMetadataKeys(O, P)\r\n        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys\r\n        function OrdinaryMetadataKeys(O, P) {\r\n            var ownKeys = OrdinaryOwnMetadataKeys(O, P);\r\n            var parent = OrdinaryGetPrototypeOf(O);\r\n            if (parent === null)\r\n                return ownKeys;\r\n            var parentKeys = OrdinaryMetadataKeys(parent, P);\r\n            if (parentKeys.length <= 0)\r\n                return ownKeys;\r\n            if (ownKeys.length <= 0)\r\n                return parentKeys;\r\n            var set = new _Set();\r\n            var keys = [];\r\n            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {\r\n                var key = ownKeys_1[_i];\r\n                var hasKey = set.has(key);\r\n                if (!hasKey) {\r\n                    set.add(key);\r\n                    keys.push(key);\r\n                }\r\n            }\r\n            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {\r\n                var key = parentKeys_1[_a];\r\n                var hasKey = set.has(key);\r\n                if (!hasKey) {\r\n                    set.add(key);\r\n                    keys.push(key);\r\n                }\r\n            }\r\n            return keys;\r\n        }\r\n        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)\r\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys\r\n        function OrdinaryOwnMetadataKeys(O, P) {\r\n            var keys = [];\r\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\r\n            if (IsUndefined(metadataMap))\r\n                return keys;\r\n            var keysObj = metadataMap.keys();\r\n            var iterator = GetIterator(keysObj);\r\n            var k = 0;\r\n            while (true) {\r\n                var next = IteratorStep(iterator);\r\n                if (!next) {\r\n                    keys.length = k;\r\n                    return keys;\r\n                }\r\n                var nextValue = IteratorValue(next);\r\n                try {\r\n                    keys[k] = nextValue;\r\n                }\r\n                catch (e) {\r\n                    try {\r\n                        IteratorClose(iterator);\r\n                    }\r\n                    finally {\r\n                        throw e;\r\n                    }\r\n                }\r\n                k++;\r\n            }\r\n        }\r\n        // 6 ECMAScript Data Typ0es and Values\r\n        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values\r\n        function Type(x) {\r\n            if (x === null)\r\n                return 1 /* Null */;\r\n            switch (typeof x) {\r\n                case \"undefined\": return 0 /* Undefined */;\r\n                case \"boolean\": return 2 /* Boolean */;\r\n                case \"string\": return 3 /* String */;\r\n                case \"symbol\": return 4 /* Symbol */;\r\n                case \"number\": return 5 /* Number */;\r\n                case \"object\": return x === null ? 1 /* Null */ : 6 /* Object */;\r\n                default: return 6 /* Object */;\r\n            }\r\n        }\r\n        // 6.1.1 The Undefined Type\r\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type\r\n        function IsUndefined(x) {\r\n            return x === undefined;\r\n        }\r\n        // 6.1.2 The Null Type\r\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type\r\n        function IsNull(x) {\r\n            return x === null;\r\n        }\r\n        // 6.1.5 The Symbol Type\r\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type\r\n        function IsSymbol(x) {\r\n            return typeof x === \"symbol\";\r\n        }\r\n        // 6.1.7 The Object Type\r\n        // https://tc39.github.io/ecma262/#sec-object-type\r\n        function IsObject(x) {\r\n            return typeof x === \"object\" ? x !== null : typeof x === \"function\";\r\n        }\r\n        // 7.1 Type Conversion\r\n        // https://tc39.github.io/ecma262/#sec-type-conversion\r\n        // 7.1.1 ToPrimitive(input [, PreferredType])\r\n        // https://tc39.github.io/ecma262/#sec-toprimitive\r\n        function ToPrimitive(input, PreferredType) {\r\n            switch (Type(input)) {\r\n                case 0 /* Undefined */: return input;\r\n                case 1 /* Null */: return input;\r\n                case 2 /* Boolean */: return input;\r\n                case 3 /* String */: return input;\r\n                case 4 /* Symbol */: return input;\r\n                case 5 /* Number */: return input;\r\n            }\r\n            var hint = PreferredType === 3 /* String */ ? \"string\" : PreferredType === 5 /* Number */ ? \"number\" : \"default\";\r\n            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);\r\n            if (exoticToPrim !== undefined) {\r\n                var result = exoticToPrim.call(input, hint);\r\n                if (IsObject(result))\r\n                    throw new TypeError();\r\n                return result;\r\n            }\r\n            return OrdinaryToPrimitive(input, hint === \"default\" ? \"number\" : hint);\r\n        }\r\n        // 7.1.1.1 OrdinaryToPrimitive(O, hint)\r\n        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive\r\n        function OrdinaryToPrimitive(O, hint) {\r\n            if (hint === \"string\") {\r\n                var toString_1 = O.toString;\r\n                if (IsCallable(toString_1)) {\r\n                    var result = toString_1.call(O);\r\n                    if (!IsObject(result))\r\n                        return result;\r\n                }\r\n                var valueOf = O.valueOf;\r\n                if (IsCallable(valueOf)) {\r\n                    var result = valueOf.call(O);\r\n                    if (!IsObject(result))\r\n                        return result;\r\n                }\r\n            }\r\n            else {\r\n                var valueOf = O.valueOf;\r\n                if (IsCallable(valueOf)) {\r\n                    var result = valueOf.call(O);\r\n                    if (!IsObject(result))\r\n                        return result;\r\n                }\r\n                var toString_2 = O.toString;\r\n                if (IsCallable(toString_2)) {\r\n                    var result = toString_2.call(O);\r\n                    if (!IsObject(result))\r\n                        return result;\r\n                }\r\n            }\r\n            throw new TypeError();\r\n        }\r\n        // 7.1.2 ToBoolean(argument)\r\n        // https://tc39.github.io/ecma262/2016/#sec-toboolean\r\n        function ToBoolean(argument) {\r\n            return !!argument;\r\n        }\r\n        // 7.1.12 ToString(argument)\r\n        // https://tc39.github.io/ecma262/#sec-tostring\r\n        function ToString(argument) {\r\n            return \"\" + argument;\r\n        }\r\n        // 7.1.14 ToPropertyKey(argument)\r\n        // https://tc39.github.io/ecma262/#sec-topropertykey\r\n        function ToPropertyKey(argument) {\r\n            var key = ToPrimitive(argument, 3 /* String */);\r\n            if (IsSymbol(key))\r\n                return key;\r\n            return ToString(key);\r\n        }\r\n        // 7.2 Testing and Comparison Operations\r\n        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations\r\n        // 7.2.2 IsArray(argument)\r\n        // https://tc39.github.io/ecma262/#sec-isarray\r\n        function IsArray(argument) {\r\n            return Array.isArray\r\n                ? Array.isArray(argument)\r\n                : argument instanceof Object\r\n                    ? argument instanceof Array\r\n                    : Object.prototype.toString.call(argument) === \"[object Array]\";\r\n        }\r\n        // 7.2.3 IsCallable(argument)\r\n        // https://tc39.github.io/ecma262/#sec-iscallable\r\n        function IsCallable(argument) {\r\n            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.\r\n            return typeof argument === \"function\";\r\n        }\r\n        // 7.2.4 IsConstructor(argument)\r\n        // https://tc39.github.io/ecma262/#sec-isconstructor\r\n        function IsConstructor(argument) {\r\n            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.\r\n            return typeof argument === \"function\";\r\n        }\r\n        // 7.2.7 IsPropertyKey(argument)\r\n        // https://tc39.github.io/ecma262/#sec-ispropertykey\r\n        function IsPropertyKey(argument) {\r\n            switch (Type(argument)) {\r\n                case 3 /* String */: return true;\r\n                case 4 /* Symbol */: return true;\r\n                default: return false;\r\n            }\r\n        }\r\n        // 7.3 Operations on Objects\r\n        // https://tc39.github.io/ecma262/#sec-operations-on-objects\r\n        // 7.3.9 GetMethod(V, P)\r\n        // https://tc39.github.io/ecma262/#sec-getmethod\r\n        function GetMethod(V, P) {\r\n            var func = V[P];\r\n            if (func === undefined || func === null)\r\n                return undefined;\r\n            if (!IsCallable(func))\r\n                throw new TypeError();\r\n            return func;\r\n        }\r\n        // 7.4 Operations on Iterator Objects\r\n        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects\r\n        function GetIterator(obj) {\r\n            var method = GetMethod(obj, iteratorSymbol);\r\n            if (!IsCallable(method))\r\n                throw new TypeError(); // from Call\r\n            var iterator = method.call(obj);\r\n            if (!IsObject(iterator))\r\n                throw new TypeError();\r\n            return iterator;\r\n        }\r\n        // 7.4.4 IteratorValue(iterResult)\r\n        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue\r\n        function IteratorValue(iterResult) {\r\n            return iterResult.value;\r\n        }\r\n        // 7.4.5 IteratorStep(iterator)\r\n        // https://tc39.github.io/ecma262/#sec-iteratorstep\r\n        function IteratorStep(iterator) {\r\n            var result = iterator.next();\r\n            return result.done ? false : result;\r\n        }\r\n        // 7.4.6 IteratorClose(iterator, completion)\r\n        // https://tc39.github.io/ecma262/#sec-iteratorclose\r\n        function IteratorClose(iterator) {\r\n            var f = iterator[\"return\"];\r\n            if (f)\r\n                f.call(iterator);\r\n        }\r\n        // 9.1 Ordinary Object Internal Methods and Internal Slots\r\n        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots\r\n        // 9.1.1.1 OrdinaryGetPrototypeOf(O)\r\n        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof\r\n        function OrdinaryGetPrototypeOf(O) {\r\n            var proto = Object.getPrototypeOf(O);\r\n            if (typeof O !== \"function\" || O === functionPrototype)\r\n                return proto;\r\n            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.\r\n            // Try to determine the superclass constructor. Compatible implementations\r\n            // must either set __proto__ on a subclass constructor to the superclass constructor,\r\n            // or ensure each class has a valid `constructor` property on its prototype that\r\n            // points back to the constructor.\r\n            // If this is not the same as Function.[[Prototype]], then this is definately inherited.\r\n            // This is the case when in ES6 or when using __proto__ in a compatible browser.\r\n            if (proto !== functionPrototype)\r\n                return proto;\r\n            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.\r\n            var prototype = O.prototype;\r\n            var prototypeProto = prototype && Object.getPrototypeOf(prototype);\r\n            if (prototypeProto == null || prototypeProto === Object.prototype)\r\n                return proto;\r\n            // If the constructor was not a function, then we cannot determine the heritage.\r\n            var constructor = prototypeProto.constructor;\r\n            if (typeof constructor !== \"function\")\r\n                return proto;\r\n            // If we have some kind of self-reference, then we cannot determine the heritage.\r\n            if (constructor === O)\r\n                return proto;\r\n            // we have a pretty good guess at the heritage.\r\n            return constructor;\r\n        }\r\n        // naive Map shim\r\n        function CreateMapPolyfill() {\r\n            var cacheSentinel = {};\r\n            var arraySentinel = [];\r\n            var MapIterator = (function () {\r\n                function MapIterator(keys, values, selector) {\r\n                    this._index = 0;\r\n                    this._keys = keys;\r\n                    this._values = values;\r\n                    this._selector = selector;\r\n                }\r\n                MapIterator.prototype[\"@@iterator\"] = function () { return this; };\r\n                MapIterator.prototype[iteratorSymbol] = function () { return this; };\r\n                MapIterator.prototype.next = function () {\r\n                    var index = this._index;\r\n                    if (index >= 0 && index < this._keys.length) {\r\n                        var result = this._selector(this._keys[index], this._values[index]);\r\n                        if (index + 1 >= this._keys.length) {\r\n                            this._index = -1;\r\n                            this._keys = arraySentinel;\r\n                            this._values = arraySentinel;\r\n                        }\r\n                        else {\r\n                            this._index++;\r\n                        }\r\n                        return { value: result, done: false };\r\n                    }\r\n                    return { value: undefined, done: true };\r\n                };\r\n                MapIterator.prototype.throw = function (error) {\r\n                    if (this._index >= 0) {\r\n                        this._index = -1;\r\n                        this._keys = arraySentinel;\r\n                        this._values = arraySentinel;\r\n                    }\r\n                    throw error;\r\n                };\r\n                MapIterator.prototype.return = function (value) {\r\n                    if (this._index >= 0) {\r\n                        this._index = -1;\r\n                        this._keys = arraySentinel;\r\n                        this._values = arraySentinel;\r\n                    }\r\n                    return { value: value, done: true };\r\n                };\r\n                return MapIterator;\r\n            }());\r\n            return (function () {\r\n                function Map() {\r\n                    this._keys = [];\r\n                    this._values = [];\r\n                    this._cacheKey = cacheSentinel;\r\n                    this._cacheIndex = -2;\r\n                }\r\n                Object.defineProperty(Map.prototype, \"size\", {\r\n                    get: function () { return this._keys.length; },\r\n                    enumerable: true,\r\n                    configurable: true\r\n                });\r\n                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };\r\n                Map.prototype.get = function (key) {\r\n                    var index = this._find(key, /*insert*/ false);\r\n                    return index >= 0 ? this._values[index] : undefined;\r\n                };\r\n                Map.prototype.set = function (key, value) {\r\n                    var index = this._find(key, /*insert*/ true);\r\n                    this._values[index] = value;\r\n                    return this;\r\n                };\r\n                Map.prototype.delete = function (key) {\r\n                    var index = this._find(key, /*insert*/ false);\r\n                    if (index >= 0) {\r\n                        var size = this._keys.length;\r\n                        for (var i = index + 1; i < size; i++) {\r\n                            this._keys[i - 1] = this._keys[i];\r\n                            this._values[i - 1] = this._values[i];\r\n                        }\r\n                        this._keys.length--;\r\n                        this._values.length--;\r\n                        if (key === this._cacheKey) {\r\n                            this._cacheKey = cacheSentinel;\r\n                            this._cacheIndex = -2;\r\n                        }\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                };\r\n                Map.prototype.clear = function () {\r\n                    this._keys.length = 0;\r\n                    this._values.length = 0;\r\n                    this._cacheKey = cacheSentinel;\r\n                    this._cacheIndex = -2;\r\n                };\r\n                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };\r\n                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };\r\n                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };\r\n                Map.prototype[\"@@iterator\"] = function () { return this.entries(); };\r\n                Map.prototype[iteratorSymbol] = function () { return this.entries(); };\r\n                Map.prototype._find = function (key, insert) {\r\n                    if (this._cacheKey !== key) {\r\n                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);\r\n                    }\r\n                    if (this._cacheIndex < 0 && insert) {\r\n                        this._cacheIndex = this._keys.length;\r\n                        this._keys.push(key);\r\n                        this._values.push(undefined);\r\n                    }\r\n                    return this._cacheIndex;\r\n                };\r\n                return Map;\r\n            }());\r\n            function getKey(key, _) {\r\n                return key;\r\n            }\r\n            function getValue(_, value) {\r\n                return value;\r\n            }\r\n            function getEntry(key, value) {\r\n                return [key, value];\r\n            }\r\n        }\r\n        // naive Set shim\r\n        function CreateSetPolyfill() {\r\n            return (function () {\r\n                function Set() {\r\n                    this._map = new _Map();\r\n                }\r\n                Object.defineProperty(Set.prototype, \"size\", {\r\n                    get: function () { return this._map.size; },\r\n                    enumerable: true,\r\n                    configurable: true\r\n                });\r\n                Set.prototype.has = function (value) { return this._map.has(value); };\r\n                Set.prototype.add = function (value) { return this._map.set(value, value), this; };\r\n                Set.prototype.delete = function (value) { return this._map.delete(value); };\r\n                Set.prototype.clear = function () { this._map.clear(); };\r\n                Set.prototype.keys = function () { return this._map.keys(); };\r\n                Set.prototype.values = function () { return this._map.values(); };\r\n                Set.prototype.entries = function () { return this._map.entries(); };\r\n                Set.prototype[\"@@iterator\"] = function () { return this.keys(); };\r\n                Set.prototype[iteratorSymbol] = function () { return this.keys(); };\r\n                return Set;\r\n            }());\r\n        }\r\n        // naive WeakMap shim\r\n        function CreateWeakMapPolyfill() {\r\n            var UUID_SIZE = 16;\r\n            var keys = HashMap.create();\r\n            var rootKey = CreateUniqueKey();\r\n            return (function () {\r\n                function WeakMap() {\r\n                    this._key = CreateUniqueKey();\r\n                }\r\n                WeakMap.prototype.has = function (target) {\r\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n                    return table !== undefined ? HashMap.has(table, this._key) : false;\r\n                };\r\n                WeakMap.prototype.get = function (target) {\r\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n                    return table !== undefined ? HashMap.get(table, this._key) : undefined;\r\n                };\r\n                WeakMap.prototype.set = function (target, value) {\r\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);\r\n                    table[this._key] = value;\r\n                    return this;\r\n                };\r\n                WeakMap.prototype.delete = function (target) {\r\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n                    return table !== undefined ? delete table[this._key] : false;\r\n                };\r\n                WeakMap.prototype.clear = function () {\r\n                    // NOTE: not a real clear, just makes the previous data unreachable\r\n                    this._key = CreateUniqueKey();\r\n                };\r\n                return WeakMap;\r\n            }());\r\n            function CreateUniqueKey() {\r\n                var key;\r\n                do\r\n                    key = \"@@WeakMap@@\" + CreateUUID();\r\n                while (HashMap.has(keys, key));\r\n                keys[key] = true;\r\n                return key;\r\n            }\r\n            function GetOrCreateWeakMapTable(target, create) {\r\n                if (!hasOwn.call(target, rootKey)) {\r\n                    if (!create)\r\n                        return undefined;\r\n                    Object.defineProperty(target, rootKey, { value: HashMap.create() });\r\n                }\r\n                return target[rootKey];\r\n            }\r\n            function FillRandomBytes(buffer, size) {\r\n                for (var i = 0; i < size; ++i)\r\n                    buffer[i] = Math.random() * 0xff | 0;\r\n                return buffer;\r\n            }\r\n            function GenRandomBytes(size) {\r\n                if (typeof Uint8Array === \"function\") {\r\n                    if (typeof crypto !== \"undefined\")\r\n                        return crypto.getRandomValues(new Uint8Array(size));\r\n                    if (typeof msCrypto !== \"undefined\")\r\n                        return msCrypto.getRandomValues(new Uint8Array(size));\r\n                    return FillRandomBytes(new Uint8Array(size), size);\r\n                }\r\n                return FillRandomBytes(new Array(size), size);\r\n            }\r\n            function CreateUUID() {\r\n                var data = GenRandomBytes(UUID_SIZE);\r\n                // mark as random - RFC 4122  4.4\r\n                data[6] = data[6] & 0x4f | 0x40;\r\n                data[8] = data[8] & 0xbf | 0x80;\r\n                var result = \"\";\r\n                for (var offset = 0; offset < UUID_SIZE; ++offset) {\r\n                    var byte = data[offset];\r\n                    if (offset === 4 || offset === 6 || offset === 8)\r\n                        result += \"-\";\r\n                    if (byte < 16)\r\n                        result += \"0\";\r\n                    result += byte.toString(16).toLowerCase();\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.\r\n        function MakeDictionary(obj) {\r\n            obj.__ = undefined;\r\n            delete obj.__;\r\n            return obj;\r\n        }\r\n    });\r\n})(Reflect || (Reflect = {}));\r\n//# sourceMappingURL=Reflect.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlZmxlY3QtbWV0YWRhdGEvUmVmbGVjdC5qcz9hZTYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbURBQW1EO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSw2QkFBNkIsZ0JBQWdCLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0Q0FBNEM7QUFDM0U7QUFDQSxtQ0FBbUMsd0JBQXdCLGtCQUFrQixFQUFFO0FBQy9FLG1DQUFtQyx5QkFBeUIsRUFBRSxFQUFFO0FBQ2hFO0FBQ0EsdUNBQXVDLDhCQUE4QjtBQUNyRSx1Q0FBdUMsbUJBQW1CLEVBQUU7QUFDNUQ7QUFDQSx1Q0FBdUMscURBQXFEO0FBQzVGLHVDQUF1QyxpQkFBaUIsRUFBRTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDJDQUEyQztBQUMzQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDJDQUEyQztBQUMzQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsdUJBQXVCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDBCQUEwQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEYscUVBQXFFLGFBQWE7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMEJBQTBCLEVBQUU7QUFDbEU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixvREFBb0QsK0NBQStDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMERBQTBEO0FBQzVHLG9EQUFvRCw0REFBNEQ7QUFDaEgscURBQXFELDREQUE0RDtBQUNqSCwyREFBMkQsdUJBQXVCO0FBQ2xGLDZEQUE2RCx1QkFBdUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUJBQXVCLEVBQUU7QUFDL0Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzREFBc0QsNkJBQTZCO0FBQ25GLHNEQUFzRCwwQ0FBMEM7QUFDaEcseURBQXlELGdDQUFnQztBQUN6RixtREFBbUQsbUJBQW1CO0FBQ3RFLGtEQUFrRCx5QkFBeUI7QUFDM0Usb0RBQW9ELDJCQUEyQjtBQUMvRSxxREFBcUQsNEJBQTRCO0FBQ2pGLDJEQUEyRCxvQkFBb0I7QUFDL0UsNkRBQTZELG9CQUFvQjtBQUNqRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwQkFBMEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQywwQkFBMEI7QUFDM0IsbUMiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChDKSBNaWNyb3NvZnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG52YXIgUmVmbGVjdDtcclxuKGZ1bmN0aW9uIChSZWZsZWN0KSB7XHJcbiAgICAvLyBNZXRhZGF0YSBQcm9wb3NhbFxyXG4gICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS9cclxuICAgIChmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XHJcbiAgICAgICAgICAgIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOlxyXG4gICAgICAgICAgICAgICAgICAgIEZ1bmN0aW9uKFwicmV0dXJuIHRoaXM7XCIpKCk7XHJcbiAgICAgICAgdmFyIGV4cG9ydGVyID0gbWFrZUV4cG9ydGVyKFJlZmxlY3QpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygcm9vdC5SZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHJvb3QuUmVmbGVjdCA9IFJlZmxlY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBleHBvcnRlciA9IG1ha2VFeHBvcnRlcihyb290LlJlZmxlY3QsIGV4cG9ydGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmFjdG9yeShleHBvcnRlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZUV4cG9ydGVyKHRhcmdldCwgcHJldmlvdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtrZXldICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzKVxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pKGZ1bmN0aW9uIChleHBvcnRlcikge1xyXG4gICAgICAgIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG4gICAgICAgIC8vIGZlYXR1cmUgdGVzdCBmb3IgU3ltYm9sIHN1cHBvcnRcclxuICAgICAgICB2YXIgc3VwcG9ydHNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICAgICAgdmFyIHRvUHJpbWl0aXZlU3ltYm9sID0gc3VwcG9ydHNTeW1ib2wgJiYgdHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbC50b1ByaW1pdGl2ZSA6IFwiQEB0b1ByaW1pdGl2ZVwiO1xyXG4gICAgICAgIHZhciBpdGVyYXRvclN5bWJvbCA9IHN1cHBvcnRzU3ltYm9sICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wuaXRlcmF0b3IgOiBcIkBAaXRlcmF0b3JcIjtcclxuICAgICAgICB2YXIgc3VwcG9ydHNDcmVhdGUgPSB0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiOyAvLyBmZWF0dXJlIHRlc3QgZm9yIE9iamVjdC5jcmVhdGUgc3VwcG9ydFxyXG4gICAgICAgIHZhciBzdXBwb3J0c1Byb3RvID0geyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheTsgLy8gZmVhdHVyZSB0ZXN0IGZvciBfX3Byb3RvX18gc3VwcG9ydFxyXG4gICAgICAgIHZhciBkb3duTGV2ZWwgPSAhc3VwcG9ydHNDcmVhdGUgJiYgIXN1cHBvcnRzUHJvdG87XHJcbiAgICAgICAgdmFyIEhhc2hNYXAgPSB7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBvYmplY3QgaW4gZGljdGlvbmFyeSBtb2RlIChhLmsuYS4gXCJzbG93XCIgbW9kZSBpbiB2OClcclxuICAgICAgICAgICAgY3JlYXRlOiBzdXBwb3J0c0NyZWF0ZVxyXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeShPYmplY3QuY3JlYXRlKG51bGwpKTsgfVxyXG4gICAgICAgICAgICAgICAgOiBzdXBwb3J0c1Byb3RvXHJcbiAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeSh7IF9fcHJvdG9fXzogbnVsbCB9KTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFrZURpY3Rpb25hcnkoe30pOyB9LFxyXG4gICAgICAgICAgICBoYXM6IGRvd25MZXZlbFxyXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGhhc093bi5jYWxsKG1hcCwga2V5KTsgfVxyXG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGtleSBpbiBtYXA7IH0sXHJcbiAgICAgICAgICAgIGdldDogZG93bkxldmVsXHJcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uIChtYXAsIGtleSkgeyByZXR1cm4gaGFzT3duLmNhbGwobWFwLCBrZXkpID8gbWFwW2tleV0gOiB1bmRlZmluZWQ7IH1cclxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBtYXBba2V5XTsgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIExvYWQgZ2xvYmFsIG9yIHNoaW0gdmVyc2lvbnMgb2YgTWFwLCBTZXQsIGFuZCBXZWFrTWFwXHJcbiAgICAgICAgdmFyIGZ1bmN0aW9uUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uKTtcclxuICAgICAgICB2YXIgdXNlUG9seWZpbGwgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudltcIlJFRkxFQ1RfTUVUQURBVEFfVVNFX01BUF9QT0xZRklMTFwiXSA9PT0gXCJ0cnVlXCI7XHJcbiAgICAgICAgdmFyIF9NYXAgPSAhdXNlUG9seWZpbGwgJiYgdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmVudHJpZXMgPT09IFwiZnVuY3Rpb25cIiA/IE1hcCA6IENyZWF0ZU1hcFBvbHlmaWxsKCk7XHJcbiAgICAgICAgdmFyIF9TZXQgPSAhdXNlUG9seWZpbGwgJiYgdHlwZW9mIFNldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmVudHJpZXMgPT09IFwiZnVuY3Rpb25cIiA/IFNldCA6IENyZWF0ZVNldFBvbHlmaWxsKCk7XHJcbiAgICAgICAgdmFyIF9XZWFrTWFwID0gIXVzZVBvbHlmaWxsICYmIHR5cGVvZiBXZWFrTWFwID09PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogQ3JlYXRlV2Vha01hcFBvbHlmaWxsKCk7XHJcbiAgICAgICAgLy8gW1tNZXRhZGF0YV1dIGludGVybmFsIHNsb3RcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeS1vYmplY3QtaW50ZXJuYWwtbWV0aG9kcy1hbmQtaW50ZXJuYWwtc2xvdHNcclxuICAgICAgICB2YXIgTWV0YWRhdGEgPSBuZXcgX1dlYWtNYXAoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIGEgc2V0IG9mIGRlY29yYXRvcnMgdG8gYSBwcm9wZXJ0eSBvZiBhIHRhcmdldCBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIGRlY29yYXRvcnMgQW4gYXJyYXkgb2YgZGVjb3JhdG9ycy5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgdG8gZGVjb3JhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgdGhlIHRhcmdldCBrZXkuXHJcbiAgICAgICAgICogQHJlbWFya3MgRGVjb3JhdG9ycyBhcmUgYXBwbGllZCBpbiByZXZlcnNlIG9yZGVyLlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgRXhhbXBsZSA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIixcclxuICAgICAgICAgKiAgICAgICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiLFxyXG4gICAgICAgICAqICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIikpKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiLFxyXG4gICAgICAgICAqICAgICAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiLFxyXG4gICAgICAgICAqICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpKSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBkZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzQXJyYXkoZGVjb3JhdG9ycykpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QoYXR0cmlidXRlcykgJiYgIUlzVW5kZWZpbmVkKGF0dHJpYnV0ZXMpICYmICFJc051bGwoYXR0cmlidXRlcykpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKElzTnVsbChhdHRyaWJ1dGVzKSlcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0ZVByb3BlcnR5KGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc0FycmF5KGRlY29yYXRvcnMpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNDb25zdHJ1Y3Rvcih0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0ZUNvbnN0cnVjdG9yKGRlY29yYXRvcnMsIHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJkZWNvcmF0ZVwiLCBkZWNvcmF0ZSk7XHJcbiAgICAgICAgLy8gNC4xLjIgUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSlcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNyZWZsZWN0Lm1ldGFkYXRhXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBkZWZhdWx0IG1ldGFkYXRhIGRlY29yYXRvciBmYWN0b3J5IHRoYXQgY2FuIGJlIHVzZWQgb24gYSBjbGFzcywgY2xhc3MgbWVtYmVyLCBvciBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IFRoZSBrZXkgZm9yIHRoZSBtZXRhZGF0YSBlbnRyeS5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFWYWx1ZSBUaGUgdmFsdWUgZm9yIHRoZSBtZXRhZGF0YSBlbnRyeS5cclxuICAgICAgICAgKiBAcmV0dXJucyBBIGRlY29yYXRvciBmdW5jdGlvbi5cclxuICAgICAgICAgKiBAcmVtYXJrc1xyXG4gICAgICAgICAqIElmIGBtZXRhZGF0YUtleWAgaXMgYWxyZWFkeSBkZWZpbmVkIGZvciB0aGUgdGFyZ2V0IGFuZCB0YXJnZXQga2V5LCB0aGVcclxuICAgICAgICAgKiBtZXRhZGF0YVZhbHVlIGZvciB0aGF0IGtleSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IsIFR5cGVTY3JpcHQgb25seSlcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSwgVHlwZVNjcmlwdCBvbmx5KVxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXHJcbiAgICAgICAgICogICAgICAgICBwcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QoKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QoKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSAmJiAhSXNQcm9wZXJ0eUtleShwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRlY29yYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJtZXRhZGF0YVwiLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lIGEgdW5pcXVlIG1ldGFkYXRhIGVudHJ5IG9uIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YVZhbHVlIEEgdmFsdWUgdGhhdCBjb250YWlucyBhdHRhY2hlZCBtZXRhZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSBtZXRhZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBkZWNvcmF0b3IgZmFjdG9yeSBhcyBtZXRhZGF0YS1wcm9kdWNpbmcgYW5ub3RhdGlvbi5cclxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gTXlBbm5vdGF0aW9uKG9wdGlvbnMpOiBEZWNvcmF0b3Ige1xyXG4gICAgICAgICAqICAgICAgICAgcmV0dXJuICh0YXJnZXQsIGtleT8pID0+IFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCB0YXJnZXQsIGtleSk7XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZGVmaW5lTWV0YWRhdGFcIiwgZGVmaW5lTWV0YWRhdGEpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbiBoYXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBrZXkgd2FzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbjsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlIYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiaGFzTWV0YWRhdGFcIiwgaGFzTWV0YWRhdGEpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHRhcmdldCBvYmplY3QgaGFzIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWV0YWRhdGEga2V5IHdhcyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0OyBvdGhlcndpc2UsIGBmYWxzZWAuXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJoYXNPd25NZXRhZGF0YVwiLCBoYXNPd25NZXRhZGF0YSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbi5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGtleSBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHBvcnRlcihcImdldE1ldGFkYXRhXCIsIGdldE1ldGFkYXRhKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBvbiB0aGUgdGFyZ2V0IG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGtleSBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHBvcnRlcihcImdldE93bk1ldGFkYXRhXCIsIGdldE93bk1ldGFkYXRhKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBrZXlzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbi5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdW5pcXVlIG1ldGFkYXRhIGtleXMuXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlNZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZ2V0TWV0YWRhdGFLZXlzXCIsIGdldE1ldGFkYXRhS2V5cyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdW5pcXVlIG1ldGFkYXRhIGtleXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdW5pcXVlIG1ldGFkYXRhIGtleXMuXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlPd25NZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZ2V0T3duTWV0YWRhdGFLZXlzXCIsIGdldE93bk1ldGFkYXRhS2V5cyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyB0aGUgbWV0YWRhdGEgZW50cnkgZnJvbSB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoIHRoZSBwcm92aWRlZCBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG1ldGFkYXRhIGVudHJ5IHdhcyBmb3VuZCBhbmQgZGVsZXRlZDsgb3RoZXJ3aXNlLCBmYWxzZS5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcCh0YXJnZXQsIHByb3BlcnR5S2V5LCAvKkNyZWF0ZSovIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCFtZXRhZGF0YU1hcC5kZWxldGUobWV0YWRhdGFLZXkpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAobWV0YWRhdGFNYXAuc2l6ZSA+IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldE1ldGFkYXRhID0gTWV0YWRhdGEuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhLmRlbGV0ZShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRNZXRhZGF0YS5zaXplID4gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBNZXRhZGF0YS5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZGVsZXRlTWV0YWRhdGFcIiwgZGVsZXRlTWV0YWRhdGEpO1xyXG4gICAgICAgIGZ1bmN0aW9uIERlY29yYXRlQ29uc3RydWN0b3IoZGVjb3JhdG9ycywgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdG9yID0gZGVjb3JhdG9yc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0ZWQgPSBkZWNvcmF0b3IodGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQoZGVjb3JhdGVkKSAmJiAhSXNOdWxsKGRlY29yYXRlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzQ29uc3RydWN0b3IoZGVjb3JhdGVkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGRlY29yYXRlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBEZWNvcmF0ZVByb3BlcnR5KGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBkZWNvcmF0b3JzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRlZCA9IGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQoZGVjb3JhdGVkKSAmJiAhSXNOdWxsKGRlY29yYXRlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KGRlY29yYXRlZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gZGVjb3JhdGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIENyZWF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBNZXRhZGF0YS5nZXQoTyk7XHJcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZCh0YXJnZXRNZXRhZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghQ3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRNZXRhZGF0YSA9IG5ldyBfTWFwKCk7XHJcbiAgICAgICAgICAgICAgICBNZXRhZGF0YS5zZXQoTywgdGFyZ2V0TWV0YWRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IHRhcmdldE1ldGFkYXRhLmdldChQKTtcclxuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFDcmVhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhTWFwID0gbmV3IF9NYXAoKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhLnNldChQLCBtZXRhZGF0YU1hcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhTWFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAzLjEuMS4xIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnloYXNtZXRhZGF0YVxyXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcclxuICAgICAgICAgICAgdmFyIGhhc093biA9IE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pO1xyXG4gICAgICAgICAgICBpZiAoIUlzTnVsbChwYXJlbnQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4xLjIuMSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5aGFzb3dubWV0YWRhdGFcclxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBUb0Jvb2xlYW4obWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuMS4zLjEgT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWdldG1ldGFkYXRhXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xyXG4gICAgICAgICAgICB2YXIgaGFzT3duID0gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd24pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pO1xyXG4gICAgICAgICAgICBpZiAoIUlzTnVsbChwYXJlbnQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCk7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuMS40LjEgT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWdldG93bm1ldGFkYXRhXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuMS41LjEgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUClcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWRlZmluZW93bm1ldGFkYXRhXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUCkge1xyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gdHJ1ZSk7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuMS42LjEgT3JkaW5hcnlNZXRhZGF0YUtleXMoTywgUClcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeW1ldGFkYXRha2V5c1xyXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5TWV0YWRhdGFLZXlzKE8sIFApIHtcclxuICAgICAgICAgICAgdmFyIG93bktleXMgPSBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duS2V5cztcclxuICAgICAgICAgICAgdmFyIHBhcmVudEtleXMgPSBPcmRpbmFyeU1ldGFkYXRhS2V5cyhwYXJlbnQsIFApO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50S2V5cy5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBvd25LZXlzO1xyXG4gICAgICAgICAgICBpZiAob3duS2V5cy5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRLZXlzO1xyXG4gICAgICAgICAgICB2YXIgc2V0ID0gbmV3IF9TZXQoKTtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBvd25LZXlzXzEgPSBvd25LZXlzOyBfaSA8IG93bktleXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBvd25LZXlzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0tleSA9IHNldC5oYXMoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgcGFyZW50S2V5c18xID0gcGFyZW50S2V5czsgX2EgPCBwYXJlbnRLZXlzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gcGFyZW50S2V5c18xW19hXTtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNLZXkgPSBzZXQuaGFzKGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0tleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldC5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4xLjcuMSBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5b3dubWV0YWRhdGFrZXlzXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCkge1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICAgIHZhciBrZXlzT2JqID0gbWV0YWRhdGFNYXAua2V5cygpO1xyXG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBHZXRJdGVyYXRvcihrZXlzT2JqKTtcclxuICAgICAgICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5cy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IEl0ZXJhdG9yVmFsdWUobmV4dCk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXNba10gPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBrKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNiBFQ01BU2NyaXB0IERhdGEgVHlwMGVzIGFuZCBWYWx1ZXNcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWRhdGEtdHlwZXMtYW5kLXZhbHVlc1xyXG4gICAgICAgIGZ1bmN0aW9uIFR5cGUoeCkge1xyXG4gICAgICAgICAgICBpZiAoeCA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIE51bGwgKi87XHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHgpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjogcmV0dXJuIDAgLyogVW5kZWZpbmVkICovO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjogcmV0dXJuIDIgLyogQm9vbGVhbiAqLztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIDMgLyogU3RyaW5nICovO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInN5bWJvbFwiOiByZXR1cm4gNCAvKiBTeW1ib2wgKi87XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6IHJldHVybiA1IC8qIE51bWJlciAqLztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjogcmV0dXJuIHggPT09IG51bGwgPyAxIC8qIE51bGwgKi8gOiA2IC8qIE9iamVjdCAqLztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiA2IC8qIE9iamVjdCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA2LjEuMSBUaGUgVW5kZWZpbmVkIFR5cGVcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLXVuZGVmaW5lZC10eXBlXHJcbiAgICAgICAgZnVuY3Rpb24gSXNVbmRlZmluZWQoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4geCA9PT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA2LjEuMiBUaGUgTnVsbCBUeXBlXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcy1udWxsLXR5cGVcclxuICAgICAgICBmdW5jdGlvbiBJc051bGwoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4geCA9PT0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNi4xLjUgVGhlIFN5bWJvbCBUeXBlXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcy1zeW1ib2wtdHlwZVxyXG4gICAgICAgIGZ1bmN0aW9uIElzU3ltYm9sKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA2LjEuNyBUaGUgT2JqZWN0IFR5cGVcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QtdHlwZVxyXG4gICAgICAgIGZ1bmN0aW9uIElzT2JqZWN0KHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiID8geCAhPT0gbnVsbCA6IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuMSBUeXBlIENvbnZlcnNpb25cclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlLWNvbnZlcnNpb25cclxuICAgICAgICAvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxyXG4gICAgICAgIGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0LCBQcmVmZXJyZWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoVHlwZShpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBVbmRlZmluZWQgKi86IHJldHVybiBpbnB1dDtcclxuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBOdWxsICovOiByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogQm9vbGVhbiAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIFN0cmluZyAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFN5bWJvbCAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1IC8qIE51bWJlciAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBoaW50ID0gUHJlZmVycmVkVHlwZSA9PT0gMyAvKiBTdHJpbmcgKi8gPyBcInN0cmluZ1wiIDogUHJlZmVycmVkVHlwZSA9PT0gNSAvKiBOdW1iZXIgKi8gPyBcIm51bWJlclwiIDogXCJkZWZhdWx0XCI7XHJcbiAgICAgICAgICAgIHZhciBleG90aWNUb1ByaW0gPSBHZXRNZXRob2QoaW5wdXQsIHRvUHJpbWl0aXZlU3ltYm9sKTtcclxuICAgICAgICAgICAgaWYgKGV4b3RpY1RvUHJpbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZXhvdGljVG9QcmltLmNhbGwoaW5wdXQsIGhpbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKElzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgaGludCA9PT0gXCJkZWZhdWx0XCIgPyBcIm51bWJlclwiIDogaGludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuMS4xLjEgT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcclxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpIHtcclxuICAgICAgICAgICAgaWYgKGhpbnQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b1N0cmluZ18xID0gTy50b1N0cmluZztcclxuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHRvU3RyaW5nXzEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRvU3RyaW5nXzEuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVPZiA9IE8udmFsdWVPZjtcclxuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHZhbHVlT2YpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlT2YuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVPZiA9IE8udmFsdWVPZjtcclxuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHZhbHVlT2YpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlT2YuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9TdHJpbmdfMiA9IE8udG9TdHJpbmc7XHJcbiAgICAgICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh0b1N0cmluZ18yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0b1N0cmluZ18yLmNhbGwoTyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4xLjIgVG9Cb29sZWFuKGFyZ3VtZW50KVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8yMDE2LyNzZWMtdG9ib29sZWFuXHJcbiAgICAgICAgZnVuY3Rpb24gVG9Cb29sZWFuKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIWFyZ3VtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjEuMTIgVG9TdHJpbmcoYXJndW1lbnQpXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9zdHJpbmdcclxuICAgICAgICBmdW5jdGlvbiBUb1N0cmluZyhhcmd1bWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIGFyZ3VtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjEuMTQgVG9Qcm9wZXJ0eUtleShhcmd1bWVudClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XHJcbiAgICAgICAgZnVuY3Rpb24gVG9Qcm9wZXJ0eUtleShhcmd1bWVudCkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gVG9QcmltaXRpdmUoYXJndW1lbnQsIDMgLyogU3RyaW5nICovKTtcclxuICAgICAgICAgICAgaWYgKElzU3ltYm9sKGtleSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICByZXR1cm4gVG9TdHJpbmcoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4yIFRlc3RpbmcgYW5kIENvbXBhcmlzb24gT3BlcmF0aW9uc1xyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRlc3RpbmctYW5kLWNvbXBhcmlzb24tb3BlcmF0aW9uc1xyXG4gICAgICAgIC8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNhcnJheVxyXG4gICAgICAgIGZ1bmN0aW9uIElzQXJyYXkoYXJndW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXlcclxuICAgICAgICAgICAgICAgID8gQXJyYXkuaXNBcnJheShhcmd1bWVudClcclxuICAgICAgICAgICAgICAgIDogYXJndW1lbnQgaW5zdGFuY2VvZiBPYmplY3RcclxuICAgICAgICAgICAgICAgICAgICA/IGFyZ3VtZW50IGluc3RhbmNlb2YgQXJyYXlcclxuICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4yLjMgSXNDYWxsYWJsZShhcmd1bWVudClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXHJcbiAgICAgICAgZnVuY3Rpb24gSXNDYWxsYWJsZShhcmd1bWVudCkge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gYXMgd2UgY2Fubm90IGNoZWNrIGZvciBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2QuXHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT09IFwiZnVuY3Rpb25cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4yLjQgSXNDb25zdHJ1Y3Rvcihhcmd1bWVudClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXHJcbiAgICAgICAgZnVuY3Rpb24gSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gYXMgd2UgY2Fubm90IGNoZWNrIGZvciBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZC5cclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjIuNyBJc1Byb3BlcnR5S2V5KGFyZ3VtZW50KVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzcHJvcGVydHlrZXlcclxuICAgICAgICBmdW5jdGlvbiBJc1Byb3BlcnR5S2V5KGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoVHlwZShhcmd1bWVudCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBTdHJpbmcgKi86IHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFN5bWJvbCAqLzogcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4zIE9wZXJhdGlvbnMgb24gT2JqZWN0c1xyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24tb2JqZWN0c1xyXG4gICAgICAgIC8vIDcuMy45IEdldE1ldGhvZChWLCBQKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxyXG4gICAgICAgIGZ1bmN0aW9uIEdldE1ldGhvZChWLCBQKSB7XHJcbiAgICAgICAgICAgIHZhciBmdW5jID0gVltQXTtcclxuICAgICAgICAgICAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCB8fCBmdW5jID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKCFJc0NhbGxhYmxlKGZ1bmMpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuYztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy40IE9wZXJhdGlvbnMgb24gSXRlcmF0b3IgT2JqZWN0c1xyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24taXRlcmF0b3Itb2JqZWN0c1xyXG4gICAgICAgIGZ1bmN0aW9uIEdldEl0ZXJhdG9yKG9iaikge1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gR2V0TWV0aG9kKG9iaiwgaXRlcmF0b3JTeW1ib2wpO1xyXG4gICAgICAgICAgICBpZiAoIUlzQ2FsbGFibGUobWV0aG9kKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gZnJvbSBDYWxsXHJcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG1ldGhvZC5jYWxsKG9iaik7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QoaXRlcmF0b3IpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuNC40IEl0ZXJhdG9yVmFsdWUoaXRlclJlc3VsdClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvMjAxNi8jc2VjLWl0ZXJhdG9ydmFsdWVcclxuICAgICAgICBmdW5jdGlvbiBJdGVyYXRvclZhbHVlKGl0ZXJSZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZXJSZXN1bHQudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuNC41IEl0ZXJhdG9yU3RlcChpdGVyYXRvcilcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pdGVyYXRvcnN0ZXBcclxuICAgICAgICBmdW5jdGlvbiBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gZmFsc2UgOiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXRlcmF0b3JjbG9zZVxyXG4gICAgICAgIGZ1bmN0aW9uIEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBpdGVyYXRvcltcInJldHVyblwiXTtcclxuICAgICAgICAgICAgaWYgKGYpXHJcbiAgICAgICAgICAgICAgICBmLmNhbGwoaXRlcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA5LjEgT3JkaW5hcnkgT2JqZWN0IEludGVybmFsIE1ldGhvZHMgYW5kIEludGVybmFsIFNsb3RzXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnktb2JqZWN0LWludGVybmFsLW1ldGhvZHMtYW5kLWludGVybmFsLXNsb3RzXHJcbiAgICAgICAgLy8gOS4xLjEuMSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnlnZXRwcm90b3R5cGVvZlxyXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTykge1xyXG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgTyAhPT0gXCJmdW5jdGlvblwiIHx8IE8gPT09IGZ1bmN0aW9uUHJvdG90eXBlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3Qgc2V0IF9fcHJvdG9fXyBpbiBFUzUsIGFzIGl0J3Mgbm9uLXN0YW5kYXJkLlxyXG4gICAgICAgICAgICAvLyBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yLiBDb21wYXRpYmxlIGltcGxlbWVudGF0aW9uc1xyXG4gICAgICAgICAgICAvLyBtdXN0IGVpdGhlciBzZXQgX19wcm90b19fIG9uIGEgc3ViY2xhc3MgY29uc3RydWN0b3IgdG8gdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIC8vIG9yIGVuc3VyZSBlYWNoIGNsYXNzIGhhcyBhIHZhbGlkIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgb24gaXRzIHByb3RvdHlwZSB0aGF0XHJcbiAgICAgICAgICAgIC8vIHBvaW50cyBiYWNrIHRvIHRoZSBjb25zdHJ1Y3Rvci5cclxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgRnVuY3Rpb24uW1tQcm90b3R5cGVdXSwgdGhlbiB0aGlzIGlzIGRlZmluYXRlbHkgaW5oZXJpdGVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gaW4gRVM2IG9yIHdoZW4gdXNpbmcgX19wcm90b19fIGluIGEgY29tcGF0aWJsZSBicm93c2VyLlxyXG4gICAgICAgICAgICBpZiAocHJvdG8gIT09IGZ1bmN0aW9uUHJvdG90eXBlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgc3VwZXIgcHJvdG90eXBlIGlzIE9iamVjdC5wcm90b3R5cGUsIG51bGwsIG9yIHVuZGVmaW5lZCwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cclxuICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IE8ucHJvdG90eXBlO1xyXG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlUHJvdG8gPSBwcm90b3R5cGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSk7XHJcbiAgICAgICAgICAgIGlmIChwcm90b3R5cGVQcm90byA9PSBudWxsIHx8IHByb3RvdHlwZVByb3RvID09PSBPYmplY3QucHJvdG90eXBlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgY29uc3RydWN0b3Igd2FzIG5vdCBhIGZ1bmN0aW9uLCB0aGVuIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGhlcml0YWdlLlxyXG4gICAgICAgICAgICB2YXIgY29uc3RydWN0b3IgPSBwcm90b3R5cGVQcm90by5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvciAhPT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHNvbWUga2luZCBvZiBzZWxmLXJlZmVyZW5jZSwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cclxuICAgICAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBPKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGEgcHJldHR5IGdvb2QgZ3Vlc3MgYXQgdGhlIGhlcml0YWdlLlxyXG4gICAgICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG5haXZlIE1hcCBzaGltXHJcbiAgICAgICAgZnVuY3Rpb24gQ3JlYXRlTWFwUG9seWZpbGwoKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWNoZVNlbnRpbmVsID0ge307XHJcbiAgICAgICAgICAgIHZhciBhcnJheVNlbnRpbmVsID0gW107XHJcbiAgICAgICAgICAgIHZhciBNYXBJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNYXBJdGVyYXRvcihrZXlzLCB2YWx1ZXMsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBrZXlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxuICAgICAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3NlbGVjdG9yKHRoaXMuX2tleXNbaW5kZXhdLCB0aGlzLl92YWx1ZXNbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA+PSB0aGlzLl9rZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gYXJyYXlTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdCwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS50aHJvdyA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXBJdGVyYXRvcjtcclxuICAgICAgICAgICAgfSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNYXAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5ID0gY2FjaGVTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gLTI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2tleXMubGVuZ3RoOyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gZmFsc2UpID49IDA7IH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyB0aGlzLl92YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5fa2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleCArIDE7IGkgPCBzaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXNbaSAtIDFdID0gdGhpcy5fa2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpIC0gMV0gPSB0aGlzLl92YWx1ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5sZW5ndGgtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSB0aGlzLl9jYWNoZUtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IC0yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSAtMjtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRLZXkpOyB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRWYWx1ZSk7IH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRFbnRyeSk7IH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW50cmllcygpOyB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmVudHJpZXMoKTsgfTtcclxuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuX2ZpbmQgPSBmdW5jdGlvbiAoa2V5LCBpbnNlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVLZXkgIT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gdGhpcy5fa2V5cy5pbmRleE9mKHRoaXMuX2NhY2hlS2V5ID0ga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlSW5kZXggPCAwICYmIGluc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gdGhpcy5fa2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVJbmRleDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWFwO1xyXG4gICAgICAgICAgICB9KCkpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRLZXkoa2V5LCBfKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKF8sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RW50cnkoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBuYWl2ZSBTZXQgc2hpbVxyXG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZVNldFBvbHlmaWxsKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNldCgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAgPSBuZXcgX01hcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldC5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAuc2l6ZTsgfSxcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5fbWFwLmhhcyh2YWx1ZSk7IH07XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5fbWFwLnNldCh2YWx1ZSwgdmFsdWUpLCB0aGlzOyB9O1xyXG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuX21hcC5kZWxldGUodmFsdWUpOyB9O1xyXG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fbWFwLmNsZWFyKCk7IH07XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAua2V5cygpOyB9O1xyXG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAudmFsdWVzKCk7IH07XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAuZW50cmllcygpOyB9O1xyXG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZVtcIkBAaXRlcmF0b3JcIl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmtleXMoKTsgfTtcclxuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlzKCk7IH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU2V0O1xyXG4gICAgICAgICAgICB9KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBuYWl2ZSBXZWFrTWFwIHNoaW1cclxuICAgICAgICBmdW5jdGlvbiBDcmVhdGVXZWFrTWFwUG9seWZpbGwoKSB7XHJcbiAgICAgICAgICAgIHZhciBVVUlEX1NJWkUgPSAxNjtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBIYXNoTWFwLmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICB2YXIgcm9vdEtleSA9IENyZWF0ZVVuaXF1ZUtleSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5ID0gQ3JlYXRlVW5pcXVlS2V5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUgIT09IHVuZGVmaW5lZCA/IEhhc2hNYXAuaGFzKHRhYmxlLCB0aGlzLl9rZXkpIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBIYXNoTWFwLmdldCh0YWJsZSwgdGhpcy5fa2V5KSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0YWJsZVt0aGlzLl9rZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBkZWxldGUgdGFibGVbdGhpcy5fa2V5XSA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IG5vdCBhIHJlYWwgY2xlYXIsIGp1c3QgbWFrZXMgdGhlIHByZXZpb3VzIGRhdGEgdW5yZWFjaGFibGVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXkgPSBDcmVhdGVVbmlxdWVLZXkoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gV2Vha01hcDtcclxuICAgICAgICAgICAgfSgpKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQ3JlYXRlVW5pcXVlS2V5KCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gXCJAQFdlYWtNYXBAQFwiICsgQ3JlYXRlVVVJRCgpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKEhhc2hNYXAuaGFzKGtleXMsIGtleSkpO1xyXG4gICAgICAgICAgICAgICAga2V5c1trZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCBjcmVhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzT3duLmNhbGwodGFyZ2V0LCByb290S2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHJvb3RLZXksIHsgdmFsdWU6IEhhc2hNYXAuY3JlYXRlKCkgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Jvb3RLZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEZpbGxSYW5kb21CeXRlcyhidWZmZXIsIHNpemUpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IE1hdGgucmFuZG9tKCkgKiAweGZmIHwgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gR2VuUmFuZG9tQnl0ZXMoc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbXNDcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWxsUmFuZG9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSksIHNpemUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZpbGxSYW5kb21CeXRlcyhuZXcgQXJyYXkoc2l6ZSksIHNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIENyZWF0ZVVVSUQoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IEdlblJhbmRvbUJ5dGVzKFVVSURfU0laRSk7XHJcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIHJhbmRvbSAtIFJGQyA0MTIyIMKnIDQuNFxyXG4gICAgICAgICAgICAgICAgZGF0YVs2XSA9IGRhdGFbNl0gJiAweDRmIHwgMHg0MDtcclxuICAgICAgICAgICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdICYgMHhiZiB8IDB4ODA7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IFVVSURfU0laRTsgKytvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZSA9IGRhdGFbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09PSA0IHx8IG9mZnNldCA9PT0gNiB8fCBvZmZzZXQgPT09IDgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIi1cIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZSA8IDE2KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIwXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJ5dGUudG9TdHJpbmcoMTYpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVzZXMgYSBoZXVyaXN0aWMgdXNlZCBieSB2OCBhbmQgY2hha3JhIHRvIGZvcmNlIGFuIG9iamVjdCBpbnRvIGRpY3Rpb25hcnkgbW9kZS5cclxuICAgICAgICBmdW5jdGlvbiBNYWtlRGljdGlvbmFyeShvYmopIHtcclxuICAgICAgICAgICAgb2JqLl9fID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBkZWxldGUgb2JqLl9fO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KShSZWZsZWN0IHx8IChSZWZsZWN0ID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVmbGVjdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVmbGVjdC1tZXRhZGF0YS9SZWZsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(0)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/NGE4MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(14);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzP2I3ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTs7QUFFQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQSIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz85YzMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxFQUFFO0FBQ3JELHdDQUF3QyxXQUFXLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDLEdBQUc7QUFDSDtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(12);\n// On some exotic environments, it's not clear which object `setimmeidate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/YjA4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWlkYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_property_decorator__ = __webpack_require__(23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_property_decorator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue_property_decorator__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_draggable_vue_directive__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_draggable_vue_directive___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_draggable_vue_directive__);\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\nvar App = /** @class */ (function (_super) {\r\n    __extends(App, _super);\r\n    function App() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.boxes = 0;\r\n        _this.draggableWithHandler = { handle: undefined };\r\n        _this.draggableWithBoundries = {};\r\n        _this.draggableWithResetPosition = { resetInitialPos: false };\r\n        return _this;\r\n    }\r\n    App.prototype.addBox = function () {\r\n        this.boxes++;\r\n    };\r\n    App.prototype.clearAll = function () {\r\n        this.boxes = 0;\r\n    };\r\n    App.prototype.mounted = function () {\r\n        this.draggableWithBoundries.boundingElement = this.$refs.bounder;\r\n        this.draggableWithBoundries.boundingRectMargin = {\r\n            top: 2,\r\n            bottom: 2,\r\n            left: 2,\r\n            right: 2\r\n        };\r\n        this.draggableWithHandler.handle = this.$refs.handler;\r\n    };\r\n    App.prototype.onReset = function () {\r\n        var _this = this;\r\n        this.draggableWithResetPosition.resetInitialPos = true;\r\n        setTimeout(function () {\r\n            _this.draggableWithResetPosition.resetInitialPos = false;\r\n        }, 0);\r\n    };\r\n    App = __decorate([\r\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vue_property_decorator__[\"Component\"])({\r\n            directives: {\r\n                Draggable: __WEBPACK_IMPORTED_MODULE_1_draggable_vue_directive__[\"Draggable\"]\r\n            }\r\n        })\r\n    ], App);\r\n    return App;\r\n}(__WEBPACK_IMPORTED_MODULE_0_vue_property_decorator__[\"Vue\"]));\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (App);\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9hcHAvYXBwLnZ1ZT83ZDQwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStDOEQ7QUFDTTtBQU1wRTtJQUFpQyx1QkFBRztJQUxwQztRQUFBLHFFQXFDQztRQS9CRyxXQUFLLEdBQVcsQ0FBQyxDQUFDO1FBQ2xCLDBCQUFvQixHQUFtQixFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsQ0FBQztRQUM3RCw0QkFBc0IsR0FBbUIsRUFBRSxDQUFDO1FBQzVDLGdDQUEwQixHQUFtQixFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQzs7SUE0QjVFLENBQUM7SUExQkcsb0JBQU0sR0FBTjtRQUNJLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNqQixDQUFDO0lBRUQsc0JBQVEsR0FBUjtRQUNJLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLENBQUM7SUFFRCxxQkFBTyxHQUFQO1FBQ0ksSUFBSSxDQUFDLHNCQUFzQixDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQXNCLENBQUM7UUFDaEYsSUFBSSxDQUFDLHNCQUFzQixDQUFDLGtCQUFrQixHQUFHO1lBQzdDLEdBQUcsRUFBRSxDQUFDO1lBQ04sTUFBTSxFQUFFLENBQUM7WUFDVCxJQUFJLEVBQUUsQ0FBQztZQUNQLEtBQUssRUFBRSxDQUFDO1NBQ1gsQ0FBQztRQUVGLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFzQixDQUFDO0lBQ3pFLENBQUM7SUFFRCxxQkFBTyxHQUFQO1FBQUEsaUJBS0M7UUFKRyxJQUFJLENBQUMsMEJBQTBCLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztRQUN2RCxVQUFVLENBQUM7WUFDUCxLQUFJLENBQUMsMEJBQTBCLENBQUMsZUFBZSxHQUFHLEtBQUssQ0FBQztRQUM1RCxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDVixDQUFDO0lBL0JnQixHQUFHO1FBTHZCLHdGQUFTLENBQUM7WUFDUCxVQUFVLEVBQUU7Z0JBQ1IsU0FBUzthQUNaO1NBQ0osQ0FBQztPQUNtQixHQUFHLENBZ0N2QjtJQUFELFVBQUM7Q0FBQSxDQWhDZ0MsMkRBQUcsR0FnQ25DOytEQWhDb0IsR0FBRyIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXHJcbmltcG9ydCB7IFZ1ZSwgQ29tcG9uZW50LCBQcm9wIH0gZnJvbSBcInZ1ZS1wcm9wZXJ0eS1kZWNvcmF0b3JcIjtcclxuaW1wb3J0IHsgRHJhZ2dhYmxlLCBEcmFnZ2FibGVWYWx1ZSB9IGZyb20gXCJkcmFnZ2FibGUtdnVlLWRpcmVjdGl2ZVwiO1xyXG5AQ29tcG9uZW50KHtcclxuICAgIGRpcmVjdGl2ZXM6IHtcclxuICAgICAgICBEcmFnZ2FibGVcclxuICAgIH1cclxufSlcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwIGV4dGVuZHMgVnVlIHsgXHJcbiAgICBib3hlczogbnVtYmVyID0gMDtcclxuICAgIGRyYWdnYWJsZVdpdGhIYW5kbGVyOiBEcmFnZ2FibGVWYWx1ZSA9IHsgaGFuZGxlOiB1bmRlZmluZWQgfTtcclxuICAgIGRyYWdnYWJsZVdpdGhCb3VuZHJpZXM6IERyYWdnYWJsZVZhbHVlID0ge307IFxyXG4gICAgZHJhZ2dhYmxlV2l0aFJlc2V0UG9zaXRpb246IERyYWdnYWJsZVZhbHVlID0geyByZXNldEluaXRpYWxQb3M6IGZhbHNlIH07XHJcblxyXG4gICAgYWRkQm94KCkge1xyXG4gICAgICAgIHRoaXMuYm94ZXMrKzsgXHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXJBbGwoKSB7XHJcbiAgICAgICAgdGhpcy5ib3hlcyA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgbW91bnRlZCgpIHtcclxuICAgICAgICB0aGlzLmRyYWdnYWJsZVdpdGhCb3VuZHJpZXMuYm91bmRpbmdFbGVtZW50ID0gdGhpcy4kcmVmcy5ib3VuZGVyIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlV2l0aEJvdW5kcmllcy5ib3VuZGluZ1JlY3RNYXJnaW4gPSB7XHJcbiAgICAgICAgICAgIHRvcDogMixcclxuICAgICAgICAgICAgYm90dG9tOiAyLFxyXG4gICAgICAgICAgICBsZWZ0OiAyLFxyXG4gICAgICAgICAgICByaWdodDogMlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlV2l0aEhhbmRsZXIuaGFuZGxlID0gdGhpcy4kcmVmcy5oYW5kbGVyIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIG9uUmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2FibGVXaXRoUmVzZXRQb3NpdGlvbi5yZXNldEluaXRpYWxQb3MgPSB0cnVlO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZVdpdGhSZXNldFBvc2l0aW9uLnJlc2V0SW5pdGlhbFBvcyA9IGZhbHNlO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL2FwcC9hcHAudnVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_app_app_vue__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_app_app_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__components_app_app_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index_scss__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__index_scss__);\n\r\n\r\n\r\nvar v = new __WEBPACK_IMPORTED_MODULE_0_vue__[\"default\"]({\r\n    el: \"#app\",\r\n    template: \"\\n    <App/>\\n    \",\r\n    components: {\r\n        App: __WEBPACK_IMPORTED_MODULE_1__components_app_app_vue___default.a\r\n    }\r\n});\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHM/ZWFjMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0I7QUFDcUI7QUFDckI7QUFFdEIsSUFBSSxDQUFDLEdBQUcsSUFBSSw0Q0FBRyxDQUFDO0lBQ1osRUFBRSxFQUFFLE1BQU07SUFDVixRQUFRLEVBQUUsb0JBRVQ7SUFDRCxVQUFVLEVBQUU7UUFDUixHQUFHO0tBQ047Q0FDSixDQUFDLENBQUMiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVnVlIGZyb20gXCJ2dWVcIjtcbmltcG9ydCBBcHAgZnJvbSBcIi4vY29tcG9uZW50cy9hcHAvYXBwLnZ1ZVwiO1xuaW1wb3J0IFwiLi9pbmRleC5zY3NzXCI7XG5cbmxldCB2ID0gbmV3IFZ1ZSh7XG4gICAgZWw6IFwiI2FwcFwiLFxuICAgIHRlbXBsYXRlOiBgXG4gICAgPEFwcC8+XG4gICAgYCxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEFwcFxuICAgIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2luZGV4LnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/gif;base64,R0lGODlhpQPhAff/AAMDAwMDCwMDEwsDAwsDEwsDCxMLGwsLEwsLGwMDGxMDAxMLEwsDGxsTJBsTGxMLCwsMCxsLCxMLIysbJCMbIwsLIxsDAzUjIxMMAxMTGyMUCxMDCxMTIxsLAwsMAysdGyMTGysIBCMTIysdEyMTEy4TCyMLAzQjKxsLEyMLDEMrKxsTExsTCiMDA0QrI1M6KxMUECsjJjssIUgzKyMcKzMhGzYGBEcoBywTE0YqGzUbEzsrKyMdGzcjEyMVAzsjG1YoCTkuDlYyHzYTA1lFJ2VDNGVBK0YZAysbClY7NFs7KzYbCysTA0g5NkoFAzcbA0cuE3lHJ0szISEbE3pYRmcwCGdQRjgjCXNONmhLNodeOWhOKH9lWUg+IX1SNllDNWY5H5V1WxseCZBABzg3N0MzIH1nSFc7IQYHBVZJR45oWFg3BwgHCHhdOUk+K4daJJBtRkUjE0UbDp5/chscG3hVJzQ3JL1/Rm1AA3lDFpJPH92HRDArIHgxBisnCCElE49hMWkhBK6Gc2lXONWnkstqEo95b/nJmlhROI5hRqZ2Wn4/ClYZBKWHXvGndZBRL6BoR2c+EZ92Rffr2Xlwb7i6mX9PDUhHR7mXb49PDNOVb1g2E4B5XLZ+Wi4tK9+oe4B/eGcIA7iPX/n59bhvQp5jMLikn0hHOL2Jcp+ijsp0LVhXSHNfV9jRu59SCr7As/GdXdKYfmdiSPe4f/O0j7BgKdW7sKBlO9uWXWdDILJWBWdaU7RwL/bLriMjI5ekeM+me7+dfzszJMeQXNi6n/ndtrJdGK+Yf6t3RdeIWY9/fdq2j5uOdPTPvztBIL+gjnNBG5CJX8WAWa+bjvO4nmdwUmpnXVZVVZ9eIOGALJaPi3F/W/nixw8QDBkaEyMZDS0OB5yfizAWCoVzbEdBMD4bDSQYBi0wG14uEzAuLSwGBFIuFj4bBoVJHzoVDIB9dCkZBjIrFqR6ZauGaIZSJh0cImdONXVWOnaAXFsyGpNtVVM3LHJUN2g/OywsIQAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYxIDY0LjE0MDk0OSwgMjAxMC8xMi8wNy0xMDo1NzowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNS4xIFdpbmRvd3MiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NThBN0REOUQzRDc2MTFFMkJGMjA4NjMwRjAxNTdCNkEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NThBN0REOUUzRDc2MTFFMkJGMjA4NjMwRjAxNTdCNkEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1OEE3REQ5QjNENzYxMUUyQkYyMDg2MzBGMDE1N0I2QSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1OEE3REQ5QzNENzYxMUUyQkYyMDg2MzBGMDE1N0I2QSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAUHAP8ALAAAAAClA+EBQAj/AAEIHEiwoMGDCBMqXMiwocOHECNKnEixosWLGDNq3Mixo8ePIEOKHEmypMmTKFOqXMmypccAA2ECkLmQpkybM3PmvBlzp06eOn8KhcmTqECjM4kaXTpUadIAUKP6dAp1atKdVKNK1cr1atWsT7mK/er169izXcluZcqWqlWzb73KbRtX6VK3P9n63FsUbFWhgJkGPjoUa1nDagkXBioYKdDFivVaRUzZbliyhO9qfYrVbAGln8+GDg01tOKejitnjgy5sGu9jFdTBtyTdsGik2uepnlbIW+Gj2vbbvjbpXGDxVETLJ5cueXUkpG+hT3YLfW/OOFaP3x3rvXu2itL/56KtjPasZzPCjjPXiz39ODpat8+/73a+IjxNiZ/uK58vrJlx9p+uD2GW24FxjWZdAImFhSBUZGm1ABRUfiZamxRKFQBMw0w106kpafhdcjtdRBOrUEH4GAsBqdciqs1d6JvNCYkI3OnOSTjcTxGtKNuNtam4pADFgmbX9MpeJNf/yV25IffYdjeZmuZNeWVWJ7nXV1Nccekl1vWh+R9/K3IIJf4kUjmgx8C6FiUcOYnXHwJqhkXh9dZSR5UFJbmE55YXiihnkxduBWaYfmXnpuv0UadayUayVpQkU4am469LSecppSyuClELvYoKqiNchppap+aeGmjB7Yap5Nbdv9Jopx5Zpbllebdqiuufbl36HzPrZUXlIRWeVWLYEHG4JfhyfdkVnAhOmRaxe55mZb77bmUhnh61a2Vdmk1WgDjfmZuaQEIMC65TvZpaLHosgtAiPf9etmiatInra372jncjJ7+OGeOBAuJKaUCj6pwRb8RGeTDxEm6qqv8jRlsxeGi19auUa23Hscgj+UxtWKN/PF5I7OHb352fXyysCGHbN+Y+FIJnnjO5mrzzNdmHPPPYkmo7brixkvay6WpGwAB7DKdLmlOnxU1eqH1GexzHYbVJ3xQVkyrf8bCaufYiA6s6Y2ZVlrwi6sCXCNCCS8sd3N0K2tqpdHFOB2cadL/qrKvPWvlMlRIq5cu4YenjPithWc5+ONTpjw4r961Bya2wAaua6K+Qluez2dZyvnoTIYOtOmns/dxAesN+tkBS3d8buuts8sV0UCTfq2gfr9qXpn5ip2r12SSfaZGycX9446hZtq23NBnhGK2kDpM5MQGfy282KmD3DjHJ5uc+Pjil5+uAJMj/X33qeuMLZrsxx+45vHrKiFpg451LtPrlouu0+di17lYF6+oOI1/Sktgx8hFuyvl73M161d+8GQoltUMXPBimZOOJC8+ZQxDEjxe2p63Nomg6G7RS2FIXKQiBAUoeytiEwj1Vb/ILa494ttV+Mi3OPP5MHHoMx8P/4VYQyzFaIEiO1wRl4iWyRmOibcKIP+aBpUpfqaBtmPaAQXIRdux7oqj+dgUbZe0KiIufz9MWf8KuBVugY5zxlojuegnxwAOkGR4rJwH59UhdMHHXsbLDUUuhbZOEeyEKkyk2mrUKlO1UDoQe2QEl+Ul0NmQiIhzIsqGyEOurA+JC0zj+ATXyVCOMoee5OQPN2fJKylOiaSE4iZX+TfSxcyONiQgAmOnNP/hclwAjBDhwFhA/AmTgEF7mjKNyUBgPhBdz3wmyegHuLXg7oZepCIulwnNot3Och8Ml7YCSU5DJsg2yltkqhRZkrgFiZAxhJveDFQd0UHHKQVr5FHEWf8vKvXsleCLHCpHabj0mRKTmYRlyRLauE8yTpZYcuhCkzgWpyVQlz3EpiwJ6L/YmTF2d/wM/75oRqUh8Iu12x9I17NFLk5xilj8pv9Mmk2lZZOYa8QoMuWYzDF21I4NZJ0Wl6auohLAqAIYKgGkKMxuctFdXOxlMZOpR81UiUBJKic+IwYkdyKSnaOiJ28EVL3sHc+d8lwQxpSkPUcdUYeqjOsOVzlQUQYRfecLYildCdG+kpKWSHxZUc2IzFQqcZdH5ShLyaVUXpprcKHZ5a2UuliUatGoREVpSWMXzKhAQJseFakyi6pYwnJRtEMVamZXd7ioMW2wxIyaaE06WG//fhOaUn0dSDl7gKRCQF29NddnPlsA4jaWabAbanJ3S9xmcvGziU0quyyUNKCWFJktHRR8AIU6Ov0Oa1qVIHDMhlawHkcwemvRbiYlw0bmTb0wOxY939Pes5WuO02Bayolej7y4fWuAEbfUQOcxB1m1KAFBhpA+aq6vSruwf8d7BgZWEwJY/ayqo3uUTkbIZYuVV3R5a+GkXrUEqeLsqqVLuwEsOLE5ZRdvTXxZV8b3QxzNqnSLTGJcUyAo8aYqEz7LeuETFoc33i0Z7TwAY76WyL/FnYFGPJwRdrbA1hZizIWMrmai1KSirawhXusaJurwOGykZld7CIurdjNO3ZX/2MYDGHZcJRP9qLQR+blCJ0h6UgYjnW9CAP09QaEJH7xzW9V9Z3nMOjXjgU4wpi86xD1SkTJEe7ROM40ptGXAE57WgCd3vRdB0xqUGua0qzz2F1TnWlevra/HrMskGetYx2nOsU1BrGSSzzixCZUK1uUMZAPwLrkxhi5SxMy7IjNYhbHbsnFFoCTaVfUCxd5yBjW4nKDm2MCLDmpPmaxj4UaYpLmmqM39WJSY7zkGDeb1Ev2cbvXvWQiu7vKz8Z2AJI7ZODaDsoMhECPV6tF1ApQ2gHfrYQN2OaoAPyzh/ulaSXuUZtmEy3v4l143/uwhNVtkeXtkcfJ2+cimWmf9v8hVpgup6icba9vNOscNRtdUIU2cdKTlrSqNz1gAeM4AQgAegKGLoCgB93Ud0VA0ZeudAQ0nemgHjrQP91pAiTgqAzItNWRTnSfo5qlqhacx6qc1Kvz+MTN/va3S6x2toObx+vmsdW9/fYe153WRvUxlhOwdmQXoMfeBny8pY3cLhP+3eJWewHm3e7As3jJfA/3ARjQdxxDYMn7DryVnb1i2Ik9w4vVsdyLTgAECP70PTb95A+ges0TgPKBf/2Ssz742tud8XRXO+dzn+zDt3vfJBW4lPdNVHcTWblLC65MqXhcNTfclxfHJdJME07AdQ2Q+zLkcBo2QrdpX4VfPWf/3lCFVeu9cEkqbxZ4y9I9TUaUkwtdsH4PCv+a2zWwsCwfpH3e6f6butNK538BCHV8xwCdlnUIuHRSp3RzB2oDVnUBdgBVd3X9538KOHcU2HMEhmmw5m5294G5B3Xo822qN3nvZoKlJwBZZ3qRd3g65oGIB268Vno9Fm+tx2Kwp3T3pnfihniSN4JmF2+xF3uz13hLZnoIYAAM8Ho06G1LSHp1B3cb1ns8uIM0eISuF29GmIVcuIVayIVEWIPipndaGHfhhlxniGNVxmS6xmySV2xAtnvORne2hlnMtmwc1lx6aEbL1VhAxVMV4isUBBPctRTfImdko1at8X0ylEJ0/8aI6RUbg3ZyYrVWzBI8NMc4OSREopR/cdVg9YcyO0dpedVfNtdElPZopXhXodaKnnaAp9Z/WSd1UWd3m8aASZWAfEeBKgiAVhd0EiiBCEB7KdhsAFZrWnd6dadjTceESHhUpreE0biEDJCDK1iDSzh7TkiNTJiNTkiDSyh40gh4BgB4rxd5NNh6qweGWMh6Tnhl7UZ58riO7XYACxCOSMgA9zh5SciEkzeEgZeN4YiFrYeER7iOCFCPpSePV+ht9NiQWYiFQ/iF6ZiOB6l3YeiNWyhwmpd4lkd4S5NYeEh3AheSljd3VVhrWFZkyFiHbGh4/WYunfVAGXdVUoEa2P/HcfPEJejkNW9jZylRSNx3SDvJNjspSVkFc1LSSktES2HXYN+ziQSlHjsnVwylc/9llaNIivoHRD5UlQCWV6I2lgHmf66IdKzogErHAGtZdAFodHxnekXHlmyZgkbHdCnIlkW3ixL4erT3hILHgEN4gtS4etJomIhJAAtQevxYl9V4kJTHj6VXjkqYhI8pj/tYjtlYjgnpbUi4AAgAmoxpmAuweu04jw6peapnkJwJmgfQmpSnma/ZY+X4j+koj51pegZwZUrompR3j4tpZbDXeJ3phVa2eqtpkcMZeEmYkJH5nO6YmEWomYvJjhNZg0vlehhpZck3huJ2fCrWb3b/12TIRgBCVnjItmK/VXEQZ1pcRlqnlW4/dVukwS1JASjw8xSjcX3ZF0lctU7q9BImBCPTs0/v43I3s36ZaFiFY2lK1KATtV+fKIqS5klhuYH6J2piOZZeGWr7x3WPBoGvGEQWqHRo6aFZp4Fp+XQD6HSgFnRCd5dwOaMxCnRsCXROlwAVYKNON4w92qMVgABBygAVQJevh4QsFpdW5nSMiZslyJDSqXqUV5BXyHoKGZqKWY7ACZwGAJy6CZvBuZvO+ZqzGZqxqZj6qJg9BpqZmXoEUJmst4/HyaQJqaXzyJllWpugmZCuaQAGkIR/6qeBqoR+moSv2ZwLEKiJuqeJ/0qmu/moZTqnS3qcqdlusHmRY/qOVSp74+iFmieQXxiqqHeGZNd4IqmGZwgBQ8ZvwOdJ6wllH8ZsqkpGRfOezXVZTwNbRuN8EjIiSVkniFg2P4lnkHgwziEbrHJEKdcsy7pyz7JoMTOFhmV/ENqJBqZRFpqhWMmVqkR1qnh/H0qWeXWWHBp2F1qWaWlqWaeCaEmiW5eAKZoABjivUmeA8squKziXwCiNblmN8rqjRTqkQsqWTkewRCqkCBukCut0f+p0CxukOpqjRjeMkgmMlsl6dJmbTcqPz5iPcTqMDUuwk3ePvckAfmqyJkuohFp6XJqE+9iPCdmPVvqonEqQL//LmHg6j1PKmHXKsD7bpYMqqK9Zml26qIkatIBqmYUaqM3pp30ap5DapUn7p1ZapzQIm7JHmSwbmlxLp5wpe3Kamt62mw6ZpvbobcFZnZ5qnGmne43Xg23nnbpXkp+lqoiXXCO4b3NoUyrVtwHAZc81Vb1kU53lU7XTOeWnLfyZiD1ZKncGQ5BLPHKhKoRWPItLHwmqoHAFWE8EOQ06igkmWAQmV2RZugBGrqabuiBKdKz7aSA6ohaIrq9burEbuyRqlhXYgCqYlzAKo33poSOIPgNIr/OqgkF3oyvoo0EqpBXQvBUgAUEqAQggvX+6vAjrsw7bsD2qvc3ZoxLAvWz/SahK+6coW5mEmrLo27CV6YTjm7JLW6igKajfKwHzawDf27Q+y3r4271MW6g/Gr7VWL4qK6j2+6ffW8AZIKgJbAALnAFTS8AEDKhLm7RsCrQEnKgS3L8PPKiNKrVMi79vGsJaO6aLSac6S4/w2IUqbKqBJ3zEZqoUqcJhiHqmGm086G3PRpJLxWG1tnhiRHxABV3xyau7KnFHmX3hdSoSU0L/wilkhSrrdWgWg2gJuqyhS1HgqpVaTFc4R6IV6olbSZaoW7qwtqHpKmoeepbAa5amtnVs/H//58ZwTIt0LHVyzMbAC8c4hoBCN3TXiHXnaIIryJf3qoNAGIz0+nT5/5qCQwewAdu8w/i8QmoAChuozSu9GVABDswBQurACJDJ0+t00lsB1Vuo8zu1pGyy/Lu9hxq//CvA5SvAAxzBE/zB74u/Gsy01Du10wvBECwBDgDMwuzL8msAHCCon+yn9XvMDOynC0zMBHzAp5zAuAyoMAC/TovNr/mnGMzNXEu1+yiazxicaoqYyxmn5byY5DyykVnOa/upRnjCKeypwfl3L1xs2Jl7tydlIAk759l7TzZFs/pwgWtmBv238flibLQzj0IdeOKrhwgu5gQkabMpB0LFf4YZknSJM8SUP5PFrzRQ9Hd/B6W6qeuVKmoyY7munFZqXvzGcxzTeDzHW//ngK/Iuq2b070YdatLvMWr06drr/OKgAlYevJ6vPLaxwZovPdqgNCY1EZn1D56vDNajVMdyZB8sJDcsNIrvQzg1aRMyqGcsJQs1qNMyUlo1gwbpAYsyklIvZQcqNJ7zKRswPabwe+LzH/6zH66zQx8wMXczIItARkwv3wNzRCcwA0gqA7gzAS8wID914WtwH56zI1NzIuN2AUc2Y/9vc/cwI7NwDCQqNeczZqt13U6tKEZtRbczVNLpqVpZWJamjF7nLFtZaWpmClcm2hrqSzbkO8c3Kj3bmFog7wGt273gegjfFFmnjS1bV3EZkXsVNAXQNuioHzUKf7iXl0FMc7/o1YXTTHMKsWVxGhQOZUfTbrcalffusX+1a6PltJlN6I8N2oiKtPoOotzTMfsWq8HWIFJLXVJ7a/xinX/V4E8HeC6OOAC3uAAO3Qw6sfzCqNEKnQBW6NuiaMaHslsWaSWSaQSQKR0WaQjTqQBK+KpDMnLm8ppHddv3db0iwCcHKScDL1dPcnTKwHHfL9lDb0VwAHPywGeTdmHbQCXDcFHvtkFvOSEzeMGvMnNnMBSHuVRPuQNnORSTtjMzMwJ3NiLHcxgbgBfzsCXfdkZcOZk/r2NDcxGXsCNnQGN/eZrPtnSXNhyHuVmTuWQbczNnOS+fLQEfNmAfsFAi8ExW9qL/8q0e5rNjboAjl6ase3ogOqbuQ3c7nzOmieEmq6m5rjp+Xyd7YZtLPZFytVvfch87NJc051u000ZEf1ddxKszbM8kaQfJmcwmsFW/bSgDzXS/rWK3SpqKirfo1bfmRZq67queXzTXWd2/Y3grNjgr0uBSR11AN7gAr6E8rrUcLmXN7qABN67fdzIxMvg9rqjR12j6X6jcDngAayjFR7v/9rI8w6XJH7vWD2MIf69lzy9nEzX9Gvj/O6nkgy9cS3JnPynnJwBOy7jdy3kEK/jEh/xEa/jDTDx9MsBF3/xQs7Z33vMn93MEr/YQp7Z9rvADcABwazjYg7MF2+/Ki/MhP9t5HBO5m2e2SDv5wl8wJOd5RlA8sH880JP8gEfzWJ+8Q6w2GMu5mIO5yrfAA6Q9Elvv/RL9Rtv5VGu8n4azDGv9Cev9FNv5Etv5N+b2XEOzYm+qEP7qKsNmhlQwRDs6BZsj2sP21LLpqvdtHgv27itkOXInIFXnYKXtmi7pp8ew/GmZSBJ6sRXnrt1UghNcSHlVJwxItWSHb66cWkFMHvmxOwlExAwAAUwAKJP+h5in91CL4jL6yGTRhu4iq/ldQIGixN4jF7Xcw9q4N5K36dLdUdldso+37zIx/Yq7f5X7hhoddiurjgNarP4/FdXvG05dXcJgAKO7hf+4Oweo9v/T+EEXqM0GnQ7iuL/auLsjuJX3eEj7rwHK72hrMliDf/NmckOrMmh/O/wn8lxHfEcDxASJHAYWLABQYEIExbkQJDgwYcSGkiUeNCiRA4WNTY86CDDxAYGJBgw0CDDRwMOUq500KClxQwtY8bk0LJmRpANQjqQ4MDBzZMfT5p0WbTlS50NKCRNSuHjy6NFG4jQCUKng6UvRUTlerWrT5cchN786VMlT589fRp42pNlzZIsV849G3MBSRQk9WYgyZfv3Qx3Fwy+a0Cw4cOJCxs4EBiBYcgLDhyQLHky5cuWLR9AQNkAAQILCHz+PPoAAQQEJhOAoNo1aNixXQuAIOBA/wHaAlgLKEAggG/Qtn0XqA2hQIDjyQNAQN78uPPmAaAHGBAAQAEA1rFjt949+3fv4L9z915evPnwANRbV9+ePfv28eHHd7/+vPgC+QcMKMB/AITr/svPOOPIK6876Y67LrvtpHPwQQgjlBBCASaMsEIMAxAAwww71FC6Cj/ccEMCSByRgAQESHFFFVtkkcURY9StRRpTpJGBFRPQUcUcXdzQRhUZ4DEBBhBgUUgEWhSSRSOTTBJGJF3EcccXBXhSRScTQC2BJIu0kksdi8SxAgYq0LFJMBFQk8gEyDSTzSmfbBKBIsF800wc80STTjrJpLNMQCuoQIIyCS2TzEAZIP+0AgQqMIBRQd1sFAFCJaCUUkYtlWDQSyXIwFFNHyUog4EGrcChhEQaaSADGspoIJA4klUnnBqgoVamcKWVqaQyqjWjn2i1SSaLoJIqqZaWaoAOqZBaSlleeaVqKmqngpYqbJV9VimdlhKBBxEo+FaEcBsAAVqmoF3KKnOLokMEOrDCKiaXKDiKq3uNalZfqL5yySyfnkIrrp3q8guwDFAIzAHAYDBgBQNgCCyms85aIDC9BMsLYoZTSgyBwh67yzPKQK6s5Mo0O23llVkjjjXXWj5Nsph7ay2/AG4DEULmkOONAOKOY045oZsbGjrlomuuugYVhLA+8BLMrjrk7vP/jrvqzhvgO/q47hrqr+F7D+zw0IsaQe0CXDC/AKumzrqsE3QuueP4c/C56wYMmsC60Z7QQ8B39lDDE2UscUYZE1d8xhIb9xFGG1NEEcUfBViy8havtFFIIX18csU6rfRRdCe/5HFPHVE0EscDojSyddRjPzPNNMVk9FBE/ZT0UDUptd2A3oMPHlEGyhy+d0gnzTRSSBnt89GRIDV+0ccYfVRNRzv99FFTOTj1e4dAouhVnWCFdVeIbtWJBlub4pZ9+NePv9v1p6IhfvbbF2H+/POPltv/AfBZ5VoK+wqoFBqES1wUANcCCUgDClCAA7eCYATDRS4KJFBcEFSgBZ8V/8EIVjCDF7wfBsmVQBJeUFwXVOH+wsXBFi6QAufiAbcaOK52OYBcU9FhV0DwLmad61//AphZKGZEj5ilJ26xWMdUshIY+AQFPlkAFTsmGBhcbDAOu0sWIYOZkQ3mAIYBI2VUIxozygw0ogkNzMzYRtCsrDVAO00BTtOam90GaHvsTW/06Eec+eZoRFtOIQn5HERe520Lcht44hY3q0FykdwZD36m1rX50GdsmrSP1zYpn06aTTpRy84oR7kdAPBnbVUjGgQ2sIAHwDKWEYjAClbAAhJoQJcs0KUGkFACJIwgmCPAgS5XEIEHPMA4W6OkdPhTgFjCAAUwWEEyF4AzC/99yDcawg1vKnS4xYVzcVraHOlEt6EDJOAA5yxROm2jJeEEBzansVLpspTOyTGAAEgCU+hKFyUriUlNReKTQBnQOgOICXhiIqjwCHpQPmEvU4pyVEUvhb3rCQqjlnoUSUbyGEtlb1OqEsil2PIYlF4Pe40aaaaA91KRkARUMV2VQARCqlW1qgKk2mmnTlUQhnhqJAoBSatYFRKKHCSp4mNKRXplLPdxa1vqoh9V2Feu+FnVVvtLYFc3yEIUrjCsLgThBScQrrNOIIMToIFa78dWuLaVAhOga13Z+tYIqhWEc90rX/2qVr2y1a99Fexf82pWtCaWgTyY4QJ5AILHzlD/BOc617jAVVkQkOuyDaihvHggLxDIaytFJO29zDLFtQQsiStwosdUkheGSXGKC4AYCgaTsMREhjC75S1hKHOyNoqGMAWoTGgmg8bTPMA1rTmNajbQ3DnajI59BE0f9WZdoOGMOEozpDPdphxFVgeS9kmbKK1mSfOaDWxQ2+R8Pkne82bTlOJZz9P8ZjXuPOe+yElOKgeAgQ2wYAQD7kEPaiCDHgShwAWuQYEJPOAR6DKXGsjlFDSAg19KWAO0pGUslYuzEMkNNyL6TeBEFCJ0ymhNr7NRkkikTsStc51RkrFutJSa09xYN10aaGp8bDnb2GYyarKNk1ADUdQ4acUF/x0oZxqKvSIlFKVT5kxnHtqZ3gFvymrKgJq0rOWVUupRn8qyl9XEgep1uctgDjPwOIrmj2Zvpzm1qUBieiro8UUkpCLVnkPCFj435KgSKUn4wicRlMRqIjxpVUhM4qtdlaUmYXkqpD8iwVl9RKpRPaABXcjBrpbwfnOlQQzkOldfTCDVpSa1WmNQV1LTwBe+aHWp2ypXvcZgrrB+NWBdXddeT0DXw54rDybwAbsm+9jCtuurda1qvgI21bsGLF+fneoJ8ODZDFSrsfOabXBD1rITyOy5PnDByo4LBOsu97on+60fQtYBoaW3T0JbRNaWVoprgVgV8zLb2FZxAf8WOP9sBa4SLSK8t7tFzMlANsbBEECZooHAASpu8QXgMY52pLhq+qjHP2b3Zta9jR3zE7STY7e/2DmaiF2OSO6ijb7p1Vp5mjlf6niNa2ILJXwxGV/0Tq07BqpvKWl+81KCR78PShrSgvbMAmyAuBt4wBRG8IEFJzjBUNB61nsw4BJoYAo6GIGBa8CHHvwAwTJQu9qDgGCuKxjBDtbAAzaQ3T6O6DeEq02NVSOk1pUoNUVO8WSE3M6YxYwzVkJNPU23ss6gBjWc4UySJy/5yOPYx5VPKQOkzJjTgLnKlKf8S4XXu8kcdAFm/vJjXhoqN1fP9GsGHl8Q0GVPNcqjMeWAR2//zxZPfYovnmrVSk6ClpvatNEpEepHhirpYCHVJD15FVpwMumP1CRY2b8Jr6B6lKkuq1rcIuCmHYhCDXb10yCEYAVHfWoIuvp+tyY2/WPw6hMIO//Ovr+wnc1suvq/Xvu//JuA/Mu/CzBAA7yAEzjABNw/CJyABFxABUzACTzAumpABURABQTAAUy2/wtAAJTAZJvACVQ2FFw2ZYs2CkA2YzM2BUosBaKsx7KKzJo3e2E3eqODeyutfJu303IA1AKYKZqthzlCweAY2iKJfiOMhls4KOStu7sm4SIuiZM4zHgAO1Iu5cKjjPuj2yi5PwqaPZoul8G7lEvDRYoOQpoO/6dpJkaSJKDzpFTKpLDppK/Jw/pQr6sROkZipLfBGlZ6G0IUxPCSGgUhGkJquedgDkcspEc8Of46OQh4ABTYjxT4gAH7gLP7uggzARPQgBFwATd4gRfoAinoAiE4gxdgxVMUgi44A1ncBCLYhDNYRSmQAheoARRQAI9rrt6go9dQozuCGeZirsRjGdUIvTRKIywrrod7xjGaRsYAmYebRs6AAWtcPW5EAG2kRmtkDHF8OHEcI8jojAyYRm0sDHbUC7lgC5JwPXjUM75wmL0ADC2aGMPIgCiqooThC4/YCb+IibmIiSUKSJWYtJJIi7LwlInovqjQtJfIvmAxFh6UF/93oQp0CT+ODBcaGpe+Yr+9gqsIejYR+rYPFEEARDYBdLYIjAEM3L8EhEkDPIH7s8kYuICcbMATYMCe7EkGDMqfFMqgZEAZaMAdaMCjvAAVKMqmPAEXGEqpjMoLuACqbMqmrMql3AGjPIGj7Mkd4AOvHEuwLEqgbMCqNMu0rMqzPEud1MmczEkStEC6SsAamIC7JEFliwGWRDa78ssPaEG68ktyC7cZApdzW7fHWkwQIIHG1MEfcgASAEIQKMLKrEwhzEyFmSaGWYGB88yBG7h+7K0IkKXBKM1YgiXVHAwPU02LY40D4MIrVK4FeK6KM7nb0ELikDotdCW+sRngLLn/k8sukdOPvbkuSTTOvEkOZqpD8bqkBcmarSkvOTSv9tiar8FOPdTD9sKvOPwO7AxP9dia6cwallubBYEA8QpEAFBP5vAAlqubRzQO6mAOu3mmQmLD6BgkoxEaSiTDZdoPFvgAqywDKZDFWCSCMyACMJBFKCiBDlAA+JQujdM4O/JCmHku4TKu5+rC2EyjiEOjjDMubpzGk5GMcsyiMjpRwSCMLAqMBciiLspHLbotzxiMhkMMGcVRHj0AGZXRicFHv4gYIj24u9jMgEtSuXCYwJCYiwkMiFkBioGtzNTMI0oigDGKHjKXexktgIkXpziKz4rMGtLByZIsyoIsdvuW/8YitwgCF8aiLL9irGITgcAEtzs1tg/ANhVkSWbjy7iEy7QkwRrIyRrQyUOVQKlkS7E0y0blygvgyqQ8yqbcyhOQ1EjdARnYAazUVE11AU/l1B3YgRkYVRXg1FMt1VQlVU5VVRVQgRl41Vd1gViNVViVVVttVVMdVVFF1V49VRWQgWAN1h0AVWEV1l4V1VPl1WTVVKw8gUqFyqCUgbR0gbVMS2q9Vm19yxioAQLlxJz8gHC9gA9ANnE1V3NdtnRd13ItVzsFgQ9Ytw9IARCgV3oFgSl4TMV0zMlcARBYARLwV4C1JYItWFtCARRYAYTNIs+0rYS1xAdggWQqTWRaAP9kolhZqthk2liOTSYF8M0HGAAt1E0qjDpouqYNUM+QdaX/SFn+mNAC8IACERD17I+a3Y+Yfdn+YLn73FlH2jnyzLn+UA+n2U7pNA+ivSRUwo5Ualrx3BoPCNqlddpU8oAAiFoAwdn/GAAF2NmX9Y8BiNqojdmnKxDi2Nqw9Q/1DFub/doCgc8JLRDj6M3jdFkMsNkCuFtlStm9nVtocqXaLAAFwAALKIEciEUo2IRN2IItIAIoQIIOGICUjTq++UIupELfTNmUlYwHoAwIyLiSjaVK/C3hykLWZNEo3CLR9DAYsEQZtURYmibRFDjVVd0djZi78MyAG4wonV3aIoz/zjQM29Ld0Jwm45UmaZomhV0B5BVNhzVehZUmgn2YKYoizhw4B8g37fUJ1tre7p2iybQ3ypw3f5XMMeXBz5pMx2S3MZ03xYxXx4xXeY1X+oVXHqjfcj22dYVXEKgrZCNXvExXbyXXuyxgvKxKApVAAr2AQz3UbQXKCzjKpYzWSK1grjxKa73gTZWBDS5WUt1UUC1VTZ0BGRCGV43VMpgBWn3VMlABKVDhF56BFJ4BGq7hGn4BG36BUpwBHcZhN+BhHv7hHf7hF2iCHAZiI56BJE6CGSjFHS7iHjZiI2ZiKlZiHmZiHDZFIzZFIAbiLM7iGoZVIYjVF3YBM6bhW01j/xLm1GMdVmfdVE2NYGq11jneVm39AQZuYAauyhrQY04k4HYNZP0N5A/AgXLFAav7ABIggRFY5EZeZB4ggUiO5EVe5IG15IDVgIRFARJAAU3u5FoKZRQIZYuFgYu12I7dWGTqWAxIZbt7Zap75ZCdZZHlDwxo2QOY3KCZ0P8AAPj05f7AWa/1WupIuUk8Of8o5qll2vjQzjr8w0XaD2me5mBG25yFT7DdD7EdZmyO2cmVOvf8j5r1AJctkLuFgK7lWvfs2o/tWg9gZ3SGJpGFJm92JXKu5byt53m+23z+2Hym55FVgGQS2QfAAHR+AHK+WwDzgAcQ6A1oZQCTZQyIgP+JvqVWprra1Fx53gByrsRK/FvNhaXPhQCSnri/jc3Q8DCMjmVZ2liMtqaNzVhUPmWOlSUUeICKXWWXfmiuDeZhnmb/INutrWZv5o8NeCb++FjJHdudJY6uRbmRjbqjtjuphmUt1FuCFuhWLmiqo7oO2ICvxujSvGmyTs3lpVicxulRHmW1vtjktaUIGGUOY4EU8FcUsNd6vVd2W+TGrOS67mQSqOsUIAFcquT1jV9C7mMcuLoC5kTH9tY+HuA+Jtc91lZrdYEfwGzNVgEzvuwcMGMZ6Gwz1sUWplValQJYJWMajuHUlgIh/mJTdAMsbgJTfIEkMEVWVAIieAEiSAL/JVCCL9Dt3/4CIvgCIyju4y4CI8gCI1DuIiiCLSgC5pbu5o7uLTCCLWDu6MbuIiCC494C4yaC7j7u5hZv4jYC40Zv8vbu7m5v825v4u7uJDhuJZjv+jYC3v5tIvht3n4BJehv/zbF//7v2i5wFRCCFzhwzoZV0zZtIXABF+bszuZsq4TKy7ZKDMdsDKfWQ8VjPcbjH4hsEY9sToTsD9CBdsWBGkBxFS9kby1kHlhseCUBRTZsw6YwgNVkFugwHufxtB7cguZqId9YaHplgZ5njuZooa5ZAPCFS+AB/wJqALgGZUglnyXP8Wxap2VaLHfatBFPO9xOPRTPrllP85ya/2rWWpVt21t+56iVUJEFML1l5SDHgMFVAIHW6o1t5Tu3cwwQ27SN2qEWWzf/L7JN6Fs+6q1VJjwf3IfW6q62u4We5a125VRu3SDf8weAgYnGgE6PgA6gaAAogk7QAmnwAgWIgFhWdbtT9UiPZbD2dEm36olN61pHJohOpq2e6LRW9ZvWaU+PAABQhipXgA646Fee6A2gukZ39FSu9IaW5WSiuohOawsoaIpOpq++2A24aVtPa1TudVXG6R6/WA6767lOdxZAgR2naxZYgRRo93iPAHlvd3on7MAObAob7BTY917KJYAP+CkAeA0ogbCLsLDTgBSIMB/AgRLQARxQgP8WwIEQsIAUMGQcsAA+qIEW+IIXCIHPxgEboAJtwAIbCAEwUIREeAIjUIIbkIIcwIEiaEorcIGOp4QQKIELSAIdWAIZIDuyQ4IVr4EQiGwcCPEfSHqlX3o8zgGmbzu2y4EIdvoLyAEZsHrR7mwhUPAXcIGufwEpAPsXdoMxtu0CR/AC/+35zoIi0O/fFgIlMIIkcG7lbm7pzoIswAK933ss8II68Hsv8II38AItGPzAP3wvAATCB/y/rwMscPw6cPwo8IIo0ILA1wLL94K+rwPMb4PI9/w2aIPAD33SrwPPj3zObwM4MAM48Hw4sHzO9wIwiIK994K8x3u7f+62/23/3t/92vZ6FUjwrZfVrC/+zs7wqrTWqk/6ak1LD8/jEifXD7ABTgwBcsWBxcZ+RGbkSqYwCsulFdCA8K+lDdtxEoiA8193el9/DuOwVOZ2SX9ojzXyDXBogRZc4+haRddmoAaIAQMKDNgg8OBBgwoGKGgIQEEKCwWbXBAI4OKOJCguLoAxAECBiyI/foSQQWTIkABIrmz5USTMmAIhCPQQcyVDBbsorcIwwo+PESM0fADgAQOLFRgEKsAQAUAaazE8AUiR5oKMGU3cuEEKYFUqMgFWXDwo7GITHk2dkuiggcTSJjIUALDAZImfFiYsKNDBZIAPDUM1fLQAAMZFFhos/1gIwYWQIWXXLJAwkcZUEwARHmx2qkDGKhOfETXpwYdPBxNTOK/QwCJCBwtNNMxQ4WMGjxGzawhr0qRGEhxf5lhJo4LKnBw3zlApA4AVRSskPDVxexGH4BAhctQY2uF76sAmknxB0iNOjh5PrshhAmBIjxIaNGBX0ERFDcYjdnx4qmBEDQN0oNiAGnzRhAVvvRUBg7AxOMAXrCigQQoRWHBBDBbA9l0Ee3WQQgcRLDUABhqS8AFnTjEYIoMVtsjgaw5WyAIASSTBmFYJ6jbDDr7tgqAPEbiWAgtEBjkfkQzOJ+R8FDb55JPyISFYCUjgsEQJPkiJ3QjyDbaYBibQp/+BfCWUMAJjOKj5VgkktHmmDiNcNAQnVMwgBBdqYAGGGoNkMccNVLgRghWrhNBDnDjoMEMaTLAiQw2G/MCEZTOcKVSccZZgQQk6ZFpDDj+4kIMNTxwhhBpG/NmGF1RYQcUZWQihBBVxZCHIF1TkOQcYVByTCBBchGFEGFxQQcUXSrwgxAxnvLDsC2ecoQQR0876ArVKaKuEEUoUQYW20RoRhRdFGHFuFoNgsQUe0NRRBxZePALJI49okQi+WsBxrxqKEBKMIGGIMowkwaAijSaaxPLJLMsUM0kvvSQDiyOz4ALLMLiIIsodb7wBCCDISDJyKW+UcockJb9xB8fLgAz/BxyA6AuHKMB8ws0ok8CBDct3fFIMN5jwcofNyAxtzB243LFH0rzwggs2rriCzSedPFJKKZosg0oU5HqBRSKNeAHGuUYUcXa3YBQhCxZJKKvErEIsG+6zddudxAtJuPFCEzPMkITffd/nt98uqCCECy4gnoPijOfweHo9/PBDDzVMXrkONVSOKOY16PCBDCroYMIXVtgQp1CdZjEDEyE01lgTabDSwg9JhCCDFRfIZ8EcggABBA4pCGZCm7rVQFGFLp4YwYkfkPB8BCVQ8UJdKQizg2wztFAhAE3kOscPD1mQRBMtkMBKGg8J9MAlZDAEABlNkMDDQAoUcL8HKMBA/xBBA1n00kHu1z8Aro8uZ5BEFA7ygQvg4AM4GABfMIABg5RlAAF4SGwaspCytOQiF3wJADZAkBCSoSg8SMMDAAAKU8hAJDxQRhIOMhIykGEkAHgAigSygZagIDYzkMEHVGCDGXCBDLIwRTUAoAEX/GUtLPiOD0ilOCYMYQhcUEQUjCCEIeSKCTOYQwsskBoufAEA38FAUyhIogouhCEjWogCNtCgCDxRMN5hCAtqMINT8IGDHymATQZAE4QchC4tgcBFHnAUCYqoKWYcEACYAQrcTWEVZoiGGypRDUO4AQAYiEYYLFCGK5jBCFCAAtkiEYYwzOEMWsxCt6QwBCqEYf8TNwiDEKAQhPW4p1M/KAELxDQUIjXhA2JyjQbo2AEBYeA7clGAYqDCDPFlKQUjCIGaSvAF7AWGQsIjig7ckgL5hIA+IWhBCcREFxkkwQpceEEWviCLISBCFlJgQguYoIMSaE4HS/BnD3qAlxIsoaA9OGUOgIDLJ8hhCQIVKBIwFdERRBQJVhIMEkgQUUVd0wc4KEHsPlAD+UApNkgiEwmmgJ2P4mAEaqqdcZQ4hRJMYT5csul8ulQmM3WpBV+ghGzUwAUlPCEOQjjq2cJghVvGIhiOcAQtqEENWiSjqtKQxjAIIdVOCCIWkIiCI6ihCWk4QhNweMYzpmEKZeTpC3//a8IgFBExQkACEnnIBRbakIVdWMEMihBEG9RmBCIoIQtUaAMczNBXZjDWEJXghBuEBYY1gCESRlAEJN4AryjEq6/FIsIgQruFQbTBDG04LGnNYNrSjrYNjcDEz4pxCGIcAhjBAEYjLAGIYQwDGbptRBswgYlGLGMZtqgEMVpRjFa0ohLNtUUjohEMUK4SDpBAxrw0AQlLWCITwMAEvrChi1ok4xaqqIUxjNEJSbxBEYoYRiOqUAUwJIIQx7jvHAxxNipMYw5oFUQoNEGIPpRCEbF4hCI08YhFROER0MBsFaKwiEyQohnNqIUeOtEJL3QiFnSNRcI0kQxN1CIWZU2G/zQIUQygTWIUozBFKMDwAhdIIQdlyIEUciwFGzhhDYlQBCvVQAUhUMEMQgCCECAHuTjIoLCkQgUhEuEEQsTCCUUQQhwCqoNQxQcJP4jDErrUJJoCwBB0ZYQchtCCEFTTB98RjA9c4C0XKMoEKfBBEbAQMCxEob6xQIUiUAEJJ4SBEF5owQVMIYiFWGAGOVAUCUS0mQ08oNIsgIEYMI0BMYhh0zCQ4EWaokgBLoUgEKg0BOyHAYJU+gEFmGAEUjADKVyBBUjggwZCdBEK7ICDtEoE13QFACtYgSoisYIhbvIQEgxbEEVwHQBqcIEO0KUHeopDHH4wqxK0cQARCAEVvP9ggxI8JAIKQEELNNMQ4dWFBYbxgWgI6ZIKFnIlGpzBBZqQbFaU0UI2CIECVNAChtglBDa4iFA0gAEAnEgDPIgAiRRwFDVS+gED4EENv3CKhgxA2tBkgRh8YAdn2CEIftCAGEjeBTfISYZpqGEAA6nBAazgAyzQIBxZ4AMxirEDC3+IDxqigzCEzwTlpMsguACAFujgIoYxxC6W3oKpL2TqAwiB0zWwhBCA8CJYB8AlLmABGgGAC6yQguRynIMntGAarACAaD6QBhMAQBmmuMiG0KgALqiAL3RUgAVGQD6IW8EFJEJjpTHwADROUPEPSPXiRd2BDbDI5xw6YwoVMKD/J0YABSz4vGug2AEk2AUJOvcBp0cQPgsswaJiuMLepECEVd7gCesZDhekYIGA5kBuNwDCDa7g0DgEwUw8bsEQkgyELB9Vz20Qgg1yYIQzhCAJXMCBPnVgASQwIQ01AHzPk2eCGrDiBWseglGPEIIQnXGDXLCCdsx0ThtogOk6CFMK7Cw8Ox8zBFfoARIswRWYRwlQDuUEFKEYQgs8gUUBCCLIgAz8XxkQAREEwTFgAhAEjBEsxxnU3hUI3xKsRw78Xw98oA4gCu54yg/UgAyIygXkgAwwTgtOzqiMigz0AAQmzlEJgRMcAeNIQRlAgRQIIRS4QBk8gVBBQV5pgRZg/00n8NYdPMIbSIIiiEIwwEEdaAEe4IETuEItIIx2PUImMEIVxAIm3MItwMIeOAIsUEwb0sIhzEIvzMIe7EEbPhVUqWE21OEe4MIe7sEeqiEpMA02lMIsaAIyNMIcsJIhGAIlUIKQHYsVnA0XGEIjDMK5AIEidEIe3IIXRAEYYEEWgIHaQEGS5RJ6DKEQmIEaVEEn0AKV2WEtjEEg6AEpkMIt1NWebEIVqBKUEUIYOIETGAEqCIIi2MAgCEEXPAMotMD/RU4PIF9A9YAUyADqhBkSJIpg5FQNTAmUpEA2OYnwdAiIpIA56p8JpMaHpMY5wtudxdqH5F8KsJmZyEe6pf9jB/hARcGbhgzICFzBT5jeRYhBF4wABvhBECRkEEBBF/iBva1EB3iSa3BC1A2ATYjEp/kAJiwDERjFRaSCKfCFR9ZdEuFE1ykbSqakSq4kS7IkCLHESbLEvHVQB8HkvBESU7SRU8QGeGCAB/wkAPzBKpzCm40Ap7GAH0TDIMBBI9SBKBTXL9zALyRXK2zDQf6EQhLBNgxCF9yAQgaBM0jBL7WADaCTAnwBJwwCEVyBBiykFrDXYd0AEUSDGSDkEfQi1inApbDABdTQV7DCDdQBMnyCI3zCMnwCLSiCFwBBFIhCJyRCJ0TBGmABKqCCDQyBDUACNVABAEQIAPxAGFD/wROwGecsQQ4wGRKYgNEliOcYlRywhxAkAhUwhqT53GZ0AGc4CADwxEWswtuthQLwgDVkxiIhxgqF2gNYQG5GwASoBaVZAOVFHiMp0zKJ0RNZns7JwC5sXJMIRRCMgB1MyRT4wCpQAh/IgDZQQvdsJyLo3B/8wQjwwe4l5BrAwSF4lWkFQxtswQ3YwCn1QBnIQDYigefkgKcwARPgQAhEWoOswApEAAiUwaRUTjKRQAqQQYa8SPJsyHdoHmyoiQ7ggAmQQA24GwlUzgUsXQjowBaFEbZM3XcYxkPUBbc1gRU8QVB0yRTUQBnIhTBcQA1g3QDkU7qlgRXMqEhsaAo8/88KZFAcnMEmgEEU6EsOBB4fNIUPnF8QMMET3EAOUMEgbEIjBMOYmgERmEErEAMhCMETHAMxEMMxXEGn+YAPLNxBusEpJCQiQEEIPIFC5kAXSEsXRMMxAFdD+oAfOAcA8MEuJIGiDQInHAMzDIIZhMFUMpY2cAInTMMvMMMrDMIqVIIdcEIqBEEXtAEoDUIHDsERSEESpEEa8FW4eUEeOEExmkEiaMEcmEIayIELvMAJ8MFH2ED03UARzEEvfMIhtJiLNauzjgI3NAM3fII04MInDAMvkAI1oAIjWIIr6IIuzEIsBEIkZAEFagEtaIETAEEWsEsjEEMV1AEgWAIeAP/BIdBCKATCIryBJXjMMCwDMmwhINRBJGgBMAiCJeTBG9QMJqCMb+HBFpgBIrgBFWABMcyBE9wAM5gBMzzDGtjADcwBoFxBGViUFchCGfABachACQyA98QRTlTQqwGeDSxBf2LbEFBKt13E/RRSTuZfCBjV71ABMuiBHozBGIRCFOQBI6ifIVABEFSBMDpBCDABbGxAG5VFSLxEAFhQS67kBcHAJfQRAHgCDdjQ1yrbScKERdDk/8gQvb0EKxibSCDSRcRAH1nkIMUkQmxAM40AsxUBKszBNADAt5SdIDyDIKiBFZDldhTHQ9BFCIAYFaQPJVgD/JCBMPBBN07BCPj/QDWkwjb8gR2YASd4wA2YwS8ggkdCARFswTIwVyUEw3K9QiVUAm5Jgig0giA0QqVyARTcQBy8wBdMgUV0AfIGgRiYpL0NAB+QwaftpjZMxRR8wCl8AQT6wcoRQRc4w3fygWnIgA9kBRFgbw9oAJ3yARFgQjCswRpcgQkswQUggQ8IQRTcAItUWofsBeO0QA6oAOnJwBe0AHrAGw60wLe04ibEgQ6AQR2oQddEQSRELa04QS6UwtXwgio8gtL2QR8cQRVxgQt4zBEkCIIqwBSIRGys2dQNwXzw0wj0QA5MXQ8IQREogSFkQQj8U7oxRmwAwIpqgAKMCyQIAdyFyV40/0UYMUZj6MCy1NgSMAH4McEgJIEn2SYJ2JFI1UANTJ0ZRdQF/MB8/AESfIEaeIEW3cD5/oEnkAEN+AJCJoELtF4HyEAwaAIQ7LAf/EAEtkEbuO8uYUkInEEi1IEX1EEu4Kg+huAT9M7YVMERSEInHEELyIDsAUEkJGwv4kEkdHLKZMIa3MBelF0SdQH3mjKkViontAER3ID7bsEWrAEst8Eg3IAftAEWEEEktEEiRsIN/HId8KcrB0EorwEFViCiLqTrUmpi1cEmUOAgbEEXMKQZQMGA0KlCmnIFmqqZvu4W1EEp4MIw3EEpIEMob0E0bEEr69IuBQEi3AASMODWdf/pFfzyFdjeEwxBn16BAsgBGFRBHlRBLoBBKNiCi9mCIGiBh2HCMMzWJExCMQDDHdSBJWDNHQwsHrjvMaszFMTBB4rUEgyBFXzBECyBDYz0iubA2ThBDoCBFSTBuDXQB8z0Ap2ATU8AJSiD3Y2CMlDCrjYBFzzDFhSLDQjBuLRBJOhuLgTfDbiiIsiNC8yBEciBDbyuFBRBDiyBDDSB9u1wC+glgmoK+lLIlFRJSdvsEwjBXTKCKzxVIUDVINKCMZACJISCE3TC7IRAvGkQ1vrPQPgRB9Fk2g52SrYtYR82YsOE3dptYgf2RVyCMtCt2s4kTK5tY1/QBfUP2+JEATz/nmUTtkoAwAWBrQel7Wi75EyKxGlXtgzJJEngJACgwAoMxAYYBEF4wEd0wHmSwMzVpG/Lm0Wy7UxchAwgAgV6rx/4QcjBm5YE6Qh8wA/owBHc8xZIQjTAQReU2/FcwAekwA6h5NSlQFnoXUM0E8cZEkxggA+QnUi4QRIM2dm0gBB4gRfY0inl0il1JUPegBTo95YCwCBoQR3ggcfggSWsgRjcnEMwhBs5XgRQngL4QBdMYDS/rixXyxkQgRRsASa0gStFASQQgpCBwiu4WCqAAg2QgS/wgaj8gETAbQoVASFwgQK4TgtQ28w1hEH8j0tgtmiLdgAEgEoAkEvg5NuC/xAcNUQNzPSOty0ivYQcmdsfYfYfMe9LwiRBqBEKdFtO5HiXo1GXc/lCDPkDbDnOwZE4Ap6aZxBf4FysgaMayMoQBAoVFIGQCZUVsEIS2HQIpAAIpMAHoACEpkANqIAK+IZvnAAZnMAl2DSjXwKkNzoIiERjXACQ9rk5poCgzxEKbAAKoIABoIADOEADNIAENMAJpMEENIAIiECpu7qpm7oB1LZBXEJmbNAAfBEXbEIWKMM0MAMRnMLP2cQpcIIFVENzlXh/2QL6QJz9CFDPyuRN/PVIbJBI4NzbggRIeG1jd7u3fzu4h7vXGYIgxMBKdh0JXMBGyETXDnkBtHtMKP+DLfhlU7xEpQ02zTm2DZEEpVl7YaNtBe27YJMIxvGAalvQX4OQB/yBGLjBWWy2tL/Ewjs8Sn62Ye8m5pIEesuEwAs3TsoRx/G4ZuOEAjzAp+HkAL32ALTaecORCB053Ha8x8Ptawe2yq+AR6h8QZgbHBXSTIM5g+dkz+eE3zIIY7QAEGwCEKhfHECB7dmsHHjpUcXKFhjBPcXGAGgAELW5G3V5DEDcS4hRg3BxTggINUaBBtehJghC2SmdDYABINxiJ/QC238RNaiBBRQBF8ywXtvAuOTqC+AARBhCGNyBKixCGzUE2BMSRaxbDigBGIxNCcsbCyxAzJNAQuVACOz/AApd/MwbecyKxONwHeCx0Zmf+QDRRdc5hQzhgBHYAEJEbs93W9fGrUmGPJc3OUIowOKXfcgDwC6kqEkyBQD0wFepeZLzuF8XRBwJRAHEEa0XwAYQwAJUf6gvAK339e5vkAV81NDvfiHpOMd5fP+k/PAjxAiRRM8OkEIMRNe2LWvH/I/rO9qqvGCLu0pKO7h/Nr4DxAAABQoAMHgQoUEICQ0KFMjQYACIACDQgUDQAwA7la5NbHhwjjIAChSYKMGEJEkLAAT1auLES7NenapgwaHgoceEBRYQCCDxoEOdCnrIGDIihYYPIyIoADBAqNAHP4TkyVOlipM5cyRMkGBg/0POg00o8Wg4Am0EgQULDGgb1e2DB26hDthA0kcHBSxI4HwIVQGGDh18MFlyhYmJw4ipGAISKU8mbKXyMGIkxEaIFiVe/CiRooOFlFEbRkCBgwRovwMufBANeEAEEh0ipMCgwIIGBR34lPHzBMmVJ0wsmIhw229K3BYsDMCt8jnzDiZatAihuXoK7SFs2AATCrycFkS5SGESogqkZtQe9akCpEogUuvf9DkypIQFK1ZsAAHUSY+sjnhiwBtuWGMNPEoZZphZYIFljz1gmWWWQxzZw5irFnFFFWOk0cSRQw5xEJZsJrzDlT6AOAIyrPTIJIobDsJAijkuAAAVWhxJpv8WJ8574K0NDGrrIAU0wGGJHOJgAoBLLhmpBB2coIIQLixowYTiUkipBy9KqYWURbTQygoF1GjGipFUYqEpqJ56qi6BFAjBEDVGqutNNxGqbbyVAJjGlIZUsgA5BVpwjoQLUuqghTMSCaWWRajopYjxWgDgGVuu5I47J6roA1RQGeHuCCeEUKQIRkrRo48xxgjE1VpqUfGGIeSQY6UewAgkkD70eOSIgcT6yCAeKEnDKTyfuguAL2KBRRMnhHUuzgfUWi0nOTUIoosyBoGjjVx6EE05bKF6CyHnNoggrLAG6GAKEkb4gIQI2L0rzhkBOCENjwaA4AEWFmABBbkegMD/zQI2uEuBFGoowQQTDCuhBBuqG2KTT51QZJJE7nxrrXQP8oBkAEoeibk738xzZYcKMBeAGajAwU89G5ouhIhbeA0ikhgtzroQJvbzKblQQGEFFDAoqC6/gHrAIM0Wxkm5ON3NVycAVtlmhBo0yBrsdBeCqC4e6MiajCeJhZohBS45Iey4dcKAD7PgrGsDhO8Oiu849dSGEjiZ/otaBQxhBYAINHjNTaxRQGKI8agmCQAr5jCIJOeWq9pvzf0aiEiHSIOKhbkaf4gMYZ7KnLYIOgCAEpFwwoB2pybHALAQ1AjDiVCACaa7IZhgwgeJP9MgBNEETem2ATAAuPaGU3D9/wHlDD66+rYeCOuDm+ROSfni/PDhCT/8cKOaalp5hX3227Akk2XWH+WV9VOhhAwyAvCAhwMUSugDZunAXPLkEJLURjRICkFoqBabppjrXKbrHLrkVkELZu0vE8FTtogFEWsELgIjWMm53MQ2CvLBGp4IykPSAAoAuAAMQBhCCEZDFw42bmXEIs0FedhDH+pkCnyQAhTO4IUinKEEmcNNCHQgBCNgAQxRDAUYoPGrQADBBkNwQtBaIAesVGERWwQAIXoBRkAAIQRDOIIWZvGJZOzBRLUYAxAqtjOcWMAGEHsgSTTQJqiU7GQTYQsAJAKVdTXhBzjpWwfvNqec7YxxDv+JAMWSRy4cGhBL12FCFjk5BC0aYhJzsMERoPEIYxTCGOBxAiNKMKyWJaRpmeucUCACg1Pw4Yc+dGXcBAIDGOTQgjx4RTUwsEK50TIiQ0ImLAEANTUQAgC4w9oi4VTAl0lnMHmZzs6qE4IbEOEGPkgQEFQxoRJhYw1HYMQidOEKV7kqEHqAhBYYAYQePEGbFuhACkzgA4OIAQlrOAQhFhGJMwCHCU8AgCF2MZLpDM8ET3hCHKAIBP9IoxPDUIQWFpGISRDiDci4wydwoQpVZGMPquCFK1zBiztYAg+iAISBkFCJUdyUfvRzoQ9WUQ1EdMEEbujCEG4ghE0Y6Ag3AML/DSKBB0asgRFD+KJ8aoGLQ4xiEsFYxCL6EIpAHCGpuYBCZiL5EMDdbYMtMyC5iuMD5kSgOCZoHe46UAYXDIFmJShmLvnaV74CBShke5m9hmDR+FzxCDULGwu+xpCCKAEVpAiEEwLBiHhG4RZRsFjmqvmUsTknBT/QQSsbQpeCBMAtLCvtyq7EBS5cRg5JNCRcOetX2972IAuA2itkEZuMeOEOyZCsDRQgJACYQRGxKIINlhCHVtosIVawRRScUN0WWA5uQemABgbQHebUULW4taBb2pKoFEwNAKwIhhrksDoFwLU435UlVHCQgxIAATPNaUITugMAKsTCC717hB6I//saFFwgB8mzowXSSMOPiGWDTZvl3nYpXoYIxQKGMAQIGCmyYQnkATUYgQlYMAK9BAYATZiBQSR4OoMY4hlCSAIvDdKCJKQBBQDgQjMMka7pDAYDco2ogXJGmBAcwRJ6cGcmMtEHJ3SnBTaogiUWYZkq4AGL1yksIyJRCjyEogp5cE+vAtGJYoiiEKrYAy+MkQmUGiNBrmCyJSwBCDw8ubpOMJBSqWSLSYRhhVDBgGr0MoARjGs3FkhBDogjGubIgRBqGM8Q2lCKO7g0o53oxDIOAYxPHKIYoT7Ep0Pdi2JwgxuH6EUvRgQLlpYTFy/FwxreIAlLWygZs0AGHo7QHf9fF9YMWgBDHdRgCJyOwhZTMgEARvCCEajkLgwrSQ5yoFQ6YqkES/DBaixs4cB2G9zhFvcP/9CEGxwBDHnYanusA1awkhUnGWEIDOjwB51AmG/fBtsDSGDccf/bI9YCTBCh5pCxZS0lIYjDEoDQh0VUAQApiIMTpmELtd1W3hIEeAUH0IIjRMELgQhBFB4xhjwEIj6bvSEwMUi2V2bNAzD4wx/4EATdQOERapbQHkhRi/dAIQ5XGMEUSvcAaTrneQ+gAw/itYIRxIAHPMggywdQAiGA9QZhtgQvTIpSlMLiEJPAKTeW8Yk73OENb6AyV/EAqjzgAQ/vOXfW8bAI+Ln/whjG0PkekiFck9aiyUtlRBhCkMQRyGEIS9hEHHLGhNB0LoeuHJtEIZIDRZiSwAaxQKmqC4Q8bOIKTukwRDLiAahYAAlPyIIVDIgIWQDABz7wQyVawQlmTOIVqQDFKTwgA3+SrcIekbfL1Vrh4DMkBEZIEwt6AIQlPIFQZX3wQdimN5ZvHPvZ137YHiJ6Al6wLhHAleiXiRANQCEIP3WDHWLvAzt04f12mPnBCUnIAEDg2xgYPtggQH8AsIAP+CAGPsAThGEB9u/CPCEGHIAMEMIXqkEYMAAREMEPaGf4tsGFhEWQFgAGDsD/+GYFPsApWsAWBMHfDuK0tk8FB4AM/0CBfazBT/Tt3pyDOZrDvTqrIRZIBXcQAJzhGFphFU7BDX7BDDBABtZPA8QABmiHCWnHl0zPb+4mABSACprBFJogNm6jNk4iCEbAB2wuCI6rEvgGlhTAD3ogCK7gBrYADuAgCLYNa/ANAHqgDuCHyTLBFXQBG/IgEo4gjQ5FJXCHZOSNg+JGIgKgIJKJr2DAE+yAD/6AB2YOBvqv/wYRAp5wEsOm/ziOBD6ABfRJA0rAVoQgDpqDxGpLGNZvCcXADBqhEdoQEwYBCrogIeRNV+qgyqzsyrbKEqoAgqgGAJRgEgQBra4PbBwCA3pACKgoEqpAqdbgCobgdcTtEOuvgv/uyUBkayQuQBuPzyMC4GwAoAUEsfRKDyGGD5DSpXBwQ42iIAomy5MMggR0oAeQAAfhZDRIAgMeyFrYZR9hwI9cDACWABtUQRf0IBtUgRRuodf6AxvkrAo2oREQwQYSAwqEAI18QANi7zCIhzlir5g8wAeQoHi0w5JSq5Ymgge2QQxWYX0qgX0y8ILogA8OQCDEYArEwAMGIRq2wQ5UKCHsYBXswCBggA/oIH/E4GAMQhhAgRMQwQ2E0A5+yYcASxH9KgUqsgU8KXm4jQe/EizBLyxHr+UuwRaKwAJKQDcKMV2upAOYIIn85YLeQgHkwjlCgBGUDA9sAADEABI1wAP/xAADxMAONOAPPrCCPAACVsAXPEEIU+EVKuAgZHC1LEwgeOASpoD6VsD0DkDe/KANBgoZcuEKSFIWquEULqyCMOABTI8siU8nSIAKqCsKTg4IxkNzSuBTeIW4DoLBnACsGIEaqEAcrWOUIqfwlmAIiqMEcsYHRqsEaqA58kUgBnFk/qCxbMYbGQJgPutNCmAKRqCYxMAZnOENvzAIxGBkAOAaXqEBdQICWAACTM8DSgcDYCDqeGAE/sAOeEAxw2YQfWkJiykVUkEARiYTLywn7OAUpoAOHFQzK0jmEOIS9U/erPIbmRIRiKALkrALgmCvDmJsDu5dsi0FugvoNqEH/3LACMBADpJFIHLgDSQjD8AKGtQtExbhKtZgqdbgBkgyCIJgDTjU3uzADmJuEqGLr/6CMrOm/yaxMVeAQkl0LBNCA8qzAg0CAcEGtfgGA6ZAAwbTB5gqD6jsU1rFPmZo25gJHwtvJLLkUighlDSoSut0IsigFVLBTnlITyKgBi7AF94FCRaOhpT0gp70CXHrAQQ0bcggQfn0KWZgAruAUomACKQACaLPBHLGAm7gRVnGUNnUAhJxO+Wy/ERHczblCUZpCUp1vNZRloyRTkXnu3KiALqhEcygZHxJdHJJdDbx3rLPDsLxn/SvKOvtD9Rz436CWQMrAGQuEvczWbeUh/8QZgBWIEzj5gHEwA8QIRqiwQxGwAMiwFpYIAUsoAZ+4AdCYAFCtSE0QAN04AqgwEAe4z0Ywd3AagiWTScGEQqdo/naK+IayHM+h02774EGAGpswAU+RyzO4A5UoRaMgRdchasc7uEWYQyqbDwAAAfkAN36oLK8arJCobq6AzeqwzqIZvsgcRuuITVNZv+atIecwwSEgKuW6j7Ir28KVln2FGiPacI2rvx2gjtz6RL/4FEBjg22JxEDDQBqMALsCHMyiA12IwTAwQSwoAiw4Acm8yojgg0C6xHqYCC6tNv87Qg6gRQwZwn0yVX3LQJyQAfQKgrJUFFREPjkxgM0YAT//GAbmMGfYs4OZIAPcEdkRIYEQiAFSoAEpi9ugzZrnvUhHsAGJTdOSAIFpsdde+gPzMAMfkoWfoF0OYF0U4F0QWEbhOEPWIAFFLYu2WBvRgJxIS8nqNQ3FTZpVoA6hYIJaytdyPUBUmAEhiASFkHksmAY3KlDnEABhgBUHMERaAHQIqoDACMPAC8QxCzMEqsGZrMWTKpDTiobCsF8CyEUdKEQxoARsOIITECRKowMYsDldsNvGQJtxW3qbqtzISItubKaIrdaqQ8uRE9yOQ63/sUTLmEVGngbfgEUQAEodQlvJ8IbBEIIoiAEEAINOBj7JOJpD7iCKKFAdY90yaEh/3iABCqhdPyCaTTzAdqgETCBCEaCBY5OIEL0TthyBpPDBOQACOTgqapAC9CBHR4jF2REVnkQcXFDIFg2AkQLP6TPZurHDSjCmCgCBSDv315ACUbIh9Cgg2GpaarDgAdg+NCgf7NvjHlJIK7FKbZgTFQ2aLhjCGwgCkgBGyDu9BSJbDygLZjGgvyHbwhZbnzhEmhgBtmANVNgM+AXAErAsl70dO52mXymBJpABu4RADwhf1YBIboBAMiBDdqYIZBUhDFnj55iUykGBxrLr5zD4/pAzcYgFB7h5L7KCTY4lXsZbBDBCIhLgH05mE7hFHrqEkbAmIn534qWmbNv6mgjYv9SoLAsaqmE43qHGSGsxYA1Twd8IA7iAKluID/8OJc8QI0HoJSTEA5wwRXWwPTsRXYvSIzRYP/qszx/byKYlSIKICPsuRvYAAJKWYz1lk6jljmuIPRWhzlagAkKS2M3Vu6E43WBSYcHWRMpogIq4EDDhg0ac56pKXHfJKTDTSBaYRLsBmymgEFPwRn4YBLFoBWIYRwooaN5qQaIQAaQAAmmUZufGaiDWqgZogN2oQF36aeHWqkhoqQNoqmXWppwK4QRmON+di72zxNIWG062JQhoht+oRIqAXXJwQxSQazZBxHOAQLamGbrj2YFGQC62rYKQAbluocYZRr5DwBE+TX/wY8McAlglpghgmATouEX3AAB7YATiOCiIWKqewgNzgER7EAYqHKpLxuzM1uzN3ssn5qzPxts0IAFDEKuH+APqFW8pqH2wCYR2zpDEQIo/oJICggpLKwDdKAcygEctLZm5otNw8a1LQg/W9reQHsi7Nq4k1u5l5uzkVtyPTvcnNuvoFtygztDZTCwpHtGepW5w5gi1jgsL+E9D1i7u9u8zxu901u91zuVrSALIgYAcgAThgESgiWp2Ru/81u/95u/+9u//xvAA1zAB5zAC9yCrNvAE1zBF5zBG9zBHxzCI1zCJ5zCK9zCuVQRMRRD8RdsM9waq9GtPVzEnfXDQ9zE/6vRKkEcxQ8RxcG2xX/C/lbc/kKcxd36xWccxptVx3WcxmWcWQUgAID8J4BcyHmcxXN8x5NcyX28xpEcx208mVI8ypt8xk+8xGG7xKXcyXP8yq9cw02cxnvcyjdcxaPcy5/8xZlcy7PczMOczd9cyuHczG/cw6n8xu88xo/cxpEctZKcrn/iz/98yZ/czfGczdcczOO8zPWtxc/c0cMWuDtc0bGcw63R0i/9KhFc0yt9n9HcwCmzSWl20sPWtUdd0tt80Sn9y0/d0gGLyVs9Ipq8WaFc1sV8y1d8yZU8xtFcx4s814/814Nd17m81oud1tMcx+381Ym9zGM9z8Hc1v9nvdlJnNkJfcQLHdbDnJ/5XM+3nc5TPdNZndrnnNwx/dS7Xdp7HN33PNfzPMntj67jHRHnfd4JAhEHALXk3d13fdVJ/NCtfMyx/cv9Hc+pvCqP3dwp/bohPeEVXsTNfcMvHOITAsQfPtXBfeBRXdttvdwzftlrfMyRfcuTnddLvtrvXNaBXeWFneV/nd+9veWHXdlHnthJvuBpfeON/dYR/ubHfeerfc6VPdvJ/MzXveKvfdpVHeAzHtaZHth5/tiZVdDp/WzxfSDY3c+5XONBGMWtnsdPy+tzfuPFneJdvMv7/dzT/uhZfejrvNHRvtIjnuAxnOHpnuwlXu7Nvsv/O13tAf7N2x7O0f3tbV7O7TzZvT3gnRXlS34yd9zdWf7lY17yJx/xT77nxf7jc97wl93kq3zutTzzf77YdT7Wtb7ZE//nPT31Xb3dC/7pLx/lczzs+xzJp57e6V3eAx3QYb4a6frq07zyE//xI7/Rl97zyd3H6zzgyz7pE/21K37tV73uOT3iy97uJZ6Hxh3bdaL6p1/Oi37rlf/kOZ7moT3LdV70BT/XhdzXKb/lidzIlZz9dxz+e33Yyd/kg334V979ASKAwIEEBQIIcBBAwoMFERocmNBhxIkSHzKk6LCiRogWMypEGLHhxYYkS5o8iVJkgAIbV448OIAky5ks/wXMXIkT582cKwUILOBzIEuSAIYyDBCTJ8GjBguEPAq1YlSmED9ylIqVIkasWaNm9fj1o8KxYheSPXsWJFm1ZsuiXRj2rVy4Y9nWnYs3r969fPv6/Xu37Vy7dM0S1gsycWC6Ep92fKkRckqUIVH6vGwSc1CBQTET3Dw5dEHQnQMI0BzaM+rJjiubpLpVdEGqJD2XxMiU9uyrum8/BPt75NeWYHvL/n385FCloEsS4KzTJ9Cd1JUmp8w7o0OWuA1qDQv+u3jt4XcHLz9eK2C0bAkffqtY8NrA7+fLT7s+v/79/P+2dwtgY4rFR6BbXQmoHoLndQccZMI9Ntx1EpZk2/+Eya1moWhehfYgeSdtCNuHIiJHXIYqfZedhxIaZ6KKBd3E0nM42RSAjM/dJJ1pNcWI0wE1/khAAUL+NONzNjX3olBEyjYUd07qFlFSrmmXG1cd/ScWcBBOaViWjEXGUWX35YVlffCxh1d8ZanZX5tuvglnm2yuOZF4CdK3WIEG4qmnmCW2KFuFJyEpYWmqmYYoaoqadlqijg5kqKONAjqhVVchiimhK1JK4oWZcgoqQU02NF1OpeokVFDPGbnjj0vCqKR1sS73k6AD3bhTrCbRSqWHXC6V0nhEwoSQU6ImSRWvVXYX5VVJkZceegfS2d+c1Nqllplmxsltt97ehaD/YNiCey2AeRbWZZ3F9RpqapC+u+iimHoa76P13vsphpHamqGmoPKbXIft+kYbi8eNuqSFNKJKJKs6+iQjT62WujDCN5YEK8OkhsZdsX6qhJzBphKbU0xFcfxqxUrSOFTEGMsKbMy9uhZtzeid+ZhfffaV7bc+/5yfe+X2PBi16SropdFxqUm0lbL1ttpm/g4qab7zPkqh1fgiKW9tVUPX7tQDey021SlJB3FPrtbLGrRbuphyT0CpPffFOt1ko0Cr1tqqUjfSSKOMoFEHeE6a1sTwqK3+PSrLOhKJ8ME5HcTrxJBLDHnarrLkY+A/+jiUyjslNXfpdJsqq8Afuy3t/242q7cYmnJpi1/sQN9++7bWMqZuuUkPmB7vwAvPVe8Frgv3pVSzfe9pml2279daN7p11RgGOvZkZYeNEq+fuZqZ3uJP57ngiJI/49XvMvnjkTweSYD7aNf6qtxpe+6qjBOn/fePOPKots6J73GlC0oBd7I3/aEuOjuaX/xEAysfyS0AEPAfBRdWwYu1qnB7g4D7gkQ+oMRPhDU6UgVZUsHEoc5y0Rmgsi7VG684qEFSed22bIdDPJnraLjroQ91yKffCXFaexJinQpzPGbVkEDrCqKXnOauq3VtedDRlKKAciRGOS9+1GMU+L4ntfV5SnvWU1+o2Ea29FFvbu4b3//jHhZCASQQSHQsIQnz9zj8eS9hI5RjCcWXQPmRMJAFMJ9tUthH9B0QcHE8gAAO0Mc5ElJ+q6IkkOBHx0pK0n7tI9/eILkS0K0EhTMZYfwIED9QfhJVBcjgJYHiyg4ujIIMxMkJH+cwVtIvV8tBWC8vR55fug6KUXHS22x4xCKi6zD10ZO1bvjDaA5vZ+c6YtN4JzwnIu2YSItWeWjYGi0pb0MhM9GhFOU86jkvUUZqnhfFVhp7ybOM6OxiOu+Jz+e9U17Q06dmsPgwPPrxlHKE30APWslScc6OBxXhaRJ6UIaaD1F7M50lD+BQAniwAD6aoyMh+UiNBsmRnmTo5nD/SUuKLXSjPlKlHE/50VS+tKAQICgBQFrIlAqkowVdYf1OWSOZyhSkMQ1pKmF61JliVAAbtUkCYem+pt4SAtOB0QdRdUtY5ep8OXrOLeXnyssAUI/AxJwwYSazMEnLTukyGl+YqbTZRZNMdK1dmnJoRB7yEEzCQVE4/bqgwAKWr2Aq3nmSNxqidCp7YGus9OgpqXRqUYv5rGxBBZAAASAAs5rlbGc3m87Nitazl2UAZ02bWdN6NgHxY60cXVtZRnGRixC7bOjY+cjX2rSEQD2lTS8724cWlKAgRaVwhRpS8O0NkyQ95WbjV9MAdDRI1A3hqjwY3VOSL6YjFakcHWnc//DOFJUHYEB5O5tUWFayph/NbW5d5UEbHSmLCgUSUMB7U+cWlLuQ7G9+yWtcSBIAAeR9JFEDfFOjhpSpw30OSR8JyxpRlZZBkrBTpTsdUzbUj480jYxSiFWcOPhzqFKZLgk3GsUpNinPUt1GtvI6JO7QPsqc8ZigOVe8ulVody0i8JyJTeT1FUKGpeGVhgxDi3yJXSHCHvTctb3wJRZ779RaovpJ2S3iM7i5He1mMwvafHr5s509DQIScIAEnBm0mc0sAVxrWtW2mbSnMS1tLXvndXYYvJh9M58PPN7vJhi8B8bvcHOb4N8ulad7y8lQ5Rjn+JkXwAAWcH552t9DA/94wQT2r38HPWjTHoDAIWUAKm9qaqL6N7cOxcwD+6np/bJWwJ4eMKo/Xd7/XjrVqb6pp019aUErWMAhzfRQe5vb+CZ3oQ5GpXQlikmIYhEzKUxhfXlUX6pCFds5wuNy8mbBAeYIRKw7MmGRiSXZ4XhM6MrxuORa4yAm0XgynuYTASssJE/JMo8dkciiGKnEVm+K4UNjwSeL5S7OszZ6vmxmnZeAOT88tX1mrcU5+/Avl7nNEbd4awn60DzHmbPtTfObP0tx56U5tOn8rahfGl6Yovk0H91smmOKgFyb19Rotnh5Nwvs3Foa2KdGJWttetRLGyC/vQ6pzVWL1AL7udf/uT5ArftL4E5feuvl7frOCWBqAvc6v4hecHFvOvOPht3WWee61iH5dq7LXe60PnV/C7n1rYt60p0GNneLLV2pE3q/Vw0Sgzlq9oQ62JPjhW5yExntS0pVkDTKqsaUUrATFes3xorxWsGzzRmvO8dvraYOw3Une9Ppx44pbOtnWG+vYc3Js3fswdNocNxD1lCShfXuy2hl21TPevd8+Gotm86Ua/rhUOcsaFELdgGYFuidTcD0QQv0M6u557kmsJoZcOY0h5nMkbZ+ea1/ZlObWvrSzzXYvQ737oNd63xnu60hWX8AE3gB72fA2pduagawdju3AP73dQjQdjm3c1Z3/1NtN2oNmF85B4F9V178934GcABLhwAL0Gn8B4BgZ2uTNmn4B38jOGALkIEQ+IASKIH9BXe3Zn/+lXVdR4ELaIMlWHWT9l9Xt4C+ZmCpBAFWB142V2A15WAzxV41Qj5NVVTK5kFLhV0jJoUK1UYh9COx9Gx2gyO79Bp71BJSckxGARHG8nmwI3p2ZWM+xDTmwmPisnrV1ERvE4ewR2SSwVj0Any3J3CQxW9Ptoewpk69B4iBeGWWhXD4lGXI13IYR1pgRmfClXyPOHESZ2aY5YhohoBqplkDRmZeBn6apWZrJoqf+Hbgt33+13brZ3KduIk353UK+IBdF4Ev+Gs0mP9K18cABoAAS8eLBFCACyCABhCMuUiMApiCKUhgGKiBXXcAv7iBqNR2xqiDtwZ/qNSL8cd2zNiL9wdJS+eLKciBwLiB5gVJKLh/vshro1aAudhfGuiMG0iBvuZrncaMBNCLS4eDAyaLDBiBlUZ3Jmhp7KVrxOaCObVoHHVfoJRpRGUTLWVh2IUZEmQk0cVRNSJKIEYQU3VSDmM6KaNiPGEyw7EsZUiSyZRD1LQ7gEE7MiY75OIg9EZv4GRuRsYgIrFv/QJG0hNPaBRw8dQQPrkv9vR7zRE9W9NwioiUgmiISWlZxpdylHhnE2eJKHeJ5Cda27dm34cA/od+ppiV2lf/AQkQlhVwZmSJgGeJlmapiwgIfmu5lVlZZuIHizX4c+Bni8xoXp2WgPJodTO4dAUohCjIf824lQJogRk4jhyoi8aIjAWYXwDomIbpfxlIjIWpi6OGmdIIjgwAjCdoXviIgfa4i6OGgIq5mLuIABKAmgYgAbkYjKgJjxnIgYipi+HImfComJiZczmnjBXIgPdojyconLLImVjHlw6oj/qnnFdHd2SXc+dVdWh2VPjFkEclYT3BUoE3UGeXbB2GQrYEnhGmVQyTNx+JMFrhFC7GTfhWkt7RY0VTV3CFhjFpRMczh3Uoh+HkeoGFWDlJcLKXNf45L8xDWVUWL8+jiFlG/3yDeBpSKYkNCqGSyHHH56BOGYnH94iVZXyQyEXKB30tF3EYN3IM4FqzFXEkan3S92YJlk7tBYrn55UkGn7gx5ZbWQFrWQFkOZYIoKNueZY6ipahCH40mnV5OaSLOaSUiYBgp4Ft6X+6yJlRyos0KoBbeYADxouGWZufOZiDKYxfKoASEIy1yZurqY4EuIHKOI7wt5t1uZin+aa7KIxiCqZ1Kqd1Wqc3KoxyigAwgJrAmIGyiZtqepqw+adm2ptkKoyUaZspiIFrmoDuh5f72JzMeXWHuYODRnjHBmjQlYXSNVx8loWsdhrR1VEMtVAR5lUDYXm/hEKe40sLpELFgf9uqYdMsbNEachuKfmGNdMlh6VE+0mTQpY816N7/3k2QzmUSnlPXwOIFRqhDsqUSGmh0JqhiohaFQdxGHdy0EeJF0dxF+etp6Wt3QqJbhat7Cej1peiF7eiKupx6Td9FbeKctZZ83pzQ8qjDHCjN5qaPGoAPcqjElABBMuaqZmjFcABPKqjZLmwZKmaa+mWrumaCOijZ4mYCEiWhSqMN1qMH/uaqimm/kqoq2mxJquofKqLGXCye7qnimmy4YinM1unYmqzKxuwrGkAHKCzGSCMPuuycEqzQ+uyKKuM4viyqwmzJqu0cmqPgMl/swmYGrh1FCiDsUiOHniXllqpXVv/jpRWd5labIMGVdkVR02FbVkoQhulU99JEyemQuYpM3RIn2vVeY3RkvLJbntbF3E4Lh7RO18yZDPkt9wzcL8HNoeruMiXiP20oY07rcg3otq6odsKroyIT9B6uW32ZuzaricXoigaunPmWSbKiNIKoRG3oqFbZ6w7cl9mctqnunN2lV6JlaYIil85pLs7lmJpozyqsUT6rydLpGZ5lgELsMa7sbtIssz7rxCLsqn5pngqskwrtHeKpwjAshK7mngKtHM6tN/7s+PrANQ7sw0wvhlQvgYAtN+bATdLp8JYvvHLmt8rAfQLpj6LvTMLjAbQv8K4AMAowP5LwHPKp+Io/7OBGo45h4LTm6axiYGYKYR9KcFW96iD2Yz9NZj5FbVWV4Bil4JeW6mYqmrT+V1KFWtLhXg4xTJ4Q2JzZHmiUz8qtlXIEZIydDNlCJPpple92nrE+hK+M7j5qSL/NiE7mbhV9IfK6k6IGLmRW4jbuohTHJWpG6Gni6GRyLnh+nESx3EkKn1ebInbR3FxNqEhOrsoiqLVV3wdx65qjMaWaIro13Hr+pZYiXJZabui+Jb6+pbDeJb8moskC34RC7ytmaMAO7xombPVa7Mai7AHm7OoybILO8koK6bv+6US8L5ySr/w271KW6foS6f4q7Pji8o8C6YS4ADxe7PoC747y/++BlC+6svJmizLHFDL7JvJnPylPiumPAu0quy+9TvLwqjK3nvMqPzLnzy09Hun7Vun/zuzqFnBKKibCBioGMiyApzBHkyLUXtT+AiQtNicXAeQ/zW2sjiQxBVrMXdQHRVHVngTtwRM1eFTkdMUxFIUlMPPCTEqJ4MTnneS8Mljf5s03sQnfisZdniHgGKUvUdPT/zEeRa5Fo3FWjyhxZfR7NdaljvGbozGJwqKayy7b5x+EZfSIn1mb2Zeb+y5Yem5YtlxWanSZKx9JArHJFoBptjTY2m7YcmvWPnTglzUkWywG1uw/fqvqsnUjvy8wwukyyuy/fqwC5vUwSwBDXD/vxwgAV791fcb1mIt1mBdzLzMshngs9K81rysszxbysB8yu7ryzyLvuqLyutLp+sLwMfss+Vr17OcybLss8nMvqTMyfe7s62M1+ULy+hbvpEtv7M8zK28s1vt1VydAbDM179sAHe9vp2N15MtjJxNy1/6vwMswAKcAcAIA/6bpsDY2Ql8tKPZwN8smBas26H5zRhojocJmJO6weRlgb5I3Lo2UhyF3C1oXDVFqur1OaXyN2xrz+NpVmUlhicTGw/Sz0hRETfcnjQGRC1ZLThDTuEEhkb80FC2oAmnZ1HM0aRbWbRVxYfWlBx9xRsKuqS13986lSLdcVYM4APOrqfr/9LsN7vkatKdSMY07eAyLdJDfaLpF5ZbCdN7HIpaaX29O9T8Spa3++E93cciLuJiadQ97dTAC8mQzLKoybM3+sgcsNQyLuNjfb+a/NUV8L5hzQFe3eP3y9Vb/dWZzeMc0ABc3QBGvtVHvtWf/dVcreSsLKZcLcu9fOM8O79qndgZoMtYPsvCjL4NsNk+m+StDNibzQFkrtZiLua3/NlhzuVHfuSf7eRs7gBG3uUOcOR3rudyrud//ucNEOgOEOiCvueG/uesfNoOoL7CrNZmTstSXsuRvdnsW8u+PL+ZftqbvgAO0OmqXcAG8NquTcCjTsCkHsD+m9t+ioI+m9qq7v/buY3NGYzNvq2OwinOgDlpoVl03cXBqFTcdndqhUTsI6WETEVHpzokrsS2Q5Ix+Fwdy0Ey/GwsTfIr4a1k80nedpVEEjETHtBKBaAA2gYBRTEAQiIk5Q4srVfD601FBNo8DCrFlJitHzrFmXuhlHvGGS2V7frFPceJHsd8GqdxrwtmrJV+oBjGcax9mPtlQEfGmsWVQ8rS7JqVvSvUQo3HOq19NmqA1ifIWHm7a2bUHl7yS80ArSnIiIykTc2vKQ6x0NvIChuwPPviO77jrAnXiX3ZSf7kyJzkQc/jQ47nUN7jSV70eJ70R27kSH/kNND0QV/0ZS71d87mbI7mdi7/6Los54eu541O6Ea+2YhO9l1v9oIuAg1AAUfOA0e+9lF/9mrP9g0AAmhf9w6w9mgv523v9YJOAYMuAoRO6GU/+IA+6INO9ohf+Kct6LQs2ZJt6Ysu+RkAA62N168t6uwbwJa/AK8NA+WLAhkQ+iig6jDw6v2b2gNMmLJO67bejLn9jVdXU0F4aRjFtbRmQl4VXdglEBXUYYZXU+jeSiHmtiGmS5NjTN4jLCG5z+G97fZx0PCGei4pEDFx7gMAANgvJOce7uVuTKM0EGygPBBtewd3uAynoR/XZ+vPfHUGoe/qWv59fKqFuX3GcwducTotxyhNcQCBQACDgQIEJkAo/yDBQYMCGiYoyCCBRIkGISJAsBDhgQQEBBwwyCAjRo0jJ2ZkIFEgAgImUVZICZMBTJkIRBI4QKClSJ4zU86cmIAmxgoIioq0abOCgZkSmg4terQCTZFUlSIwQBQjAglbDSwF21WCBAMSOFTggICDWbZs174dy6GBhLkNGsjFa1fuXbt8+cqlofcuB7kU9uYlPLhvX8SL8crNwMEBhwx9KzcwPHkxhcWY7XKmANozZxqkAwduEJiCCNWjMYtYLZpOAwe07c6ujZtCbdGrYTf4/dsw5toNZtPevZu2CAcOmDcAQdsB59u2lfc9zllE5+K4azdvbvu7eNsZHJg3ACP9gv8MKxwYWGHAwYL58unff98cvnwDCwz0B9A/FDK4774AD+jvgAUWQGABBRU04EH/DqCwwZwcxBCnnCgkAAKcPtxwQ51yKuCAEgkoAMUOUSwggAAgeDGAAmYMQMUSaWwxRxlj1FFHGHfcsUUXAwBgyCJdLPJIJIeUUcklXWwxSSKnlLLKAoocgEgAttRySy6/9DLMJMUMU8suzRwTTSrXXLPIK6e8ksYsswwgSwCEnLGABxbYYIEH/gQUggf0fEBQP1FgYYVEWWABBhYAHeBKKZlkUkdKhxTyUgEC2NQhTh3qFFQBPBpVVFNJdYhUkECFSCFTQVU11VNH7egjWXXSydX/jjJ6iFYCJlIJoZEcEqghhoLVyKKTfmKJJQYOSGmkpBZC6llqM4I2KZ4qcEqCpZAyyqepivqKqK6K2gorjMTCCiyMys0K3a2iopdbcqfytqyvymJAX7LONYossLLqiuAMyso3LbEMWKuustaiiy67DJirtrz86qyv7YD7LOPNPEOtY7sCY4211E4+jWOTRdjutO2oE+41GoRbObSSaZgANgpyxllnnUMrLTQKcN556AlKmwBooYUO2mijkYb66aF3hjrppW3GGrafl9Y6NBC8Dg04EXhguWzfYANBhK/Tnq45ENx27jvw5j6vbrvn5i8+GPKTb++8DUDhPRTwIxwF/wAHXwCGBdXzr3EGMZQwwscVJGDByiWsfIHKP9TcQRBxFfFGFT1MkXQWBUgxdRshSJ31PPPckQAeodzxzjuB1HFOIt+0800s1+z9dyntbLNN33cHU8wuyfRyeearLH5SSqE/svrqpy8eUzfrpJ32OxXA4AEWSJhihBKQGAF9JHoYIf0RNCiBBA0WfQCDASKdEdAVVtCg/RF08N8IcEACFCDuR5tyEeo4tcBO1chUn/qUsSRYrIaUqlUH4YitirUqWsnKIRzhSEtsBZJiibAlBOAJtG6Ckw8eAAEuHMkJmzUSkRgEWhR61ryqcpWk9PCFP4RhD8GVLiL+sIjpKhhXEP+Qga3ka2AVyIC7jGKUKDIxK/9Z4hKhmJYo7qsoClOiwr4igQyQBS5uMUAVlwIXDjDMLAxz41vm0hY3OoAsc5ELxSRgx4pFbI51+QvG9KKZi8llOntxTSKpg7LUlGw1M5ua05A2taTRwBdWowAPrla0pB2NahSIwc6SFoMJHC0GOEPlBC5JAV+EppSvTBoPJiBLWRbtA6KEZS6phjNMcnKTnazlzmqpyQ+QLWelhM0xdwYbWX7tA2pbmwgmEM20gaCaFEgb2XhQm21Gp5vQcc7bmEM38ATOAYEzT3MyELi90Qc95wQcPA2HuAUlbgErKNDhCNS4/tTTn/7sJ4b+Yzn/AjzgABBYAAQO6iGFFiChGzDRAzpUAISuiEQXpejruneAGE10RzBKHUdlByP8AQACWLKd7Zrku+O9CUjB455KYUq948GUeMw7U/N0OqadRs+n1Pvpk6J3PCNlb0nbwx2UWPcA8o2AfT3oQRB6kAMZBEEGUZ0qVLXqVPfhQAPyA6v8poCDKXxgClMgwf4iEIEHFJB8JGBUBDCw1gdsAAJ2xUkBbLVXjwSAo68CSWA/4pGc7JVCIxzVqlTFwsA+iwEoNAhkWbJXlmyoWdmS4Q1bcsNnudAgK+FJDzc7w3QhJUINSheCXIigd70LhqpVl7r+c8WopCsrWcRIGbX4FSYe/+xgV8wiFstYxv905bf/Oa4ZETYWMjY3MmzpSxrT+MYMHOwtk9FMZSQjmQZUxo8MI2QgCRNej3lMOyqzy8Zetp3igMZkKQPNaUoz36HRwL5Hu28qj7ZfWJKylKQkpX79OwEAE9i/BSblCUqpYP8qOJf/RfCDC0zgC1C4lBV+pYMx/GAOw7LCB/4vgSfwgQ5zmJNWG3EpP/DMW7JYbc/kQTZzVs1sqm03anNAdOa2G7hZk5wOcI976BY4+hTwnM0xHN/m2Z/51Kee61Qck/85ZSpXuZ4OdSgBNlBQBZWIoQVdEesOANHSLSCkFEURQ1M3IxuNrgD4ex2OaARSk94uSP/dyxSdbjpU4SFvSnYCNE8F3dMyPU95QEV0TLknVErFyXaOjhP33hTp612qe3fmXklz5DoUrIAE7euBDKiagxyUIQdSQDWqy1AGKay61VAoA6ylAAUpCCHVqN4EqmkNBV6v2tQykMEP+FCDD5BAc7JDIAM5taHHQusjj63gYQUrAA/5ddki2lACbmhDx+JwtTncrGoNgBMgNmsnsbUtasddWR8aUV1MxApwixghervQQS+cbb5lGy8vyhveTDxAb4MrXeRmkYtkeRjF4LhH6Z5HusOdSxklQ9wGUMy72G1MXiqz8e56BjOIzI1jBEkc5fDALtNJb22+RnKWxaZrMyv/Tcl4xhqeedK+N8d5fkF5SlHS4JSmRKXP7RsDACdYxBM2eoFPQPSlEz0GS4f606UO9ROcgA9Sv8DTs36BqnP9Al4/Ade7Hnayf93qJ/DE2MVOdrV73e1lX3rWFRz2C0+gwgwOsYI/fPcJ4P3DEQ4xLHFJgWeOWAQufubYponNZlpTbdDE5thAEOMcTz7HKr/83N7W43IKrsmNc7Lh8Dkffg4uQAKaMj3reYA9VXRBlBsz5SQ6ezB7SKIILV3uWRTnOLOORRPNKO93RCeQ0s5H3mtRliJNpyTxrkppGh6VBp08MQ3A0NfH6Zf+7Ofb3c4DRAJ0TK0vKeUH4Pu6U75J/1c6O/TT7vu8z1H8ZdQiFtVIdvJ3dKDfTLoCKGAACgDADnCqHrA1IeiCM+iCTTgDIjiDBVTATRACGWCCCCCzG9kQ0SEdbAORC+SQhsI2bHMQ3DMzM6MQzak3yaGQBHGQB4kQGFAtCjkAF4ScBWkQx+mnfrIQ1cqAFFSt1aPBBfkPxvGP2fKP+fCtfEPCJgOc/WinNGKPAeEP9egPAnEA9TBC9TgYh+Mb/djCu1E48hiP4uiL4pCbHzMO2xCnuHm8HKMDtWkAkyOb5PganaGDOcwkxju8O0QxW3KlpekkURowUvoADKu6viMwvPuAGPgAPjCwGPiwqnPEuHNEpptEqP/jOhk4gR2oOky8AD6ouky8ABXYgUs8ARc4ARnQxFE0RUxkRa5zgVDcAVGMxVg8AVncgVuURVGURRfYARlQAWD7xV/sxWFERVQcxlq8xVvkRBVwxVq8gFEsxa4Du6+7AEx8xVMsO2acxrCjxrKjxm/8xkm0O7tTxAsgMWJTsRVLMRVLMXV0x5xpMRqzJmv6AMdLm8fbvB5bARAgAQdIq80TMvfotHNagU7rtP0pyIQcHHxiSHtaABRoqz2RSD+hyIncEz8BlISKPYXCK9bhSAgYALuyKz0hyYJaKpK0KwXIqAFwHdeJFJB8swLwgBlhyTxhyUjBSUl7s/vJvzpJqUz/A78tkRSfhD7pw76g3Cky8Unrsx2mDB47OT/zW0oAsD4PoMqrtMql3D/bOakryRKrhICZxEnWmUmxlMlI8QC0HIC0BEmYnMm2rMkZ8Ui5DD6P/Ciy5L27ypOW3ACK2oABSIEecIMGPINNIILDzIXDhAIWUICZzKgM9DIwaz0+QSiDgiiDQiiI6hwua70SvJwZlBAMgRwJURB/skh/Uhx/Ur2AmrLUTL2HdM31WA8CSU3XVBzFyYDb7A98WpCGnI+CbCeBvCf8CJyFhA8YQE72SJz0SI8BmSdyMqfACbIf07w2nJtuok4QoIPm2M7cmI46jDEQqEdraqYYM8+v4QGy/xlPbEqayYOmGZOmaWpHEBgxdxzEREzEGhjHCuPP+6RGu9NP/qzEbTQ7Aj1FauREGajGUxxFVKzGtHPQXzRGYNsBFyhGUZyBWXSBGZABDlWBDJ2BD43FEP3QEg3RE1WBF1CBFGXRGXDRFHXRE43RGVXRGV3RF5jRHI3RD5XRHe1RHjXRFyXRE3WBFV1REl3RIhVGXhxGCyXGYbyAVyxQBb2AH7iAGgBHR7zSbwzQQcTS+ywl/fTPFSPTDwiB+hzPekxTfsQBEBgBEig2HsABHiABEqDTAarTtNqftNJTT/NTAlLIAirItVqrFYgAFIABRF0AFliACEicPYkAGIhUQP+h1Er9k/DxALsSFEKpq0EZlLb0AP97gAEY1bOsy/2bEbGES7HEyVR11Terk5jskTtBv5h8tKbcEqbMVe0DKq+kSusDVqHEyqu0Pp9MS7BcS/MDNJDESZ5UVfxxy1Tty0wl1ZvcgLIcVZD8y1HN1pvEy7Z8TIpSgLvKVHBFy3D11LsSFIXy1ALAAAgY10EpV7tq1wdQgAeQKw2ogauCKqrSgQ6gQHVlSZFc19kbQUEpFLtKqIQyqIY9qAWpzNOsyNN0VHt6AMX5Exi42D9JHIisp4uUSHza2OH0WET12IrESI+EgJVF2JZNV4qaS46tTD9hvYW1sgWBSLbSWUc9VI7/PdRDxSdGTVREMUiDZAGDPLLiTNr9ATKCBIE9Rcim3Uf36Md9vDx+9Md/RCt+nEfx7Fqv9doVC9uxJdN2JLGz/QBiU9v7TFs0nYAvfVsvxdIt/TopBcevs9JXZEYpZUUGZcVinFBlLMZeBDZgc9IRLYMYlYIZkAIeDdEk0NEZcIMZwNHJdYMXwNzM1VzNVYIXUIIkUAIjUILQHd3RTQIjAN3SVYIvGN0vIAIlIIIkeF3YBd3XfYHYNV3Y9Vwi8NzRfV3cTQLQPV3hXd3PLV7MTQLPfYHkXV7M5d3MvdzNxVEVxVwWpV4ebdwNTdIQLQMVcAFeDMa9lYFX/N5QJN+6/43Su/0BK2XfKq3SGoBf+E3b+ZXftbXf/wmgDxiBD8AB/n3TYqtHEnBTEECrOtUAtPoqFtAA/kmrBf6qCICrFEAUQmWBCKjgR3kUR9VYtpJIfLVUQLnXQvmTTS1Vu6pWeIXXmBwUWW3VFqZJWI0UWhUep9zVq/QSXb1h7Hse49mdpWzW/ePJ+2HWc2XV+1HJd92AIy6ADcCA/mtiDGDiak1YQSFVd5XJe23MvrzJ/rufv7zW/5PJ/oPXuprJUl1XYL3X/NFWFA7JFObWuiLhexXJS/UASq3jD96AD+4ADZCBJvgAAOzUvnSdFR7jQcFieB3J2burP8ljPVnkpRLhTv/F1w3I4zyuVISVZBHG4j8hVXutK5VsTCv2YlAOyf/7v1ANVS7u4mq14qXqy3pFybvKYzmuqySuZE9WACamZEa+ZUpWgCagAAXgYA7+E2IeZkJFZoBF5rU62mWe4BRggRRY5qNtZkO14LVKgToFgGqwgkH8UFZoAVbgAjWggjBQgyRIA3RmBQDI5mw2AQtIgRTAgRSwgEOFZg3QgBRgZwWwADz9qjpdAQmW5w/4AQtoARtAAnyOnxLAAQFy6P4NgRrAAQDCgYpO2/iN3x+A3/XlaI52gR8gXxfIge8tAxco6Q11gcZFNcZlacp1gemVAsy9XFRTglND3s3tXMzNadX/JQLR7WnZLQIjKIIsCGosMIIsEOoowIIsMAMzUANzboMoSAQz8II6iAKlVmos2IIs2IItwIIoyIIoKAKj5uqhFutcOOotKIKt3uqw5uotMIKtBmukzoK6zoKljuu6JoKxZuu1HuoiAOy6NoLBJuygLl3Wnd3cNV7NTQIrSIIPTYIveAEXSIIsWAMgUNHgbQIVsIImKN/PTt9XZN/2xdLSntv4DYELCIEyNdMV6982fVM89SoSKIF//qpsRgENsGBoDuhoZuZlXuYNkKtNjoAQxoBcPm7wAZ//G1X/A2NTvp9S5uKdpO4gfu43Cx8eUIAJ2IFf/dX7IUqm9FXwDlYa/8YSX71KRzO06CETYLXKtbwfAEhLAMCAFasBFsCA/H6AFegAD8CAUD3u/M7v/hkBMShwDGCBDhDwP1mBKdDtDmAUDfgDFjgr/BZwAVfm4l6r+cFnC4bwDhBAHADxDhiA8iGBATgFN1jEGiirVSADC2gCGWgURoGB/I5uL5ErY87x+m6CKVBwZa7gHLfguUJwuUpwR8lvgP3xCFfg3pbmCJDnPq4BBRjxDuCDC+DnueqAHYgBC9AAYUhbPgAAULAC8KmfB+gAT46ALcHXCpZUNIdzALiGNPC/HbiGD/CEJtiBa/60OmWBC9BuALCGHQCfuUIUxgQAElCAL7AGZVixCv9WALRiKj4YgDrNcyyHYBYgsREQ7hVTgBQw1LkqqwhoggtgBRCwhjQAgAj4gOLehUtYdZ21U7ZSgDwXZiivUyX3cAs2gQTXAAhPAXweH/7J7fHJZ/7BZx/A5w/QABNwdgUogS0Jgdq2ABVIgiEYgifQgW1vH68qAR/o59o2ASuwAkTogTKQgeD9gRxogRJYAh3oAR1AgvOpgR4wAQCwAXh/9xrQASb45ayygeBtAQDYdooOgRbAgR/AgRAIAR34gRDIdx0ogf+ZeG4v+Iv/AHjvgXrPgYL/gR74+DhYAhcoAiFIAi7IgSJIghwYAlLr6Kv6gWAbtfEVte81aZMu6ZX/XlwhmAGex9yYfgEhcAOhl97OVd3UDeqkH2zA/msqoIKxxoKo94Kp9wKnp4I2qHot0AIq0HpASAQtgIRbkARkQAZeIAVkgAS0v4Vb0IJbAARAgIO3j/u5b4RGAAQtgAMteIM2eAO913qtbwMtCPw2aIO5D4ZGgIO4BwRJkATEb3zGhwNJmHtkkARMAAZRgIM3eAQv0IIoAIRHiALQjwIwuOpIGP2r9oJBIIJEEASpRoUwUF4hUAHZp33v9d7vnezvtf3bz/3Zt/nft9DgH19qPN8cqFKOtgGOxgE5qGg5ACAdqOiHFqA+z9M8xWcNmO3Z/ip8BisJDvLvXysUoCtC/xVmZb7XALeAJK5nYRbuXKbk4w5V547uU+5LlWzWH7b/NxNKmuRJgABQAMCAAgMEIixg0GAAgQYBANgw4OCABQ8mGiwIgMwXNWqsvADgaQrEkhAnEpzIhEgLAKxsMDPlCSIEiHKUXSqJEsC1JiYBPCBYsqbQn02aXEgDIM2qGML48GmyiseIETvTWCt5icuHkmR2AGABYNccGTIGJNlhQSnQnwp+Wjulc0UMBRMp6oTx00PRuxPtKsCg4MFbv0XfAjVhwkcIEy1MWFDQYYSMJBdSFvRA8S4LiYQLYBjgYYOCCJEFK7A7IHWECB069KiBRAOAwB1SK9jw4IFrwR0wWP/wHfw2AAsajiNnYUKDD+YmfswoYeHLsRItjuNIYSKFBhIlSiiG2Jp7iQsXLOxoIiPN6w4RfERgEUFDivraSUBMEUH//Aj4AZDAmA8pDHgcd9qx0EEKkWlggQXaddBccyVw58NyALRQggYaYrfhFN9NgQMSIiKxBBI6jIAiiiJ++CEJx02BHA7Idaehdy8ep+GBBnbXHQkp/EgCC90BqQELLyLpowYzMqnBCDhA+SEOGpYwo4ZTjlDCFFVxycQMhpRggxVc5AAEFV7cAIQUNgBhhBA3nBGMGkd4gQUQd0IhxBln3LmJEVSAYYSgWNRphBJuCgGGEF5QIScQeOBRRR7/bWBRBxZqhMHJHMGgEgYqVLigBBFbbJHFFnD88skyYQADTCbIICPKFnWYocUbokgiiibDzEJLL9Tc8QYccEjSSLGCSAIIHIAg84YkmDQCzDJvKAuHFnUEswwvd+Byxx28SAKHGcRiUgwxdQByBybBaCHJtW988oklb+ABxxuRjLpGHaLgsscnxRzySSed3EEwMvHegQy3qsyiyR2q7JFMIarc4cowmpCiyCNhSCJJKXCgQogpanChRiOdJpKIF6hAEoUXLjNaRCBVPMKLI5oEEkWgghZRhBFYAF0EoVR4FIYaVFSxhhFZFPGFFVY0bUUWUzMN9Qsu5JB11lDkUEbW/2VIEbZZMuQgg9czhBCCFC4E0cMPb7/ttg4/6NBD3XIMUYQVwSQSBRA3BGqDDV9IwUQIRahxBRMmkGxD2nN8YUEICljxxXUpdGDCfizUx7l+KYj1oHvuWWACAIYQslppprVm2mCBiTZAaHaRlhoGpKEWWGoAplFXXxNBUJBfGen0kPCY/QXAKpysBoAKiUCihhAtTfHBCCFYIUxRP92lE0QTxIBZUQvwYNJq3aN/EEIEPRD8TwBYoVQBF+lkQ20h/GDDWypYwUpXyszBBkVohhXmID+DBAV5KUngQQqgGsmk5i6aARArDGEFiKSBFQBIwgVl0ITIAOA1tLlCF0ZwpP8OaKAGMgjCCHzgg9vARgZu6EoDEzIACCgAgbtpDWWsYIYWtMAKR9hEGHoxDU5wgxM2yAUVgLAJLrDiUlngwjHC0IYtmKERb4gFJtZwgy5AYQ2MYAQcwgAyQ1jDCkKwwQ2gQAQiBAEKZpgjEdoACGrd4hF6yAMmkDGMOyTtBoOQhQWWsAQNFacE69mFgxTACqWYAIUmkIELHgkAE+TACrLwgQVw0IMRjKg2Q/iBG3RwgxtkIRhUuMES7IaEHvTgO3TrgAUeYwIUlcAHOshBD4bAhCE8IZhMuIEhznDKJVxhCXGQghCM4AU4JKIOUVhDIJywhio4wQl3WgMe3pCLG2z/4k1XGOcIrgCRG7QtNhYAQAhwEIIW2EAO9kubOS3Qg9lY6DtLSsMP8kmlFJxODTbIwTGoAAAuCCIJQ4Dl3JCQIh3gQAc1gJICLFACJBRSB0sYXCx7wITvlIAJSQgBAATnBBsQbQ5caMEV4vAEJiABCUCMgw1aIIRVFE4KVjAEIZ/EpRoANahjo6RZpPCCRnEjGFswAhGUgIipNWEXzDCEGqahUqoaIguCMAQVlLBTLAjCFMdQwgtuwIVn3GALWDADFQRxNEqB9RmCCMPKqEGLTxyiGJVoxSRawddRtKISmqCFNBaxhUFgQa1bgJMTqpCLM4BhDcAQxBG6GYhb3PER/1F4Qx4acS13RcESmSCFJrBxsDssQhSdcEUtxqALV+wBGLyQRiykoYs9FEMTruAFL1yRDEeMQQ96uMMnREFaSNyiE30jlM+WNjUj+AxoHqECFpypCOpSIRHKjUIUqpAIQTyiE9QgBCoS0QdISOMRpJDGLRTBiESBIb5gCIPfNrEGL2DCC3goRSZqcQdd3EETsYjFzJgpBKx1LWxngMIg2rCGI7QhDE8YQhueQYU2qHIQr2gGF85QhGNMY2RCkCgud6mDEGTpRVSiD33sgwIN9Ic/n2vdePajoAiYIEGucY9rWsNj/ozuNzsGDpFPsxocagYCwcPAQFZgBw/I4hRiCP9CFxCBCDsAQAxd8MMgiJCKakBENcFrHwyCIkEIaEYz6hPe8RZAAb38bifc29775Py+O89ZKN07CZ/xjJc161l9eDZfn/9MkAA8pC0/CcERoLEIUjTsFlqAhF0scJvIeEB3tsONazTQgyAEgQjRwMQgguCMUwfhOH7wgR9M3YVXn7qE1VBKa2DnHxJEAAWtIYEFRmCIEyjABlIIQxioobFbRCEPUWjDDarQCUEUgQkEGUEN4CcIKrQgDgu+QghIYIgwCCHHCTqOCWpAbRlEoKKIBICPN/QbFjRHAy2QASX4gAMZqGAEFjANfF6DmtZhoHXuYcEKAo6BBxz84Lu5HQb/MAAAg7sG4RE4+FvIcA2CSCQGZIjAwhG+gQ4gPDVTWAFvNAACiHzgAvJhgcN3kZUJaIMSAKiGKSjxFh8gwhAW8AEL3GANH4zASaC0wCk40QRQ2HwEQbgCqDsgC1kgIQhS8Kg9IxN0GCtHPryBwcRfQ4IXzQcHE8WBC5IghBKEoAQu+AEAZKyAE/BgPyNIQhNa0AMqhCELV5BFGAbRBRdkB4gheCkTNGCCEuTgBo7bnRzAkDJoePUGL5DFC37wArSXbnGLUwwSauDRFFhHDbYgBBCInQstiEJXt8hDH8AQhyEMIU1AiEQe9OCKQxDjFmPg7hYyZQYvnrKMEcbiHKZh/wjEmUERWux7EJ7gBCwc4QpQ6MKCw2CIUW1BDYowAxaEUHqjibcXLaPCM8w1iC4TAQpuDEIcylCGGfBBBirUQQtyQP18SSIYcFgDqd5IhBuMiSEwQxgswxwowAwkQRFMzZoEyqTFgq8M2COEAhj0jKG4gBBgIAWqARb0jN70DKFgARVQwRYcwySMwgmi4ChMwhyYAgCVDBeI4NQQShQwQgTmQhvUAaks1Rkw1RcQwQuMShK8AFn5HyDwyx70QjNQgx6EQh8kV7JhghY0QiPYwM8cwUlVwSa40BXoyzL8Aq68QRu0AjFkzQwMATMwwxmUARHkQFZpAxcMgQzA0g98kv9DgVIJjEALHMEZKIIgCI4PrMQMoIgGmIUGhAASgBTsxcERWMEzHIEvGV4JuM0SDEHaWQdVtYAcyF4ggAE0QEIiOAEjVMHfPME4PQEQZMEZbIIxmUEzHIMFXAESKAAT+EAXTNUWbMIpgRoSQAQMjIAwuIEbTAELFEQBNAREmAKYAUAANEQBHIAxegIPYAAEHKMY+FVJqJmgDdo2cuOdARpe5BmheWNfmA9eMGM5rk+YRUBxhIALDAAr+ITuwJA8olDQWcBRlAALiAUiaI8dgAInyMI2+MCoHUMwVMIxmEEbREOXAcK/TAI36NUWNIIJjgIoMFgXlIEb2AGVjYAH1GL/F4Da0vkA/H2AMsgFM1SCGdiBYKSBzGHACHQBEQyCGWxBF/xCJRABJ9jBlH1BE3RADhRBCDBBDzzcCnQAhgwBIpaIIYESEigGLH2Sis3AC4SNDjBBkagdFMwBMXCC+0lBGQgB9PhNCMzNOkGGCTRGJBkeHyQBCLjHwfmYaZSbDFxdfSwFK8wAC0iGa6QGEiiBEsRie2BAjFhPjwXZeDiGDqSBC9SSDcyBGRRBdh0BI1ALL2AWfiVCG0gBFJhFTHKCGaSfHygOtf1AVWgICtXABWgACkmODTAH6FjAB6jFLjASfSjHBQRdbbSADyjAFKSBQzWBBngCK4xAE6SBcYyF/zYAAIXsABfIgAI0xythzovggIO8RgRUz47h2HbUh2K8hqVZwNNYwEEwGmSdQS5AwRN0gd/5QMDxxmDgWkWlhoNMh+XAFBPUQHAigQ/UhnQgQQ78QNa8wBwlQiNIwxvw3hlIQRfEYhl0gSwegSAIwgA4SBGEQXHY45ZESA8QAR9Ihj6yHHSykA+IQcOJAV9EQyP4gR+IgR9wwpY5g0aOwB84iTPkACLA4ILlwGIgh2MoDzOAAglxwjG0wRWg0xd8QSvJgBRgH76cwhuZwahVQiU0Ah6swUKuwRpsgvqBGhSAWjLVjUT9gGwAohwkE0jZgDu9jQvEwS65gAq4gA7MDf9QmccLYKAQOIEQVMEiSMIw3MItaII0BEIfxEIzPIIXKIIihEEzEMIcwEEf7AEstJYqUIMjwIJrUUMshEJjLUIe1EHS5EIU4AF31QmhJIIWoKoW3JElWAIgKAskKIIROAEY5AIeAIIkeMu2zIIjJMMe+Koj0IIS0kIy6AI1NEMz9KojPIIThIB+REZu5JBGqM8xXkIa1AQFKARRAAAOmA5KaCOdmcQDTIFF8NlmyGcLhAAjyNNbZNByCgFQzsEFqAY4WgMZ9NkxAsABkAEN0AQMwEABQMBAmIS+kgElkEEAXMLF0YRJ4Cs37kY3/gQF0AG4ksA0cAEA1EACQcQFqMD/vELsNmYA1PSA7PhFBAHAHAiCx/bZA0wsxDpBL5iC+HxrSTTsx4bjSYDjoAmat+oZnUWAMmQFRFhDE1iD9gwAx2kjGShnSkDEbuyG7AAHFCwBfuoAeDhGhlhIgiDIbzDBfbqQ4ayTAsgHLVkAExySDRhS2iyBHBiSdFjANFiB4LzrrDKCDUCBG4wARJgAE3Cb+iQIQShA2shBDrTAKw1AAJCBvYpHDTgIG21CD5jAG5CCKpCCEwxACXgpFNzGZuhEYGCAB/DFxyKGUAzGxGEAC3xADXwAjJUGCeStIRiCChhCV+RAFjDCQpXADFCCGrrBKVzCJSTuvu4rHUwB17mG/2L4wCvJn/aYhAyYU0VZwAU6SG1YwBoeARUEkAokgRF8AfIUBkS4QOfaRUkQR20owILsAhdAxskqg0nEAElQ6LzFJBGg7qAZgjLexfhihsqWxoNMwHdkyFvUgBVYVQt8QAl0BY35GwoBydf9xxT0wBU4gSKY4CRQARFkQRnwQQrM50H1AiPUWQqZgBBsQS5wgRGkqYP4gIYwARTEAUTgQAvYhzs1awqEwBBAwyP0wSOggiLcQsDkaRIkQRYYQRsoAhwswyFIghM05ICt0SGR1BzMwRpAlhHMASFsKpQcBQicHCsoQxokwASIgBiHcUueQAM0gAio8QSkrgrYwA+UgP8cMIITHMENrAwqqIEToIIS5IAcQIIjQEISJEIRAEEIWMATHIQSEAMV0EIsAIEShMEamAEmJIEyVA5ApcE0zMDJhgEVxIKAhUInxAIYhAIkaJYWPIIph0IgKFskFMELANGzOhDxHO432uwt43Iu6/Iu83Iv3yygAQAOEUXABg9KKMQ2zmyfvQ8PRKNfODMEWEQynwQZCMNbKMPF7oQ0c2MErIA+HoQCLJlgsNnp+MSeHUSmeUBGSKsEkWymYcCGIAET2AAYQIIoPINkgNJxtJDnYkAMrIICVNVJ4IZv3JILGMEzaBBGqLMzew+44iwMlM9PFIAvaKxIUMAAbEAKoID/TwDABcxENjN0aRDEd6CtgnTAXdROSq/AOv4AMYwhIeFGtGIERp+PM98FCkxBXA6J0H3Aa6TGjxwIRLSEeBCGRACABhjnF8yAGyBCGjRB0CGGAuiAUptNE3zBkyKCGWRKJUwCmMGAPgJiD3wACuia67zACSrDQH2AFXx0BKnGBoQZa+DGBtByz8rZZjB0Qxca91DEvJqzXZsEDuQAFOjASeesXvuZof0ZXsf0ROBAEaACFoQAgELJgpCGA8X0XGOQUqBrBEEACExA4L6QXRiEW9M0Q+8sRgPGnqXEapOGRCz0RMB2ovEsRqfAB6TAAmzAbueG8GREAez2BizAAhiA/wRIAAMU7DU0gASgMXMbtwEsAAEQAF0rhEJgtHVXd3YXhETQdXfPcv4ahrdyLvoQxEMMhPosNPIYGjlqs84qsy/D98c2RM3Gd32/d7iSwUz8BB8MAh94z0EEzwr4t0OkI2Lf94Hv7M2OIzI7dEPbcrlqY3vTBB8EAZORY4Mvoy9ThG40T53Z9PtogB/IwKjUQR0sQinkwRHUUmtEhupsAMf5daAleMmitniPd6ABtk48AArcxQOsAI/btDOHLmmcT2roRrpFxgZERnAweebIMLqipQlU4i/FQRwYculkzt4OARBYQim4wmuNwRh8MiMgRuhyI0bQd+eCt1+jRGmYq/+dqfd7U4QD5W8EScSHq/dq1JpqCHQtwal8ssZEpEAOxMENyOkSyOmJbI1HQUYEkbfAqg5upDdKuADLWEAOGAYATIMaMMIStEAVACspkIIjGEMthEItOIIjRMEj1IIeGMMY9EGYlwIvwPoYPAItaEFJOUEg6AEpUAMqOMGmOoEaCEILnBQ8vRN9OgEhKILgkFRxPAYtRcBEVYkc3KkXQAIqxMIkEIINMEL3tTjohUAc5IL36QwQeMEt3EGmntSlnMETxIEQpCcwTZgNeIEtFAEA6IARREEdQAIk6IAQFAHhMgFl18ARhIEtaIEokwIjHIG3uNYnYEwfVMHBlEIgXJP/EfTCM7zTYzyBEESBt6iCMSwCEJzBjlYUaURAC5hCzCpACwiGBZAGACxBJ7fTLuVACETAB6iACsAtEKGrBbAJIdhCmnLwsz4rboiH/r5PBCSBCoznt673Xq/ZTvDGbqf2ALwG5jwrnEMEZqeGA+HQA9RAC1CCIYhPDFgDWLDCJMTsXoejKTTDEUDEfJ/5NsbALpzAoAksnW0GBNCPe+OyhN9ZAEhADFRAAoDrALTP+2grnq0ASfiZMgtaGiRBDQDUOH4rGYTPhQe5TWd2RWV+CziIYpjtE9SUDTTCIfhVJXBCK4ACAGTaaoTGbQcFBpjASx2115ROsne9SFzD4/83/+gzPefWGc76PWDYhmlgOQ44ARUoAhg8YiUq0xlsVhRAg85ge/TbQIuXBBA5DjxBxjrtwhHZQB5kwhi0Vh/UAiow6hhADCz0Cy0UwyQ8ZC84wh3QAjF8AUCEOJLrRsEuZMhcIgLoDSBgb25siiTp0KFZe3pN0qiRG7din0jR6tVLGilNmrR4iRIFSIsWS57EMQIEDKFYoUIoADAAAwAFTkooGDAAwM6iR4UOPVp06AAFCi5E8Hmhxs6nTXc2Jao0aYGiG4hmxTq0gFYFGx6AHfAAQ9ilb4+ujZAiwlitSgEE2GBjTUsLFp6CBZAjiQ2hAJYIOWLjiZwlQ/4ukcNkwP8QiVWOZB7SAvDTq0nhuo1bNMKDsUzfio4bAG7e1q+LTuHzgQQLBUiIEPHRoweLK0H8MHW7VatYz1YPq4YNu6kCCylClCiRM7TQp0h63IjjOMeNXHn06AkUKpSxWqGcHAHiRA2qUEdCuDQxRA4QKHJy4iXqwcPS/st3ei6FFnQoQYMSelBBBqtwuKBAHCAsAYcULHAqrKECGAC6IUKIDzC8lnLOAhNaMKFDJkIYggnr5vpLp6N2YSW0o1gzaivjhkrqrqMg8G+ptTpYQooilFiChRGc0QDA1pSLC0TmULPRqCmfXNLKG1mgzbYHrtJqgwikAgCCG5ukcgPhiLNRqeL/bqRSSq8AeKADzxSIIL4hnijoDUhuAOKIJ1QMwQQTOii0AzDlpHMFHe8CDAcWMKDTsxyfisCCDv7qwKkQrFAjBzmuiOOKJZD4raCCbLCBC1uMsOBUPPLAI4gb1qjjjTxsrUNXXW+oQQcZ0kDkCzdekCKIMrqQAQoZguCtBx2uuAKJJ5gAzEXrcmyuUB+eiLaFIQoKNY44oIhjiRKWIHROHFzQ4MUBRhQoiliW4aSRMLaIxAKfmhNNPxqt/HEAr4hTrsyAEU5Y4SUVCKGKXlBxcigMULA0BSdiEcSGFmDLcEojNBkjkD6c6PAlKIZgMi4SPkjBQrweIG3OAVDAAYBL/6wZrc3UolzY55+BBvDCMgaJIpdcgIhkEVcsOaIFnb4QxIUWUpTDhhCKylCOlfQYQxppahljjFDu0CQWTSABgsV9LVgixSFs8CmCw9S8UCysANgmlVRWSbK1CGqILzmPmSxgTAxi9umqAkZsYU0ymbsrx+iGyIyRyxkJRI0iDAOgUyfASOQWnAZoAQhGQrBbNTIMCeMJZsy4W3LIg67ddqYeYAE1olaRccrRbo+yyTYNbqoAr0ZwI6tIQQvQWgswMHSIEp7IsyAgqlikjzFcWcQSY1ThRZVsYNljD1hwwcX8bFRRpRBdCpmloopwuSMURqKoBYgb8DiklZ7E4IMSjP8AQm8ZkQbAZIIlMAEKa+hDH0IxBj08ohYV3EP7zCc/i8BiFhosRkU+sQdehEIRhPgEL+CnC0vwAhnLKEYw4PCGN1gCDzPEQx3WEIYwAEELudBCHbzAMRtUYQ1R0AIcohAJOEgCEJIQhSsuuAdsWCIKknhDqkLghVh0gmRxY4qJ4vM0RoGGTJNSgAk0oINLQQ8vLIiDEEpwqdn9Lnh1tOMdEVYjPPqMJwQriolaYAMlfAoaeqjFIoAQggrhjY8rU0ALggIXbexCOD/a4yWv9AAYhGUJQPCCExjRgjXgohQpks6HGHkwBMZFAZh6ignqIwQdoOYLzNjjwYCmoXOdawj/vfRl5WwgBzAIwQlVCEQgSNGMWDghFBQkzxhIkQxH0OIRoThmKOJWpSmBghIBs8vdpIQw1jVhOQdrkwKacIKs0EiP/qIjmpyDBCsUIQRMQAITohWfFHRAkWdcwp+qdZUS6CBHFqjcQQnlkhT8wAVGyIEipcCSI/TSBmEgBCpQAYhIAIGjqAICNCKRhzc8AhpViIRJowAGRqzHCVF4hBcaMYgrNOIQRgCADdLTyyf86Wo2uEEk8FCFKvRhEWPIhCs+IQobDOAGcGgEEbaiAG75wFrcSgElUkGGCjinBU/gRDPC4IQ14CGklsiDJTKBDVes1Ri8EJ8k6vAEJKiICS1g/4L1zCAEPOUgCFR9SlEwEJE65KILYpjSFKaAATBFDwlLAMAgMCGKTSDmCMasQh3MGlRA6CEUjpBGKIh4KkCB0SVifEpZBrYzyKWpOKwJwGsxGVvZzpa2dcSllfTogRGMAANiEMMNtmAJ4eLhCdoMGB08kbhwvqUAMDiAN2EwptpOt5I7+1EBLtHN2BKFEq+4xHIg0KPXqOYFL6AaCegyKbMM4AMXeBpgiqLI2wKAEs0whCBskTLqvsUUo4gCz6w73/+IiT9lggFiecADO9hBGHYYwRRYwKUcIQ5SZwELBlhgAhzoYAk5yEEWwKAIOChCh2dwkQWYcIMqYA97wkVrJv/W4IdIDPcGR4BGHkIgiGcUxQa1yEY2CgFkXQy5EEU2ciFgcQhcYOMRvWiGjErAGTY5pUuWRBhRQDGJBKSGNTEQRlEu0AS67fdKVuYZXGBABxgErQMFeYIP+gODIPxBA2LAAAY8sBYu/QgDKxjBB/gQhBEEgVlBUJLQ4OXKMd9OurfTo9De2ci4EGy+ZR4YXBgV6Z/NMUctkEMVjAG/MTCiMwroZEsqvRRlmEI1quFBNTBwjUpoIxWtqMQ2PPELM4jhD784hg9aQwdOpOIXoNjbKybxip/FTBuTaAAZpvELWZCBB0vyAAQCAAE6qHnbACADKMgQgD/Y4RSIOIUdehL/pxVEd9PvPMtwdteUGpEADo5wBCxgYZ48hDPVZF7So/0dcNq64RSncMYIBgzgni0Jb2zSQBA2QYQtaOGIomjEJm6wCDCM93FqctPCi9KCQOihEO4zzxj2ped+F+UaaRgvHTS9JPGK9y3ZJYPPRmCGNgShPyOwQ53/EF0Y8MATB/eDoe/sBz8MYhtm2MYpjvIAEJAACSUgwQg0MAIfQHIJOjBBKpcr6SIQwgs4PUIgjOm0p/xlJ6ccgA2kAYtatE9sY3hgFW5ALSbs/eudKdOFynImRhaFB4LgghoEAQLZDiUGniDKK0AhgBp1oRGSsERwAGAHPvhgUAr8QQrEtALE/655KPyBwNDtkOCgt4Y/rceAHcTQHzEEgfZ+8IHtfeCDAGrAD0gwwVOYsIZcADUSa8C4UzlhBjJ4Imtl8QCeI+VOOMGlP/wpCs2XcmcFXOEGhDLBsAvbBd0Am0mlA0AabBEGn6rnDa4wBoyD8LRVLeivX/kAD9IksaN4wA5d8D/1AWDABmABsI8ppGsAVoAHegQGDuwPCG4QTqGwMMAHNAAG7CxhTm/NAPAtMkDynqs1vCIEs0bgrCQNmsApUOtfdkJOLKBDUIEaSOERvChorIsEayshHABAvu3mbPDMajCXxuIpDOQuCuA4EG+pDgYDpiBZukDzNPAtYGAbfiEaiP9AA9JNtjyBDKagnHpkABxgBWLGnG5EuZSLTAYmcQzFA1iADy5w4fxFNOiADJ7wNMaLjqbAXWKO4ewGTbJFLRhlANTCLorDyqzrFF7hGgAABlovz9ZEYVIhZwALEY5hDhTBCgCABXiiwOjru14DFBCxDsGJKA5s21TPDv6AB67hElzLP6yPP8TADtxgEDhhEGRBFhDBDf6gP8KL0WCAAjIAtpbCEy6B2JbiFEBhG/5tSR4ACbpgEzYBCjYhCK4gLDwA4K6PRwIg4ejwRzpgQOLDBiorDxbhDpYMGTChEbbBGaBgC4IAEX5hCxZhEeBmtCpELGLOYMzMZ6yRKQrlXXb/pNU+zo5g4BJiAABQQLmWw3Ae4AFObwEQ8ihgwBd44AltJ1uQQyiAYBGwIROcoAiEYEYYDi5SYRJcrgdN8iQTpl96ZuWOwhfIwA58IfUUzA48YQRg4A/EoAmUgRIqoAL2kQQ9oQnSwRRspik8gA2Qkg3OKARyIQpsYBFIYQ9IQRpw7EW4ygJc4kMAYFBKy++MYgNwgIBwoAZw4AdGIExIoAaEYo0a8TVygJiCbA+yYWycwAnmIAwC4TV+sg43wDl0At4McgUUDjB/5ANMwymWAlIqjSV18Si2YRS0Kx/fqQD6gyVPgfmKwg5qsQt07wprqwAygA4K0EpgAAHIgAYk/0AAvIkoFhIutmAZKgHqbCsrivBL6GJuNmAF1o0oTm/6flA1FGAIEs7a1mwFSMAnNIArB+VaqAyV1gk24OsoRoRufhBgAMZS/lIGWuARVKHuyAMSNCEUxqfIfkxs5PLIjEwXRiYeq2ClgEC/WmMvB4AEQOBFlqIajoHYKqEVWgHZXuEVWiEV4MAMzADqKhNK6ggN2u4GhKDGjoAl98gUJgEM9gUl+UgBTIOMAm4xMTC8sA0KPcEOMoAiMQkrZIALxGRhpq81FDQPzwwUt0t2YssDGFAMWEADWGBO3k1nhEMBWAATb4t2QqM5IkADCqUtX0MDiKALjsQOIDQ1ROTESv9t8CDtRaujTLKtKDYJvB5gRe9INKaABJrnZ2juCwxhB2LjGmLAJRPHLboLFIInG4sCFKYwGr5sYVrUkijFHoeC7XbCBCxAEQLBAuoizPiUULukSe7sztqtKFggf+gBHtigRvZSj2jgEmhgJ+BECjpBZBjBmo7ACVLFCQIBCAzjrwiBEPT0LYIEe06Ko/ZnCw7hE2iBG7BgJ/jA8TBAAxrsLZaPDSw0aK7yKQZEK29nADRlJ1rgCB5BD4aMGpphPEQ1BFJlOaahGUoyWLX1ytbCJPN0uvL0+YAVWH+EXGcrTUIAGtqBEdChCNwAA9DgAfZGubxUZSoJA0qgSAnFuFb/dSvGsgR4Ai9ctaNSYC3lKHjMFQAStnZ48yg+UDIlhwR6IFpK4PfqAll/ICgwgA2QddGqFGHQQAEw7M5mhl+Xw1zr1SewEgDUgBCoIFUghXluCw1olg3MATjwDEAW9pLCor90cwTcIRewwRje58fQsxDqrg9KFQiuQAH4QBgwoBtmS0GlNmF8gZz4yAz9aEfsCA0gwM9wABEa4RwRIQd6wBx+1APQYACSkmZpdlsDTgGYIDOAQA7wo2CxBW71dm+pay/59m8Fzm8BJAB2FiUvRL2qU2FQyyeYYAluIAQwRQd+YAkoVx06I3jQwHCUokUHYG2bwjM3cBFbjwWCIBzC/+EbfmHm2G04XQPgquEVKoFvnEEoW/RbeZQonMMI8kALFMEGwOARomARSqpPMjIPoiAP/ORp8KgAE7coECAVgfFnKDO8iGcEA2YVR3O2PGAK7ExtWxQCyFVwU8MHoCAIXqTRADd91Xd992u+bJd94Td+5dff6qQDdECNTEAHwCFbl4RjX2EUxiERYQDPWNfRlkJwW1R8k5G5QBLkACRmosc+q+Mzog5GZUvbYO4tEIETOGEbEEEYVgEUqiGPLkm3bE8M0KCA53eFWbiFXfiFYTiGqatwuxYuKLV1F/iS3ldhdlh4fJjMqNR2FOAJDi14HIBELZSGZXiJmbiJW1iBa/9rXBW2hzEpKZMyWN+Wip24KJQYQBTUbX+mBsIgGBoBCgALUh5AhbdYW58Uk/JUi/cIjtd4jum4ju34ju24i/F4j/m4j/34jwF5cK83kAm5kA35kBE5kRV5kRf4hl3jkR05kq1Xkhm5ki35kjE5kwsZikn4ka3Thj95FSF5kkdZj0T5hiUZlUcwldkJh10rklfxlfMilluXlmFLlnH5lV/rlne5l325loHZlwNA8nqZmIU5l2P5mJV5l4PZll15lqH5lK03mKkZhz1Zmp8ZlXH5ma15H025m6N5m8FZlbnZmUs5l5u5nEt5nbOZlNWZnVnZnLHZlZ25nms5ALwCn/P/YgB+WZ+FuQB2GaCXWaCZ2Z5VmZbXmZWtOaFH2ToRWpQ7Zpo9OaJDmZ3jczkE15FzGKMV5qAn+pA5+S0omaI5epqlWZ5XOaXBGZ4b+qRTmpej+ZrDmZeTOZzp+aaTeZlnuZfvOaZ92ZhfC6h5OqdnepmF2afRGaaVuqUP2KZvWaJHmqkPGp1lWqKbOpVteZvJmaVZOqmzOpvJ2aMV+qHdGZtRup2tmprtOZsJWqt5GqDzoq0D+rUIWq7pGqLV2Zyleq+5+psBjqw/OrBFuqSbeqUfzW8P26EvWrBxi6Q72pJDupEnGrEHO68V26y7WqXHGmCUWpbP+Z772adxuqY7/7ufdVmrkdqodfqpVbu1S3upUZu0v7qz1TqpRVubdxqlS9uwPxu2Cxuzt3qqwdqpRTuzmVqzkZusAVusdzq36fm0L/q07zpDaPquQdu1pzt6/5qrZdqjeZuhvXueDRqhF1ujf5ub0zq9GVu92fuT3dudNRlo8LqyOZq0ofmdKXm28Zuz05m1e9utidu2/Zu1BRzA6xmZoVu6Xbu5l1nyhFq1H5y2C/y2Y3u0m7udCVyt+1u5u1m2qzrDQdyySdml+7rEw/qy0dql8xvD+duUh/q54xoABJqfndugWdy/85muo5nGqZvFQXm9/XrEk/u7IXqr6fulhZyh1/vHl7y9Kf+7oYGcsONbL00ayjebw4dcxfcaGHV7uCVcqu1bwmfbqzXctwdcxU27oLH7mJ97zYc5qI3ay4faw8/cqWObzA1cwAN8yzHcrA28ok88oTP8uI37m1N8nI9bnrN6vJ2ZoPlZn/O5p//5tWgcyXs60k/70VuXx9H6qsv6x8Obv1d61OeZsINcyc8bylP9yCWbyR+7yae8viO6wkeaxEMdtwd8cHW5qC+czsM8tRlczJE6wInazY392JEdu4n9zw/czuWcwp09z4kbzKPds3EdtascxSGZpof9xc3bGlfcm7OduRU8wSXdn+8Zro8H0tt8rvHZtIsin3N8wB99xpnCxvX/mr0Nfa2LHNCF/KlVPdW1HOA7maTNu7DpG4qjOtYT5ttt59SX+9O729KFXawBG6ctPNcVPeMpfM6NPdjLPdlFHt59fcTHfM9LvtnVvLb7+8MFvdqf3cz3vZox+8bDvNm7e7VvnME3nTUwndOL/alzvHUxXcave81ze9cXXeltnsB//cSDG7wz+8ltXaXh27g3epD1XeIFWb5jHeInW+CRXKMTm+ytfrNJPdq9nOZbXrfv3KbZaeRJXu7p/qjte+c3XO1h++T3HqyxXcnpfOfN/Oj7nstdfrzLHPGrW5kF39sFv6htmcfr/a7tepgBmgDuWgDsepZpXN4XX6A9358H/z7pSd+/LXv0zf7QHx/LDZ6vF/69qRzhX53VGb7hBzvQaf/qYd/1J36/WX7CVb7K6zzw8bzd697YHdzbjz35kb2ZCzrp49zuCf/4n1+7oZ/Z8fztC3+m+7zFV5v6qT/Yo1ndKT3kARr0gRrzz//d11/zsxvz3z3+2xrkd/rRo3+X7f/dm77X/R4gAAQYKLBgAIMIDyo0OJCgwoYMBT5MSHGhRQAFMR7EqJGjx48gM27MGPLjxpEiEYI8WZIjypYwY8qcSbOmzZswF1KU+dIjyp4pWXZkKbRoRYkJJypFerGh06dLH0KdSrVqQwFWs2p1irWrU4lQvWINS9bqUYdNt/9CZai2Kli3Dl2+hRhXpNSkFdMytSj1KVikHdnS7du2sOGpTPdWLTCQseMABRhjjRyAAOTLli0zbjw5wOSxWgFs/ju474Cmm0u/XX135demQWMTnpuUbt6zKWsKDQlUbu6SF1XONJp7N87jyJMrpzlSZ3OfgXm37B379/OdcflGzL4d7Vyz3tEe9kx+vPmqY8d+T08etFWvWwNrPxn/PHjCVBNHre0Xd1rn2wVYF1F7CfYafvaZt1lqWhUg0IKFCbCZZpcxppl7lznFYGVQQRjAaQSNNhhCDn544Inc6cVXinnZ9pqAKs3nH27QkSScTdTVaJJvQxW33I9ABinkkDz/9RhjdCvVSKB8ZykFW3iKlVaYgVOJVV6VA2HY3pXmaRnhluxdRZWVW7Yl4IGsoalWgYZ5qRpi4uUXXmgrpqkfm1FKmSCKCmq4lZadZSghZIMSmuGGiO5J24gyOijXkzNCKimUT75oKWCSHqUjcsYhmVOSwE3HpJKjEmnqqacC9dJuwem04280ZupcVPs5CaNfsu6pK3y6/llmr/fxF+ykds6H4JQpGrummZXiGadh3wEbrWGPcVjhZZ119tgBHHJLQGQeFiCAZRK6t2FDiRa22WmiPdiYi8IWG29rJBkbKaU9ylinvZ5KR6q/m/Z7XI6oFmzwwbD21tN1ruKInWzV/9F615x49UUlsBhnmfGXbnK1MbJZTauryB+X1THJwpZccqKPQRjuu5thaNm7mXFYwLeHElquuA2+myBpcDYp3qIrDq3jbLDxt2NwbOnnIkE3UbdqwD76pmpMnSKs9dZBEowkgQA+R9ySRrHK45K32QvvsR+76V7HaoFm5dxg1i1AV3R7rPLGF8tZNdsk772s4BhvOK24LaMLc86SpZZ4ABAorrFnFvocaM5ZnTu405GS6PNCJRpIWp6W/nfnxAKxG1dqo9faedINl5qc12dzbfvtB4vNZKvClW11dfU+euS+fROuMdweIx933cfb7TzeeTdPt/KED/UU9cbTuafc7/9lb5XmflYrPnk8Y8vzzNWif+2F6lpbfpXgS/7yWqiXfuZUCwqdoZ/XJvoW67gqWkJABCI9te51sLKRqBJIHKy9KngCw53BaIc7SG1qbDf6XZGuA7HsPMt7YppcVqbHpS89rzwkTOGV8qbC7YUMY7yyT+AEJ5gZ2id+43EZzazFvpntb0GDGtS6GKet9v1wK4wZQBJNxDZFMUY0A2HXE+tTEJaRj3JY1FyJcGixLupLVgjUF3T2E6qBlRGCEkyjBLOWrwgmCW1RGxXDglKrD2bPbSeMYZfy2B68OU96fLwe80DYJiyVkJAjc5IdjfgULlJLiIcq186wQiEs7vCIUVz/nCAfVy0iUuZ9fvuPnIbWyM95kCqdlBzmxFeo8TkmcePbH8UMWDQw2lJT0uEOqGTHwOGo8ZfABFgD5whBNhbTSMOD2k9E2UT0ABJQIhzhH/X4qzElj4/QJNM12RMmQaJwcmHCXn+aGcIQwk2chkxQC194ugQ9TpWLIVTjBlVJxB0xcfTMUuMYp8oJVUV92OInzzjJw2thjln36VBpHKchDMHyc0AEokLDx7/SvUmRLILd6WZ0I6ZRcIENPGMw1fhR3fzOmK9CG9iMhEH6YIpH1rGLDS0qSHSmM5zPvKYzuflNEm5Tmtq06fIQiSWbdlMrQZQnJQdCLp6Jszu5eko9/22WLcz0DzKOCWLlBprUmVGoZl51n5++ytQr3tNnOnSfVsVqVbUOFJWmVBwAJZrVCn3mXa0cS2Z2xiEIIE5CYWUrQa/qSngWsIuKWdS9bmlBgsXORiV9IExHSlmHJYylkP3akTbLu+HJplnK7OBGQ1mWnMInhXfrI5l8Ck7VekaFsC2kUAk329Li77bdgydexXQhe5arrDxtnnCPKs2mulWSSmUMBPKp3N/a07hNzes8K1dQf3pIUNXlUKFsZj6+6hBCYfXqUjNX0VWuj7uW4dZyo3uzypRrueKC77e0Oi73/nWrmvQtXfVaVmshlk9OkeLaWvQwMBZJgf6a2gITWP/ZBgOpsw70UWN3h9k33abAipzhDFM7N552+G4cBjGHT/g8EP+xTKxtC04PWbIV15Yr0AvxRK1ZzlImb6uf8W15aqZdFKaWxd/jEAGWKq4hE8DIe7WnkmE2ybdW9buAFbKUY1k5Xjk5NT6ksnlzxmPn8rW8/nSvkaUcOeVeZrll7lZ8y7VXI9e3ZgcA13wPMOQDTHLIDzXRQ1uZ37hObJFPQ1qAPJupAyM4wmicrIMdTDuzyRGzFP4bTn7SxoqNNl8afTQ5acy82LZ2kEdF7bjuNmRSi7iaehMh9za2zj0CdZDXK19SsWjcVe9Yu0OWcm+NXOS73TfHlLurI3X95rL/4pnN9n0zX/m7P/gyWVDTLeh7qRq59AbAW8kucrJ1rc8rQhK+v811PA36V7/2L8pHHrWd0yuuOEMmzWVucj6xXbPIXcvZZkbfWl2577tm96AP2aKfM0pTgTM2jJI+NDETvOiGa/qYm/VsxDnY0kh30FYetd7DID3Lp7Wom8F9dY1/KmMRi7jUJgYyr2zNsV7VFnmsxdBp20Mu7Ya5fOGVd5KLvVf77has/t3KsXd+7HLZ+dd/zcy3fDjeiMrbqj3fuZ0h4OZea/vY9yV20oWMbDxXJtc9P5+xk73ucVm72pA7s3vXe/QhU71bFzI3WOubVWdb8tyPQbtS713QLae1/5Pjm0v8UHZRhBNLwQjm4KdM6nCSZnCyAOrdSZFJNuERGuO80x3B2aQiZwWOc6csZE/BZPLSmxzlpe/0Nw8TPdNiM/Ukfz2JmbrUH39GkuEWM9etnvusIv3OlOy68CUzOVhuF+hHFwCalc9uCdE53d/ylq+VfbObDSrN3h11qavedTGru87aFzL43TzmNSO9oYYifrZ3Ru/lt9u962Y7+JMv32tf+757Xa4A1Ls/ClXuyA9lZgJof07BLU2mdsqHFdjWFVhWVvZkUA21T5oEJ3FieBvXKV5DaYfmS403aQ/GYA+kO5klcZAWMRGDcRKnNpxXMZlHK3lCOqxmWqb3Wv8l52OkZ2LrND1+VIPcE2I6aHpACGLbN4MxNnPgJxb+RnM8x2bUN2rnN0/Bd3XeN2Z7pWwxxFxLBXbXNi7r5YTcEmfMd3/712509nV1xm31JVDkhndlR3Xat3/ad4bNN35DZ1fEpz4vU3d1Bn3qZnbfNy7rRgBlF4iAGIbWRgDghmbWthnwhlWPgXWWAW6Jg29p91vS91Zphm2MwS3kkWVotThWBFGbc3ATpmiIJjAhpUEd6IFmNEa7pIFp43kZVWmZliwv5SydpyKYhzp0RD+p5j0zF1SkR4M+WISwBihuFoTKKAAJcDfNSAAJMGQMMC7NuIymN4TWeGrtIWsd5hn/3EeFTOhmZUeHVPdc1DV+6+Ze1lIoMvOGdBZ+X3hkYuZ2cGZ/X6iAwQaHyzV17zVfgviHe7h//5hug1gAitiH3zhJCyh24TVlTGZ9dvaHdvZ8dPZ8RyaOgkiQZudXyveOFTku5md+cwgZiAhJOyeF7WVP8baJUtZ3vVUZZpaAA2hW8kRVWmY+NClL13UQT1QiqtMknfN4jwZTiseBq2ho/0JxwqRBYYNpsoiL3dFOUNlxllZHT/lnAWRbRPUrHjZ6SPhhOEiM2WhyCVCWAoAAZdmMCYAAd8OWbcmMZ/mW1UiWcAmXc/mM0RiNAjCN0ziWoxaOPWVqQ5aX3Md7fDiI/wH5jkamlwHJh9BnZMk3d5CpbAgAjdB3f1R3kdU3X4jzhfGVZHZWGftYAB6ZmAL5htDHloKYAB4pkIi4dv8YkaEZmvvnjUx4h4SCkRlJkUdGkQxwAL9JAJVZmRXZm0dWmRm5fx4JkQTZnBO5h27Xh2/nmfooiIhziPandGPYhOQCfhuSZr4nkweYfqBoV7I0FjvpJ6KjObXRnodXNayoQArjRqt4NQpnikpZYSZIYa7zRSx4lbaEgv5ZS+MxWy82cquHVIBkNz6oWqcnmG8IYmw5oXEpoXGJABh6lhS6oRVql3VJodQojXAJjdZYjcczZtDTiaM2jap5mhqpmH64bv+D6I5I5oc1mpwB+Ws0up3AuZenGYjGmZHJCaMz2pwDWZGkCZ1wCJxG9ptLGo3HeZwJSHUTeW3g91q0aWLsxXXQV5x0Npy7eZFMCqZfKogMEKbFeabP55psuqYf+ZHzh25rlpkgaVddyIk4R1hYVZvONRCZaFXn96fQ9Yl1VT6FOms+9CYlImhrM4uFhkG9lHi7JFlHSTWtGB2Vp1GuYjqYN5W5kibklDJ7E2M0FnK/qKDnIYxi8pUjpoSkVo15WZfVSKFq2YxuKWJsqZYe6pa22pZr6aGvapk+CqwPmox+WXPkR40y6pq9CYiTWZrzl6yKOY685nxwWIjJGpsEeab/e+mlaNqle0iILyqQpemtvLl/bHkAE8kAv3mm7Cqk5RqbqZeifzmO66amwRmc5pqRyCmk8BqkFRmwgsibbqqtiRmmLjqOpAZ/ZehX8+WGgphtNidvJmd/WAGe5AZY1WaQD8ttXLVKRZRK9COV+EE0pLgTuWOKjedoDNeUK3WBBSZadHRpYlQc0gIsq0UW2pSqsbezRYVNOTUmxXg3fcmMuuqhvWqrltmMDECYvcqiaYmWIsqXRPuXpuajJHq10xiNIIp6y4h63al94gqjZ6mucbmsgeiRZ6qXlcmaUMqaF1mvo8aW3KqaF3m3/mqc5DqQj9mjiqmR4eqvFdmu++qt/8jJpAZAAGcqpnQYhzuKmMAZuYT7rYNbuJRrnMUZprsZGZr7psK5f2oqrQO5j+K4pMpWnDZqpT8anY4Zfkm3ZmXodY2YZtlZuzWjX8CmUN9BQI2ROhpyQCdrYLUIgkQJMCO1MLUzgk25n5oKPJrngvhClSr2adQzU4Ykc4HkU60WTYHUPaRKr6aKHqZ3tCIGq844mFWbAFu7tSCmq0mrlou5mHNJtSTKonczkWfJtm6bv+uGAAfAmkCYrYKZbpWJkEv6pmfrrkxqvyw6uUyauXh7ZNOYjHTbmwsQpc+nr9P4wM76r5irr8JZuWGKACBsrmXarmDqrv16uHxrdshZwP/Eya/CKZz+q69eygBgGsMi7K2XG6SMi7lAjKM83JqxmaSea7rRSZpqloDSZ2R36rilyYVOyJ08t3bvJW8zySDnAkUAdhEiIryuyFgyAjHEm1Iri6nJC2GRt7wVB6BV+Z+VojLhC2Q1tVPSM3M6C7Ss6qB5lGJeuarTBMjGyKrOCIRzeXq6urRvyYyDGZF9SbcX6qP/y8ho6bZoScIkDJyX7KO3OsGxOrV11sCKG6KVeaaJi8KSO8MYmpEXnMJlSgCJS5yLq7iDuwDuepEsLMu0jK8BW8LBGcKq3MuRG7nAnMMjfACxbMuRe8G2bMsE4Mx0xsti6sBmegDKHMPD+aX/Oty5rknMZXoAxGnMwWnMKTzDv3nB//qckquudYa/VEquZwl+mSmaZieGnwmTUjx11Up/9fiwxSaJkIPFHpt+6EnHevIUqiMVIOIfDbHQA1aKZZQjqRhZaZSfEobGbEyLl7eCs8TRm8Zp0xs91PSz1uTHeTxi2iuWx4PSeszS3fhaDAq+Q9u+p/a15ltqz0jTOo2WG9ytbpmrkEyh/4uhOHzJbjum+YvJkjwuUovDo0zCe0nC6suuBcyiirvLw7zL5kxnF4zCtGwAKJzJWw3L4MwApyycvwnWzUy4iQvOgpjNwUymxYzBvxm5xDnM+moAyxy5iWsACGDLlbkAidvV/zM8poVdyl/qzW9tzeNs1yHs1Owc2RVZw976m3Bdzv6ryo8tueh8yus8pGZ6uXSWpEc6wxE7kMqpfDTXz4MIhveoz9l5z2CYdpmRb5fBLeEZgLulQ3wGFw8iESLiHwziuxaIUrxUMPZplLxk0S9LTGA8NioY3S1oQi/XWiZdxyW9oO8hY4K8QkhIgzD9vS5NhH0U3uUNlmNpviZ3q6V3l4X83ofsjEF9oazJrklt1VKbycN530YN1Ekd1Wspyj8so1LqpIhNuE7tyme6AMj8zGdKwiqs2aUM1mZt1ggA1l/a12a9yxhOnMn815QtiH3t4N+M4Ro8sJZtps3816qszP8MoMyfrcCxLOIOvgAgrsxk/eIvDsuFHcKSXdcDG+Sf7b/EjM1vvdmOTdnELMM8zrjm+su8mZnP98JC2s1jBoaka8/MJ57TKdue4WwG2Feq7UO0m2a9dbHS9YlshX6WwruyMkQZ4tAWaKnJfdzLIdEMx3hmHHnBsy+U0qmAHpVzspV1HIy55SWett3gXVM4WNPjDYTgXYTzKpZzKZblC98gxr7u3atxOauYXpeFrKu0mr9muX+/uqGfy6ETGuAYupasjsOwjqF+HeuxfpHcWnas6b9l69VGLsx1Tbhync1mW7n+28ywfMEGsNYGANYXXuHMzuN+XcN+beMN7tZ63db/zyyctpzMX33k4QzO4N7YlA2mbV3U1H7Of43MNr7u197M4Izs2q7jNp7M0+6/147M+H7MwtzLytzW4TzXAivDin3D3+yvVJeZHjzFfuVucfZ2zQqdE+nl6lVzqo2P39JeXwiBFOV73WUoXVZY38XQD13cQXmKG2jcSAkqnQWLlveoMdXRHnSV94Mr1lugJ8a9J7ZysIagOqjHK+TzezyWlh6EQ9+MQ196XvuqoE6YsgrqwCrqou6j9rvql9zfOKy+PO3q/a31CVABXe/qFYChYj/2CFABElABRR3rmHzqnHyhZArstX7ZiV3Nmk2u67zuA5vuu/ng3F6Zg/3ifg+c/zAenH+/1hfe7c1u1uq6+CGs12kN7Wvd77B84fX+7mLv19FuAGEP1hLQ7JiP+X9979d+46S/7iCurv6b+m4d2III730t+DuO7dtszULe4yw8xE7euQiLuukanN38++FaX+72sM3nbkmn2n56VY0YX1fVVlM1WMHdKvUTvMEbcZYaRxsoWR/lO2kDWroING8svcWTMSwXtN3dQqvmNn50gyoNW4Zc06/X6NbYR+r93vOK0jFW/+0d6k4PEAIEJhDAQEACggQEGmSA0GHBgwcgIhCAIAECAhYPMDiA0CKDhgwqJKgwcqTFCgwQIEjJUiVLmBVgrqQpE6bImxY/bszYE//jz40rMxrI+NPAxgM/MwZFiuAlgaQZFzAgimCqUwMGEBig2pVo1qNZCRy1iiBpWKhml1rlKJUj2wNSlQKde+BA1QVmt4a1mnWBgbxg+2bdWljrYcRb79oFHHZx1gOBI+8tnHTj1Ls9v2rOXDbvAqQcuS7oiblnXLtt1aKGipo1awJQZb8WYLe2RNyzayuMu9t3XN4ECggoEEAiBAEKYxtPLhD5AebQi0MIML16AOoErhfnLmB7gOvhiwfQXpx4eO3Vz4MfD559AADs48+HX58++Pj18dvnT9+/fQACFHC+AeEL0EAEB1RwQQINZPBAAQHsL0EJG/zvvgv3m3BDDPX/y+/D/Tp0b0QSSzTxRPe8QzEA71RUcUQXWZSxxRRZpFGgGXNsEccdBfLRRxuBFNLGGX80csgbdSzySCaNtJGgg46EMskepWxySoMSitKg5qJEiAAtwRQzAYUYQigkiBgSiACDlKNIJYdEIukkp2hS6SWZSIppT8MKk8kmOi9aqiqOVMpIpaYMxajQqaBigICpMPvpTq22KhQrob467K5Ih/qMqMjsAk0ooezCaCquuPJMNKjwsqxQy+j6rDDDwLK1sVsRyMCAXW9NjLDDyjrqr8X+sgo0voLVyzKyQKPKss4wS/UspwLryVHXZDsNo7hIi6xVcGfzdrbZ7OJNIIlq//stuHV3k6i14ZAr4N3kFFK3NuaGO0678pL7jjrusAvvvfHSG2+47gImDzyDBy4RgPH8y/A+9yaeeEIII8wYYwIfdPBBjRV0sEKSM+6YPw9TBlFEEFUO8WWL9VuRRCplnNlmGMF7Mecda1Qyxh9/1pHHIJvkEcmhfYRy6YGaNvppghCKcmqlq7Y66qt/nNLpra3UEmsjpV6aoCyVI7MhMA2iiMwEOvIxXbff/Egnj+Cs8yKd/iwppj9noulvm+qkSdWu6rxzrwpUrZQBVKlK1SuOIqWqqEq16iq00QRDjPG+9spKgs8tlYCqlfi6i9ZWH5s1KrM6O4t0A0AHNnbaa//39VdbZZfAc8q0MjavxRQLS/NgEZv9rrB+LywwuDbL6lmzYJW+KXJfq/562GKLCwICuIcNOPCxvxe3hW3DKDZ0yfvNO+igEkBe7eT1V6Hh+AVPXoLdC3h/8b5bOP/2hOhiAywZxlBmIZEhsEIdC1mCNmayAj2QYw7UEIk6tDINYfCCLzsgipJkohfVjEY3o5nQRPizoPWoayY0GtOo5rSnxVCGV5qhl2xIphvaMEtZyiHWfAgmiEQNiAMBor2iZC8sHSQkF/lS1B5FJvR5aUwFYWJG0mSRirSNIE4JyksuIhIGjE4CEqjA7gBlgMT1DVB76pufSten0jnOK2+kVV7/LCWTYOERU7CDnFZAlzjh9Ykwvesd8pA3uDfOTjRylJxYbuerXYFOAhkA3a4QZwAOxI6SWelVr2zlOeP95ZG/qtVfiPVJxwwSjoxj1FtIA6lVfWY284qLUlADq9bIhixIeY314IYuYNoFNe7SXjG1F77YPEdb72IRcuRnHPVJxzsAI4514qUv/iksf99RWDf9J7P8GPBCBIxZyEAGwQieU50LKiCE2pkyeG5QnBl0WQc9iLN7nlCfSjJhP/Upwxwt6YVQa1rXmhQkgR6JS0McKAxpyDaqlQ1sPtySFKN2poM4hKJko+iPFtocITJRI2djU5quaMWGdMSKWrSi20zK/zaF6CSLKNkbTsrIkr0hgIwI4MBNx5hGngaVAzMpiVaASpPd7e4wsLNUWWhFyM2lKlVxRIzsHAcsQFbujY8RJK2K11WljrIBBhjrWCXggEdKsni0A10mHwnKUaKyq8Dqy6e2MqtkVcZ3ZmmWSvASOY7cMjSgGRQsoTKq2GAEVN/KzGu4hS1yYS9b1rteZIcJnN3wC37kuSZxoPPZ+hEHYAuzpsBKO9rRZrN/qx1YOMlJTowVYIAIpC070fkxCkrQnbfdrT05xEGWwQy4GzpRjEq4T+QGNLlUIpoIj+akKhWthlybbgqXRDYjDXFK26Wu03jYxCAO5CFY+25CyCu2jP9q9IYdPQgQQ1oRKlokAWhjyJhQ+kQyrU1tTGzI3eZGkTfVBk5gxAkT/0SSL8pEJbubiVIDZxM0olGnE4bJYSRpGAZnNZGCRGWElerVr8Z1K4DkMK/AQklP2iqSxstqXG9VSRPHeMUm1pVaNeniR86YMGG9lSklkwFaBY8vkklMpAzJV6uIKlbQEmbrQBOqJJuKybYEVVsIK9hc1qVc2CMX9yAwr+DQxlzq6k1vlKNZz9brOu1T7Wn/xU3/Hew9DntYAAbAnzv3loB5li2FZluyk60zgYGOZ380JsAFzrOe/yk0CR19XH8ql588i3TPgEakKhn0oEdKaJem68KFTHH/o+1tL3bJ20NUj7ohVISoRFFttS6BCaJg05oSOTqR8GJEi1sSW9rm60T+CkonauuJF1dyJ5vitCTJdglXNJySNIZ1jSOmsIMrlVTDyITBH+Y27z4n160wuKuWTHFhMkBio47SkzOWHVjQeqtMvht0784xJz+XgXe7lVe6sx1Y9E1WsNjY3vU+sYkzYMrG+NjHt/NMVQDjGc9MRnN7Ad5RhHlxKbcuVKI6LGNPw7hvtYoqU2mLL7lMWY/zBjePqpdyOmLm5rRPXegrz5eFg7D3LUw77eufnOUMZ5/3vGLCHfpr5ymxRK9zZCBzYHBb9vSkU7DQUIc6PB999eXis9Jb/3dup2do0CklzWlGrJKnreS1jDa0ad8FoqsbctG3s1q7aZfvSy+a9l8v8dcDBXB68z5fLL5d8B85k3z7+yWZwimLW8yISA9nty9SCiciUTAZKycSP7JEwoD8cLVnImGjjhjbf7Rk5iM84sMkLqkmliSQebUXt8quVp5D3rdrR+8UQ1L3Am+3WQu+K+Dz6t+8GmvwM2BWHWsSxqNsd4qHD/xJFtwvtnJr7F3cO1ydklO20j5kEAADJZtql05u+MYhJdhvyTI1tZzsyYtpcnq9C+WxORf6uFcv/NO8fvkiTv/lF/TRErqgE0CH6TP66LPigJj7QEDwuLOiO7oFYpCPSf+nCawtC/Gzplu6Bpm6RRsuDEKZR/ugqyuRnak0pPknJkGorCu77iI7sqMuTRuojmIaWiuoVPMSqXm7jboojdI7NTGTHnqIVZu1v9MoI3QIujmTtkEbwEMw/6qilcAbYzOwmSgcw7lClVi2lJg8y8M8m3gJrjCjrOC8CSOj1UuqCuCA3Rkq0puw2JmwXUG3NxqqtcoKtJKkO2Q+29skfYu+rfCkP7Q347O93MmKTAq+tnq34CsrgDureQs+GgM+6LNDSlREXrFEf2Mr2pFEXlmAXYEBXMk9QoyrkUO4hMMVsBAlVVyW4VEex4A4YvmMBQANb0kKZBmLLaulk0OX6nn/JfCZuffTnkdhE/qjueDgl/dJRoThuQOIl/5DGJ2Ds9Xypmmcs5TJMwOqD2z0DwM8OpPxM9s6pwo0J0DTQHPUs9/qoA0KpxHMGZspwXYEIX+yrq57Gq7TkRc0u+pSO31UCBzyNPa6GvfCQYeQNVkTQr9joh5UQl/7NbHJwTj5tZHQQYdEQoVECJO4SJD4Ozg5CZFywrwhCTxxiZZwitEJozAUwz+RsJ2ynNF5sL+pCb8pwzQ6N5Y4NzZ8w0mSADXkSZ8co5/sSaAco0P8PRyDvk2KPuvTN125HRQbOBOTNxW7FUg8PkxygHbbN6x8t7FCK6zMvU66RANAq7ECOKxs/wB868qwHCt9U0PaKb7l20ODs7focze7BAsUaAwHUEXAMEW+VMViyT5bOZ3um0XDtLiNixS1GBePc42Law3S4BZQgZRieiXKBI5iXKbMJBfOqg2EsZ/2eQ5oKo/yuY7UAqA5+7mfU0dFEy7Yes10okCm85hycq2kY7SqkyfbjEfe7E1Kcy56RKFN85F8XBPjJM4Z4pLjLM5XW5O7k5qwwSLoJLVZw7sjvM72ks4syiIf5MhfS7yPkBOKxMgiVEj58gjyDM+QIDynOIkBa08Ey8gohLY7oU9tQ0kvNEPLKypt07xo06k0irAArYBz26Q0BFACLYlzix2fFEqifNCfhP/QBgDKXmm+Cm3KuXxK22s3R7wxTPpQniRLgNsVr6TErChLqBzLEzur2Mm3G4s+DbVKBx0jTOrKsZQAG2VEfOOAEpVKTZxQHM1QqiQ+Q7y3q2TEd9tKE72dvfSLgzvFTwEyUcKVx/CLupoVWgwVLMVStpCMUfkMYWoN14hM+sNM+iMNohgXYzLTyywmz5QInEOYz1QP+cGfeEHNAWyz91DA6mC0CqoY+uCz1/TGQZNAdKqtcaRN3qIQq/PTP/VNSA3BeRQoTPO68KrBfjQa5VhO4/zHsHGoquGh5Nia99pBIyyo60zV8XKiNCnVxouaugOwj0SwOBkJ8ixPOWlCw/v/zo+kGziZr4mkz/jMm450ivqkPD0hSZwgI20jUJooUF2RiQVNUDQCsjQso57qKQjlydhRw2xtUHD11gnlgHEdV57kAHLFUXU1K7KsJORTqwlFsTFCUUyC0bLcFR49Kx6tneJjyxt9yqJUw3HFShPzvV2ZUAdoAB5N14Qlq62cJLRUWAfg0ePDt+NrgAZI2AzYUYtFSwc4voQN2Ywd2ZB12BslS3yLvhw92Umyyo9Fq429N3l7WBWlN4RTuCaF0ie92YO72caIDNDIgMlAHp+dxWHJUot7sicblss4FcrslM0gDcuECjDrlsPaTG0RDuEgDn6Z052LRtKkJmgMQG+i/8bVPJj4iBg7gw+0XdsRsc1BRTpDFcfZbCDd4lMGkS28XVtHpZhHjVTAXZF/UsHnGg4WzCHlPM4fYc7mENWJAlXuQs6pgZIyqSgcqkj1EpslWiKDVNUhvKi0mYj5YkL3uoiZgi8Dc4iMfDtbPRP37NVg+067kRO6+YjVBSOPRAkwEpzHa09oM8n+FMOVIDE6yiRsY0OeutYI7Um3FEp0DVdvbVBvFVgcjd50nVDsVVdxVdjsnVAV5Ul/PUuXPSuELSuEhdiBq9iyOj7QydEdndiJrdiKhV+MHdn6vV/8nViMXdiIFVmMFQGStV//FdmEvd+QJWCyet+FJcuzvFEbPf/YS8RXfFvSHjVRtFqAnOXLQZw+o+1gwOhZhfNZ1Zk+wCiWxAy/JHsyW1QN2VCKo2jTZkQmrHVTZ6La99la7gFb8qCOLwO6aoyzbQJiDYJAiolbQzMnu1VUQfOYAfgyJy6AJ4aYO5ti1wxcKzYueBTcIiFcejROGXHBUgvjf7QXxm2ayu3U7gI1hfqRtVEpiFqbUX1Ivys1+6pcWSPIUuNBKvpVNNlIXf3IxUOJ+IxP+fxIyMvVAVtPAyswutnCLWxPysNd+/Qr/BydPUHD2EnQngoqXenkZ3VWBssknloxdQXfB71eHAVSn8zengRS5j1X7CVXcuXeWZbl+63l/dX/Xx6NWHIF2X11AK8MYIwN2QWmWI8dYAIGZpIl4AaggFkWWQrgXvw1YAGuXwegABEo4JGlAG0G4AagA2oWZmYeZnIOYK8MUpglPpE1S3WuWXd2Z7TKy71M57lUxF3xxAUAxXwGDH3+xFTk4L48xZ81zFBh2mQ5HchorLggikcpi1xCjardTF8iMzDjrJ2rH31pji+D4vPQU9QaGNUMD4hhW/loJ4lJwG40YgZC4kGrwKZ7oIsZgAKQaZqe6Y2GgCYuACgWDgsCQSC2Yt8c3BVkEiS6we/ix6p5XCgpL+vMGi/5riVCXSBam6mGrzbOLzre1cWjqLWZQYGQm/FaopTg/ygEO7xgLWtaVQmrnsKMBFYlrN1eBQlom2S6FomXDEOv2hu98c/RM8MyIlAymlYBrdcL20nr9V41zIDpNeVxRVdatuX9VVjHrt/JpmVpvmVaht9ZvlhfLmdyvlj7rWb9Hedsnub/Pe0GyGYRiObUbubWvl8agO3W5oEGAIEG4AHbBoFoZu1y5u0CdgAAtm1lBudrTktlBubjztgDFmdyTu4AJquyAuaxrGARRVIVPTh8+4sL9ucmBUXvhmcDWIFOHO9dEe8STcXuq6sU5pRiORYtNZfJoqXuoVpfCrkyG00IaEZnZBHocA7/01qd/ujSCpjTNFuSHmkH7Gl3SnAQVP/pCIxNJQ7HCPotBL8OmZ5pO8PwnK5pKZYZ/9lNoNYZrdPiexRxEW8SfwyigRw1sCvdOV7VFKc1tvnBGX+pPZ41UZtqWHWhAJs1JtwiIN9OmWo8nYDruRndChDdn2jCkJjIzaWbirCTKNQoW20IBZNy3p3rMCojM6S8Y7NPZ7uJuZ4wm9jPnbK8n8pJ1dMpNPrWoBzKBgVSxbZlOo9sW6aBWsbzBsBz3rbsyL5sx4Zs/c1sXm5u+2Vt1v7tjN3t+2V0jI3m2F5t1wbgSGf0aJZ016YATc8ARr9mbl70b8b0hGV0EZD0S49m4q7t1L5mVkd1c1bu5Y71Vy9gb7ZtcT7/blxXZl8OWXyD2b/wbmDOABTI7nmexWKf55rF4MZAAcPcS/HOSwy+WSw14VnUUmSJDK0IP1p86Pn2noiG72IEswIQjmaECuywJju16HF3M/4RcCBuj7SF254eOvFI2yqemD5zQAiH6bm1LXCipwucj+K4M+4YaZ2GGOpoYik+eL51W4G3xvYIIA+vDp3W6bftMy1eQZzxNDLmVKJe3OwyzhQ/ahpcO64ZSNSd3FFFIl/TcbVJ+SBfCbw73VXzwSwKCi0yctjVefnK3WOla5yCZGMVHDv5QvtsicAZ3pqYvJJQIy0Hqt2J5JdsKmpbCWurSf9seutd13VtbMjGZcrG/1g9l+3YFnuzx99IL/s9n2XTPvtGb/v8Jec+92ZEd+1mpoHVjm1NX22+t/T69fvdXm1sxntsnvSELXVsBvy+53vCB+C6T3xJB2BMp21WFwHbpu3V1m3N1/RrznTJb+ZST+1L/9/OT1jKV+5PT2bk7vWMneCMVVHr3ktjV9FoB2YUAGYMbtImVbieNQB9bgz1pkXhB9pjARdwNzlvGZdX8kWq7Z5yF3cAj37umZdxj36Llw7TfDP+qUYFxPiRjo9tZFsHF3jwnyAJD0eX5i2JUSACehmZ9gAAoGKdJvjdOsCKv/8v8wCd1v8BAAgAAwZA2OBhA4YHGx48wABhQIGBBf8ABBgQoOLFjAEEZOQowONGkCIvftwY8qTHjypVEmC5cmXLmB8TCKBp8+VHBB8P2CRwsybOoDpv6kRA02iCpAyACiias2lTogkOGDUatSoDBAwOZO2KFUHVBFURHMhplOdXBhUqMJBQQQKDuGwRVNBaty7Yu3TBgjXAl29dtXL/5iUsIe/at2sNJKbL+HBduJIr+AV7+PDex4wNQK7AwfNaDhJEc2ggwbTp06olZCjNoXSGBrJd0yjdQMRt2RRk0+AtojfvBrt3397d+/hv5L9/N6BxvDnw3LiRy64u/Ppw48aF/6bQXYR3CuHFgxdv/vx58CK6e6eB/j0F9/HFu6//T2P5ffXqJ6z3Xj68evfNV95/4IEgngMAhnegCCD0h5sDIiTogGx0NOAAhRTKhmGGHHqYQYcOgCgihgY4YKKJCzgAw4onnoiiAygYgIIDC8howAI2zrjAjDAskMECPuI45AE5FrlAkQYUeQCOTBZJAAFLLhAllAccQMCUWUZp5ZRVQollAQcUQECYBEAA5ZljFjBmmmS6+WWZZBYQAAEBzHmnnRfNaeeeePapJ0YTBUCRRRQROihGAAha6KKDNqqooYgeCilGkgJwKaaDYrppppx6eqmmlho6aqSlSpqRqZdaZCdEkM7pQaB5LrDQAwtE8MCtKDygK0O44hoBCyRo/yBssCwYy0KvrVq0qkaOromnRhzt2axJHs1ZUkotCaCttkG1RFNQOHG7UllXvkSATgLwpG1Z6u6U01RiCbCUTvQmwMC9SYXlFL9AWdVvUQRkJTBXUW6VlVj3guUVWQdzlRVfgtElmVZ/QUzZXnittRdYGWAsAWchuyXBYZshYDJeGesVmWWO+fUyyCCLTDJnMSPAwc0IZBAyZW8ZIBrJQGcQc82pNWDA0aVJ4IBqDdi29GmyIW0d1VVbt91zVBsHXm/E3dcbbrch9/Vw3OXX3nK74Rdgd/y5NwEFbsd9Xn3mvU3DBHjrLR7cc8NnXt98+5133G8L7jd65fE33n8UHP/IIA8URM5Dgw06frkIlGe+HuUHRvg5Dw54ToeEF35IooeplxgjiAaskMHrNcqu4ow71ijj7DLmiGOQvfM+5O4LIIBkjsQTL2WWUmJpJJdUWklllGEuEGac1JN55ZhyullAmmJy/ywEzz5rJwQCzAlBRhPN6SpF0KpPqaGCpnrq/PGnKj/9iA6wqab8g/rp//xHqv71jyL5OyCqLgIqaiHqVICak0XutCYIhK8ACnkAC1YwLBKMYApImEIJRiBCHSBBhCPYYAQiAIMHDAQi4uuVsUhAAhBMAQQyXMEKblXB9F2kTtLiiA/ftRKUtCRdPyHXtlTSLqckoFtl+da43PX/lHUpcSlNsRcD0CWwuGhxKVbiysP4JZaBgWVePAFjxfYCsYWxkSpr3ApZ4rhGwvylLpWhI8cMczK8uGUzLMNZz+jisZ8hoGQnK8wdL3PInBlgkBUY2s0aOZrR/IySHKgMzjLJGqJdEmgkG81rJsmao4EsNRyIDdQagEqnoeY0U3ONdVwTG9jMZkNUAw54sNOcXQZnbc5JTnfk856+CdM8kYMP4QIHtwn4Im8TyBve4hM4XxxumYATT+Q+ILm4PdOaMXhm4eSzTLw582/YJE/cDsSDCawzc4tTj3feCR7NOW5zj6ucg/LZABDQYXQSypzpPCQhEKiOQzSi0epc1LoX/6mIRzJCgY4c6jshrSCiQ4Lo74qn0Y0Wb0lRyhGWsASBAzyApCZdwJkgMD0kSY96V/qomdxUwfGdj04BQF/48oSnM9m0Tupbk53YV6llOepQiJoWo+pX1ERJ6lGnSmoBA/ipUE21qvmLFAMV6ECsasSACTRVV7XqVUApygMFyKAIS6gDEfbADzpYaw9MaEIN0DWFGFRhBoVVAiTgoIQlHAEHScACFEB0elklSbUSi62Q4CRdjo0KTXwyE8meZSrv8gkVy6WuJuqEJy+hCsEOhi6HkcVK7loiVBAwWq6otrUQ80pW8KIWurw2jXyhim1ru8g7EoYquMVjZTBTmccUUv9nGPNLBgozsUMeZmeHpEzJQHbJmNFsZJzx2SU5ExvOXNI0Q/vuz7Q7yVC+RmnmbWQnJ/ldUpqGaaxkpWscwAENzbKW8a2ObeSrteoQx2u5LM7XkhNgYd4Nb81k5gS+2UwKxGBuDX7mgucGNwOz05rPJKfevkkBbcLtm91MMDtjwIMHgxPEH/7wB57p4RILrsQWljDg4LZOyS0TBHATwY0n8AEcr/NAO6Ycf3BcOcp1zp4gAEHnHBchzxH0yAMVnQNWEGUOSVnKCT2RlRtau4e6KEVDqpEBXJciMPNIy7zjaGELq1EmlRmkJd3AAUYqZ5NugEphstKYxCTTmHrPe3L/8t5M+cSnCW7PfBiJYJ4S/ac/MXBVBrRfovAHv6sqUFCUrioABdgp/136sGJFYFg97WmvjjVQDIkAB3vQgysEoQethsIPgiCDOMigB7VudVxPSFe6TgEHG0QCCaYgQ2HZlSEbmN6aCFArhcz0WdcrgBClqBLGIrEsla1Xui6rrs5yFiqa3Yq6oFQvd2mxJVdyLbre5ds4NoW1lYGjHCv2RjxajN69ZZi9+/KXO+qlY3hMbseO27Pk1sVjmYmkXw4zXZHNrLqe3EwnuZu0mpGmlah5Wi1Hc3GLN21proHla+BLtQyZzjoa2q/Jr6PyXX4NOs2Zj3O+9ku9dZPm7vkm/84v3M0VX/ibGM55DFYM9GeewMTdlLCKJ1D0nBsdxBeYwNNPnOCo7zzpVuf5MqnZN23GbZ1SPzHfZExj8ew4nUEmT5B5sGMn57NBSH576ELXZCgTtKB2Vx2NVESjHeUdozZyKIpoN6QUqZmjht9oSLXkpiIVYHpwmtIXrfemNKlJfM5utuWTLT7vKSqC7tPpA28Kej8FNaiSvvTptUqtR296gJsWles7rdTZq36ptJ8foBSte/Q9SyG3SqEMRViDH/ygB8U/fhxU3QMdLF+uw3q+CT8g/Q+IUPo1+EANst+DGsQ11x3UgEKcDW2faKt85cPJE097pfRrtv1V2tb6nf9nrtY2Jd2dLWJODAbahu0fXef2v/+RxVSwFmtpxVa40bn11vCQhfB8UWnFkQFsRWU44MuczMuE2cscl78h1wEkl19c0iO5DAY612aAzM6EVyOl4M5kQOuklyeNF9O0RmlwBmqE13yxBgZ63NFciCrNBoXERg/GRmuwUn31oNaUhoUIR4JUjdrkkto84YPk0nIkh3C4xy5pR30Qjjg5hzNlWDRdnYnhnHN4GNMNHYjxHM6dwNMVXdEp3YctXRuS4dPNIdQ9Ex3W4ddVndB92DdFXR/uXA0kWCDq2DMFYooRYh5aGCJ6nQjsmCP2WCNGoo3Vk+bkk+MQFA/s04WIAB3/iE4/iU7dYQhBWdndqcjdYQjgsUiZGYCP1MgKiFmZveLhzeIsHlvxHBucwdlKiUlB9JlLdQ+bqImY+Nma6FmazJQLZZ4E6Q8PuU/75ImiMCOkFQr9WBql7A+kXMpEZBoBuV6m3V7+UCM1JhADgWPtNZCoLZqfABX4bEAErAAJYN8PyEAOyAAU5MA9lsE92uM8tloQ9KMMBKQ90mM95kAOlMFB3mNC5kAQQIEMyNr2fYCwkQBEjUkSbQS0CUD5bETBcMW8hFsW7YRlsV+5PM//gRG9WJv+qdZJsmQWgZHzwJHBUInDkBEDhBkBGID/HUwcrdu6HVKY0RuSWImSxJHw/1ggBjJXmH1McSWXISUXkFSgB6ZgmJ0gVK4gyXzXJu3M0jTSi2hlDI7Gi3QX0nicfr3Xa5zIDcoXEALhDzpNhgihLVHIfM0lD+qGypWNFHIHPPVlffRHi81c3aAH4RROgzGYNAFOhOVN0CUY050hZFpd0gUdZcbACQTdZWYmZlpmDFxAZ3KmZ17mBYgmaFpmaI4mam5mG7Yh1eEhHb5mHRbdHd6ha0rdHxpdHJrYIeYhN8GY9OmYJEqOg/BAPhFngxhnPh3ZkdEdc4aiKN4dQsXIiagimelOjTTUKrZZ8JwZLRYPBDyASj2AsjVemIineKLUSlmQmTieSlnPMT5b5f+JT/hsj5xo3uZNBAR41U7p1DNehKOB46SIClXpD6kUKP18o1XN3ulR46OhSp9EYwRFI4T6J4WaXlHVFLSEHlBVkFdFaETgCgeNQA2MwAWUgYm6QRdIQRcIQRd0wRm06IvqY4qewQucAY3aaI3W6BlIgRTsqBDsqBRAQZAiZA9Mga4kW0x9yUstKfSEmxSVi/NE6frFH/+RURdRRVEODBjp5AIwQJd+kQP+1nAtIFBiKbpA4CEdpZKMKY84SXIJzwSeDJMMHlXmYMtgIJ7iqVXiCJCsYJj9CJ820gmeUgpCDQoaqmhsFxHuINIs1NLsoG0AoQ/axoXAUnVoSNiQnIb/UAClMiF/4eWB7JOCoBPb0A19FE583A00caEzfdgXwlgzNSbOyeqsOmaCaWZlcqaucuZldiZpauYJAKtlqiGxomaxBqsMHOsFGKsLKCuxNutoEusJ7MC0FquxLuuxOmtq/uquWqYbsiEefqsbjuvTpVggUl3UHWKKresztdME2Bi8foCD7Ni7wqvjEOclHieU7WsohmIKxEjdRad0DqyOQFRFoQAM3AjuYGeN+EiO1MrDctSyLcDElhSWPImWmKeyRY8xjskDcM8GrMkGhM/HUs/36Jn3WB7mJSPL0pSFts8zEhWiFQrN2g9RTVo2IqjOIminPVU1QlqjROhQSeOh/znKy/5UnsAKooUV74FenoTPfCbbTUnQQ0BEC13tQOzKCvBADezADIzoD7gAj+aAFAhBj9oo2hIBGKAtjc7AD0RAlrCJknpJ/NWtlEbJmdjtlEaJTj6J30ZJaQ0lnGLpAgrP4K4pmA6PXwgPkCzg4srp48KAkmSAk8CA466iv1HuVOpMnp5I61DlCVYlivip5AbedNZIn/KI5LKImO2M5ypUmHVZmCUNiZiIeyENh5TcydnShuyGhvwuyfFghxBUQFEAhexGqJKO8TKO8hrI5VAOOlWT3bxYzfXNgZEhuJ7hB8TA9m6vZ7qht2qmZ/Iq+UrrCXiCGnrCtaohHyDrCf8k6wXsQPwuK7VeQLLKL/5egArsgAq8b//2b7Pu7wn87wAXsAror/6eQLMucAITcACrQLIKsAzgb7JWcLUma7W6b7TOL/xm6wZj67KG8Geq4Wd6pgnjYWfWoSFOwAqj2DPtJnC2U9k5r7wSpw0np3K6XXM6wL+uAAjgEAlIGUINcZShwAoYsY0c8e3MyO0sQEVp1MTqiq1QbMUWT0mhZ3seQJ2Jp0qN7EqllAWBLMhS0AR9D9SW8ffIpzI2Gxs/S6usCUFExETc7P5s4xzbXv6sj1RRFadgIzbuLDcaCoNGWqRA0KDsT0VkYyLb8U2xz/v4STTmZ0QEAKxIMiUPWpv/sKPL8t46ZkROcXJOLWOfRMQAbAAL6EAZJEEX6GgXbIKLnkEunMHaCgEU6AALKIB88lmSxtmU5K30JN6UXHHjDSPebglMUdBKwZSUHMky+9ZQPiAMLLPxHIDD0ml28k7h9uSa+k52djOS4CntSG7o5intyAh1gkiQsKKJLJQ4S+7rsOLOiDMLvi7ueojtdpkqyZc+ayoI3OXvboiEYEgDdKJAYchAXYjniKoDZCLxZiLpPDRgPo7k8Bg7bVNFz02KORiHLdg6pdjQPV0Ks+E3sSb3eub2NmZoWqu2mi/+IqsL0O+0xm+yuoD8TvAORLAC78BN6/RO27QK7C9Q7+8M//DvT/MvT/80Uuv0/ho1URs1UDP1TwvDUvM0VVc1T9v0Tlv1BG91Tb9vsEbrV2NrB4cwWZO1tZrwZ9ZADASiWmPfB1wAu3r09BGiXL8wfyRnI4KAIzbIu0pics7QDf0wCfCrKOJQERPWEeOQERtxYiOswTpxkCBsraxQxFbsslVxrVBQnMlZmJAs93zsyI5sAYSsFn/naHu2aBeAWZlxRDwEHKu2HIeP1a6JWREEpCwLKauP1QoVIguEqmTjNtZPgQIyAEWVp1jjIy/yb/sxAHiAb+9PbWOE0l7ysgCAa8O2a1+3B5iVdQ8EJZsVrKx2d3OPopRxBZ33hp4PfoJPff+m8XkPAAspgAKMgAuw8iYQAX7nAhGcQRkgAQaINk7F1EjFiUpVSd4WePFcbK1cLPE4j5aQFIMfz/FwyRcdD8RSbMQ6rI9seO84bI44LJD8SHcWDyv2joibeDQvCeVaLoins5AIieyAmRHXzhEv1O3ozitueJ+yIgrAzj0bFIbQyOtYGSneXUDt6yemDkF3IkGLonCyHZJtzg0T2YO863ncMN8QSDyth42p3YZtmNelWLlGHUir9Wza4WeO8AarobGmr0p3sAzYr1fLuUzHNAXH9P5u9f7S9FMLtU977Q5INVKrwAy4AKH/9Awc+k+/wKAnuqMruqIneqQjtaM3AaH/P7qlD/UMaDqgSzqlQ/qgh/pPuwBNH7VOY/UFvPQBp3oFp/povjSblzVZ14AIozWtl7Rd0/W6xvULT5+v6zWwA/sHpIC8foAMGTsNySsOECdg/zAOPTu0R/tiTztiOzGu6IoK5coK8YoUnxoV9wq4gzsGWJBDgGdoF4SxoXsBYMAAeAB8vzsEKEBtg08cQ8RDyLZr17G7c08cr3YEcTfvjbd1l1VF5DtTDTem9LY2BlChJLz9PDfEC8T+yKx0Q3wdS7xv42e7y7FtF4pzNzcl8zspu/ZqqzZBnPxDgHdrb7zIq7zV3ntt37ttY3drg08al6x6hs8GDAAG+EAP9Ggr/+P3FhDB0AeBDyjAuLv3eJLUF89KQaDnsb0Zne3isakUghOP1S8b8tCiw0LsA1A23BaPh+dI4XXni/c42s9IYVUU2/dO22eAjDwxwjKsjfgI289IY99OwlbUwAb5Kwqxj7ROjvM4kKsOkUdZlRl2kTMnKG7t3MmdKM4QPy3ncL5dsB+Z2sFdDWeOjx1ZkMlrg8hrN+0mu+rYb67rWr8wXF8AW7Pw053rW4dwbLL5+Y7mWLuv/LK5BcMvtB4wBJ96VkPw71/1UC+18M/ABLvApvOvo3vtpid6pj//C2w6o1O/9T//DEx/E8zA9lv69F//9icB90u/Cog/9lO/95f/ov+XP/erAKOLv/dLf6ZX/6NX/6E/ehlQOv9KtQwAhIsdAgUO3CHjxAUXJ2RcaHgBIsSHESlW/FHjAkaMHy5MqOGR4wePEz6UNHmyZIgJKkviADECBIkRJGTSnEKTxE0eNleQ6PnTZ4oVKEigGFo0wooIRpMuZYEiAowID1gsoPogqlWsD7hu7foAA9ivDzaQhbABAoQCEDwUwOAWrgcFA87WXVtgQIG2dAd44Dsgb168gwMH0FsAcWLEgQsAwBtgAGTJAwAEAFAZQOTLkCtrtvzZ8WbKjSFEppwZNWXOjfMCaNs4gAfDHgBAyLw37961aPM+oHsYcF/hgdUWV9zWr9//4X6Bv21b3HiBB4iNV7+rdjrfB3Wn10VLlmwBBQ8UaOhRRgqUG1CIEDnTw4QCtNcRH9hOAMKCAgs22J9udoEF8rPvgAUO6O8BAbkKkMEGG0zwQQcXQCFBGBZYgUEUAtTQqgk7vFBDDFHgcAELEzzxwww3XNGoCTkcEQYNYyyRQwwtrDFADGmM0QEYHEAhxqGGAhHIH3m80IEflTTKKCUdWCFJKKFEIckolZRyBRCS1FJLB7TMMksvxeSShJhA4AGENNVcs0yZzAShJDjl/ACECeqskyOSSDqpo48+KmlPkC4IaVCINIroh4wqUohRhRg64VGEGjroIE8u2IGhHTSV/4FSTmXgdIcZBlKhjFBFnaEMUlWQYoYZVHCVVVRbnXUGVl+Y4dZWk5ihCTdeeCGJX4F9QYlfi1UC2WKJFVbZYJ0ddthgowX2WWilfRbbaaHdVlhpf/VV2CZeaEKFccs99wUX0H31VSlWVQFeFXaQdwYZ4J13Xk5dQGhfRl3wt1GKLoIoUUMV1aiGhD/YCKWFTcLhgxFagrilD3DgAYeZPiDh4o1jKvMmnHDqiQWfiDq5KKVQeCoqqKKaSiqpHoCBq5gjmGqqsXQuqyyuysIAgrdKU6utucLrLjHdmOtLL8AaY40wyBQrwLCpC1tsMssu25rrrUH7OjWnXUNtMrJpi/8NsuT4Ouw15PD6i2281ForLwgUKA0uBfbaQDvkBthgL98ABzzvs+gbwDffhl578f/0MwstArq6G63K7eZKurPA6+rmpFZg4WayMKBrPsrP8mC7DfSzKnMF7YPgAf/sCzC/DsmySvUTdabZwqh0p3Dmrhg0kfgEI/jweAgDPBH2uoI7LLa7fttraLnlJr0txfVSfAP6/itgg/A9QEs+sNzqWWfhj4dqwqVGHKpJKqlcYEkHfBLy/hX0F3L/nozyCYA06QkJ7JemMslJTSJQE5rmBCce0OmBIJjCAxu2p5L4yWGDWthI/MTBPimqIv8iGKNyAJF/qYBRKHTBvmTAwk//tfBTKpCBq041L1eVAVavmhUOccUrXJVLXLu61RDBJSxhfYFYyUoCEZKlBCYagQhJMEIRjPCFKSqhCFb8QhGIYAQoVpEIWwwjFKXIRCUs8YxMZGISioAsKSrhC040AhrjyMY4bjEJSbjjEtkIxySc8Y98fBayjNitX+HKXMA6V6tYBS9XvcoFM4hkJOMlSRVG5F8rbJQILaKQgl0gURdJ2CgdhoMaOExhpzylxXQwglZarAYQG8HFaOkxEmzsJhoggQamoEsNsEADKwjmL4UilAiwAHQ4YwFWMIAzsORsLD3DQM9+BjvEIc5uZ2HMXwDzgMsQ5m2oCc1oMrOYca7m/5vi7FrXTnMadq5TnO5UJ2hgo5rgBIZpwinN2piztOEs7jCCIx3i5qIX3nCPenxLXG70Mhe+8c1ufyuaXdoyzf+UxjcDEBripBMX8mXTaB0lz+m+AjughQV1YtmczqbJggs04QOICx94drMWBRj0ciLlzn6K8z3YHeAsWnnc46jps5LyLH3pQ180yXLTt8wFquL52wBuWtCC7uU1gfENXuSCmO6ppXuAsdtgBjMfwWBnNzwrCwDKx5+chYUr4+kKXL3CFWgmTysosusCnNk5qPzVr1sJXQQ6YoEIWGAAKbiMAhSw2AikIAUogGxkI5uUFHQOs51jgVBokgL7DTAFJP8ILQksoAJUCMIINrhICGY5gta6dpavlJgOFjbKRflLBXlc4W55u8J0rVAKLnBXqnDIKvTQEFfkIqIhh3XGZRlRWU5MFhOtKEUparEIVMzCFrRrhCxgIQvh3QJ4v5uFKHx3vNxVbxG460XvGqG9VPQiFekL3+zad75T1G92uXtfKiKiivvVLyKiGEc1NtEIZ0xwdAsprHI5GLmpcldwJ+mu3qpgtwrJZKNKKAOMHAyEoyTloGI5glPSlmIWs9gUXosDjrnYxSKjiS5JcDMNrAzHS8ksWMZjAQz0mDzkUcCPR/djuQDGoRnl2/iueRi9kYY0fPlmcDJDzssUhjJZvvL/lrWcmq2ZhjPtDA081ylPMn+ZnZLpTGjeds/rLUajcIHbkfmGU/FglC43TVxHgQa4/8i0NEK7W3DwNpzlMNQ54GtL92izgzSQgQRUlYtfwgo4+YxPOpibJkEjijgPoA5xX6HrM+u6gZtZIAQXSEIN/mZUpIbv1eCBa6zR1zNodgWbRtU1VkwtatHxLSzBjsAGLEq5aW5gPGVJNlmomjf5/JjYxGYseTAwzWorGzyvDh9jkV1UWGebPMPm9bDJjVmX3awDmE3mMf16s2QmM93qdvfNoKKBCNw4BZutcWgfO5QIkEDf9w6tBnQJAAtAVgMl0AAOQlCCHVigBCYoQQpC/0DxD4RAAZRQhiG4wIUW/MAKVEDEF+LACkRwQRCEEMTKkVUEFTQhBC1IAQ4AoBIc3PzmJUBCxjLmWhTfvAYhiOXQa2CDGlxElD9QOtKX3vRElfAHOWjhBXKwr91SeMITrlWtpMAqKyRBCi+QQseLEHIqhBeJgQRvHM/whSycgQpcIEIbzYis/GbhvVi4bxSKEIVc5CIKWvCCF6JQh8EL3guGjwIWomAGQbQBE2FIhBnCIIgwNEINYQjDMhSR+cVTwQxYoAIcqNAGL2heC2bAxBw0H4Y2ZB4LcIDD5SkPh0G0QQu4N4MXtJAIKmhB87unwnixMAj5WjG72c1CEXJgCv9bOEEIvzqXC4SA4XQNkQscz0G6qu6CH2jykhv+Vyg/mSgRM4yUNlhYqi9uMRxMwcXwx8nCSVCCGe/y3pYF3VPsrZTM/v/WdM3UpinZhgzZzqeqiA188uIA5+KeHtBp8KnN3CICKAMiAOASrMACHPDKAGPMsuxp5gk2PjCdLKPLtEw1MkNrzgzNvow1vKwDNUrS7snI9GbIbBADOmDU4Goq9m+wQsfafoYrqg0smokIf+yZjnCfPAADYlA5bvAIxyICchArDNCuOOcBOkAKx2KZphALiXCZMAAGdBB0xhCZjinfUqADGK4FAsEJnEANO0AOie0rcmYq4Go8LsOijLD/LOwQC99KLAAjLBaLsUIHKzwnC70JACJABxmRB5kpAhZLLJopqXTmrpDtCqMtyNZqAzKj1wRrQY5nsJbpEAEQs/LtsZLJ3kCnxmpMKfStJ9DQlwguBQguJ0qgl1xrl0KgCWagBWbJ/uDPl3ACB6hKAULAB0xgBH4AB5pAB3hlGR3OCmpgBpIgDQxBA60gDYbgBKaxBlTgB3pAHHuACYZAB5agBEpAB4agBdTRlHBAB3RADpgxHuExtuyxBGpAB0ogBOKxXpSuGsMR5JJAB5JAXbiAIOSgBHKg6aDO6aIu6lro6WSg+6quDIBrhWZACDQSV8JOI8VuiDhSWKKPWZKo/4/aCIuSb/mSjyWzCwteEgvaAAu8gAoGryZNTwtyUie14BZ4kicToScBQSi14A2I0ijb4A3gIPdy7w3qYCnfoA2csg5wL/eUUifhQPeWUieLcitzsg6+kisNTwtqkvC84CWNQO/cqyW/oIvAwAiEQAgISQWir1zUpS6FgLcwbLf0Ui95C5M2yYQCc4TM7+gKM2HgUQfgkedmCf5yKSdEhsZ8yZhQ4MaW4sZKJhXV7SvyymciQAHIbabIots2wAK2DdZgDTD4xgEJ7aaekKqeJzigCtlGYzHwQp1Q42k4IzPI4AI8sBpMgQu4pjGqzANbo8zMrAO1KTi4gi4+japW4f8UgAkAVqEJAIAFFOAUqoGt9u+XQKcDWEAOv/MPHm4urkwOkSkDyIAMEOAPRmcK+CAGPsA6AYDFOuADhKEkTIDgfong+OALEAERZCAfR0AB5PADugA8kakDBsATkqBAgYkPmmAKWAADKNQN+CAIZAARdoCxmmkqGIsmRqAHZOAHrqAH+EAG+KAHkIlFhclFj+k7I4DFPkADcjDdalEDZkkDDC4FTMACWuAZk0AGdKAMFCD7rFMBDCvdAEMHh0xGC7RAby0SM6MJmiBK0e2YfglGz5Ox4m0K0+0DOsATrNQE5HAELsMCVpEoBoAPruEDFKAW0zQGpmDeDEuzHvRmCrH/A5y0Q6dwsLy0FPsqyDDrELNwBXYABfZUBppAGDiUrdAQmLI0/2gxAjwhDRSAFW/MFgnOB2pgB0rgU8rgC5bACubACgbgB6RgCOJODQYB4nQuYxROBr7gAiihV2RgCfxgCAwBEZZgCL7ACrigBnpAB5BgH0dAHdORCVjPBlwgDkyUCtSgCJyACnJACKjABrLAEOIACSxgHbXRBvbxC2AO5HKgBHrAVZKAFeJRH3+gDHBAXV1gCYY1HnvgB3QgB1jBBeIxDqquX3MgB+KgX+UgDoCAC7JADgC2X581B24gDqAAYIUrB6TgIoOLYouLI4XADXAl+qLvDIzoY5nlj5Ro/45SUiXBCwvQ8iWLYPBmsiapIBFidvZUTg0kIREAAQ4gQWdvARKQ4Q5+FhfuIBnuQBpI4Q5IQRTuABlKQRJKARDuYBgkQShFQRSYFhmo9hMwQSglQRSGIWllDw4kAWzhABMkQRIaoRFwthQwgRgmYRQmgRhKQRRwAReSdm6HYRY+4Wd5wREc4RM+wRFwARk0gRQ6QREk4RNiYRk6IQoWLxe8CwzgEi5/5Y8a7Fdc4AXq8gWEIAnWBV4yN3PZpZLihXTtcrci1gWqjvtcoARcYFfuVQf0UXZhS2IWs7VujsVujjHfD8Y4hmN0qRaLqcZG5LGgYrM0YC4swEsVQFQs4P/cMMvUpO01x0OjVHPbLuMBToC05oIHyGAFLsMzASAGmiAFypOtBOM08KITPZGs5CwCs+x9YfNvfGAIrJNNdwAA0sAKbCAYUMEGQu00zKAVMMEaUqE6DUMRuQYC3cnMaAOePNA17skDWIAPPAE6feA+oeAYjkEWhOES4Jd63YkHtMEKDEEGWoALqIAZOOEIUtgUWoEMOGEVdkEbtcEQqoEQjqEImMEWZOEZ2gAVGsECcEAOtyYLS4IFNAoAQIEZqkEbfGAKDAEAOAEAUsEa2IoJbxAA+MAK4kAJciAEvkAG3CAJyqAXheECdOALhGCOnKAIODcHniAHjCAHWkADLkD/AUaADDTgFHozf1khPgagCTyOrdZQHP91YoWg636gBCyAC55BB1pACNRADeKg4RRuJizAxEoYAJwRB6zgAtK0Wy8gDS5gP/mzA2hxmEygBmQAB1rAAspUA1KgBTQF4nSgB5bgBXKAhuG0fK3RCh6OBDqZDKI03dJNtCDreRmRES+rBIwAFeYAAEyAmoM3RtVQDSOVmDaLBUzgeAlO4E75lHeJJuyP/jimxW63tUgACdgZB2ZxU1X5neN5lvcTR3cJeGkCADqAmi0A4pBgP32A4GbJd8l54eCPoGcpVhXABN65BF4LolupWEvgB74gB6yg7BShChQBC2ygWofgBkLa/waOAAqAwC1vgAjMgAhuQAi8QA1yAQiEIKbB4AgiQQiqQAjOQAnicu6ygAu0Sw1gMryGmqh3zwsEYRqooAt2OgwggQqwAAxicgu2IAyKIRjWIBK0AA4AQQ80IRnGYBEs4Q1mwRGQQQ8AQQu4dhjuQGqRARPWmmuf9g5wYRk+YRmKlhSwga3fQGwBga//dhkOoWqlthGQARtEARkkgSu1oA7ggGoxARMaAQ7eAG3vABuMgReglhc2mxfeYGmdFhAsQQsAQRKG4RZuwRU2+w4cgRCQIRPuIBZi4Ra4cqsTwQsSoePUQBFiVvBsOwrca4ry6L7AIBfyQPDki430a76KgP+NMDqQ7Ihym2BcmyAJfMUNimh1AVa7y0C7J5a7X8heZWBE7TUOwtFeE8ZecUDpaqAEhCAH1PsHlkC+S9oIBAEVnEARqtUGACBg+xGWf5QJmADVbIAfJ87AcbRMH8tL829P040rWMAC4iARkmCfk/SwOgDZxmM8Roex5MIBoQoJ5+LHOnQ2p1eqpgo31qYx+AB/q+xt9EdAgiMpFEC9TYBqsqyxBuAZpgFNQwAAbhg19Lc2bBMAyEA+t2YH5oDCB8ACsEAQqKDK8pcS3KkGxNgEUIMMPMHLyOASAICGAUANgpMHqGoR06AJamAKAGAJgoB5k2ADO6AFWuDofoALHLn/CCygVC+jGqTYEFiBC6TZEHYBAKzACgAAjS9jB3a0ypQDMO6NyAYgAoThe/kgDaqMB6yBBDAgJ6ygCVhAoE+BQ+VQA5CgTDewQEegGmOAOFuDMmhDbR4QqhhLBkdnCImsLFhgBPiAa6rtNCi0QpGJoX1gAGQBEXJgCcbxX+MRYNGxBJigBNAU1SKOCZCgkYXUBJIR28NTDb3Z3rTU05ugW5GABU6pl3hAA0piBDRgDWVgF8g0tPQTRy3A0dJUP2VAPwnunVvZAmbgUt3gCxTACr4ASEvABwi+B7pAB65ADbJg2hUOCVwLFx8eoJEACeRbvs9xCIiVWFvp4e1PR1ks/+F6aZ7vT5cUzv5OfpdwtORxVOXreRZN/qBNfpfeuf4Irp1xMeEWDuYL0rUsAABGwMdbYAhKYAlwQA6M3gZsIA5CWg4I3AacIOmf/g1tgBHkwAmOwAmAgBG0QAiwIBE6gRQgARWcOheowBCmYRrCQBE0OhGCgRBooRdioRe4gRAOYRK4oRIIYQ5iIQqegRvUgAqe2goGISYFoRG0YAvwgKrNAA4agWodXxSylmolQRNEoRM0oatRoQraYKo1j2wd/w4gWxEEgWwxofEx4RckGw6C4ROAIbDr+hA+YRjqNrRJG7GRgRcSuw7QeguAARMYO60BIRh+QYB/QQu0lmkbQf8SOkEU/PYTcOETZmEWYAEXDoEb3HYUuGHuJ2ESeiH2CaEYDgEXhmEZiqEXeoEY5iD0Al8RWI8K5kAQ1GDwoiAWiOERvEDsNYEWuMH8AYKWIz23Okk7SIrUI0ikEjmkAklRojC2bMGJssULlSxbcg2icmaLLC6silDBokRIjpU5yrgoo8IlS5guVkqBou3YjSs5ZMj48SMH0B8y4vTQYSNEEVRznByhYuSLkB9SZCxBMgJJiRJLto7Y6uOHDh1UhOjw0cJCCQ0aUrAwwZZEiRYhcPzAoSPNjBZykiB9EqKFjSEAALQoYcFwiBQRGiso80WBBQ0RLCiI8IDHig0PODv/3iFjyoPCLABoM9QkzYABCiAUKLAawobVtFfDpj1bgYIUU5D0cMMkhA7LCopwcXKCy4wRiDwpwKAgdmEAlx1vmD2gcG3YEGg/yA5+ehI1H6Z/jz4dwGr1AFZc25Fe/fpLaQpbmWMFwAUuIdKwqp9YYaMBgIKAtHmwmgLqYTDbdF8IQ10HcPnQRA2sFYagAhtol2BtCb4223XR6SZZBx1oUAMffIyggW4d9CCDG+WtN0AAB9qGQQEeFKDhAF/MUQQmasSiSGIWjOBCNXFAkYMVX1hA1xBEdFHYHGHcsMkxnDSyhUiDcAIFElBAcUYbOQxxxBIttDDEEEw8ccUVFljw/yYQcDSCByC31IEHHpGIkkgIVDDDBBI9IaZMfWyxNcIHLJiogYlvmWjCByOMMJwbZtSAhA4mDLAKKyHUABQUJTDBGhNLfGWCDyW0asIIFH5xARNfcIEFFElZEAKULSChYFpMFFrCSld0usQScQghxBVFCHEDFJuAkQU1gkSyyQ03SCFEF0JUdcUTQXCxSghL+ARjEDJIMYMOV8nAihsm4GBCB2uxtVYJU9TgwnI1jIUppmP1AFRNOZRgwwusyFAoDljhgMOlISiwSxIt9MDFBSEMMQcrc6ohCABzcREGF4II0ksv1HQC8p0aJXXEEUWoUQUqjkACxCZnHGGDDTdsnP/DEUMwGQIXhsiShgpNKD1DEl+kYQURa6wRxkVJFPFC1l98kUQWRRBCDTCKeJ2E00lYYUU1YTCjDTOgUALKNVKcQYQSRiCShRVZZEEFF2ZQYQUVgpscRhtmRBNNGIb8wswxx0RDBRAmDWLGL2EQ0cYWfeKxBhBHZDLMJ4d8Aswes8yCiyTDDKPFFlW0EYYZdeSxRp9mEDONlZgIogUg0OCxBSBRPILMI3nU8UYej3ihRRtRWGLJIo9EoUceeliSRxTaG5GIGkUUgYURRmDBxTFz9K0GIZpoEQUkncQCiR5eJKKJIqg8Q4ggiUShUSLBzP+IQPRhDIG4hftQIYhmqMH/CVFIxCOqkAdIxIIaKROIJmoBCDhIAhjPUAMYmCWFlZSBSVK4yRzURwhUlKIKfQhEFdaQCzAYwQwfFET4ikAEIRAhB1IYoQu4UAQlUCEHT+hBD2pAsB/U4F84cIEUfoCEuLSFBBaYwQ2SEoIRGOJJKegAY0wQgQ40ZoyMEaOkiKOAFqSnAyWSTAQ2pJ4HRGdHHtgAbL7DHQ/oEQJ67KMHIDAdFrBgAwzaEY+6M4DbxGYADyhAjnaUSNxEZzUb0JCCzpYII5yFCkkAQBOmUyNQxic92QEACVZAyuzEoAkwKGUTLrAmBZjACiRQj24AIIgwUEENOVBDEwZgAgXMYQ4A/3CBDI5QBUJQAQBFgF8sAuEzHfRKMikAwC7mEKDV1IAKF6DND1TwAwD4xwKsiU5jAEAJYk4yQc9ZJ3SiUxoAYGBAGGCNFfhQmBDYYheFYcUxupCaEZxoBGWQQRD88AcxYMAHI5BBF3ggn9dEEjYU5cwDLnrLAYTgJ0sYwg3EZwUoUMELkiNEJxgRAizsLwqK0IIQmGSFQawBC4RQBMiCEQtUoEIPkCCELUzBCioQIhFniB0xjkEEMzyDGJjAhCHMUDJDrEI1nAiDDzixCgUs4Qr56oAF1uUDy1imA4WJgH2sAQB3MaEEP+CCxVKgARaV4Gw2kMMXfhaBEoxAQXTSgP8FTBQBtnQAAyYiLGHFaILEXiAJxjRiD8qwBlvIYlha0QASkJCscLXpBlu4hcqkUIVEKAIQa1gEKiZBCDxEYQ1QyAKzsnADOAjiBSEoVAvugwgbmGwOShGEGhhhAzV84TBMeMEXTPCDHgilB2zVARLUeBgAWGAIT0hKHIbQAiZcoQdXWUIIWPGkxKbABFspgUaD464l6GAtJEjBCgSpgXP9oLxdNEEIftCEEqRALotqC1w0UAIStFcDJNBAE1jxgSmcQgUMvZRYWuDcgBmRKi8YBBeIsAkifMQMRTgDF2wxBy4ME4hKGESIsbA3K3xPCS/IgiyUUAYpPKEMLDnTDeL/EIccCCEEIbDBEYTQsxs8CwtmIAInpmGLV0wjc1GogyLacAYpfGEjNyicJpCBB2kkwxW0QIUmpKEJSPRBE59oHyQSAQdRAMISkEhGMmABi9MdYhZxpvMe9iAQWByiGL3YczGocYhDmG7OszAdLByxh2zs2RF0xkUybqGHPkADI1ggckzzVmm+FUHFV/ve1YywCaq9gX/Mq4P2oFGFVDcwDFiIghGEoIQivBoIL51WJCKRhzCE4hGa0IM0DtELTTxCDwvBwhqksAUi3OAJnD3DDTCXBSxs4Qzi6kHWgtACOPlhCHGqQQgAcIovCEwHX4lYgft7L7iqOwICdi9j3u0W/8aMsTFdjLcZuxgBeTdGjPJOgQXCaCIzBhywbNQNBuaJAQgc/AHQYUEQurCJLhnODFsIwi+4YQZOUEmcLLgQAFzDx8JU4xIAEIMwVnHwPwYgAACIgIdIqR6WN+GT05nCD+aUgh/YAAgmSA/LUbkeUAadQ6MsenxKaXTtFN1D4UH6KJnOnvQAsjCGeEYIBKEIWlDDEY5ws0CkQY1OAoAk0jXjcyKAAuhc4AJyvM4DIvAcQfpADGIIgh380F8x+EADB6f7COzQhS7YQT2YIVFtEPSAFWDgnCT4CQ4URJ201As8klm4YxTQAR+gJbEhQEJtEwuFJcRKsD4oAx/gUmAkmv/gBnOgBAASeyIfOFENc2hBEiCkgQ8Ek6wtwIF+vTpYoDOcRApggYLEeHAFeAA60DkPHxl+8MEivJADqCfDCXmZizJo+wyH++K/34EHDLwDLKgQ5llwggkMwFEamIIMqnEiP1yKBSxiixj+4IfLAssPmt+7BvwgGVfwf3+ABCzQf7YiA4mVBYWzGCHgV/ZlP5DgBUUABEPwV2mBgSHQLpZhAmr0b3DXBDiwC9YwABZgAj3gA5KRWHNSAmFlX+NDayWwGHSCBZAACJHgUTkgByrxajYwLGoUAlwRAk8jSz7wKZzACmWABBaALCawBMyVAzbwBHIQB0dwA3hAEKVwC43/cAdceAeA0AmfgAfIYwmRUAdnkANBwCQvcDQiBRIvEEJQ4AJJYAR8gwhOwDdSACMyoFwyAAUyIBQ9AQUqEQdPwAVfwBMhRGtC4AROIGtB9AVbMAhZQARQEHhEIAVx0AVUUAYwki41pmNEsA2tYAqcYAaNIAqdAAhaAAmBQBfMBgVVeARg4AVR8D7JkBDJsAeqwHWOIBCOkIukUAvJoAma4AifMAyaQAuBdgjLQAu0QAixEAufQAifsAzE8FOmYAraMEzK0I1cADjfQwRcwAlGAAVgEwp60AmdgBG5ABVE8CxRFkIhtBLMkgiigAyfMAmjMArUUAu6UAuksAc34wSo//AJfaAHtKAJUWCMA/EI3EAMisCFa1AHxFAMd6AFNkAFYRAHNGYDTrJdMvArV0FuWREwl7IWNSAD6zUcaVUCpAIwAaYBF9AELAJXdmEwgbEVDpgC+hWE5FUCEMNjWrEVQ5AscmADQuBbMXMFUJBDNhAMxyBLSBAEVVmVT1AJzxAEGgYFPhAEZuAGXukG0fBTPpAKnFB2U0AGqOQBLOcJdAAAHgAAAQAKsgAAPvAAfwRIIxeXGEAaLAADGIAgSOd0SWeYh4mYMHd0osQe4OGY8vGY4RF1TieZTdd0jVkb77R8HbAEm+AEcGKBlbdOCpB433FwhjEDrDADZzAIW9AGbf9wDK3wC4PQBXqHdw8HBdoSLV1Qlc7QBXw3WAoyACxAAtlhgimAAnA3ADkABDuXC2vABDbwA2HQC6igBceYBzMDDUCAeQMAA2l1DIzgBI4wOqVwaNVjCW/wBjawJjfgXdSxXiVggRbgf6zCFV0kfZhXcORnAtEHd25ULFRwBGkRAYsXfuEXAY/CAm83GivwAQV6cBHwAZTAA88xT+F3cPEkIB6gfQMQAddAcoTEGfMUHTFQA5gXTNqgDCBwIo+CAfE0AoUxBRpQGgMwAvKnIP01AHElXUhwCqsAALKgDbIACn5wBXwgC4HXBR1wBWsgQ1gAO0FwLEigeW/BApQRWCj/oG5uQQL51hgskKCWQVgfUAO2Vx8KoAE78G8bQEYpMAIhsAuUYF5+pZ8lMBY4wEb5RikhMAdfkANBpQZAcAPTiQqQkAQh4AKCczKJwJ5QlRQaYAIWsAM1YAFfUAMd8BUtQAVzYARFkAUvoARlUwSC4FYq5gJPeBQ/IASKAGna4wVrYARwMAhnsDeDgIhPsBJomAW+JT5boAayGgbR0AaIwAxmIATkQwRPQJVQ8ASDEAyYEAaNIAi5sDVEBCdQIAXP9iWHUwnTEA3T0AicUAnMgAicgFVswwmEQAgh1gbR0AiYAAySgAyRcANLmEZpkQTAYXd8UAaBZ0xBQatgoARc/yAER+AE2ngCZaMSK2EDc1gTG/MDNfECKsAxKSQITnAM/DgKhMANGuux/GgLvpUIXKAFiQAMavYGtRgIEZEHmHAImPALkMANc3ADnNAKtgAGa8AJ3GAKN7AGzFAMXFAFosANxUAKb6YQVXALkpAHb1AKmYANwyAJXbIJg9AIcPAGkiAJcAAIq/gGeAAH0UAERIAIXXAGZyAEyWa2QnAGuXkDXUAEQYCq3JV/MoAIADAHthAGc2ADTmCUUkCplLF4+4ZZyXIEcnBjccCeujEbBQAAq7QDXxAckxsHQAAGeXALY6AHm7sIVQAEcnAEPKYqW6UtYHADQ2AD0gVga2Fu6v8RBEiACGZwIgpABvyUmKPEcisHANdQDYWhDa/gCQBwCW4wHStABoV5u8mrvMu7dKJUmYpZSoSpmJDJdKuRIeIHdw8Api9qfwp1mnTnAXRXGN7rlVvZCK1QDJWwCZUwCfsICnUXBJoHBYMQDbH5Cxr2cLw5AD4wduoaBVBAd3FlBxZCCbtwCtGQpFWpeX6gwP0XTC4wTNpAvKxhBpjQZHOgBniQBzvnBTfgRvMVqdI3AjUwAmcyXSRgX0+wLE/Awk/gXU+gBjRjuVEoVC2QA14ACY/QCVkgB8DSfCwAfvtGf5HypbpBCRMAADDQffRHBk3QIu2knIWlG51RSdjXGGz/OiLQ1wGsMSdsRB1/VShM4AOPonlswX97NwJVyQc+4QcbVQZNwIc+cAVu0FCIEA3MQAQnclm7sAtAAAmbkFwDMANc4AZWwAqIoATTUB/BVAKeN4SUoAQz4ID5piCMAaYpgKYX0AP1AlheOm/0pqdhFEb+Zhc6kAP+5iIKcCloRCfTlAJWoAOskR2RuwMXcKkNNQKRWhl/5cVeRQKUkB8mgJ8dwAcX4Cs6IBbu0sivogE9MAM5UGVcAAA3oANggAW5ULJbkBYdIAVYoAiRQAVfEBiFoSCqLMdSCi98oAFuQATLYAtEgAH99Qd/AANsgQGnAAoYYAjaQAkWsF1FVAZE/7AKg4AIiFANbrMKXWAGgzC2zYNt1BUCV3ADaliVRooEDCwGd1l3gRcEdGeVa1CJQTAIifAMWHAFcRCxLqAEaiAN0qgGsxhENqAM1hACcgAUd4rMOJADLqACfesFhCANtaAJwEAIXUZBwSYNpAALyVALe6ALycB1j7AIbwANyIALxdAMh8B1ffYJs3AItJAyzUANt3AImsBnWnAIsRAMvdAJoXAIzTAG1DAMpWAJvFAKd70GWiA7UHsLQKAIwOAEQGAJn0DYUhsG7UsNzdAMKRMLtwCN6tgMqJVC2PQFM1AY0PEhq5F4wnsJ9HEN9ZEdlNAMtiAEQyALn6QAFBUAiv9EG9Tb2shrA1GACZEtDaHgtzFqA2A4DFUga0OwxetEI+FhIyzHvMtL3MVd3MjLIZLJmNG7mEpnmbiBAmzxb7IMAAMyIIWBAkngBahgBM2ZA/BRgr1iA9mBAqxB3YiQBroxJzXgBkFQB6LDCcFADMEQDZiwDJVA39FwJ5WACdGAB3dQDPw4CcsgCZ9QDMsQCT6AAV1gX1vVr0oKt3ELBVUZKRrAB7oxBYXxATwwGspgCvLklQEdBOY6CLIgC9PACWSAAWKgA/2lAWKAAjAQA3ywMO6X0X7QBT0AqUuQN0CQBWfAAv82Gj6QBZKbAuOFFV5sBTLwKAF3cJDaBMIATI//chm8gskjrBvUzd4SUlsawAQjgIJLwCga4AOQkuQpkAPgYwbZpQPjZwGmfBb14ivmUtozwwVcYAEqwAVRYAYu0AJAoJBpEge6+QRSQASn4io+EALHwAwhsCTuGQKF7AJAJimQ8pL9MgM/EAImoAK7cHqXkqCLggPUZQGGYAgAsAqGEIQjMANTVgQ10QIagANPIDQmQKVIwATtGQRlsAQ+kAKusl0VfixnTin29QVNECUh8AJFIIW/gghE4AJhwDue+wRrsAV1kO1bcAPJNwAbQALGt+UsggRUkQMzMA3PgJZbyZsc3QVBzgQ3IdG6qUYAoF1X4AMMrO9+wO9I0AHL/xoE2jImanwKf1AYzhCWQcAHdtcDLFAoDEyVPYDv5XsDZoAHEacFm8Dv9ueVzhAEbsAFJSjG/meERtgWkIrrp9IW48UVb9KURhAGxxAMglAFWLIGm1AHoiAKwbAMmCAKmCAJ6qlBWxAJYzvhg8DQbvACNJZcK+FEUpAELwAxpsxDnyoEVKAEQ/ACm14DZLp2J3ACtnwBJXADQjAH1nAEFtC3SsAIN5ADIWAFz9BJCnAsgOEEcbAE4tmIobA/jSgH8ln2hZJeADMCOHAVb4IE4lIGu8AMyh6EyYJjOQAFnVMFFEQKYOcI1EANpKALeLYHpKAIpDAGhVAIn18LTvBXcP+HRpHE3B9XGK+hHo4bdY0JAI4r+7KfdK1fG5AJ3VB3CqBNIwLiCU2gDUhcGMftC2QwddMBAd9ZdJ5wCdtYGK+QCiwHAZSAVgBABiRnmGDfvDzgHNA9HWRQH/JRGdRxASqAdBOgBi5ATrKfHZpRGNZwCtQbdRZACPjDBcKpGwAxQIECDSNKLJFjwwaAEiYGbAAQUeIUGAAKABgw4IECADzSnIhow5atiBkhbFgQYcGGPyMA0JEYE8LMmCX5NCFziYwviR8w1AQakQ+oLxiNBo35YMXSABFifGhCCRGiXdqeyfITZASfMiPsXHFz6oqMK3zc1FCAiNKWOsNu2WBiYsj/EyhRJCEDsqQHDg0afLCwkmVOMy4AfOTAUuoTLS8Angjp9EiPKk24joB5VEoRJEVeomhy9AgMEDDQoI3ZA4vUo1uOYO2p4oQRLVq8Sq0BosXLI2S9Dt3JcyPEGUmYwADowASJiR43zHBRIDDmhoECFbRwYSVHixQrLKRo0uSDiyU5shTxAcBNGC2NRN0qBQjMEShLNkmCk8vMmYEYog+sTgHqFHAjByCKCKEEBWuQYQkZiPgihx5kkOEHT8gggwYaMKTBjhpG+GCEHvQqo4wuiCDCilcmecUWUxIhYgsihMjljTfquEUQIixA4gkfbcCkkz6cgGuIIZDwAQkZzsDk/5BkhiklklxyWWOLZZbBZI0uuJAlh4jKIOKGTW4I4okjbljjBhTDVLOOMDfZoo0tWnlGkS0MaUYUUYDpJZg2yujhCjMGiXMLKLq4YZBBuhjEkDagCGKJJtJoIYxnGomGGUyi4eIYOlMxpIsgNKihDESOkcUEJMoKIohBGnGPmFa4+eSTYbCZBZhMANnihhNzISKKMG55AxBo6qjjDWhyiSQKSMwAYovN1JAGEi9QiQKPPPAQRBAhDGnhMiecSMiGMIiJ5RNqqEEljEUsKeUOUTDBBBhMRDmkGChCAEKNOeRwYogSbEBiiSVKCIE7H0yYtIkfQoD4kiZCACEFi01Rpv+BCU5oQBlKEmiggRMuOWGCNGxhxQpDfrCBESAiWaSKKgIBIxEh5suhiBe+GIIKIm24zIgbrhiiBQvOWAaYNaLpZQs4wkhQhx4asqADJAp+QiEnsCBEDSNsaWaSTsbQBZZemtEkGWo0CcWGKKjBQgEXpqguowEwCqAkAPI+Cim/9f47cMEHJ7xwwwv3JI0OYgDKClMMielujAp4AKO7L+9boowyPxypSV0Cyu6/JRec9AF04rxz1S/HfPTBN7d7c8szKiD22KOLXe/WAWcddtszUiBJVWUoIQIMOuggguRT0ID5EnBQ8Im4rkCiAxNSKMGCNExJw4UirKBCjWmeMWX/klFs0YaKEIKZ4woAAoSqCRlIVSENUCjB8JQkLHjBCy+0iEIesBAFUuwhGcmoRSDykAdL2CgPN4pEspCVhwjWAQ8RfOAd3hANLdxATTHqgjMkZAUyDAADGIjACkgQAQVEgAQiCgILgheEG2xhDWEgxBxs0IMn1GEWZgDAKbKgpi+sghKgAEUqQKETDdGBBA5IwQV+gAQNdGAKI+gACTTQAg0oqHgRUN4ALDCCFLDwPxGBABpNVxLSRW52CoDAAx4QgTnWkQUo+IAMdKADHLQgBDnz0gc+oIMfcIQLymCj6QYQgEVGpHa/G4ALo4OCBzyEBAOACgnqJpANbKADA+nA/wbMaEIAKcADCiDBB4wHIABMoQl8sAALLBCRMppRQKzEiAI+QAILDMg/CigBGKIADS8IwQYDM5INclCGhuAgBIK0wAUuEAGLgQAHJCiBEpJggxb40VxzoEQ4WXGJC4CsCWcIBjdiMYbYxGFgFEuBAizgghwIwQUlAAAXuMAdiznAASIIQAJEMIGNlWygIpBAA0TQgIQaQJQDQQE1bWAFNYCBmyEAwGCogBwm2MB/EskCe/JgBmag6Qg2uMFoQrCEFhjFAgPowAh+0AIbQIERVQCDZ6LACCdQgxuOSOAc1HADIwhioxYAYwQ28MgBPLIAjERKG1U3VapW1apXnapUff9Hu6ZmxAMXSR3hZBfVAUCgABgoK0eaahTM7U4ilbOABaITALDWJG98K1zvHLk3v/UuI1C9q0VqZxQIgLEDaE2OCWKJAQ0w1gIySMMIcAcAX5DBkdGBgCn/k7vZHUVyouPsKkBhBhlgxD8RqAERzAAHQjWiEm2oBiJYwQVCmKIIVBgEFS71jGYQAhO/CEEQiOAGGbAwkbgDHoCUByC7BUg9sohGIzABBy24CQqQ6gESjPcAFD6AOrE7a+x+ebyq+YUPGhBIBEZAiRr0qA2HkAQwgLGMiCjAP4e9XXM5ogzIRUeuA4kr8ljgAx8MgAV/4IEPbmCDJ/BBGJdIwzV04gn/GeTgBUbI6RnuBpHwGNgCVkhDPucwrhJItoUgYKHtZsdZ3emVdZbrG+mUsYtcbm6TsINxK11whcnuLW9PXaRUgYJXzx73P6Vs4SwtRtMPWGAjA8JkiBXwyU0CIAmGSEILlPuBeEank8nl5CxTh8oIDKAFOECBQFBAAhCQoQkXmMAFTlCDFFxuIIET0EMK0EkFTKAJLqAYCiLayaUSegGHPrQBHBAyjVHiFaaIgUAXGjIJVNoADl1JRJZagAIICAAOqFxNBMLpwQpZIihYgN2cGmS2QlLVXPXr7/B2OSKvDqu3xnWuxSqRugoOBjtxY1cBwAxQzM4DpAMrDr5whiDg/4AFINjIFbBQhBxAQY/RcZ2pMfcAHphAA2XWXOkkgqE09lUp/qEd5WDAAhjUzgMAeDe8PXBsth4bubmL3bFFFxErcMIIW1gI7pgaOxaIQXYP8MADWBABFhz2hJj8AABasARSlRl4GdnAHGvwETnq27SeiPgAPEDHAKHVbt39rH5PLselyDHjwEuBC5RgBCAMwQIm+KTtVs3WpAC5yK1rbgRA8IGNJLduAIppDSakAQBlfCMARqoJWjCDJLzPbqiNqw4M8gMdLOEJSLLAL0F5tw5EZIx9+ZCJvsCFFGjFYiEoghBCIFfppC4CEjEEJUInERv84H3ozcguSFAT7krkBf8XiAgPKBFizdmNAtJJAyUiMKmXCgTHpHMADyJCgnq6E8dRBT3Px+q7zR5Znv+1fHRqN/CL76AoaK3deOKJ1BDUQAeV7/QmmbriWLv6d6tmau0UULu8jcAFccgBDurMXPCulfWTKwABCsCABTC00tdnqAFWwuc9c7rQ3x1+pwvNaT13es/U2cBDLN9VV7ca6GwEMvsfkuqf847nboxIre2va7u+bnJh5asA5D9cCwD9c6PCCjWJ4BvagbdqWAXA4QNP2CuLGKu8CrcLxD/W4YhsA72LaKtwU4AEtIi/WQA+MANE2Dshg4BVkAUxsCqNYKPAWaPPApzQcbWjW7/LC7b//PK9v7obDwQ6twq3tmqkRoqxzvIrAbEl/7iv5Sol6kCh5BG7/0Ae6/GBOMiFPKgCPJCZC4qEL4QCOYiDOLgBKPCDefMADBCDhbMljRCPKTssJBsAMrikgfgu24GIiJA5zQmQLpKcAFiBNrIxpIoAuisJ7wMAfvECLHijI/slgaA7ALuOEGACABmskrCv6gAAHJAB5CsBXUqxfeudzYKkFaOpFggfzakchfCmlmGEEBgAG4CYPDCGMVAAFfACLZQZIACCI5ADLdADPViI9/kvhbCnlsId1OIlxdqADxiIDziBEkiBl8KdNfuy5kqBEJhGeTIajggBG1AAITACG7CO/1KyPAuAGIiRJ2m8N+uwHhOAmJayDgtoKX0qibj6r7jawBawMwBQg2ZQBDPjRsVqpS+AiYiAGOvpgIUBgBewBTUgxidcKtAyx+pAgQtAgQBBsna0mzxMP+vIQU7zLM5indXbt9GBgXLbO4xIMwC4hFdogpUUwtD5sQVIIyKjQaB4pL0xNV7zSQCMiQVgqweoiBoEgAUIxFmLCGFIgynIv70qgHjjybzJyc+DgB/7nRaSiGmUOF/Usp4MCtJhADKogFpbI896RFJcMaMUsgAQgASASwbQG6jKHEq4hCETPdFTsfbjHIw7nggoiOy6gjPwAmQBBBvBBl7gBWzIhFIoBf8ssAJZ/EpS/EBF2sH3mawYYDzdiRw0xAB6E7X8sp4Z+AKLMz0kA4Ad2AUXQAu56gB8bAGp68a4AoCqgccjcII+CIRAOIIzAYI8GINMsIQqGIIQMAETkLgS6M080ANa6AVSGANSoIVQ6APJwAZV2ANVKIRsKITuVIXvdAVXyIRFwIOXCcY+gARp0AVjMIZsyAZjuINk6ANRSARGuIEhWDAr0KEjqLwBKIEXwCcAcIEo6INdvIECg7VYAyWoq44vAxB8vJ0AsQCgeZle5LeY1McbFIgOKAGpQYLnkYIv6IEby7E00AYpYy4FWIH6ai4WxTbY0UoZKAIbiAVC4KaFcBv/PXCCKmAEu7mBR5AGUjCGPnCFQjCgUEgGWnCEPXAETTiEJc0GVYAFR3ANR1AFXXCEW3AC/gQAJVCEW9jNPjAGKt2DtrGB1/wPE8iBEhCy2NxA3HmpKOCFQpiFT9gEJUDOEAADIlkC5HyfFFiOfFSsT8JMoACmEjCaqimlmlCAJbgBIHCCJxgCEASCKriBg8EoAFAeBUEC7CAEVnAM4eDIh4iISsrKDRsI7EmBT3IlLWMpuJC6mwGDPiDHcZFFwNyAsBuAFHicUq0GkNArKwgDJ1CAHHgGL+E9GHsxRwKeF8CY2tzL93lH2TTEyJlHpEKq2CyBH+gB3rm4MksCOYDF/5MUQL1xASqQA96LVokIJ6oig2twSsthpLKSStcZyQ0gARygO+C5O6ubJbkiHAPsKxkEy1azHA/UgCTAgiNoAVZghhQMHUoSJTSVNd+7JeqIKxOQgxygghdImBDQAYRhgiVggjSUN3gjMDGwr7v5AGXwBBOQAjggBohsATCwKCFIBCoYArmTpw64mx5TJOZrrhi4gFAjydl5uClggeNBAigIEzm4AsXCgP9K1bhqAR+gWm4MgScol5YBAzXwGbgIgRHAgZt5BFJohl6IAhs4ThNw1CGwgVwYA7KphZgBAjyQ0lrsg0yIDSeY20CoRT0Yg0V4hMKMgjGJgytAE3jhhv9RAIY9mIVZwIVPWIZDwIUrDYW2cYJAKARdUJteACpdMKA9MAYAsAEnqFRoiIIq6MXeBAJoiA0daIFPujs14AZaAEcFaAIriEFKmAOjmFdaYsc8vJsISJkjYIQ1lYMuuzjJiQAdgNtZMgXehVZ8Uyvf6YCnywgRxMCaeF4qUB8FmIIckMMWSgEbAINFgIROUKt74wIsCIRImJkxKIVFCAS43dE8iJnlfINFGM8CZYQjKM7iDAEjEZjeNJMn4EfNoTLZ+QEXMBrNSSM6cABRS527upzBuoEjkA6tMgoPiCj1QgJEMAMiYIIeYLY2aIMgYA4fmCwNvLwUOAFpcgEVyIH/HFCB3M1BsKxMkRuIELBhkP2BHPiBEqgi43kxvQKKVrSBIQACG3iGaWiBKHiEzH0EJwgFXnyCe0uku3m3d1NJs1JWQbScB9CADxDKDUABfcQdbBudFGCCeOzGCqyvqpnd40zHIWACMWMjJEshfeNiAKCEZjACjVw/5GpHoIS3DCADlVTkwKoJHrCsXTsc0lmBogyKBUiDNEiAztGGa+icCiSDObjLu+EfcKQ3qYQdsPpBOnDkRKovEuCj/ozQXF2CEFADGwWCTZg7ExjZJRiCI9CCaICDNiCCSMADIggCdU25n+TMqvRWdfUEEjgh+yrV3EGBGKgcEwIAMpgBFtAA/2lSENO9goXBOeuJ444qAkggBUjIgyNAGMWaMg2wVmrKVxIoIzmKwuTJRP8AgDRQhmogTFToBGSIBU3og1pYl1hwhGaIBUVY3SrwAiOQBSQChW1IolSYhlRIBURIhVfgaJAeBEvIhDs4hko4Bo5WIouuCBtoAy4gApo6XUIISPTtxVlyASmQqxQgAbmYOxwghCJogSFwiAitG4z4yEhSy+1NPwUoo3190SMUKxos2KuSnQ/sy+vophbYo6pJv1IDgGqwhlxy6hKoREwURXP8nbvCyfuD2JwcHL4RWMKRo5oYARkoMJOrOwusZCQMSwU4XSFgBGMqAZdhXdIYjfuUq/+7YwT9tYRN2NJN0ANsGANX0AVS6AVpGINQYASX4akoIFCGzVqnbizZ+eJ6jQipXEDLmYIUSAIh4GocwAHA3Fepcmo5ljoTQDOOYCQNSKaEfKkahESpo0SFMOAhQAgbmMYClhlC6AUvcIJbAIOE2UD2A4BdKIwgpB3KJNdfqIQg+oVWAAVPAOWCCAIaWYZKyAJimIZfsAMAmAmwIoODlImUfIAAeAAxFjWx07a+lIhpMIVSdcom4IKI8z8ZjIgI+AAVKC3q+IBVuIBT1cFnrjEAaIJd4OMVgADQGkW49kA3ogRtAIAP4IIZgOrTAwBBsFEmiE3kqe0ebObL68EVg4j/cjyeVU0BE8ge5KiaAUMCE4ECH4GCoUHuKwCCNbCRNHmZLYiEM8iFMxACKLAnruNWHUDTjQQj7wIjjAUjbFUehuuLhaukEGQBHB8wFjABAmMCH+iiLlKQLmpbBTmDYyaGY/ACKIDbJyCClP6FY/gFG7GETI2JFhLEGbRgOp4d4QMQJgwQFRvARy/XsCSdDWw82bGGse7eAASrszIBoLGB//LlBCnqgQUAUcLMFmAC2c2hAFDrqqZqt4b0WFcdFuiBQImDM4iCXGBdM6nURQCCb+zNzWUEOQgEaHiEMQiET58BQYiCQDh2TSAGVHiE6kwG7OwFWtBRBZALSYCSULiF/8zohFh4AqtbVrgOMrp65ajaySD7wcGxhcKYrB4QAgGWZwS3VsvR9jwW4N7sTYWIAyGgghkdl1rIzluYhF7YTUq3YBuccUTHP1nPdFubyQMHihWwBgmMiBVIg12KgUuSI6G9mxCwhTnAq6q+BL2L+LyUcaZCrhVT1IGQupxagyNYgzWIhDzADV7sg9aVVCboKD32ARe/8iqsQiY4AhUIg3EM+g6QgREw2gc9Th/w+SHIgiywAS2ABNT1IOmpoWRphUkwg0awBDgABkvAg7O3hAY6TDwoFguq+bOPhkpohVMAAAygkA7IAkOAgi9YBmY4k0fdBDBIlmGChi8EgxtZBP9AAAQ9CE9XwAMPkmwbyfVNwAMt4IZlYISBGNk1LzsB6bTRW7Hr0C0joMbYdAiNvDc03YgcV/i4VsCnhPjYh31J35w4kFNdUIUqkAgFAGcSIAGf1dT60sMckCrvm6UWONtHcPZHGMbJeoBrWFEapG2q3SqwoqumGj4KtxvwaLLjrDLZB3/BoZyNqCQAWIItQAZeiFzmt4Fv6wBukjjgD4oVSALPEIWz0YQxkI0QoAKAMHUCwIAmngAoUGGKEoAWFhRAHCCRIACKFS9ixDjCjTA3zjxkJPjBBY4QIU8SLFBgAIAmKn5YsLAhAsaJNlmihJjihYsQEhWUkAMECJYoY/T/qILlSJENiwostIgKcQiQKFVOPogBA6OFigokgg0L1iLKsmbPnmSpFi1bT74wOnhwFmdFlj7EYFyxYi7ZjGtx0iX4k2aaOQAwIFaw4euAAmgHKGhh4smNyjfW4KkCpEqkPJY+Z8L2CRc2XYVOF8p2+hA3bsWKHYKtawysTn2Q1QkRRAxjBQBqvJo0atKkSqsydkDyZIiNXGcs2BhyxMkRRoH6YMfuKtOiTN4zOXHCi9ceXLNwld+jfs+dYcC24MlzI9io4a9avXpVKX+lQZWeDULIJMQ0QggxXTBxRWXL3bBZH8BwE4Zm2NwByye0FONaMZ084gg1h9CiCBY22BCC/0OMQbZBRXIJpthXdakl1gAWlDBECEwsYYICKZSAhI4QMcaWkEMSWaSRIRUAQQAXLQlAk09eNFEEFgxxhheNCEJFHEey9VQIUNG1lkU4saLGJkO0MECaOIDRlFdh9SXkX5ABMIctZQHGpZ57ogVBRRsMEIBjUVbEQxpckDhUJGBsEgcJFsBJUWASYeAXZBaUxJgFIeTQQl16ToQnl0vGSNaOIaCaaqomsJpqdA06AQQ0JVIRSyLh4ZqDIJrcoscjUZgEWQguwASpRDDQsJVZaq0kY6mh8hlttDexpIAHGPhGBiV0jNnXAxnE4IC0AAwqpwIPRKCACUBEMtQaQDDRAv8TMkihBTKZ4AHEIvKFwGoJJSyxRINArBHJImM44oguruiSzR7ZQFwIL6NZOMshs8Byh3mwcAzLLLPsMUYklmiR4TDDHILJDQD44EMEKWjQgQkahOCDDlcw1sEPPVjwBBeJUKGGIcook8gjeowxxiPYjOFK06jN8hpshxziscWw0QKy1R9jIgrVKd+BzRuA5HJDHbeUgk1okkhSiiJ3JMLoEUdEscYbeXiGyTKNLIzHEUw8AcQNkoVgQ1QmbBqHHCaaGFOPJXQAUQc2wXjTU5G/uKykbDU5ruefgx666NVaIDAQY9ACiRNedApVC0FW5IGyIcEAQ2CiximXAjVI9ID/imKKHvxjgFHFS8JVHOFQVzx48sBYgX6aFg446GBEm1hokQcjhZfQVU2fPkAGD3pSYg1C0LJ1+2Nfsa9ABx1AhaMFVNAiTSB6zGZMLbUk5cgehRwlFGMwxlEC4Smy5OkxwltgRdSgAgQWSlzRC8lPniI5DHTABwCYRitEcL6KYEADJvgJS1zwAhhB5CGhAstTbKAIKthACE5owY261wLDFW4IVLlB4KIAiDccYQiBAwIe+rCIPtxiGJ+IRSx60QtSKEIQouCFJe7wiTt0AhCMAgIY9LCHQwzjDsnQTBXysIhF4MESxlijxnABjGGIAg5vgEMpJPGGSOAxElVIAiWu/0GGCiyAfdAxAhL80gEmpBAxYtCgB1hggn4xIZKSDEEYjBACKGwiCEOAQi6McAYpVCYHnGhEI37xBQBoQRRbWEMIiGIVPeCBEU5YxB1iAwxeaAwTpJTEycLIC10YgxT7woNlKCMEKCzoCUyoASW0kQpKXIJQlYNMRH4yk5gMAFAoUh8DzdK5boIznOI8C5QwkopULDIIRIjEGoJwBDNGgRTa815IQJIRew5gBXSYwgLosIJBcfMiEPDTYwg6zm7+ZYLRo8M1oqnAtEhkUJkLk0B9EVC+RO+i0vxUs9BXloZqzknfDB1dyvUp4E1qSEVIhA2cwAhGGE59A3gABoCHEf9hzGEgMBLMN2N0qZh0oHAhqEwaXXGHO1SiErZ4hTYgga8+4CFfNzhCZea2HAXx8AlaXcLcgDA35hRODUUoUXRaKYQhAMAQtjAFQnqgBCbE5CFyfQjsQsKCEbDANxXhAjDgENUghMA3fNhCHbiTCVccoSJVwIUjOLaHhVkisc47iT0BgM+fAGAX1eAEM1bBCUO0IRiViEbXgNEKYrSiFdxohXBaYQZARCIIXoHZjW4kxK7ooAY+0GtGnDGIIFQ2Suh6AIoiMIIDomUJUFiCjfwVByFUARCzQkIJvoTNICX0ewk8aFlGyt3vclejGs3IDiZhmJNulC12sMMIQOKBgXb/bkkBsGdwuYSTFXyADjiBAAwMmhE6UIAM10gDDUgFAZx4FwAEhcBkAwo9OV3EMU0qKXhDxzwNmAUCHCADDTgQX5RQM4Um0KEQwFCFGzJhCEGJSlAskINEdKITTjCSR8VJKhxAaoIHVqiQPGDPmOBJfbKDwQNYECY6bS7EFmBCDnKQhTAIAhBAgMoQbtCd7rjCGKrYA8ZY04pfvOENlogqHs6oB0hoQQ9IW5guMjHmoqIGNbqY82nGEB5GGNESyFvOEBD3LwuYQAc9uMKX6gpiJgmAAwg4TBnKgOG+pCCmEa0xQm83hQ/weKej86l9AfCAEXwgCEgYARI04Acf5Bi9/4RiYVrZWuGQeDfBceJT57IrLcqVa7wkJQh0mtELijpL1xOEVqg+wAUzrOxabfhFKn4xCFlwQhYjOAtB7QAFZ4xgFds4xUHOAgOQPMAXl1iFJzzgGzE84AE+Fmg1HHqWKdhhG7JwBiJWgYguIMIMskCEG+wgBo8OYKArGV5EShCFKPThCE/wjU3TexEOAIAKVlD1q4sEAV+QgQzV+AFNKu5x4fFgG9fwBQ88YAdhoNzfLBCDGKYwgj+MYL12+IMGai4GP/BhBLZLt/NUBIAp1KAHGsDAy1jQAxPIIA49yMETQImFSCQiFzkQzE+gU9U1WMI7Y/YDEraQh0j4BAA5KP+DNJkABEu4Ahu/ZJgx5uyKt799DNuzgZomt8IxkdAv47oofxnsgZHKOnTBDQvRJWkCJpQAB0YWDAA2EIOZI+ZIAxiCHA4+FCJW4Qa60cAINDCFxUPkZX+iugKmcAE3NMENM3AGpucikZiEoMpV2MQNoBCEK1xBAynAwQdIECW17Ji7ESjBIOIQ2CJHYAUR2LGwT5JxMnABB1Sn9D0tS8GwLNkJnfAQF84HGeqnJfyDWcwGfKeAJQDBjElbPzRKHIVIZMIY2HCFZs6Qg35NzvtiIihL3GvZAWBAkdWURxnUCIgBDKRCJWACJ5iBG7jBKfzBtjnDfuTHJKRC4KGF7NT/hTOwFnG0QlJVwjH8Aiesghv8mwesAH/RAQz4gieQgSd4AgxcAihYH0b4397dzng9D0uEQB7ogRNUwazEwRI0H0Z93BEiIZ84A76ZASKs1x8chhiwAJHBwIuMxeZQXEW4gCK4QOP1hswgDgbUFyZwQy9MnExlEwuN0Pehz3alABXUwhqtXx8EwhmwyN1dxLrVl1ksABlkQIRh4VlQwgViBB2QgSF2Wz1NAQ/QAQ/wwBRMAX+BhB10QRAEgTNoAMv5GAz8gez8wR+slwbcoFk8AAngwDZZgA4sQRzEQQdURAR8QATUVJx4wCk4YUWsAjFUghkQgRv8AbrxFgDcQBTo/4EPYgMs9UEVBMLghBi2uA/iAEEp1MIYhAJ1OASNJVkKlUAKIIHtiaIRHomsTRiTJEACHEBFkAEzkIiOSEoLlAAT9MtD6F1IDNQ91U7k6aH1+di1+EAQ+ME/+kEQtIwYXosFpEDAINNQVAEjNMgNOEEjAIMo6FIW9EA1ScQI/ECOlEDM6F7+7ZRErJtj+MmSOIZd3EAeMA3yFFoLVMa7AEEwQILfyMAILIEQ9MsQ6IBJ2MDlVUHWuRke+OMSlADiRI5YfE9FaIMyYEQACAplWda6FckAENl7LaJsccIrHIdlIcYektMnPiEoXgK/wQAPzFx/sYVjoGVFYCCRPMAP3P/AEjzBESyBZEwOVzocn3TcWibhXq6ax20XOBKEB0ALD5TBGtyADsWlZQjOMbFA+EUlcbVICETBLTDMHjhCKdggVL4XWrxgWTwABIDETNWXfHEXH6yCLf6BMNQXAaSBKYCCHwAAC/zjFRiZvW3DL0DhRZRfBOheuhBbSlHUQ52FAuBA96Sf9jhEuuBAGEiDHmiGEGiBNOyBmk2j/jhNHyjAEIABNLzUDYDBUFhAqZmAzHRAccLPNkELSIAmAPxBNdiiMATPhK2AFGIAy7FcJwKAM7HlPV5LumHAFHziL4oBD0ChXfrfVu5jPp6FB2TQ+/hAQPpBF3RBpViWWUrLPo7/xQqQwSmcQhOcgjB8QGNWhB0QQ3EIQxDYwTxihAaUAGX8zRO0wBBAQynwgipEggfQSFcACQAUASBkQh5oxnKM0O+FCgmIgScooBkEQRfQF3/VjpP218A5ZkY4xhRaVsxNQex8zgOYFAC4Jl/mYQ0SiURsQJlGQAQ8UgkoyNxUhxP0gXoA0BE8RaoRSbl0aaaB6ZFYQyKWhSEww6yFRAVcAkgJD13MaRF+Subo3RWaRROkgfSJXwg8wRX8YxesgixUwyo4gx3wgDDcm10u0AA4IqKGVHqpDwucgr1tgZgRzA0gxgDwQZZSEJ6GRASwQAdogLo5WLegxQwkARW8UPeA/0UBOM8AlEAccBEkeIEN9EC/jNgSpBUVmMi/VBddoScL5cnzEEQAgOZIAgAM+BtBCiaguh6lYIQCnIIzBOQSdoEzBMEI+IAYCsa1lBwAEKioBJxlDRR//QGBfiKBYsDsoEV9aoAlLmGlLJiFik4APFhGiMEpWGCCMaWTwNpFbEQWLGntdYEPVJY1MAQF7SOMlA4UMByjVkQHpIB0HEEV6IHaLMJn6MIdNMIRvIEZiOAvANdhDF4gJpl2BdmoqCU2HlrwZMAkvAIZAMBGQFs0IIIG8QknCmxZXMssXtQAaIAODIGTCUG72IAczBgqqMFR5unYfhep4ontEIQCiJAK/f9EB1SXDTwSjoTd0LKFf3GJ3YJXnswBIZxQt9zds4jflDpmw4ktALiYDqgQuZrFCqTArIbFtdrakAQGG8AAOSACAKxCKsSOYArmX4IjS/hcQOHttASmB9ABp34iHfhCKoDCkvgYYtQny8GAJ9xbvkVDUqXCKnBq1ErLAWRABsCAADDJN/3Bt32ORHQAMlniFaCarnFCcejjcCnAmbYhR9WAEHjVdEhHFWCGd8BBI+iSbAHAGnRHHkCDZlyeEMiBAjjjuRQAoFCO4sqUX8CvYxRG66nPJuhBH4RCH4zBEY1BIDiBjURF7AVW2gbjojIe+IkODKQgRvDBC3JL8IAFi8r/wUt1FQ/5AGBUraZdhFy0AKSS7QiXbYtAhiGMg1fM4p5AQCfWDkjAQMCKgS+co16eJayOGxmMrp6gAQBowBLw1oygCppk5xB4jzwS7kV8wAjoABeckpM0S88uqrMwnqSARQhcMCMIUC3srxxYQRHkAD1lhA3X6g/owO7lAI5dYbbS6m/0QBzoiAXETF0cGBssEKguS38xcOHaU+3YwSkk4C+4ARTcbmoVxzY4Q24iIbfCwD6Bpuy03HoC5kVsQyvQIFqQcYsQlwIUTg2gCgh0XMXeZXZ65xuUwi1EQqjgsfUVmQbEgQ0IAiqoyTYCiQVFyhqfFGSYQAkYDl0Rm1ko/8AVbEIZZR7c+sapjEGcyZkxxNlshMIiqELbtV0AC/CtZWFIbIO8SdtF/HH1rbI3UWzyAleCUtDlxATlDYHdme24GNQ6k/BBwYmYJHFZ8FfsTEF/9Zd/sYQ1IO0OdxMbSAQsFutFdMMKhC2Q9A7PPcA33IxmuIkNZAIXV4GbjUEnaEIfGIUeWAIg3EInRIFCqlli1UVe4Y6RbIAX3AEzF4J6kEJznlkWNEHGxcDzcckSGIEQTBNL7MD4CJuu2XGoJm0QBMclfytBsMDiOa6k1DLlFOE3d1NJCsmS+IkpvIIpkEq0UKg/R6VFlOn0foANoAB2QcAKUEAM+MJeVMSdzv/qt7IXzUEeqNIBH/AACBQrBjlEmvKyCTiEUXIFRHwwRqABsaKLfUEGutDEEpjRjKlBL2QNxtSCeKiGLuBKdVQBdmCDKiizaczGIuhBJ+jBER3W/4o2HR6B4WSEHIeAz0kKhQJADFxDKgQBh3ZBKkQDOSku6AzA0ulAAo/TAExJCEACI7zaWjxA69EYCUXEueyx6Px0WdjxxcUgCzcyDBxAfzl1pymAFBjCJLAVN83vACRBEtQEsO1JRNz28bqACxQ27xxvXbAv7L53B4TmrMlISUsxJdiC+TxusergU76uGATBo6FFAZgmJ8An0UEF4liktrqz55htJqdP5SguGaT/Ag3cGiWkQeBeKEiMQBNq2zYwA+s6wzboByhcwzaAQopSRHN/MAlEAGRMiU+prQ2kmilwgyn8AEIsNUtYgLmlQAoQl8lmBGvzKkEM3WlHhToMQTtIQy1AQgmoKEpQQBpcAELEZUvVgsPAQjboQh/oAcTUwhkdQfzyH54s2SZEgmVYAChMwjR0RZP4wlbAwAf8AZGPC4RL3nL/RPd8RUwoKm5fBCWMQixUow3YeZ6nVAlHOJ/Yge4Kgw7vCUCxRQ9LgRHI5XB/V0+d9+egARrYsRiyAQsAOUU8wF5ggAxQYhnUMhpESlKnTwGgSEbY8QCwOgiR9PFOr2/ytZwY5Ag0/25Z6EAOpIByR64d4IfDNcYAADSx4rbJkoAGmHeDT6nl4AQomMIpPOW41GK78fChJdBa2PFesCRMvY5esSFGlGQbdgCFHjqe4wQaRMADLECRUMAlWPhYQJ94W0EirGwg3ALIhAK5DAAYPEIe0KGbZBoAdsCafklQwSOJlMgBVwS4gkJWVoQfVEIr7AKL39OQ1aPkBZ/w6EQIpEAILIEclMDrmKqR6ABlZK//Jk0ohIIjSEMoBIIsifQ767ycRAAOoHVGoIEnjNsqqAEhEAI1sBRv56lG0YE3VAQdABhBTDB3kQAc4EIqfOB9JBV8erqUVkQPRzlkyMy5YlcNsPf1sf+QFc4IkHyDFxxMlv1vIDyCJHiVGI/wM0xCIiSCIhiuucvzuZypAqwAi+wY+8oqAK6AoZ0Fx6MF2Nt3VNb6ePu1DjwCZ7sCL5SCB7CBp9+l44upcIbqAMz7kkRABzAX+b5dJhhR0sB8dtCoHqxMqy+qnyAq3vawVp9Evb8FRLHQcNEUY/TwgpPei9dY3sVvRtjBJTSS5gcgC5Q+0T3A5nf6TEm7X1Yv6QLAumBHKJR2VMjVn4dEDeBM9e88A6kBJCh9+eP25iMhkq1woWqO5xbusIUOGzA+oI8p8ETAbkMKQCgAEOKKCQUYMIxIIRBAQ4cPIT4cEDGigiU3MD45MkT/wYCJFEGGZANgAIZ97DaBgXRnjJMjYh5EeBAyZDcMfpBAEGOOhR87fvx0kdGBZMOREQMAKEDTg8MHH0Om2QWgg0eSR6rkcaWrUNds2QrpGrNoEZ41R3x4RIIExyCabx9CCIkGQDe4EW1Nkgsg6V2/f++OVGChI5sHKVZYUByBhZg/f8QgRIjGJoZuMOgc+DuRBZIlSIgWhQqYdGnTJBWkJvxx9GnXr2HHlj2btum+NG9T3PsQBo/av10fBU5b+HDjgD12BKBAHJAbSwgXDZkb5OAWA0wcAZOnyg0bJkK0sPF8SAcLE1uXRmO1YQodN+q0ibz6NBs0GNCESyWgoQc0/3TT080hNGDwxZtu6AIgQZDQK0CBEG4hZQ9eHgnBghBCMKEF8Gw44gggQJTDguMAmKmh9AoYgK4ELiEjgb4WoO4uCGCgKEASjbqLh10ueesBCHYhw7QOeoBikydwTFLJJZls0snflFlFKYoeaIKLLKac7cYnuXRSsy6V3DJM6RwSEy4IBkjlqATDAQACX8w8cUDKvBnEjEoqeSWcL36p8T++pqPIl2pSqSQVTwakTQEhwAihIfPipK21j+j6BoADYFgqtgdg2O20V0a5BkwPSG2qGx7+8BSptybahRIwYY1V1llppUlTiWrNVVfSioNIxl1rlTE3ValcAYMSrrhoCf8W2FDRIQg80cChphrqZoXUWHjAggigQsMDFsA1M4BffW2I3IcWhO1ciFgj7TYNlliCoYg8qlfBupa8BpRKqqEJhm2iGaQLh04BZRsAzDBDDCW98WWVSog55h0YYPgDKDGaoha4dIHt2OOPQQ5Z5JFzBHndJ3v1KzkNfEB2iRJMkTaipiyNqyEMnHHDjRE0Bo7cBSLieDj0pBtBh0hLG2Cw1OK81UkY7LiEk18q4QQDkrHOWuutIRKaIq+5DlvsrcEe2zZVkzrZIbUp2sWKD8ws+zSo0GMPadcwMEEDE5gooQRwZE5NNNdMmWSSOTAJxorYDpjiY7bNjlzyySmnVe7/yjE3LuW7nA460HHHfRLyzDG4G8wW3TU389VZb93113Xd3LjLYR/1gQf8S/eKeY45BleuaX/NLpHJELL245FPXvnlmW9+uBqoKMMFE29oY5ArSnde++25797778EP/8kpZihjsPPET1/99dlv3/334Y9f/vnpr9/++/HPX//9+e/f//8BGEABDnCAfTGg6gCVwAMqEIEEdOADIRhBCU6QghW04AUxmEENbpCDHfRg93IDuQXa5i4HNCEC06a6FAJqhS1U4QthaMIUho6GLFRh2kAHOr7gkIU89OEOgTjDHAYxhzicYRB3WEQlLrGGQmTiE2l4xCgSkYo8tKENfSjF/xgq0IUMRGIWt/irI75wik304hW7uEIGCrGKX+yhFxfowtucEI0ohOMa7ThGLSoRi30U4gCMmMQAAJIvBfChIaEIOkTm0JB4ZOMeYVjHOupxbWdsoBxdE0eKUDKBlfTLHB+yrhEKy5PkUpsaR5i+0cUGlLjZoiPD+Eo6pjGPbrTiI5loSzDuMouJ1CEff+jLXJZRkML8pS39+EYzOnKPmNRkDSeJTGd2MpR3xGUSa5nMPuLRj7usIipfKUlaRpObzyxnNwMJSSnSEJCDHBcipxRFHC4ykYhcZA/XmcxlajKa5rxiA635yXJZMoTnDNRBN+nKS66qmtQEqP5WCZcxNv/UoSDhJywDqs9I0jKO1zzhOofoTV5+0YghHWYTcWnMMqJUpUVUpjJF+k2YthGlNP1hHvPZTJqSkYz57Kcdt9lRXZIUiD/N5ix5ytEzKpWXLjXjI5OJyHYGYClJgecS6fnErJY0pxoV5x2N2sWA0rGSEaXoOKnZyoGKUqGdTCVFA2hWoBb0om59iz+1eFSD4lWvI5UjV3/pV5ti0aRPHKwTfUlUwKr0pYSVaU2JKVjIBvOWZQ1sUF+6z6Q6FpJf/SgzpYlMzGIUqZi06yhl2U18Bhakx7QqXwhJw0XGdp5KtGdLi5lZ3Xq2lkj9pznRClRPIpSsb1WrRYXbUDGWUqL/Hxzoae+KXOaukZPjpORnpwnVziIWmB7tai/lWdh0Uha34S1mS1soz5lKdqffVad2CVtYjRoQmtl9LzlL+1uYqvON58TuaK07183KMLJLJCkw9anDqtJ2kbel6jsfHGHQTTW8N+UvWPNrV95qU8PDPa50FxrJ4U63ohX98EMZWkKIKnfEyxVugTdsXwCHMZicHbBuV2pjGHtUxyIdJhFZK8zzojeHAkhke4f6VPay9LCK9S4SNVzjp+I4r/7V715jaeX5Cla/wO0uSFfr1Ci286pRha0UCVlVdxZRzYvd8own2soAL/Sz2qyrh7P8VobqWa1sTbFcTYni/KG2xXtG/yFlv2pUKka5n5Ll72Q5617FqhayOx1ypMtbYSUa+YmcDoCnEQxfKY/6sdr1cWalvFvQXhjRYLSyUrUMXG7auakY5vBJWxvmBwPRnkq5LJofvWYJo7Sq8/VqNSeqV3KOdbP/TDGWryxgEwP0xCe2ZHQfqmcAWhswv9astP8abbH6NdWmxnF7dRrTHbvWrT8mcpCJzGlPg9qkTha1uiMd2lZLs9y95TI+1xta/DobtbLm53+B3MZY6tHN7BZvhLHZSEPS041VLbaSd0jhe7Y5nsZO9ojXmugAX3fZIbdzakuMUBA7lNvTlq62+XcuthV34eBmdMDljFN9Q3nfGOfxvf/XC3RTH/nd9SavMelt9Jz+vNRJVrfQg07nqEf2zayueZLNtd2ag1PkPKV1hbHp0az2kMzDTvkNQ2fxQi5W4mH3+DbPDt2ck/zk1U3ujeEO85U/O6F3f+50qSPX+RU0xC+XOmZ9S2itP3bnmmV6pZ9OacZbMcFFJ7KtLe/wSUOa8+SePNZ9ztS3T5n0/80rdiVt9+/21o0nP61rQ4rOYjaypGUfYnSHSHtB+jrU6Ry9iD8Hy+winqAqpjspBSqbwGP7zg9cfoev/ezjl1XAde7zSEELXY+fGvM4v299t6xe7mae/JD3ZoI/n+7vp9vJMZ56uZfczMrytfXUnTqHw/7/6HLpf/0RvrgQs6rBIMz/WOuN2qy7cuu9SM/ttC/D9G/WQC61TAvFSM7F9C4C4Yrvki+TxEfmWCytCo/usGyaGM3qso63PqrnoKwEm66X4mvIDMvbYLD8LA/VEk7y1k/f8K3nnIj1UrAFPS/H1C+/vGz/2u/Ceur3fmqGYiv/xoXCnvDhbGsAHYziopD3DjD3onDX5I/dXtDuBs70win6Rs7vqE+SPpDwKLCtUgcDu62ACs/r5o74Tu/1vKqrFu7xHIsFI+/nis7tFosG/3AHlwoI3+8IXZAH+wsM+23ptk/9isr6AC50kM0Gj2kSf+/jIOni0E+RXOqqhi0UfUmq/7YwEKnqzE4xFSuv4BgPDRkR2ojrDDnJ8BLvDc3Q0FQMz/6i+dYH+SawxOLMB4VvGEcQ7zAvppJw+9Dt3DIvAQWRBnXppuxPCBsx/WqtD+GM+qiR3yytqS6xDqvvyZ6pGoOtB9MmzQBlwZyJ6CZuABmJAB9sq2hPzGJQvajMHI/w0ESrAV0R+EzOt5KLBDeQxE4p225RDfvnzjLMlQ5O8u4wDPsK7qgN51YtqXKw9OKrBuHtGTVS01xqGEUNEEFP/nbv1wTO4A5x3YrqrAwM4QrR3ALJDvkPnWDPzAZpkmpLFD1RAOORAAkAHq0wpOaxJefvr8yvs7iIAfmQ4G5s3P9kEfCe0tlUbird0NY08BYT8sWgTx/XcaaI7ysVDarg6tTuCyQN0b44Mi3TEsigSRttDgFjzyrpi+iQMuTI8f4qq8UQzP7kjurAyi6FbKXo8SEbTZiqkAqpSgDaMQB+8qQsbrxasp0ikCjNK/bAbCY/rhKPrSELsi7/cuY+sO9IyO8Ej30AcjLZ8KwyahYNDiZdUwfvzRG7UJiSTi1Bh9MEych089PGpTaZyDeFMOGYTDDhMgi9sR5xsOribxlbLTi7siUzUdegMcgmsYhsz8HG5SdrUzE/rR1/cqvo0qrEDzqHshRBUtNsCjNlDwGJ0SxPT41Ucytz0Q2dUu8KEgT/4ef5uM7k9k4Xhw8ip1EchY6lnIoire43eTNBFdQ2ca03eRM4Ow2KUhK8lO7LzpJCJfQuwQsRmbPHeI7qli7UotM2y5O1bE+rptDIEKkxBfA7RZGewDPiPJIe3RG2+BGwYBAT1RMyp2iutEjtMNMDn+v5BI0/b47rLjDulLQDtTLRQjMDQWmWiHDWyDLYvgkjC8w25Y1Bw/NBF1QtDZQt3c0UgfDddAzTCrRKqxP0Ns8STZFLyS8LX6ukwBOr3rGItLMdF3OJGtNO84/jCnBOjTIRqxPXaBKxRHJHR/QLq0w0++4+8dMpo2+CTlOhXAzPqusBU0kFr7Hx8m0j4TRU/78sQSF0Ok2SOGMw606qTI3J+9LT28TxLNmyJFdvRkXV8mKUierUHQuAOyVMAL1TJxkzMMcznZow7UqSVsNvMMcvperO2BYVURv1L1OOSNMQ/yw1ILFSleyy/v7u74jU8TR1IlXyGluL6KjrVhl0SxG0XbnUCYtsN1MVOW11VOESEBMxPIVTVS0zGunVWdU1YHOIAPQUwrAzT3mzV4dVMRVzT7eqTxMLFCHzC3VPUQ21Wbnr1sQ0WS02AaWSDX2xKh0yW4FxW00TxI6L8H4xDklrtJgxCNFUI/FJXtGLXb10N0tVEOUVZzeNVHuWZm+TWHVtBh0updKUVpHuS8GuXv/FLCPpdfT8UAFNlUsdjEWzk82GlaoK1kUT05AaFms9cRCXNic1BSo0r2P5T/w6cbySU1GPzRbjc0lbrkidr9AmkgUnlc+YrcN8DslQlWnrsciUljYflGe3NGfLz3C9dEEPt4h41nGF9jhnlNK4ykPL78CIVkQzzfdC70zNcS1pMACvNmuzSkWv1p4KoGALljsJFk6vdAvhKZTkawErEGo19LyCinYJc3czsHdvrnctcD6xLSubqxDpdkijMso49bCItejY1WY7TTel99Pm7VYNVwCw90sVN16p10EHd1X/1iNflyiFE1RblUbRK3Mzbb/Odm3BFFfDNt5ONwAgQGv/U5c7C7Yn63RXW+r/Eusc01SH2jN37zFRC1Vz23cz3RI+U1PQkO9aSQwXl/R+Hth3V3MX/TMEq89VsZRzAVdgQ1VxtxdnRXhxm/FzwXclk7I12ddM8RGE77WkojVU1beeDHZ0wfO2XFRPe7WHuxPC+lR0DTMw1bftoHM4x5Q6izZID8zdWrhHxTBJjctRpe1bIVg+NQjhzGoOr0zGyJHUPhiGfQlxE6mEr/dm0RhoaxCOMpQRZXDk/tfAjlGMOTdapVOMFfbBrLYnH8xXwdaQXLR+g9WH8feHEVNY4/d/2bIKzwx3ZZhALRPeEjVtL21eZ9fofq/Y9g4h+5OVRNZ//zhZNUWPBLkYSd3T3z5VTOkYQcm4hBXUjNO4cLN3lr1XjQW2hpsWYyu0cilzld8Ul305if2vkPFXRbmTdW+4a/W4VwV5mfV3J3nVmLATXSt0RMsOXsfTGXPtVMfvvMqsFAnUjjOzNA9KZY+XnN9nUw3SCG+0ZaN0o5pyCT+VR4N5iWyZldHYe2MZlqUXe2kZcsnYNlW5je/YXnvZfMU2oesZvXaVhW5LdYeVkL3Wa3uymAuAYAn2a3d4MR8akaE5FGH0kId2+BTwiWGvMkMPR80XBg9Qm9tXPanyUf9RppUUnQWI5i74IetwJmmSIgs6hPUZcr/3Z/P5lff5qGfZn//teahFFZilMI5d+E2h6J4XOlR3lX/jEZnzt6P116IxOqINlqMjeuIO18gIoHp39k6nmX3l7gQb8UQDuJIPtZLJ1LAkVpXF2aAMzyo7+ZPjqjToKpuMV+umzwQH1ZGrOkKDlqgddIQXF62RmnqTOp8bd3sFOowJFDgDmks3O2mnOrGncACRWY9vOFiVuaNZtJD3NGyxujstm7XLC2khWbbTsZF/+U1vq9SOuJeD8oVfWhlz8WRAc4KL14L356LSq/uaTYtP2ZxNWqpFtbN9k2Yft7L1mZ9lmZarO2hd+X0TuruDmaotr7N9eZH22FcXU7WzekUTs70Vth3VW6xzGJr/Ffa1gZKxVPqkixVEi7i0RXoekyikJ0u/c7lNLVYTqxiw+zOikpSA8BCOG20PodVaB3qVoTfzYPm6TTiyr1e77znDvdupl/pxq5q8adDEOVLAHfaQVbeYu9Z0qdB0Hxp/Vxtr9dSVr/p8c1Q2J1an5JEAt5oLxXP2Argyd1yJf/sBr3LJZ7qvy9lk3UfbGhL3qFXlRhknV6uJBReoT3zEY1mlsNuVp1uMKxzMi5qpIzeYn5uhqZaPl+K2GHaiI1qrf7WP5Vtw33t0vxPGoai1W3KrnJClbXv3LAuAV9FO1bsnWQgd3VHCUC1QaTSvPVPZci6CJfh4lcemjWNll28h/0XznSfcIp+6Z+H0wj37w7+8paybhFN9qb8XxYUafcd7wy8Xum+1zEF7MVmU9/ZcmdWbazsaot0bxo8ZkOfXhwd2iFl7BgP9iH+ayILcaq0WvW34TrVZyyFP0lGQSu92IH/XuP8a5VixH4NLP5NzWTE0qE2YxFWd1gk3rcUczdtVhJWa3Ykaxckb1xWbu2sZtE1VxG1YiPucYU/7h3kSWA3WmIXd2H14dXPczUl7mu97dA8Zqpnd0HObq4VY3oy9zjvaxe00mXs5y1XaU9GWDj92eDVQyiGIM0tOAgd7VTjTg916X0EVaKnb3bccoHU+QnE+1cXb5/fZn7Vb3Rtb3v9B16lt2br9nfwA3pcaM4j7XJF0s+MRltormqLvXKyj/pnF2k7lu9iBWKUevo0By4jT7JcMCZAcnpE4rTGxnqw5GsZ/PJHvlMB3fFGjM62mTPoSvLiJm35GBwkrcaeNL+b78JEh2ehXXX7tPdb5XXBfm7y3m4SJ3t4h+3n73WeR/hk1X/Lb/fEX+ulHsdH5vei7vutlnApXHMjzF9hPW9insNe/HuILeeLBVsehPXW1Nh79/DCD/JmnPuTNLl8NuOoW+G35tb/WOVzbMPBrB53fudy18j/H3fD5+0B3O9LL+Ojv/bHH+Kg5fDs5/OiLXrwhm/yCnrPPPPzTWpp/GGH/s9Zdzxdwh4xrU39Y95iefBUgCAQQKKBAgIIIBwYoICCAw4cHDSKUaNBhwYgOKV4UCHGhR48GOYr8WLFkxoYGTS68qJAhyY4ZH1YE6RCAzJcrXxKYKGCiQoE7DUJgKPRlSpwmj+ZUORNiU5sBbEJ9ODVqTatXpVrVilWr161gv0oduxWA2bNi0Z6NOnatWrZo4aqdS7eu3bt48+rdO1cuX7JmwwIuC9gt28NpESNOHFhs2K5lI1eFzJUqzMsWD2pueLmhZ82ZQXPmvLn0Z9Ooe3b8zDp1Zs+tT3d+jbn2bNK2c+u+jXo3bd8wgSpsiRticd+VgZe8mFC4cJQPOT7k/5mTIMXhEj2iZF5x9E2Hwl2KVnpdJUfyRjHSXBpzd9OmWGO6RB9yIE/nPItCT7peKU3u0cmnW1XJgZWVZY5NReBjCQrGIF2LtdVXY4XV5ddfGGao4YYcUkjhg4rFZRdcIXplYomSkfUYZA4O1hFUk1m2W2y90Xaaaj3hqJqNpfV440E48kjjkLD1dhyNwNnmnWutJVmbd6wdB1OT3nEEXXBEqbcReNOJF9p0q32p3HAiIeScRUctB8F2823H5VKctUnmTwedCZSZ/XlWnwDCpQcBcdkp1ed52OkGn07aZRnAnwL9eRR+RPG5UpYFVOqRQMvdyZSA6dGU5kcxTZbcV//xVeYYggymemKDE3444ltudSjrrLTWKutiF8LqKq4eothrY5RdpeqqMLIYY4FPMqlslDkC2WyYP9qo45DLiqYsZtQ6mRuSSGprnJCg4fRtk5gd+plL3Lm5JJjfettRfQrlJ2mWW1o6KUYjbbnlephqhumV5LHU0b8uWecpmh45GsABiXIp3qD9tafSasul5BPDj4K00U53EhDppylVKvDH8yLMn8YR8/dUfKUeKKpKpEJ0KquSDdtqrHvlauvOPM+qM14RigisXiFGSOLQvPp6IIstNmigqCxvWy2Rm+VIrpLjVt1slFODK1uY1obrLm+kLSmltlSCNvFHaTvV3tv/rMmZbk5sFnd1kvNxeVGW1kna75rw5q0vyYoKDqd2EX/kqLx09mteeuftq9Ge770LEcSYMgz4lv2Gt7B9hNNZVH0iE3cmQ5ujByC/7PknbMsuR2UQABUN4JDttHO1oO6q9p6W0H4FfdfPHvZs/PEQEl1h0zWzmqDQhfE6dPTFdtVW0sQO+zrW61LrvdhJfg/b1lz/KP7YLxoIrWvot3/3jdn96yNoBve0E3GZyVkw2PmTdmhnJiEIqCaHp48N50t2ahxGzvadM2EsYfL6V3gSwreINKRznLrXc/4HE4sB7lILw09Q9rYwixmEYSN03KIOhjGfpI5zClHYADFiQvrR/+lgCqoIVHBXgAItaHtTmd3sfEdECQ3PVRqSHvKWyMS8pIgxzWtR0a4XKyXuyjCBCRYVTcS7KzoIOF/rGtW8BSUmWW1rQKrW/MQUPql9r31ja5sAq4QvC8Zrfz+x3+EuWCeeUFBPdcuOe/hIQIYkkGN88ltCwDRBQw6EIT4ZiehA+MFG0WRzdhLYSAiHEExW503wkV/GFIZCxQngAKcUyAEYgsqgfO6EIfGkKxV2lD+x5oOoi6QFNzWTgAlSfv2CiYJQlTumySxqPiyiMp9HPOK1yplNjObxsHc0X61KelOEHl9SpJin1WQwSIMRM2N2mclIKTZBQmcaw4Ytr5nmjP/wTKP5xFY2djHwN+CbUtfyibU4sq81D0PckOgFyYAuEE4EkdQNCVZG3fSJZJBSJCInej+nbKQAQPFYRhe6QJAJCGT3UaB4HBnRQw6HJZ8aIAVjwjBUsnJRqRQABICCylW+coUpaSUKSTg67axplzA1oMEI1TDW3a8njixZSnsYu1NhJpmvo5lUvfm7IwJNmljN6quMRj0o/mqq4MwmiIC1IizWLIphrV6xqiejGLFLaslKljo9s5NEwhOpaAxjPWdUo3v6Zl1Z6xYYw3YadNVpM6TjY98MeJKSgi6R9yPICOvjSubwEzomJWlIU/jYw2KQKKrM46T4WMeVcIykj9X/lCINiSfVola1EBPovQrVsZjmdCGNym0i16RKPj1wKCsM7WRjqDFLJUSmF3kh5QqVnvLMMGWdwl3vcjPMqC6ziMXLkFyE9xdoavW7TqziFcfpVd9lb3pjnRlaizbF9jrNrW5tF278uj598kiy9svvGeuayBp9ib5gCqP72rW+u/21R/tzU99KO1l55S21CnStpFobrwUv8l2cyaxMgRIp2G6YNZii1IbtwzFA+e2RFB4uQzucx4lG8LGvbZ1lFayQnWLUt4m0lE2BWwBGrRIhNc0lRnEqFM7uBJeL8thQkHuQD1YShPU6WA2D+R36iCuI3xGmbarL1CGC1bw4S95V/42IRCuC98w5++qFsCfVa7qZWNQzbxTL2lRvUtXO8YXj9uxrN9EIIAE9AfSfreYsu1pNsv61FoDTdr43BhiN7Auwoq8FG41UjYbbKbGL25RYzcYY0Q22oJ5CI0kQjvAAmuYYIgs6kRuncmGrJIBGJyLrGifM1phiKH5aCdleG/mUkNU0TyUK3cU+FtVAVrVvaWqm3RYkoyNuaaRm+rkDrOmUC7tYpTBaKY068rcR/lyuqV3rv60HVDh1GFJq0kuJyccmHKzuWq/rPG3qCkPYzK530Xxm7kJvrNpLa1qVZhhjEVxYakV47Aye8KgBB1l6RuddJ54jREp8foKl5xrLmP8tA1vkjBjXOLPcWaRJF2kmtd10TADU2tZGKtwCFGBtAvhsYBMAk8pGNrK5PWtZY9TbGh1I0DmMU56mqdms3AmvKYrtHysbcDWdiNMnyctdJlLniEQ2x5BN7pl+mNo//nEBSvnjNYGd1fbR+lCA/vNpm1rceZwptw0Z2YNdRoZL5RR8VIbupxKT3mWtkJgFr7N9k5nfiNcVYe49zoCLNZwEV6/1nqhwPCvcqbxbkYyOSZk87xmuzJor2r1HPjUy0MDle834CE3xQ+uX4oVWNEJYf1zV51eEJCZxjhXJKNCZdIQpvuNeNbO/XbNW6Uq/OvL51Fu6+xy2KL75QHq/OUb/9Z5vzM+2rGO6/a0XhNerJDu2VblBmtBOdh5hGO+Vz/32o7L6fJpp2VtrduECDii8LSGOlf5Ij7XdlbXUSRdRSh6zEJTlE0VBYHiXJ0cBbxh2LwZhOxzEefP2ZW12eEiUXWGGb4m3M4bHeF21ZuUlRWQ1cGXmRerlIl2kRZYHcZLHebOhZ24kT++0IxdHcmqkT61XcfpVV/y1g0AYhPF0V+ORToCUYpCle5u2Ws8mdD+XWna1aj4xar/xR992YzcXbO3nYi7FJ0mHUSi0fDc2hr+WdMCGatnWheTWYjEVhlq3YRCVH6VVMUFlc712AKimU8mHasiXht93c1lIbkJG/3aoIxxit2I/wXNPaElC1hKA4iiUBUKuMx4fIUooVWXu5lGWg25DBHhgBTwayHiG94EdyIHbNHhclTxftIIJp1bndTSS92UtWHmkgiwx43kyiItkY3o1aISpl049Ehqj4XpnBGjGOGjHuIOCJoRCiFivN2HjsxkL1kp5dHzNtmrS9n1m8nMdA20ThWLkAmKig1xZWGtvCH7L131YyHWnxXyppHSFKG6YdI4f1oUe831s+I3QRoAdc0CEcomddI9Yp3x5SAB4WFMGeXV8eIZyN2L3uIYoJGTR9kjVdin/p1GzNEkqRG09thC8NYCLoig28ic/VThvczIelVJ9p2VZwf9UFmgzGTh4oehvIliKHhiK9vZvR0Rnd9ZwaxWC4lWLl/deDEeLmndMWSSD3MNPoKc1jVZo0bh6NLh6IIcjy3iVOYIAgSYAWpmMCWCMYDloO0gACeCDObKMUfiMxDgtkYVOUphCvZaE4Td95Md8stZ9raRs5shawSgaXHhKWhcUCLl8COmOshZrBvl8WMiNd5mQhNmGBLlsBRlTvBWYdql7dJeIJ6YeqANByJeYk8mHommQeEiaiXmGY5eQC7mQ28drXgd2KOZjTUgpIeRzfHiYt9aZtWSASYZbmIltrhM3H5VlfJd3IbOSbvN3JmiB0lR4NtkhNWmK7kWCJ8KCwXL/nZnXinSWnUbpkwvnnabyeVuGNn15YG/FcSbHes5yaXmlNT9YjFyJjH/WlVajlfEpaFqZnzmCSn9Glj3BAFvZn4KGlWnZX5A0cfzljNdmNUsHhXdyh+molzaXde6Yl1sIOg4jdVq4fZgEhod5hnaYfFnYSnS3mqrpmJAVdagEoASAAN2napszmWNnH/nXUhYkbEmVliIKogdQlgV5mInponnIAAXpolx5osiHkDWFdW/odSTqkAPhUneyJmIXkchFpR9GMk3WE2YXXHTyQJrId8+liSA0J+phGbajnCxzLNglIotnRc10MzJpk3H6TElkVm/WPBVolNtZZ945i7F4/3ndWZRJCVcy6HGDpYMmt6i+OC1raWhWM6Bc+ZWSGp/6iZb6WZ8CAKAIIKn2mYzw5GLvmaA6smChxYMo2mFxmXN3eHW+VpZkmXwMsKO8JlS6V5mtKnanxHMJmUpLB5lVCqF66GJGmodHOqtlyaIVGkLomG3AlljCp4R9lHWJ2aKgea2oJqSHOavWOpqheaJK+o7iaqIfWm6xaZBEgUI1akhQh2JoSFP2sRl/AqbIpZu5SRIkNKYrJ0gIQ2VEVTvoRzMO56eCASuwmCvbZYrPSSvOeacAh0Vu1k3ceWfW+acWO6h7anDUdRj9VGDlKWnn4ySMFnK/uDVmqYw70amA1v+VX8mV9Gmfmdp6XQmzYnmMyQiggLYTygqphiZPsMF/P6iX+GeY+8d9rel9b0itIQqZZQiSvSWhblitp1mYA3mOA/mRgwlss6pzCMkAs8qpZ3iX6dqPrgpJL7QSx0WQSXqt2jqkB0CkBgm31SqaW3utvnq3xkqugAmkqhSPhohC79eaWOiF/wJ/hoUjmlOHJ3Svi3Md61amlxg4zyUTUEOByFROnrh40NldC6td4WUh+kZekcdNloedhKp588Y0AtsyqZs+/tROiIqDAmZPuwiM9VQk5LNfymg/+Dlo+tmpCJCf9tkTw0tx9LmVkuqVfJKzkFWWutuDduUvwLagG0r/fnm5hyKqh22otEm7fF53j5AyUVYqohT6ox+qveiLvYOpfTwqa1qZh107q/oZddU6odmWbV5nEVRKL/yVcwlQkAAMt0IKt3XronMbt3dpwG6bpHh7ojb3o9MHa4lYQjVVY4kZQg6GhFt6pZ9zU42SXOl3R5cUE8FUnO7md9bVVperZS/JRWkGuvZGis/pbxqYsDPpVXE2XqZLlKWrnanCTUiDuSconnx1esKoqE8Ju/mEeiRbeqG3ls6bjC8bny5rqVZcvJoaaC0LaCxalsn7n5vqa8AWqQX6g2jSE+rXR5Ypmre3W5+Zt+UaoUSbkE46jmkSEpHCa1pJq42pmnS5/71Ue7Raa4dKCqujqZUM8L//e4Y+6qqtCXeoJG4XJKrKF6SgCbdFeslxm61A+qPcKrc/mrVwbKxrq5vXK1NMao7OVlIa3EJOFlSQvBJ/ci/7AcJiSptMgRvwwWWbpz571sIFG5RiZmY42bkw7F1stjzhpMwniMM8SZRC2XlJo5S7uJTnREZiFIzo6Wgfl55mdJZiGc4rO6mWOs4q+5U426K+67srC2jIBqA7q3MBOqAcE8UCWrMgx56QelQpWqE/WJiwtmxhu5BGKqqN3FvU6L5iPKEny6rky7ToGLZbN9EqCqJ7PJp8K79EKr+dLMaieieWeZpry8lvW9KY3K0bXf/SbGutBtzHjTlTdmuie7zH7FeO7xh+gPiYMO2QNZeQYwdZH7mEzHZk3jeBw6kwMiRKyIluA9BlMCgsOpS5wIyCXSXMr2LMmwuUXATEWz09cLZeF9twlUfN5Dm7gRWDIsueOJjNIYvE64kj/kmg8mnF4wzP93lK48zF6/yViDTO/Lmpd3nPzFtXPeqf9LnFsBeqqlFX1gh++2k/1fq+3XdKmHykElq+9RuriTSrdhXKBHDSoFnJW/irANzHpX3a2JraLrran/22rY2ipL22kkmWqH3aKd2tl2zSKu22Gy21Lu3ZTIpjFtqa2Zek8neXOjV+0cZK8eeQhkjJDZaXUTr/YbZBS/fKMNCVnB3R1GzFMtLlEVO9TOfFGGQGTTKMVTR81YTB1dbUNOOdbxdblLoBYIO1I/P9sfPFlO6SesvylA3VULXrlAEKT198jMcLtnctnwlwqTp7lvRrl3FNvMsbxorco/DM11gchEGbs877tjwK2XQL2PppkIbM2Yi0x0r3v1Lb2bB6hlvLAAvArQNsySJetDWlrIPpybvdyam9wENqACztvq/NotB9AMUq5LMdwACs2z2e0rddmkzemLfJ41LLtbQqrmJIx7IG0610fxWZjSRTmX4I3eR4avGaGx5l3ZWIiZvI3UiZPtoZ3s4Di+hV5+WteKUYnZ6bb+0N/7EHF9Z8urp8hT4QZ56Addb3ncT+vU/ajE+MOpX7hZbgXLP+qawAirx3zbL56bw4O2gW17xnGavGuBMJwKlluekIrs40G8aazV8uutHLi6JtfJvImrKJ1NIGDOoCPNKf/djWmqJf660L0Np8UusJjNvAfdK7nq152LbYismoBuNECuQuCuQnjeK5+o4IXNq5TaQA7OwLzNpCytuufZtTDojeWrdK59g9GtxTO92hPWTzN6N964XR1tzEnbTk+FK4B30pmW55dxlN4eZMxUOywxVepkxqSl5GxN7qXczgRec5qTx1vt7MzGY/nLE8DJ73TVjaoovcY8Qlp8QdFy6N9v9GXyMbgNXWVCmEta6s2zfPZGyMXVnPfzbYgsYxNe/FFE7qityipT6pPSrh5rzZRn91ycp+7b6MAOran93rK6q10d59XzvkU1/uu36XMk7ZbzvsBBDjP2qkiJzJ5L7rA2zkPd7kaL+1pQnk1n4AQP7aBYnjHx7KJ023Sg6/oBnuKA3lmwy3Xj/sBxD4aW/2eG3rSjq1q/zTp+l1Y7e49whavqV/FsrZMH9kVxdjFVRin4LUkmh3bwMRtpOmBX/w4E0VCc/DBDvnblo8DbuBdAr7Y2bxOazVespegH66GutWh56oGve6Z4Oo25yDVKnPOaiobMToAl6VzDjpHN7XDR7/aP5JxYamznmNs+2+qS2byIm89AjgtaquyPMbxh4ua0nfxbR9pAXN2r1trSlt7U8f7a599nVr28hNAAaQrcPuol4PEAYIICBAgMEBAggJJhzYUKHCgQ8jNkQAsSJDhBkbGoS4gIHHjQgPFtSYcKTGAycZjqx4UOABgigTZjyQsiLBmCcP4myoU+ZPhiQLLsDoEOMBATUJJBXAdCnBpEGZIi2AMACBAAcKCFiKFCkErli7chVQYCwBsBCwHsi6FUKAAnDlbo1bN8DbuHjlXg0wl2/fuHsBBwDQt3BfxIkBFy5wmPDjwpEfN1YcV/JlyJkJA7jMeTNn0JtFgyZdmvRn/9OpVa9mbfoz6taeI8+GLJv27dGZb2PWfFjy496GhWsGXlzxceTJAwhYnpx5c+XKn0dnXh3xc+vZm2vXvn150+zVm3rvjhw7dfLp+563/h38+/cJ4IOXv1RAgqX273OVL59/0wTkQ2C/AfsjQD4GBECgQJwCxI+BBBIckAEEIsRJwQQGHMipBBkwaMMD8xNAQocSpIgAgU7E6SMPPcrIQ4JYotAkhFwkysOMiDrgJRYbEggBkHJKqSAhE+IpppRerOmgnYz6CSQUowSSI5pMKgqhiYBKEscmL+JJKZQyiklIn0rkSCUtiSIApBqvvPIghKZ6L6GwkArKq7HUcisqPv+tEmupqrjaKs616GKLALfgKusuRfOS6y2sHA3ML0qvGwwuxoZTbgDEHMPsN8ICcywATj/VrbbSYFNN1dRYje1VWG2bbbfYcsMtNNteu7UzW4cz9VTfgNUUuVGjM1ax6cw7Vrpju+MOumejXW+78cRzL732lmVW2uPOc28+/+aDL9ymRARwxPuW8s/BAJHqT8ED0V1QQXkpDLBCCA+wMEMGDkpA3wEDHrApE//Fb8T8CoKXyThxYjOiIwUSSKWeGPqSRhcp+gjIHhGQ2CMXm7QIIpiMtDjJLZOMiGE4GcaYoygFWgDMA3SEMsYhwXRzoRNVThIBimlGmWWlaFy5J6D/igppzaFI+mkkpqJ+T6OpuhoLKa7aEgCsOOM0K6urktoKUbLIdqvQre9aNK+1wY4LK70Ci2vRto0t9ji5iwvWVE9DVYxvYTtLVdZVB6c1VsRrxdW1V2vTdbRdId/N1r2B+7Vyy4nTdlroNu/cOc+RbdY7bKkFr/T2on3vWmnLQx1a8cT99jvyxLVd3P4gPJis25saeL93BcRQX5uErxBDDBuscHl6DT4Q4IHw45d3q7HM6aktezpyIANgZNogj2bEkmSQ+/WYge459ihGic9X0eKBFpjSgB1b+hlkKTEiekv5mZZ4pZoRKUkyY9GQgIayL5GpRDSBE0aQxBL4qewi/xJc4Iy8NL6iUAyAbsoZB+/0r7PESS1jMRTYugaorSGqUGZbC18OtZytuJBRMGQOpBqVtriwBYbNedtg1sYcu4QOcKayjOaGGDjYSK5wh5tV4pboxCYmjnK0opyucnWr3Agrc8EKjnFC98XEJEtZ2dKWGLv1OmdZ63TPqh3r4AOtaZExjKUz3bfeGDv76Kd3vrOd9P6Tx/2ci4+DNFjARnQvQ85LeB0y37/stbwM0StBSJkkV4CWlJEorCHwKsr2mPQ+mVXMe+jb0opS8iOYpK973QvfKV3Sou2lTGYV+dHKSpYiF+FEJCTbCUyIIj+QZOwlw0RRzSBYMi8lhH4tmf+ZLo8SQQeaDGUUBNKYbGlBl8XEKFH6iFBQ1kknKa0kGXFKUroWFRGiZS0iEmFZWoiWsmzNnW3Bijz3RLe+sIUu8aQLo/Iml0UpSi5YmctzJjVHYoXqiJXzDWUWeiolRnFxEzUcFE9DOItWtDWOk02vZiU5yIXUM13kIkOFczcwppRz3rJU6pYlxzO2rnbVWl14OldT2p0OoeoZo+nmY8fe6RFcgQwXuYBHH0EGcpDg0VB/3lUhB1UIYBmKpIceRCEIAU2rWrVXJOk1pA8RTyhRAWe/shejEi2omyIZSL9gRCGYLAgmqeQehYCWPvRhlSDdQ1/8GFZNigDTJUi7yEv/1sQi+qWosMV0WM1mRkBjnqya6TPSAeXKsPoZYK9tnVlNfjkTnWlpaDb5mS0t2yUxGS0lwcRR/N7kMzfdqSh8Wgs6EzIoFJ6wbGfji1gMZZZBLQcsgYrhtHyrFXvypS6RolRdFsVcweAtMQcFFuASU6yH8o1xrcooFF2VUVV9t4od1S5vQGXSkmYOor/yoko357r30rGlN0UjGteIOu6oEafhiV21sNVfpa5RkEaND+6Uui6C7SdBeyQQUo2XJEcqSKoGKx4kA/bIDC1Pw9jUKlW1eiaA0WtgKYHXkE4ikzHBVXxF2uVcEcikBUjsY3ml7Cr7JTG6LtNjq3UZR2rZ/72KcaxnFanJTWaiP4nEZJhm1RFJVrnKHaGof82syf8M8KMY0zh/3Zumi5+JEp+0bEklM2aTcdlajVwMSwwZoVmA0ie1iM0pce7aCakST7VcZZ8QOJQ9mYMQ3u6Zn4uKG2CAuJd++iVvkwripKwLKiRmN9IcRZVEudvd7WL0opZGDUg3fdHHkddxHKWNeh8NUVOP2r1fZKmxxOgszvFUprOub39nJzvV2TrXewSq7dRl4AET9agIPiqAgifi+1hYxFQNsYU9nOFHbljDeOUqV1U0vIENqGGmnYj9bIJVMqs2JEX+2YKy7BEr2xh8QNYsSHCcvigvRN5nMsgnZ2RBxv+6aIAWMZKSuCk/l6x2JvJb5fkIHmWayK/KHvOYi2ycMpERGUwNJFlBFEsjCFbkszdSU5PBXHEM6klLdKLa+MhSE9viaSnDnaefUpgUGXJFT3p+pwn5ohe9tNAvBGXu3P7Z6JOiWm9Bl3TRA8fpT3+3cU9M4hUrnXTyEk6kHk015tJb9WFdN+vuhS+zykhf9ZRH7LXG731n/dM7lh2pwgaw7Xod4LYjdcHHRleHgOfHYyNoeBFKXiKTp1cMO7vDC0pABRBQgQghHmgVwCrjAV/tR8qrKXOFkTaPhDOMk1lkGDGnmIpsJM3axEZSirFfAe7wn8Wb39mjUPjOR78C7iT/l+WTpUmIMqX67ZjhwFyQBBjuMc1eWa93ZXhiF2R8iKeM3DWh2cwOMvuRwF6C5ZsZUQyL4gi6DIPb9yBEOHk1cpq85AUB28rt+cJ1tgVs8aThnvbZT0Hb5eeIRgzQi8jeoE96iEb/VKZlZUWlgzqmW5ypk6hO+6j/ixzzCg70SrUtspv2UqlW87qvSxabYiM4mi/2ILv9UrvbqbW1Izb5yKmkEjC2Szv4UBf70LsQQRe+SxC+k55ji5cJk5B7CZDk8bDHezZpI7zDgyTEU7zC4xcGYDyu0isPg5cLk6AkwyqRIRpbuhLmm4kJIrJlsisjWR90U58Z4TKO8SW/ypno/zsgvrK9oygyLPtCA8Cf6Cumjwi90Nu9avIYw9MsCeieO6yAgruyKwO+4qsfZEo+mmC+hAPDNLO4/GER/IkyHTkxo7GfjOs+2RrEkxu/q7nE8csKmRs0txgUrvAKn6sOlns/frohlgOLwZg/+muuy7kuBNQ/SuO/ptM0AHSiWdQoB7Q0wzlAAuzFUmtAkkKiB1y1r4sj9Pgc9LBA/eIpS2lGC6wvn6KpmfrA2AFBBuO1a7wd/4gX+1gwb3SwA8m7/TAIhLEXfYEQdNyXDmM8wyvCfRHC5bGrIjy8DFsQe7xHfJSAeRw+C2mrCeu2BuKqlIkfZ9KmMJlCoQE4zSI+Zf/iw+L7kYKjkPRxONIjkpCJsroSPvphvj5MLHSLmdXakR2Bw5tQuN+bw98zAH3EQ+BzyIUMPns0SWTCN6FpvsEqMwICicFKLIaYmTWpktIqLVqKkij5iZHTJIWxRHRKOZJgCtzKCkBxFK3oi7dgC/YjRaz8oVNsm4Cyv1S8FK07Dt4gOv3DoqJLwNUIwKVDQPDilSsStatbwOrylfyLy2AkxpcyRgyUwGYUnWoUsM95NWsEtmw0wcF0sADzD5+6NQYjsPlYsBUstrtzEHuBQXwxkAeJEA+RF66qgCCMkMQDPHZcPHs0PMP7QdTUw9IkPMMbQmtrEOhpCV3Cwp9hGZz/OBLA0yyHsMK26kj0Cb4roz0P8ZEBopGJYcKVob43BMnEijKeZCXEEsnjI7ji80OYBE7gBD70eUiYPIAMqBlaYr7O2rHs5L2YKSYs+58vZJK9MqYq46YqSSb7CYqCqE9v6kkP6pOpwJMwObI66wpygpRIORSwWIryqw4DTRuxuLlSHMXkIij4U7T624ue+0pRcai+4JRJGzqylEW2NEvB2a6ImpyKEim3dEvReMD0+g2GWtG6pEsVxcvEIKiYgkZWc0Y4yq+/BJ05ap0+Kkxc48DYoTuj6rVpLEFt7KNwvI93ISqnOqQOKaoQ6ReumCTQNJ/PhBAjFM1qM83D81Iw/zWA0xzTClE8oLGgD4PEbzsSmGBPm1iQgViR35NIibzHl3zI7exIFDG4KyO9jamfXLJThykgm1Em9HRO56yrHdkY+anOdmvJ7LxOR+1IPjwAGADPHeE9YKqZSF0mTVXEAlrDUN1NphFJ14K9RnwIo6RP+1Sa+yyJqjEnkvNPoJxVskKUQ+kn3WK5rGmKU4SbeGqhrNwTGZK/VZy/wIBQuSiMUnE0Bmyv84LF8sIoUns6jdqotIw6EkXR0MhFumTRk7K6GG1FSJNR0PFRZIw1Hp2vwXQ1v0S7AoM7IJ3XJG1Sev3RAxuXeF0XGCwYEUlHCDGIzFwKE8mqDCHHrBLYyv8svH1UK3xsvB8E04gV04it2Hh0WBULRDl9U46BvdcDPNLaCYddmbt6TiDpSD8EmeBb1BvLq/MhMny0x33bSPEkSMECmcly2IXkTj7sWQPIAJ91VATwPZUE2qBtTpFcQ06tmZG0zknNrKRNWSBJpVRyid+jPvo5w9CSCZIYToNEM1f1T7EdRNBiiKWcCUFBm6Q8OU38M1/Fs0jBM+Vym+ciVmFVLoOa0LbJm7bRUGfFUC0KS7KUVsN4S7S0Vk3zxWsNNQU8ulYMRnBdr2G0y8Hly9FxqZ6awB7V0Xb1Uf7CtXl1THzVV2LrnSYVXaNC3WHTIwKDwfuI0hAJkNglx3j/oSrp0RfJm5AEA03b1dJoc9h7NMIMOc2KpVgJMLzjRU0fNJ+XbQmYtKv0+TCJobEnc1nbxCtVar21gkjy1NSpdUntvEO7IreYdc7ojcmAU0+C80d87Fmj/dmevUPszAChxU6nlZ9LBaY1BL4Yo07wldQ1vLJMbbfsdLGdDMNbSq2kBTlJHDkHpk+mxCCnsBNC4a36PDnesUpNXFDnUlZjda4Yilufg4uaE4x+opsgWsVlHVfCJVxsdbq3DK/EVUtPe0W4zCJwFVcWflYeRikZNSNlSVe/BDsz2lE1si8TpMa3u9d9DbbEbGLRdeIoLky98yPeqY9ySRcE2eLYZdIu/2ZS6SkYdEG2BYMke5EXqhIx4N3HIFwQ05TYoT28nSVet6pOGju+9sUqvtLOJ7OxM10RgFMrG4POb4vaPSRJ+T3a8bXHnd29PL3HX9oYVGrU7HUriexZDojfo+XD9/VZAEaAS6Wf/g3g/u3flqxf/m04jwS+TJU4Xxqsm0jUKpyJgGxgW86RBgZKWF2z+sQStRghOcEaVBTFpqiK3iKhsCFFvLULCP2hHOIhIIrmvoAuUpnQsPRQFt6/TPMoXUzcWFFLULvhyP3WF/XWHtacvARic81cJP5cA/NAJCVM/0pSthNBKY7nKdYjoaJncgGk/4DB2gUePVowcGRS4DFY2/+NF7vbzIIwHsmzkBxsntdVYx5kWHb0TIz+Ujfe6N6zWDimX4q1w43WSK2q5FVSps/DWFeqw5alsUcW6etsWkq92pztw+qcVIZDkRuTMVFVWZ/9TZ+9Q6EWU6L2ZKNGWZiE1Bg76kitzoNDakrNLEY+voAbyubU2vgpGtjSEopLCJ/cWimkVa2OYKHAiIPRtk9c23YKYeFyW7iZm+YotBFuLgv9ymO1673omw7VIv77NF8MQHBmDV4kNRKNUbGcXL4e3BzeOneFqWPkS1pDuyWe52mcYgYzHXuuZybWbHllXeopMHsVqsgUR9ImXbLAQel5HtuVPIL1EKtCCkPyjwL/yZdC0mK7UyRp4xd21Ec97G3NktjkxWjfk1gvJerUDL7H82OJjKuYFVRGplPiI+mp5r2kbmrq9l+hFVpKVmU+RJGedYArA29PzoChzkMxBWmm3mSoTm9P1m4CTiw+JDhJxWODO09R7s8qM1WJgK2dUYrq+zJazU87iy0ueYpgvho+4QtiNiEO5hx9ousHl+u7vpTG+Kdj1euHcmHEjeElkmEm4nAYNlxKQ+dOeVG7XEBx9eEg3st1rtGzk+wmbqO4o9cjBVJymeLUdWLbIeihepd9Bu1iq+ITPJeiehd/MaSATXKCtRoZDBAYxEEbdJcLMyTYRjZ8Ycd+8czi7T3D/+OAChhu4cboN14QDhha+pXj49NDjcRDBvC9rWLuqZ5qMqW27BVT3l7uR61uR40xSE1qR5VfosXOpWbv8VZJCSBvA8hk4+5klfTZTu5zPkzkRk/vliQ4+c4s+M7u5w09TP9qG/GsqT0yFivVzrK9hgugBxat6hGnVjVbr3AKV1/rFmILAt1bqlQUeLKhCDVWsGQ0CrfrFNaUDMfmyKCMUgnsS2MVExXRXmTcZ/UNFC9nFzVsFT8jYxRivIzs/3K73qkjAMvsohrybgfd0i3deP5RfT53hdbi1TVyMA7HcMTMQMojvdtdvRuY2L1ScoQKIkFj4qkq5jkQZYuk2UZy0v8swiLUcuTVaM9M3jIX6jzc6Dmn796jVD0M9Dqdw6RGwzjXx5KGXjycdKCWVDdf2ZP8ZKaeVEI/aqNFdKC9QwQAaY9h9JRPb0mX9PYO4JPtQ/k+WT88yUb9SfL8Q6aFk+rD1FIlMowApqPH2du7vTSrVQ+yGrJu1RGCSgnGkqjYSmMmP/Qbm6vAi7IYLgn94LLv9UxZtOgKDA09IsI9dsloVs5oDO+CFXAer1h8nBZebLlcbBJP5xZn58jGRn29I5q65xOku2yc7MKPVxtn9xTM4tMOaHmvYtl1ci12993pxqNyXd7tV6jKKirl9+eRkOGRJMF7tmTLwWpLvMLTKjD/RV4vPfQvt3OVRIAyX804Zjii9T2i9Rjf//mbXkiOFNSXzM7jCz6YD3SH/P2XTCXsXPkrywDijX5PFm/sZ2pAP37go3mWn36c79mhZeql5nOTxG5KTiX65vTAqiZQ9yWmfaySgXqmFU8gOfo1dK1CVbg1AQgECwgcIIDAIMGEBQkIKFjwoEOFCQsshNAwYcKLBwQQKMAxwEaPBzxatOixAAGQAiAUCNDygMuYEGK2rEnzZssAMXHqtJnzZ08AAYQCKEB0aMujSocyXSp0AFEAUqdOHRo1atOrVKtu7eqVK9aqTa2SZWpWqE60TtOeZXu0rVuzOufSpStA5128dffy/+27N6/eu4IDDC5MWADixIoTH0acYDFjwZIhU3Ys4DHmypo3XxbAoDPHygw5d85M+XHizJgJoE6g+rLr2LIff07AGvLrzAwS7KbN2zUC3gyG72bN0CCD4AeSCwie3PXz4NIRfJaeYPrwCgkqMOBOvQICBODHI5AgXrwB8BLSpw/vHrx7BAbKr6/AXr798vMN7A8/X358/bUnH38EGrgfggLyt6CABzL44IIZRGjAehQmSOCDDiyooQEaZsDhgxKsJ2IGEki4IAf8pdjhhgacOCF/L7po4Xon2mjAAjcuIBCCABb4I4Q8EqTgAQsscAACRSq5444GHFCkfEseyd8BTv9a+aRBAxVJ0EBZEuAkRgwsFxFBFzUUEZoYEbAmm2gutNFGa4YGJ0N0NhRASiHNRBFIAezpJ08t/WnTTjkN0FOhO/Vl1FhvKeUUo4c6atVXUpEVFqWVhnVVXJaupVZccD3a6KSNhgpqqX6puiqrrfKVl2GxEjbrYLTaqlhjliF2a66aNYYaaK1tNpptio2mK2iW6VZaabfV5myztJWW27Sy9eYabJjttq2wtgGbmmeOYftZsrV5xhq3vxUX3HW2OdfubtO1S528yQ1Hb3fnbQdevvmG12958Bngr3gM3PfffPCJZ555FUgAXn/umVcexT9WjN+FPh7oY4P/yZdiBRL/InDjgyvOmKLJECYogYYccphiiRKuaKKJFkZY4Y0ygvgizDPCgOOC68kn44wL8Gf00RIabSTQRz94IAMLRF0lk08eyaPRVS5IYJVFHvm1QF1fmaSVBGj5tdlbRoR2mm1L5DaZZme0ZkENzcnRQnhzlKdNM8Hkk6A3DYqnS3fVZDiiQCW6+FyMMiVpTkWZWhRRjEY6eVaXPqppplqhemlbS40Veuabimrq6J+/5Srrrf/Vl6yx8zqZrb32umvs4EL2a7KkLXassYg9+xhD1Eq72vHQIg9buJhhmxt0saXbXGLc9nYZa6ghgBi7oJFr2gGPbf/8c9JfZ1l1zf0WnPrh/1t3nb3SJTewBN09/J13DEycn3zdpcevfQiGHv7Nh2H3MQ977MO/hlFMgewBUo+CtjWbIVBBGMoAhkakMgq9qIMzkhDRZpQh/jSgQyWMmQEaIKESGoADHmohjCiEMhfVTIQxAyEMSWZDlRFtaQsyktGIJqEKCY0/URMIj6j2pCfNp0kM4tqVvtY1JE4JSWJT20DYpiUu0Y0AYtrim94mxoWAkSARsVucEFOnNe5NAAXYU+BY8jc/+cSNPIFJSnKSEsL5BFGJ82NOCjcXyp3Fcp+ynE4khTmnjGpTnvoKpTr1qU6lji2lw5TqKFnJULmuk62rVV1kJ0paLeZWuhNWsP9K6bvOkCsxo3llZb7FLGqBy3jNm+UsnyebaeEyl9ZTV/TSJT7qLSZ6wJnNtK4VL/OtD1u3UV91qjMveFEnftcZ2MDEk5/ukOc8CPSPAr+jv/BMbIAF1I99GEYxDjysROlh4HnaY0AY1chiGuRgfUqEH5GpzAFE5I8GUYhDd6KQQRyqZ4VSCFAYpohl69EQBzLAQhVpKKEEddGKQOhQmeXwgzfTIYQ8CCGkbTChFrsSSpkEICcWSKVQkqKTrugkKjZxS1P62tSyeJCBGOBLY/wpmsQE1IaIiQEIqVvd8nS3OuGNTW4MTeD66BMA/IkniVIcoRZ3lEPRJZNokUsiF0n/qkZ2pXOcI5VYJ7WWyU3yc6RD6+o8KVdVgdIus7trrHAVGF2hsq+4KiZliheawK7ylLcxTSptqVjeME+XjX2esnwDTGFua3qd2Z5ihPmb33jGWtJzzruWuZvmVMcgnrEOvY55r+gYbH7JOc93BhbOhO0nnPG7D8TUU0ADCo1hFWAnffDjTfz41kUcSygC85POhZ7TZgmCkD8XWk+OwpCDMYIuzojIIRQ21LknnKhzJbSzGrmsnjR8oQitO6MahvSHOJSgyv75xPAwzYdGoilJEaQ1mBbJSVMKG9moFja0+VdqX0ObgaN2VKCakcFwishBIAIRoYYEj8eJE0YWchI7/+ZkcH8SilQZR6g+AjImax1kUxxXybZecqycO2sj5QKq0YHVq5g81encOtdP6mVWPgZMYF7FK7yasq6kLOzukHWaZw4WyeJSLG5SaS7VxAZ7VR7tbJg8G+H45pdeJs5mmZeY8W12y2Yuc/nKrC7UnvaYqXUOcaqJLzmL8zwVcBjFqPPNd3KTOjQKjwO/2Vvp4jm59TkPyOrDTvPoU0XMnRmFRlQh/5h0g/HNmYVCGEMKuYw/0UXvDNnrURpaKLoXJa8MGQTSCWH6RBbdWXobKiOabdBgGLJ00xjEJAPAYGlLEjCVcBQlYQMRp/U9G5YSDCaHwA1LcMuIQy4yYTeJyf9MeVMTmzryEQLMRHAy+WNUr1riEYPbJaLrKo1RjG4Wt7VSZt3Kux9pukeWDq5ifavo1JpuVhl5x6H8MZFpN8rc3c7Jm4Gy83qXGuA9s1t8VRbEvdW84h0WshL/jDLVbD50+QZdneU4dJh3rWNuxzXaMTO7nOOZ8lF2fdsrH2hLjq/Vyrk7NufOnfHnMP3Zq371oxegxdkeB6onP/tjz8PWwwH7ZFpoJ/qtiESkauNeV4Igai+MhvjEFGlsoRncoAe3208b0trTZmeRRa/raoB+2mYvfG+MssvRe7poaRL6WYhmDV1L29dpuUZa1nAkIbEl0T/yWVoSYQpEgYBRSz3/RXCVgLq2n4pRIhl26vZgGSePEAQkJHEjHvtGuD8NjsRAOf1NUh8ARZ64U5djd1rfHW9HgqVzmouxp+Baqhm7tff2blW//T2XWg2clEQOuME5s7wpT9x5kI0yYFUjWISz0srNmw23qo9lYzITmRgP12gxrvGRL/PMs2HXttoMzM1uK+as9Q6/HnZnAD4sOYW+P34CCECbZ5NC8WngAGXAnaWHALIHB5SHO4nIokkAO5VI1D3gA+Iai7TIBGJdhaQMw4DQyMgIBuHMg8BdEM3I1X2go6WIP52gQpUQCw0UiETXRFVUy7jI292IQ6VICc1Q1a3aBTJIpW1QseFI3wGN/w8BTQbk1xCqFBUlkX8liRSBTUFkkUP415CkDUSsiUD4lE1xUUJ0idxwYZp0URctRJnUCZ7YTUmkBBr2kUkAiuktThu2IaIQ0okpxeutXuyxWKaY1e2V1YvhniV51emQju/tm1zBSo8BGesUX14VxsCpku4kn2Ysn/VNGTLZErFEHC5Jy/csVpWZT/mEC/uIj5qlS2hxVihOVjBpB7ewS2yw4vmpi5jADywKR29siyq2C85x0/zlCzzNX8AkUAIxkDwNkJ39HwAC1wEiwAEeoIn8Vgs5jAJG3aJNozQyoDWmHYS4kKc9lHNZ1w7OzBCtEEYpVAXWjNixiIYgzc+8yP/LTMh3dQjLNIADqGAKQdQN3qCFNMB6sFAM6qM/ZcB7bdeIcAALuRAD5qCLwJ2FyBoFSqADLICGrMBDPmTTAN4P+aAQBohKZc0S/drVWE3XvJSXRF5C9NQTctEW7YiaZJHcdJGWoARKgGFBoMSdxAkenSGemASHxcQctQQaumG5pR4cPg5SpArmsB6jwB4jyZ6meA5V5CG9rdVXLSXmVGXrCR9WBpkiBtzsREbBNRlYQgbwuJIaHY9jHFYmJla0nCX2CI/14RLzhQtaZov0fFyZsUb3sCL6rV90GBNdghl3sN/JpRnJkdzJidNqVVZlsR9vgJbN4Utg3pnN9UvS2Qf/MwbX/TzMMJpTOMUHA5nHMipjAbITQ8mQNS4gNZ5mNF7jDl3XyNRMAtoM3KFQjZhICe0jjXiUidxICcUgrxGhR7mTCJlgCp5gPDaAPjIgcqbQh9CMQ6mghvSmPg7Ug9wmbiaUydjIP35gbYpji3BjBaYgOgLNz9hXEf4Qj8RIEGVNkijhFcGA1TAe1aQUsClJ2MRnFrLkTqkNl7CkmmzJmsSk5TFVnJQhn4zESjQESfSJVNlRHvmRUAKl6qGYHNaYjN0hhm4OWHjFHkYlH+aepcDFupUFHq4Y6GQlihoGwInSViIiI2rGWIqGGtXSKVkGWgKLw6XSbVAcKm3P+EDL/4xSjyhumceVn/o8jyuKFpedGfkt5nAYU3eQ3Pu0i8ltx3NkB5g9qc1V6W6oYp3dXHbknL+oBzq903JBjGYWGsUkHWyNx//IkDKGTNKhZtQlZ3JeIzvl6Z3qKYmczEJp4Knt4Aet4ECaWj6SWs+cUM1oY8uwjAThkECeiEFGp0SlkAqyDDupoERtqgqRkKXCY2/C4wlOqkNJwG3qo0I5aqc1Z3pNIHoZVKW14Nn90A/miNHgndP4kHsmSREO4ZLI530ZDU0JmJG8FEguoYFdodWgpE2BkbK2iUwihEIMFkNAALeBXoKuYYj1ZIlFKIQqTl2AiiL9IV0k5ViwXoaexf+G1p67NSW8RSXoqMWNoYWhlFhcoShdceUoIV9j9GsjBmlYAmz0BQ8mtkaMNhlajiWOPlwmbhkxnRlDfIZxgB/FWlxteMu4MJbDmtnJxYYqammU1uJg8oYqdqxeTlNgkmyX3hwuTlPN5WL+jIf96c87BczSYVB/OMydMYxvCaD8/RbQzp/PKiOtXaPRLqBqZipBJmeeishtuiCNVKoNOlR1yYwK0Yys0aNwxiMNfYiLKGp0KhQKVtekmuCk6iM9yqOpzmM8OpQDuBBBShTc9qaIzCN00i0KyqPezuM8iqc/Ymp0ih1AxkinqR3VulqlFu6GGMkKMK4Q5lpFXmR5CmH/fXlNfB7Jz2jNfFJNTjXhr8XU411uF/qUgfWUGaEJRWQb5YVRR9DNgfLEn/yNHQ1OhAYS6tGE5LgVV6kbhZpbUaarWn1ou0LSU3pohz6lpGBFun0VuuErv+nr8f0r7uAO8hHssyifjg7swobGcXAvR0hc8BisWb4GXe4SZrli9BQpxqovL10syBnEkHLsbHRsYEYp+qHfyAaHdkzp+8hPyZZcyN7Zdujva1npnM1szs2fZOpsN/1fARqQArUT1D3M0i0dBeMZMy5kNDZtnjZtA3AACKOtqa6mCKPqnkrdpFKIP57I24ZqzWhtC/2j2vatqX4tN6ZtDW+UQVZqpaoQ/9qKbQrG4zwurUT58IfM7REj597KI9y+Ld/yLXLarQPwbT0CLuDKoIkYZwxqFAcelG9eHYeswOP60Ing6gf2HRABYeClVOQCDdYoked2zdUcSdo8noIZmE9RmBlpyQaQiduAIbd1xEjkCYPC7l38JByC6+0SyqGoGFiN6CA5jrkqpYut67s65R7OXh8+TlSga7jyBfM6L+xAb4sWmb/mDsECD/gKrGKgErUWy/cZR7F0Ly0zS5AaT218j2WgFvQwk/h5XMgVh8VJXGMeU/aY35b1hnaUbJpFKWO6rJRC8zJzU5TCbMH8i3jATzXt33gkMM75FmzFR8gYnTKu0zhHmv/DIC2dRhqeJm0HnyYIE+QIt/Np3qkIZ2oNX+072iY+iaOqAi7aKrEKGuTdum3cfrDdIvEHq9DSLjEUQzFB2u3eNvESR3EUP7QUNwAIVDRGr+1BO0APNyc9NurgapoNiuoIGYAYAx5FivGJ5Jfared5qmNGEluwEdtKNRHg/ZocI0kVnU3a4LHpTt6WQECXPBsgn0Tr9smDDk5KPNVMNHVdLHLthpUj7+5eMG/k1CslM5Il094lu+uLHcoAGMUbPcXqScUkf3Ioi/KqlDJcm5K/2grDxZJb+k6ukEsse8vESuwse+9hCdYtaWzCOZ9qkBm3yHLEph9jI48st2/6KBP/mUHWlMovyQaTZ0XHNPPyyX6HlQrwNO/vvNALv2CpLvaLmxbd0AEaBoWmiZSzAMZ2oTmgnJ6mad6p0yatcipnByutPC80Qf72CAP3Qg/3D/dmRD0nEH9xCn4IQKrQEbdwDE+xqkaUD/OtRM0jpxaxEs8jBQh0d0f0deut3oIABTiACGi0RU+xQ1v03rL3Q+ttdquQExNn4Iqth4B0h3htQs6q2cUgRLIIDEykCFkkCN2qrdoqeVIuEGaksD744eFIf3lk2MwUk9AxSwo1Hj+JHlur6zYbQdCktVIEVK8EIReoTcxR6bGhorxh7rYEV0EOWhOSjCNFXdR4jSul8BIv/4835aW8EZCzBJAHgAc8BSW7tasQ3yGSMl69KPVKxldCYiwVz/AotlwCNvcuD19jRvgM9pO14mVpolzOMmN9H5ax7/iA4rqg2WFfRmXLr5ddhvWEh8p6hzZDc5dWKczO7Hcg5mQ2zGPCVmVOzAEqkAAuYwaE5gHq0ziXB8qsZgNGGj4roD6+s6XH826XcHAj56YTd6cv7aZvtxJLlEHXd30ztHbTtwsB5HM3MUXD93qPN3jPegN893rbOh0gZ67LY3qLAHqTtzzO40ar966n+hRDsXrDuna/baKDdODS9xSP5xZL+9n5Jgq4CAp4LYGL19TZ6nn22gL02nkqTa/ymv9FMgjhpbGUKEmw7Vp/ZZHRmE3UxDsdO5vlfSGARgRJEIS1MnVJcIRIeFu4Dfy4uaHkNPKM2yGN23jC3/jv5vgi7fgl66G8gSglVU4BPMAGQMDGb3wBlDUEDABLDEBZl7W+gZiiIPnw1Y5fFJ+PvY6TL1xmMNnB4UbCeq+Zw4Zie8svl/mYW5mWMsv3/ShssKJjhE/6ygbSe1xwcNxpnUvTS0uas8+V/oYsK6mXbdYtxste1q+XfjZrzYu94Nyew+wCUzM2PyaZFiMEd0wELxoM0Yw7NVQ7o6o8lwg+h/A9M2Bwx/MHbzqoLzRxDz6nKzHgD3HhO/FC822oJ/5Du5D/D8t3ez9xdwv0PKb3FKf3rNMAB9AAp3t+d6f3Rm+0Awx7rZ++rTcADyQ76cvj6jtA6qt3sgc77cO3smN07Qc7155gDHZaRQGkqlK74NXd8JdneZZ7r/FHr5Ungqs0jrgM4CEA83sNlRSr9d9UFopkGR2AtY7EH3cJGNWNteJkSfiJHYVeR7yRwAcKi5Mb+yv8hb6FI8d/7Hly8U788H5o/a9eWQOEhwEQCngoMLBAAQgECCocEAAAxAAQI0YMUGAiRowTOXb0+BHkRwEBRo4MybEkSZUpT05MWVKAAAIxGQhIYHNmzJw5Y/b0KbPnzQQEbtacWdPoUKFIBSBVyuBp/1OpRG06RZAgAVSpCHAmOHDTZkywYZ9iLVr15lUBV69i5cqAwFumXLmmdcugAgOoVxnwTeAXKtSsCSoMLjyY7V2+hRkTxvu371/JbPNWkKC3Ml7NlS9rxouAgYTKCCQYqGDaAALLqSUgSJ3BNWvUEiRkaC2BgwEOpBHsxk2bA+0GwIcHD96AQ/HhyHFzSP7cOfIG06knrx49+nQaz6db9y69QYbp4jk4mG7efPbw59E3MO9eugMK8N+/n3+/gYj8+9HToU6dhv8aCJA6/UBogIf82jtQvgboEGE+9+Z70D8HFqSPPvTqszDD9jz00D0L0ZOAPgMaMEBECRwwEUUDMv/IwMUMVpyxRRdhcHGBDBYwYMcbF8jxxx1/5JFIH3kcUkgiF1hxxwOS3BEBIQ/gcUoknaySgAWydDJLhrxc6IADCBCTzDEJONPMMsfEiIAADoDAzTgLEABOOgUooE2G8AwATo0u+hOjPgHlaCM/C/3zz4omUtQijiLa6CGJGJW0gIgeshSiSisCgNNOKeoUVE4/DXVTRidVtNKDABhgAABSReighghK1FGJMpXIT0Rb2lUklXxt6aWVfj0pWJiCCkunZJXtaaewalIqLKKOmgrawaRV6lqmtHW2KbP08uqsuagSiiyiJBusJrnWmsystr6K66+mEnNrMs+yYiuytqD/Kkywxx7ja12+EtvMsQoKwxe0hPsyWLPOMnt4s9HwMk01BFSj+DPRULOMt9os4+C02zI4LbfWgtPNst9K+81FA4jDbTnnuMMOuuoG5O5m8LT7TjqeuRMPaPjOs5m8oUGkIAMKcK4Qv+nmEyFAqKfTb7oH96N6QAGpe9pBqilwQAT7GkzQ6Qa+nrDrr+ELGkQNNQyx7bg9pG3F8Bx40QEVDWjRbhnLa3HFFWCE8UYYczTgxsQNQEFHB55kUkcdERcyyRX29jFJyV1bwEnOPf+8cwa01JLLMg8owPQ0zTzzANFZR5MgOhlyEwI434xzITf3TKjNQAcV1E84ETWU0Iwy/zp10Y5cbTR55JG/tNJFQx11elFJpWhUSbE/VdWHWn0oVQgeEv+g8h91VftBD+XVePZRep9Xk0xy/6Vijx3rp2aB2h/aZ8vFFoDjmta1CJgVqTjFJkrByl4MmK61bMUuYaGLUNAFMIGxi13v4soDJ5gYfPnLYl7py7oM463GeLB1i9nMCg3GsLwk7IWgqYDC8NKZzTgMYjPUYWgsRprP4OU0QXRNEG9DGo1VYGSmsc0QKwCy4NBGZckpzYmOA7PvzAw52PkPzq6oM+t4kWjgEY8DyiM0AZFxPecJm9GchjOzvfGN25na1aKWH/xE6D1Dg2ODPESh/EDojU/Dj3n8U/9IPaIHQg44EAg+FCJH1gdDHDIjG99mHhapCGhkvNuMAiejJbVscDPakeMMYDkekfKToxQSKnukJCpRiXIGuBLoPue5Lo1uTKRLE+pUl7o0iWmXYoLAnRSip4sEykuoCwABiNfMPwGveIfaCKGYpyjlIcqazdOe87ZJPept6pueIhWomncqU1EqAAMoSKUg4Cp1IuSY6zMUqtrnvvjZ0yX47IixYrKSZuHvJz7hSU9qgiywDGUqB5QJQs8yrW1BRVoQjcqzyDWUumwFLet6YFoSKBkGfsWD55oXSGVCl6aAtF5ZOVi+AiaZxhAGKwf7S1zWopYJ6tCFBpNhX/SiMJ//YoaFLgQiC2VYsRkCkTczRE3HnGga0fhmY6KB4hOd8xspDqc2J4qZzXq2s65yNTtKw6LNvrhFMcKnjOnR2lqrBsitmY0DEbpj1rKmH7tGjQYi0A8FADnIvTaIAgcSwYPAhh618TWQb3Sr2eTDgUKGTT+GRWRhB0sfOnBIkuYhW3uEBrZIPhK0FioPBzK5SRTBQJSDg9GMUFtKIq1ob588ZSqZFFsiEclJUTqSLJEUpc5dCZZZEp2YSJc61PHSl6zT5XHDxEtlNuSZfMLI6e7UOz79Tn3ZHRSgMNIo9NXKItacVDedF71LbbNU5Bynetf7KW3aary2moj3EoI+jKhT/3wNSUhH9puQVrHhJNPkr3Y9Qjx9HjigCRbLgg3K4IMu2H/QSmhSHCoWiT6Loktpil4UWlBySXShZNFoCDlKYsRMZi35MgsJPZgunrLrgytEGE9z6JmjWqwvOG5d6x5WGR//NDMWu4xlJqaXIRuMYpcRDZFTo0PVtHCGFdsYa6RqHJVBEcvG0bJ0SHScLnZHQOpha4DI3MabWYdABBorWz8rtAi9FY6JTaxc9wohqQXoPhS4I1/z2meo/XnPevZPns02V7k6ra96bVqCKLRGBLW1AQdKkFvlQ0jzHGhCXivQpd+YR0WqrW1r26SMViQjFK32RTHiJJNYvTdXp3Jxs/8lJZEkNyQnwdJznfPt56L0Iy5xrkvE3dKaFMLL1enSTHg63bKZXeyEzGmYuMvTnIKXXUEBz77Gy9Wt5NvtbkevUNzknjmr117rldub4DQnebtZK3YCQHwBMIhGlpe+WxGvVX7KJqDw+2xR4bNYwgoJPxWcv2Xt7+APBgpCpaVQqmwwKQJtME2kwq2LgmtcBizxBnuyQY+3i100takIR44wyLBF5PDy6cn1spmEFZWnoPnMjXv4ZJs/ZqU7/akPLaZD0whx5k1mDQMMoJmiW2ypSR7ibHqDxCZadapWXQ6JuvycMZqZrl4l0H7SXKCmEWg+YNfO1OQooK2zuWyafWv/X+dsNjybzc6Blbue4ahnuist7nzV+97vbndD3vHPfuZz3BXNdkLrvfCEL7zcE/k1wjKW7jwYbGDdEzYGhdptIsKsiEIkoxCpKG8W0huNYEv6JS0JBbF2QOpRcHpSJi5Jv/X1j3Z96yv9unSjK93rhMnM1IkJTwth5pqGjyfjJ3P4y2TTMNn0J+v6zpnpnK+2py8R72nvvIwyb6a0L27rb6/c7A3nuc29PfSaf7zhpWY74WQQ8N03fctzlbP1++zsp9P++fUAQQQSqeQBS1iCZeCWyeASTH8O7gANaoAQ6qGqQqEIiuIeSAILqitoilweCIFMiqNiwqQshoRECiu+/+IrAgZZQipfYi6EQErFZE7mMEM1Yg4GdS7KlKrnnkynRuOFNGPnjIoHocyoiqg0QqYvgjA1UuNiZqg1NsY2nM5koI6qfoPLuopExCON5KjM9IMGuq7PyOzssqbMyOzO6KrM/mPrtu7NyubtIqTwBgSQ8ooCvrDQAA0E9o4G7C6u7M7u2PAN9a4OIWTv/BAPA/ENAw9C3LAP9czODHHwBhER+coPCbER/bDRrObR6O5BEmTS5lBuKk3z4MYT0cNELGmTOAlwShG2Us9yWE/1gmS3jMRIOEdJZkn2OieXcG9LcGnH4qJLxqRMlutMFuL48KT4hhEYD+CYqsv5rqtNrv+Nu9rnu4in3jBl+7yPGrcpeqjxetZLnMzNetAP/bjp/zyCU+JNne7LdyIFesrx2TaAHdkRAjYgIciHVQrgAeqxHmEABuoRAzBAIDzA3uxpfnZlJpaJJOaEABGu4AKKKiTuAIBiJh6SATkQoxzSpBRyfwjAgRQuLVRsxDiIA+liXuBCpNYCI1OoJBkghTyqxV4OXPDlqPKi6B4mJovq5YSsYnij5pDQJnGKYmpwiHqQNJxMp1xDyEIGCIkyCY0wCYMIRpAoKG1jZEpjN6zMOHTDRKhu6qJwOdBuPw6tbPTuPCIE7OAQDrOOrsJQavTKruaqDdkOzxLNDQuR8GhgAqD/Zg/rcA/zsg4nABHzqi4RT8/4UjD1cgL20jDvEi8LUxAb0e4AETDlUvL0bA7pgALoYA5BQNHmUAQi8zIDSwQ0cZEeDQQui5E0b/NEhNQAZ/Ray3Jac3ECp0U8yXFmczaVxHJesdZ2q0oWoNdmKddI50fSxJZwCdiELZeUi/i8ZPhO5xeJ7/iAkU40wk96BxmNsZmksSJypbsuIjulrxq/8/uikbyykRu/Cfy+8fyqMRwdxVLgLVX6K9v8sRwXYAMeYAMW4AHwsx4jwB77MwJWgARYYAVYQEALNB8fgHzqzf+KZ1V25U5A4kFTAiMQ0iIP7iJjoiEf0iFxgkOhpQMl/3CDGlIAGlJES9SibGIEJ6in4AVePJKDQBID38KDSBIBdBEl4SJhJuPlYu4A2CJgdHDIbggFa67mRMMnjdDnatBgjghJe+g0kirJhJIoizBkOmbpptTVeoM0mC43kMhjcEM3gKM2sspFcCNvoLDLtEo6rpKt8oitmmat5KrrsKYs+4zr2DANAwnQEu0+4vIQoaYuDTFQ71LP6tBQC5Mu9/INC5MvBXEwKUAxIVVSJRVRFVMwD1MQAdExH9HuJC8yKwsEeEDyMFMzR5UCTJVUv0YTC8s9GKk0GQluUNNCZERF3ANFGMdCGGcFHMdyHKC1aGRXF2dJalNIGGcBUu9JYv+J9nwtTGqpWW2RTIgz2MwEl47T984k+LAV+NbkdIpRGOeEmY6x+abtQaMveqRveDgiUrgp+66RvNxVQbFPXsNrG8VPG8evG7uR3cBxPevtPePpusZH+gwiP/FzASJgAVYgYVkABSIgAljgYVdAAyaWBCZ2BHAACSZ2CjTAYe1TfKCHO+erdurxR+pPV0BiQvMJJRKSWRDwgVrngYjiXQAKKDyspCSQKjJ0Q2eCKx7OLoiCLnBU5eil4z6SBDvoBGtUTG5UxzxIYV4oB3e0BWVoJmFySGtQKZ+0NZAuNrTWiGjDMpoy6ZAyiKKqYpIQKbe0NFxmb1bGZaBINoyyN1z/JjdKJoqgKG/EI0zPlESuMjjEQ0WyikS2kjoGF+3ISGnCbOzizK7QcOwIUWoQLxH5zBA5lRH7cnIHVVExtTB9IVErNQvpElJFNzApFVIfdTAb1VI/93RJN3UD0w9VF0L+ki8381QhpFQ38zNxl/E+QHd5wDMdgAcsJDQXyTSPF3ljNfVICQVmk3FSr7VQZFhdbzZX6fQsR0he8Ulur0c5x7fC5Nd4kReD80w2gJl0CTiVTTmNT/iOy/fc9/iwlZiUD1AelJlGInhyBXweJV3PFXrCC16nUYAxZdwohYCvMb3qlRu1MV/jjz298d+uCXmcKVW4U1bq80fuMz9XYEAD/7RiSaAENCBjRwAJkICEL3YEJpZj+fMByuf9yhECHgAGOJiDSWBA9fN0EGV+5GdYYGImSBQoGrKiGMwjVdSAglgic4JEwWVEMRThgLiJaxQucFQpdkxqLSrHjral2GIHX47mdhAliRQBwiQGY9BJjdAna/CI1DgneWOJaGNLV6NKgzAqg8gykOyOO2aO49ht2XZt4TiJ1NY1xrRkwpQqX8Y4ioNFlCNws3IrFxnMygqNwMw9yuo/zhDOwFCTIdfPAo9Q8XIxCe8Ns3CUTXdRQ3d0T9kX8FAwUbd0X9d0G3V0L5VRWzkwRVeW9cx3RfVU+cpTMzMS5S5Ud/eX524Ob/93mEOVspa5NJHXNF01VzWveQEHtqQXNlHL9Y5VclgP9XZLFZ/kSIJEnMWZt2BxSgiAR8bkHd2XOU9Hlw5gA4CvdNz3WnknIYwxd5QpIR6UGduEu/wtVboTZMWzUbZT/bLzgAu4gO+vPcOPPMMJovk1gdtNedTvHyV4+s7Vvl6FHh9AQDWABJAAB0agBE74hEcapCe2YzHAhemxoyMABUiABEaApkcaB2R6QPNzVvZJZU2iTXpCZ3944SSyiEFUKt4lWURUqKN4RL2iiX8YLGQURdMFI8dkimt0jMO4R8e4h0boQ1NsLay4L+ICBcv4i7Waq3MMq3sIjcVYjGkwytz/Gjac1GJ2Y4Z2gzc2Jo6T6K4rBmQQIIl8w0qJ0Cjd9o/ZdjfaFrHL1Cq3DCtl5kTSlEwlOysp228U14zQiArTIzkahCsTy8/6MC4LlS9Jd1JNOTB5QJZLew8tFVJjgFHpspZlG1I9dwJ8YQJgG7Yn4Lb5UrUp4AMmQLV5m7iJG1KBt5UZ9XRP+3WBV1I/4JVLtS5plzF/l1SB9zInADOFWZg1MdK+e3jDRpFi9VUVybyb+XhdqzZ71fWat70X4EZQAAZar/WQpHpdaZzzO797zQCEa3QKYAHuGXUI4gAegBeZy9gWIsCZ09h4h8CnK599xzp1BfoAGty47frY7b3A/7P79nU8Ffjc8DW9IHhfx+m9wOv/9k0c5auawvOdPFqmabqER6AHRkAHRuAKaJqmpyCEAzQCMEAB9tEeYRqkp2AKdFzHcWAKZBoFFDbAN8KfTcIg8+mpqxyKPa6oSZQrwkSo9UeoRfBlF0pEexYkexQDNUiE9KJH15yra87MLSaFUugqUijH6rwm1VqtfWrH2DzP85xr3Zoo81pKZ7CtZ3BknE7QR2Zul66vcWpu3bZLYcRkAHtlbMNlbINvL500bANMn6g5/BZm0nQ6TOQ/6PaqykPUvyMDLPk/3iOuVh1pKJnV4WgMszA/Rhtq+myWFzWVV3uWbVm57Y4GYiBRa/87t399tnmbAlZ5t3O7uHv7dH3hA2IguJ+dt6ldt5+dLnE7BuwOt5e9UZ3blH+bUmG5UXW3M+dQ8nZZdxnvMjfz3TETbALr0vxjNC0v0s4bvUWkeTOg34E1YfExV1+zvrlZWI9kRb45nMNZvxteWbMEAuC5wLOkmKKVy+OZ+JZtGJnp2QhCv85EuiZiVgTsn48JfPrXO7eT27xLm6rxvNr1nBQl+8iTgcdPUjjcgeOrVlA8JFj+mtyNYB8gAmbaxmm8B46+Bo5e6T8AyUWaYkG6YlmgYjd2BGY6pTUAYlFAp/ckIzSChwtyJBoS2oBimFiW42SWRpuaZ50YqhuSzDH/FCUPSEyGwiiU9qQY0MyvPO/pIs7DmKzpHMe6WvDtXPDF2M/9vObamkiFaGtvUvEB/SafdIlg4zZYY9ODsEv9GEao8tE53So/39IJubF1o26nToq0qG8bmU1hZvW1aoysI5PSSpIpWWfQ6IvU0CvxzE9D+3MPs9sllbaV3bfxkNgjldgTlXSDe5UFk9uJu9u7/dutPXVz+wOk3fkv4NonYNql3/mv3dgl1bmhu9yHe7mr/XRVW/x/+Zd9FwSg23fZXe544DI9lbLkX/4/U/KEF5rNewUAAsSKFQ4IEnRgAGFCAwscZHDQMAMKBygMVJy4gCFEjRk7GmAIsuOCkShI/448iXLBgZQnCTyAQADCggIqNxwgUGBlzgU4CRwo0PMngZ45ixY4itRoUqBHAwQo8PQpgQAQokK9GtWq0wFan0IF4DQAVwAFwJoNcJZsWrFo0ZZFm3bsW7gA6pq1izevXr1w26796zfw2rBOwRI+S/hwYL9QAw8o4GHDAxYaRozocblHDxmbNQfRDBrzCA2kSUzBoYGEhimpSYzWEIFFhAgPHhSAwBQpTq9NjwooIEDAgQAEhAsofiC48uXJEQhwXhy6c+EIkh9IkLy4cOwCuBPgfvM7g+dDERBgEF549PM3pwe3Pv0A+vnm6wtggAA//vz8EfDX758B/g1IYIH9+f/HgIAGKjjgAf5VYACEECJQAYUSIMBBgRMaSGAGCFyYgYAcVHChBBBK8BEHKK5ogIoZSMBBiwZI8CKGMKLYwEcocuAAjTe62GOOQnLAgZA3NiABkkI+VKQBDRSZpJJFNvBklRk0cGWWPBbJI5UNOOCllxRwQEGYYZZJA5UUoNlAmhSIQAOcIlAwAQ0TiFCnnTToaScFMUxA5wSCCvpnDDRQQIMvexqa56J75mnon4ESOsGflVZKgS+AWjqooJNe+kEMH3Q6aKGknloqqX7y4OekrnY66qinrkkrBSBMAIKtd456a648iPCBCDyAECwIwIqQq7HD2oossiA48Oyz0Bb/5EC11l6LLUXaTmQRRN6GpFBFHoGUQUYlMcRSSRCVxFK7PMl02wEPyMuUTzPdBBNQPcEUU1C3LYWbUkvhdFVuWFXVGMJVZdUYVVllRZZbYJX1FVtqSWyxYGWZtfEAYHlM1115CeYXXiEDhjLJKbdV2FsrG3bxWIo1drBMD6xgWQ2e/RAEz1Dw3EMOPfyg2Q86YIZECaqRxhoJTo9AAhKmOb0CCrQ9EFMBDywAQ20PSLZUvcYhd1wAxg0nAAQCmG3dccadrZ5zzbnd9gHJqfecfAgkkN9N6BEgt33XCUcf4NUB7hPih5vn4HPPIfgfgPPpvV+ACCi4wOUOWp555psr/ygg6B+G/qCAHjLo4Yb+Zbj65ZeHfvrlGbz4kYwx7iijjwbQ/mKPMf4+o4o3SuAjQjmq2KSQTmb5pANQKt+8BM47RGWXzn9JJZjXX9kl9l6KQCX4Dcw5fgNlOlBmmWpSmaabbbYJZ5tvHoqnnXDWeaeegtLAaacxnEAp/vkJf5cqoAH/BMBUkSqBDFTgpSzVwFNZKgb9E1QCJ4gqAyqQU5YaVQU7RadArQlQE/hAr4JVrGPhCli4WiGuKPArY8nQWNN61peiRYdn0eFaA6HWRH6oLW9dJCEZQQhFErKRBYhrJBAZCUjY5a4ojmQoBOCJFatYRZrQpCYE2EAXXdIvmP/YJIz9OspP8iWUouCmjEQJ21K6whWuYOUrDSPMXBjDsY+RTGZ18Rhf7HKykf3lLnQpZMoOqTKWGcYxjETkIsNCM7b0BgIbiIDTSICDKdRgkz+QQSc7wxnOEK0HOrCMZVDjtNKYZgQf+AArTzMFp8VyCqZUDQlYwIIVRGADGzjKVIjjNp/8Zm1TWRva6kY35ACObsxknHpuAs3xOGeajpvmMqFZH5/QRz52+9vhuKm3x+nNQYBbQIIutx/JEYh0CMjcOtHpzs25jp0f+dDlJnQh0znIbpYrkIfmiaHQkS4DEwpRjF5EuxnN6EofOV6LkITQFSEPokmqqPSSdKWLYgn/o1iq0pY62qUrXe962NNe87JHpCqhL0ziKxP5yJe+N5XpV2wy3/raZz44HQpRJDyU/fbEJz/ZyYJELWCh+PdAo1KKUwD8X6cAeIEJMDCqg2ogABO4wAlQlaqCoqpVixqDqHawUqEqVVk1GFVZkap/ISQhnXgwAbjS6VZwvdVcW2gsFM5JhraiAPqqxYNp1VCwDthhtaRFrWxVqyLZ+qFFiGiRcjFxASt4rEhQgi4poqSKmt2sTbyoRp8UBWswgdcZi5K1nyAlYDhJY1Ie40avPEWOXpmYbbHSlbS4LJFpEWRdArkXlInst4R0JG8TyTKN6XGQi0mMUyJJ26PgZgOU/6TuBhbwABS4ZgSb7IHOhuaZoB1NM5ZBAmnOO4I/dHeTNfgBe3VWg57VQJTkHQ0vBxac4qgtAMO5G9yso0y7vYdsZINmMqO5nesoOG/o8U519qnN+nizPYCjsH8ep58KJ+gjCdLbgAywT/9kLnT7DHFGDiAgz3XIdZdDUYRCJyEGceif/gERQnd3oYPa83QGRcCNWbSiEPXIeU4iXu8U+rwiK4lGy+vo9EIK0i9xCUzWm9KVSopl8Jl0SjZV3/veBFPy7XRNc5pfnHAKP0SpOahuPRT++Kc/pH7Kf3Q2lZ0fWKirWtBUV/WqVrMqVaKGtat/hqqeDx1o/yVQrFT9k/9Yu8pBDYJKgrMSVKxKGFdByZWEdaUACpUlw1+JWljPstUOpYXYwip21daaSBCD6OqLSARdlV0irU+S2c5qdiXzagnW7gWUNeIGNz+Zyb6MckacBEw3vjSYG98IgYjNsS0Ue661r+LIt/BxYyYD5B//2JfeEve4xh3MI5OrbYzxMdzjdou1HybHiGnlKmdcwAa0+wH29gwKMoBCGaDQs8+Al5Tk5YMMZBCEgys8aDLIQb8RDvEgCI0zOnNaBEair6n0l79vs854GLAeaRK4bvztlzITN5Rqkoc80OQOy+vDTZhPuMKLmybk1okfBeEnxJtzkOhk3CDPgbg6RDedQAH/WiLXoUh2lxvxAUIku92lqJ4ZIt6HJvSREGmdyRLdXY4QAiUZff2hVvbokx4SJSfxaHrN4xJKT1qt7HlvpXTHskkb8Kucpi/N4HupTOd0JznpdMx7QlTh2UwnNyM1zhTsHwYxqNRC3fmBFwgrBSv/v8xjvvGcH/SgT9BnQh9az5kfPeilGlU9px71fy5Vo1vfegomda2oUuugXgWoEH7aWcMaFghAsCxf/d73wC8+qgV7/MM29lqu1lZkxeUtkeTaACtASRN13S6ZzGQBlDzAdXPyE9UmGwJCyZeykR1spQw7KUS5yb9iexXaPsW2DJv3cpWbsYsBYCwg82O3/z9u/79FbiUzgOtmbs4VFohUGAloR+8WSZJUf9GFFN43ErO0SQ2XA2WggTkgBVJQBhmYAyGIgQ33gRvogVIQghwIBSoIBf62givocN61Sa1UEkNRFRCwX8uxHd+hTedBHsKEN3YDTdYBYNAkTNw0czCHODxXHehxOQRgAOWBYlMYhQ3iHz1HdPL0YA/GID73Yf0kIHajEiqxhUU3T7WjdPf0ERUQIvnEED4mUAf1EQsQIkZXOxASI1MHPLQDI0GSEDiSJAuVI9yjJFWiUkUyPRyFJdvDARmAiMyDUnRQUuoDJmKCPS3lPekDU/IjJ2D2Jm5VP3ISJ3VCK0AFVDwVZ3XCKP9wpoqNxz+yd2exmFSweCkn0Hi2iHm2qIuXV3q9qIsXAHrAGIwnAIzFWIygp3kXcIzGOIy+2IuMFmhRlXqrJ42W92iORil0BnsZ1FaBYnw8YEK+xyovFEPAhyy9Z3y/l3zHh1jR4mop0GpH1BANwRHRN4+5Rlm4BgMlsY9c01lbsxLbpxP3EkY5QWylRUZmpJDJ9n7/smytVS/P1htUgVsHM28Ms1zpljIb0zF4ATLBJTLhtoDkVm4YgxiLdG5REW9QIX+R9IAImBgIU38PI11e4QEysQJPI4ObkYFS4AJC0IFBGZRl0IFdIARdIAVnYJRncAZJaZRCOZQd+G+iBDX/F+dFMIEviZMcDDAfICdy42E3+pU24aeVZVmWQ7iE5GQeWnmFTZiFBsAA5hSFIEaXRFcgXohi7XROKmaF/eSXDYKPWfg6tUOYhfk6cCh1tZMRiSl1dciYj8kjtkM9WucQf+gQQ1ZRSCKIPMJRTvJklThlZVeJYfJX3pOJXWY+JuVXX8IDX1ImkriauSICc3JmojibtQkobpZ4pmh4j8KKjvInrxh5B4RnlUKLtch5tph5yUlBu0iMpQd6zimMoMcH0UmM0XmMw6iMxOgCxpid1imM02md4zmM1/mcvxh6V0WMhOJodnZBGQSfJMRpdDInv/IBniYs+fl7yIIr+ymO/zMEAjk0WOtoLan2akAUaxxRLnNIawYAA5jlRErkLiUBkCchE1jEfak1bAdJRqX1LhB5AOZXWtIlkQRjogGDG2IxRzLJonBEbcXVXDIDXMF1MoE0gL11owU4f/PXMA+IbTx6bRLzFhUJSTApGISEFI/xGBugACTAXgdXBi5AlB74gZyBGUHjBi+gpWfwAkzJpVwqBUIwA0eZlE0JlB2YAz/wARrQS+Z3lkMRHhaGckZIp2/6pkZoTiuBRfIxhiKWhUJIhT7HT/s0dELnIJ0jhGFIOiCmEivRTm8IqXkJA033qIVpqY6JmIQZoVn3ETCwOxmxoI5ZmLNDmHWIdn/4EP/Lk4hgFyQMFT0j9SVJ8mRvh4hYJokBanc2BT7ns3eo6T5711ezSVOzKVO0Yptr0idq9maPkiqRNgGa4gsx4CeQZypLJYvOqJyVd53KGFbnWYyeAIzVeQHgqp3mGZ7gGZ07cAIusK7tqozsegHduZ3ieQE7cIwyYJ75uoziSozKOK/buowAG41/poyE1npcBZ9/0kqYJisL+wE8AFd1dSuY9nv9mSy2UnzEp47PQnyDdRAU8SwTQRAo8EMjmxAXUX1KVH3Vxy4l4bL+WBIR0DXYNRIXNxJbY285WxThdxulhS/40qYkahtDixu28X7rd7QSmRuwdRRMmxS1hRRqEUf/bDEWMWMxZWGAbSGjMEpcXJujL5N/KsOSVzsxDqgVKxmkesQVDuMw07YwC+NtgSGTvdEb+4e1TKoAs6G3CqAAGNABGjBfGjgDJbiURtmlXXAGUEAEZwAGTLm4TNkFLjACX5OVcGq5OXGnlnsTV0SWaElheroSoaunPFGFPKE5QweoUziFD2Y3IHYAk9qnGTCFsuu6AKU5tItiH0GFnpq7r0OHi2mp5LJQMiKqn/q7iRkinvq7EJGqnCpkWteY0jMjCCG9i8iZ07MQfigklRh3JiWJZlerlehX41tS1qI+rblSvQqs42OsZPZ3IxRCtdKJyJqbAtRWm6JUidZ51YpA/4HmeVeleZbXnAGbnfTar/WKnf+Krwjsr+GpAhegAidgrxHMruwawQ/8wBXMnf0awRIswfUqA/UKjAtMjOo6wh9cwiIcwt7prwB7rtq5ndYYVpVHwzGwSTa8VVzlsAwrKiXUsJnGsHhCV3MSLPZJLBuLjv/5e9UCj8q3WNYCjySrRCWLAg/6QxKRjyw7jySxj1uTXbVBs9l1s2PMfRlqGzPxa1qkWkdrXZRUtEfRS6qFoiQaNsvmkLA1ALjhtBNZtxSzfxKjf34sFvc3SNwGgI30tbz1W9umf5KkR43Bf2SLbTIZMXrEFjs6tVARbQUQXfNWMFdBMHPsMHbMyaU8AP9KehvYJRkrwBqUcRk5EAdEqZRCkLiLSwRgcMteWgY1kAL3Eh6iZS+ZS6fQxLmiFZbHHMxjKIajS5eeg6ipu8zV0aiNKoTU/IYqQZdUeIaOmjkPemIhcc3g3BEKoamNmXUI4RGVVVkIAb3lUi7K6xCpqnVChkSp6qnZa0RIlL347JlyN5om1b1zZ3dalj5/JYk7pD4FnZp+p6trIpsjxCr4GdG5R9HdSEKSooqBYimvp7/GyXkeBMDY6pz/o6/9ep3qSsIXQML4+sHqegIsba/qKtPbGsH4qgITvAMysAM7zdM9vdM6/dM+LdQ2ja8TfAIXLMEmvMDsGsLdScEv7cH/J8yM+bqtMPycNVzDUEVWolIoZxUqHhQrl/bDdEUsdfVpn9Z7pOZ7yOIAzlIQAlEQBjEQcF0120JZ1NcQJEsR+7iPWrw1F3dx3vwAMxvGNBvGXiMvEFAbOOgSBmkTWlMAGBDZt9HGBRC0lp0Uc5y0/+IBR9HZpdzZSrpsbRu1ZVEVVSvIcfQxgfzHVTtcNtrIeZTI4tYyaqGRfowVU9vaQvrIbdu2anHaQHraUNHZUeEBvGHHyP20pXWDKdqQKrp+N/gvShoBGvABMuACSgm5m3AGm7C4ueClUrAEGqAA1MVG3kfMe+oTw1yWQGGEWKmVYghG8xK6VrQSKVaoKdan/yqxoKoLqDAguq/LEMq7oAT+dCeWEQD+ziD2oAigvOjCEHUIz5ZKh5y6EKB6jxUhdcxb4Z4qEQ+xvA6KEOtc4flsLftsRJeJZSJlmgLdvX5lLSJQd209vg7QmjcuArea48zS1r8iLHhnLH1FU+O4aeMYvxEbVyIkn5pCKR40i1K1nF8tKnxgw5bXVMqJi+UqruQajPYajMpYnS6tjA8MjBUc02Xerjft0zet5kLd021+0y6wA3LO5jst524O1Dnt0zrN53re537+03xu0wjMruoqr+76wCjcwCzcwoveePnWw1+NaV1dQgo76ZcWxEfssMfSKxvr6b+HAs9iEHGdk/9xTS0Dodd1PbLqPI8viwJibLMk8deFjbNjDMaIjTUAeV3w8hIbEBlvTElDexS24caezcl6DAGP0dnJDhm3AVuhbex5TLXHfsoAcNweg7WAnO27nW6oDZIBONskKYAcE0cus+24rbZkSxZuGxVVETHBvTBHQRbHfRteMcfLtu64ke8UeYO+naLOrTC84ey38QAKAAIXkKWH292Oi8uLKwQygAQRoACMzVqYW8Y0Ed/rDbrIXKcdX8ZVRH7TfN8Z0U7YHKFj6BEnBuAjMfInL1mbupjl4uAOmhIPyqi0W+EOSuEgsfMMis4gUVnmovM6784l/uFE5C0hUmsnq1j6/BD/rKY9YAICXwLQ2RP11/IlMt7WfzW+F5srUv8mMbRX+TmsrELknuZpnqJ7nOYpgBIrdubkplJ5NTBoDUxBdG+Ny4h65Tqu5SnCUB2v19md+KrTIqyuGBzCeg7oeb4DdT4DO60Cdf7mKvD4kR/5M6ACLpD5mm/5kQ/5kE/5je/5dU76jZ/TcW7nqW/6br76Tx3BEAx6rw/VR72tZ+7C/irDNPwBNUz3NfBnsmLpmB7WO1ws+/npx/97lwQCTrP80GIQJNBDo74CIKDXJGv9KFA1EeCyUlx9OHvrtG7rNNs1XvMS2OXFtUFdE/8Ykj20jc19RovsSPHZebxa9K/spowb/51t23h8ygAxAICHAgMCEAQQAIBBgQUAFAxg0GFEhQkBXMSY8aJCjg8TGrTYUaTFkCQrBhjZ8ePCiw0vOnQIwePAiC89xowIc0DBgjt3LjzoESHMAgUgFDVa9OhRpEyPBoBAAAJUqkcFOI16VGpRggMgKHiA5IeULkK6bCKClsiZtVA0YFCg9OiBAnSlEnhwYAGBAgvqbtBLYG9fAhsEFw58QPGCAwQW6627YK9kvYwfP7YsWfNmzTAkG1gAOvSCDAY8i+acQbJq0gs8q4bhuTVsA6ZBI4Bh4IBq1rxHk66tunZoAw4WOECRIXloFKYdFM/g4LlrAyuqK8+Q2/oK6f/SUXSXXvw5ePIOGpgvLx1E+QbrG9BBD349CBEiQFCgLwK/CB71+/OYQIQJKCDwPh4M1I8HHihYcMAJJgAwwgc/oOCDBymY4IMYHtxwgg1jsPDDCyYYcYIaLojhxAtQRDGGGFhc8YQVL5BRxhhpvPEEG1U4YYcLfLxAhiCDPEGGE1zwMckgd5BhByednOFJFXaYksopr8RSBRVm0FJLLr3cUgUXxPwyzC7PPLPMLM98sk0317SSzS6pZDJJJ3+8QAUc9ZRRTx9ttHFGQQcVVMMaPrjggxoyBHHEDyxEFNIMJ51wUkg/ACFTTDMFYdNMUwCBBBKm4DRUUU8FYQVRQ03/dQVXX4UVBRYiiAAFFFZAAQYUFoiAV18jeIDXB1B4AIYHjl0h2GOXZbZZDAp4AIINpPVg2geMmnaDa6ON64EBHqjWg7g8gMArgoryiqedPPiJIHbV5SmmdQsIAF2k6kWKIZhsEkijkyyaaCaFAi5JpZRE4giliShiqSaHGarJoZZYEqjihWTaqVx4M/4pqIMGfkkhmer9CCqktuIrqqSgWiqnpZJaKltolepJAxdeOOMsKNDaggify/ABA6+mguCquwrACwK/lIYWMcAkE2wywPIKNurGGHNsssoO0C00vSpjbDOwg92M7AV25exs19ZmmzXT1vZMts7Ylk024VoD/y1vvHObLbS430bOOO6asxVX7KRbYIXEsUvOOhis6+6778g7Dob0uuNOve5E6G6+7nggj47z6FiP9FI7zRS/+zLtD4QIPxCBQgBdBwFCCGGffYLaMcU0QwEpBZFDCym1sMQJR0TeQ+RfZD5HHAet0cgicQTSSB+NvMCFJY2Uofs6ZbiySRfA9/7JKGWIcgcu1wdTChXcn8GFGV44k/4wv1w/fzNnYF/NNM383//8hyYCEjBKVVIB+RLIpO5lb3tMmh6hZlQDPpyoBidSFAZTlKFFXTBSGUqUpTL0qBE+6lK801SpQEUqUomKhTjgAQ6mMCoaznAKsCIBrHDFAhREAP9XuLKVroxFLCLWalieARaxjgWsZTGxWRB41rYwYC1sSetY2ZoiBK4lrnB5q1waO0q6vDKAn8xrAF1R10GM8pOekBEiPnnjvlySkZRYBCQbwSMeDQYUlrTkYQqBWCA/xhAAjMwg7CqkRizmAaiw8SHpildBwvjFMa6xAAR5GSaTAjOa0exlEHjKJ6M1s2hlS1ox80AHRpCDnKklF0ToWReWwAKhgdIoWTnaAaiGF70wLWxiYwzZdDmZsG0NmMX8Zdo0Y7bNeAZtudpV3Xa1neMkTjLPVKZmohOauwmHNXHzG2fQVk3jqGYF2XGO5JRjHGiebZ2Jq44DdJWBc+aqnJP/Cxw+HZC5zKWnn5rr3OfAAx/pEJR0pHPA6VDXOvuobnUUsp3tZieg2nVqUr+rqAgVNUIQDi95I1rURxFFIhK5qHk10hH2AkUjlXKvSNe7XpFkOr4fNWkH4xsfkxI4pjJoiUozaBL4eloG9QljS1+iH/+Uyr8XKPUFTVDBC5o6P6jyL6pHXepSjzpVrM6gCVq9KpeSej/99a9LVi0T/sBEwPF1z3s2DSoDZaQ9QQlpSBKswQ8seIEfXGCve72UpUw4WMLy7lEVZRWpRgCCxfLgAyQAwQxpeKocVlaHKbhVZn+oWVvxsIef1dWweBXaBTzAic1C7RUfoK1TqlZbqz3W/1fK9SxyZYxmkETjIy95yUpqTI3pohgZ4ahb3RJSYnosGEYqMrHlegSQExMIIKWbx0PeJJEx8SNQ2OWTcrlrXmikJCd3K8lNdoUp5t3JbjXplE02xZMws61R/DKtKvrFL9H6ygA6gIQcdOEMaulZLqBwBRYoIF1L8QtdlmbfvEAtWAfYgGYivICpSUZpSguWL0tbGbM9uLTKbM4yS0ssySgLbXLjjOLYqZxqNsc6ISZcNdMGmhBXLlfW5BuO11bOairuO9YEoq6gqbjt7Ao5j3ONq1yTq+2A5zvcgfKrHECCwEF5n5mbDwrWA54VbJnKrpMO6DhFugNxigRldix9Uv94oN45lqKdil2neicpwZpQo5YC6YM+SiJESVBQnqgRjmqkPezxQabYM1ICg+rWRX+vfOTr6ZhwKr8tjWlL4MtfVr/q1fk5tdNTnSpTlxrqp2ZV1JrmtKmTQFVOP/WpW3p1EmBd1U0rNUzwY5+ZKC1pS88pgb/u3gKRZCTtXe+ufNVrX/28ogtasAYpOpQFFUVYExW2sCGYwAg+gIPHMrZTJFjsqHBAWciKSlXnzqGqeLiCFPCQhz6MwLtXAG9g8dC0pW1iak2rb9UyC1ra2sAUveUtccl2A9ia2bMO/i44fne3X1SjxhYiXIrHkSFlnIlJ8tjcidnEISC54774aDH/PjJSuzXxCMRMjl43vovhmqTZuXY7RvYm5VznJe+82DvKl13rlJtcCs05CcptnTJb3lKAAjTwgy5IAQppgSURcuADBWQRZgmeGrS0OK0NB6svytLM1y28AC32UjIRVlaw0MZMXdFNbSVO+4c/7JlgSXNtPrbm29vp47ZzhzOyUZxk5LkcxclNcW8DzT2VI+Rd2SqzibNnECWnKyJ7ZgWxQc7gqhy4KsPqyvu83JbX00/upMoBBwLd6ROaUIWemXZpLjPqUMc7x1r7QSK8PUenzcFqJ6rPflbRsomEaJnS6Eg1Lb6Phj2lYbv1SXGlU5R4qoKenqmnaO2qqb/qhlVL/zUJL/h+EtwA/vGTH/xSbcILxp/+JnDf/W5Iv/vFH39Xu7/+3j+/+JMQfvGTv//6nx//Y7X5uSr7uaousZ+yOiv0USA6Yb4mOZLpERK70h4XWKlB6au++iu/arYO4rNE6aBrMyEc0LbHIsFti6EpkKHHKrfJMjfLQjd2m7d5czcU0IAemjdaeQAW4JUIMJZlmbd9Y5bTapbSeq1lgZZjUQBtCZcNKLhn0SKj84lpcaMziiN3sblGOgoPmDiKEy6d+Lg3yjiNIMOO6yNBYpiP24jo6heB4MI+Ii4uJC8sdDl1uRZ4+aSioK9q8QkvqiTu2gnaoi+YOTj2oiRQGhf6uv+W+5oZrZuWpXCXUqIWKpqiCEgBHXCBMsgBKOivMyiDEegAmbkWriOM0rIiaYEwXdIlLSI7UwQ7CIMauZM7sCMbsCMxtavFXam7YuFFITIxX/ExXiwt0vowpZnFEkPGtCnCWgQxyQi8ZzybxotGyNusytOsH6I8HbIyyQG9J/MOB0iBKbsyKpOObRTHcBy99QCdFSCVA2E9TvEUFEohTcGUNPsAe5QzORusRXkUR3mUQ/nHaYMUD8QgvzLIg/QzQJmRCVwRQ2ugt4I+uEIgJgEqFxAG8EESStuf7OMfKZgBj/TIUFOq7vu+/Ds/JVCC71MC8EtJIkgClHwBIljJ8/v/AvB7yZt8yRdISZtsSanyyZ/8yZf8gpTcyReoyZ10SZY0yfMzyfLDP5+MKqkqwK66HxeQH6tcwEsTEwvEKQeqQAeakR8QywvIAWUzS75ytmYzkWiLFLYMSG7TNh1QFG6DSxjCAcaCoW47MxmirBXQgBlCtxxKgRVggcFkARKIABKoQWCBgXqTlV7BlWGRTH7TIklkrWVprSXcgG8BuKK7pC18uIjwLTRKL3iRo4+rGDIKLp+YuNZUTUXKiDbECNl0iXJxrkWiCDkkOebiwohgl+36TTIql/Tyls3EOa84uE3yuQHYzIJwwt1SANDkmDX6ogKgLyjcFuYsF3CBFtsy/7pUjJbVAqUt7C7Z6s7VwoAHAAsFoBVVwQENIMH3XELxtM6j2Ja+sJYopDAIUxYMOwBQIrsoLCVVjBZ8E7FkNNBlMZbS6pXQIpteOZtggVDJ1MUhuzFabMQtGrqkqKSuICPzMqV/kxZHhC0qKqUS7bde6RVaPBt4+6EdslBX4bxb4TxV2SfLojIq46eEylFx9JxW4QHIYpVMEVL6kMcjnT0SeCx85B3dGSzfC0FFgdJqI0gTASmEnBG6EhQtzZ4+cRKZ+p6bchKbchP1cZI00aqPNLUtqapVmwE3EDWnBMqgVAKZdEklGEo7rdOUNIIvIIIiIAIjSAIi8FM/BdQkEP9UPv2CJADUofwCQXVJQm1JovTT/UNJR4VURsXTRB1KoURJPK3TOZWqmgw/pgTKqISqpMK1q3QfrOQ1qxyfrcyer9QePdHSHCDLXJWBDAzLvErLaKuBEQDWaasBupRLbRsBHCjWD9A2bgO3x4JWyBo3FZQsDfBLErBWDSjMc/OhwZQVd4s3WmnMcV2iWkw71NrM8PwWUqpMcNnMDTi4uNiJ1VIXligIoIguP2JDfrGJMvTXluiXf5XN2STDgMWjhqikgWjNe5UkK/TQnvCuD6W44EyXgxtFppi5AhAaTGJOd2nOuHjOjp2XKLokKqxOgvCW7gTNQ6yizvy3Y4EWBfD/AC4SGgw4xaNbFrAoVx2MAICzWKWYV6MLT2u5rw+rRQK1z2Ux2qVFu6Vd0XNd2l4UrQjljAf9sKObmYNb19LkCjCEI42R2IpLr9KMiwKIThOlL6Mz2w0AiwEAWdjqN1MCOGCh29ciIls5m2rcLM2iFR/aO2rkrHS7FVeprFU5HRMCgRAAgXEbt1NpXHJbXBK4S8M6LA76RyoFKbb0oEThQIM8EV6lVa+E1dG1yiHJARmYNKwsg/ipPi5Z3f5RKo/stE/zqqain6b6vvHT3Z/81E/NUyPA00D9U58xguEd3iJAXiMwgiwwAuRN3iJo3i34AkCl3kf10z79U0MlXp/h/17slckiUAJAFVTwnV5NRVRHRVSjlMmhjEmdJAKfVEmdBMqSdLWplDQ1zUQyERMtId395bU8mVWvXBHt6Su7MssMvKDObbYMAkhl3bYP0IFg3TZhpcsHJkElxWC9pCF0O8xt1YBwnZUQ7tsI6IC+3beA07fLlCKZ3Uy3/dCekAno6ol7vQZKWAh1oc2XYIgDWIF9ETk1TDlAkhiDjU0i/tcjLsOIaDifqMKGhSOX69CG1RiONVmkaE76GsQvek6Ce9dLMjBxyRh59SIDo88t2mJp+ZY09iIn3OKgfS3W6syOfRabpeN+EzhtSc/0BAsWmAI++ID5BLiaq5abPaXo9P86A2UaAD3FRWTRtDtCK0otfNM3fLtFSQa4uFA4s+UtL5zhiuOJK/4K6vQKTHZONzIwoUljrVvCnxvFf7NYeGWWgJPlKZoieF3P9HwtupVQIpJQBu2hEcYAnhUWImpMWfnlCEi6vlWAY7YVzHK8FAhHZ66VwnG8cLVmFMAsEkgBbTaVyBWVDwgBC7ABG9CBEigsD0JnBm62DBTLscTVHIBV/iXd7oHnMoBVKZi++OESj7y+rJoqKXgBgB6/AITfpRzUn+xUmbzUOv3T4i2CLUhe5pXoh45oiLbo5m1e6IVe5jUCiFZe7R3e6/WZLDDeRjUCRBBejNboInhUlg5UkPb/Uz2VaZRUaJ2cyaA8Vakck9t1gVaNn63EZ17z39C11QFekbPUwAny1Q5k6mAFyGZ9FAqeYAgerAseAXAjN1FJzMPc5sKsFROOgPQ8Flp+ALiYovU0sKqLzlOGLeRkYhduo9S8CB5IA1+44TL6lotoziqEro7LYYrpOIoAOTgcWCNGYjg8w9mMmCpkbCaGYcf2ijmGzjHyw1GCQqOITrMtl+cc5APT2M/O7AHYWAOjwnTVbFKGAIJI61IiiGcx5HlN4+1MCvW8oq1Dz4DTuthaFoETa7Eu6zzWAD5wgw9gzmB55Sr67FPSYpQlpZkBzfvcls7st1iObtiqljk+wmpR/63KbFdt0Vg2Zs7w1lp7WRfjFC6NeZbSzJZXlhafXa3NnOMlzKKz9YDV0u479hYy4IEjRC3fzuPfLusH6ADTKmGlpdthlNCvphVaKuERbk8QfswUAABrSIMBmAEdUIYWYIUv0JIiaIILoBVohmbEDHEcrJV3s0RstkRojgAN2OZtRgFRSYFxCwEqEARFMIIhsIImsIASIAEfx4Egl1y6TNYTDHIHtoELSPJ2Fst5Jt1MVKqefh81BckpB8mAnlMhkKr3ZUn6Db+dXMkw31NEpWngTV6LRt4oKIIsYHOPVt4tyAIsyAKIbnM5z4IoYF4saF42Z/PlRV46b/M1f+jl7f9oiV5eNEdz5V1pjV7eLBB06FXejn5U4yVUPf3UnFRKqRKCqdz0F+jpnl5dKciBHHAf/t3K0c0TLT1LvkI2X0XLBV5gGwDnQ4lPZo1PavXxXP9xydVmbN3qbYa3D74VBXfwDejZsC5rFKblpDvrpHPhqvtsceEJef1CA4trsTXbSroWgO1CJu5rwvZrwM6uiTDYwjbD7IrNc++XjqAXgxgYyH65PwwvPvwKcFlCTNaWtp2iggOLfTel6Jzjr3DC9URZNYbXaqlP4+wW5kzv1M72FeABGNDjo9CWbxnkaHfCeT3CJFyW17LZ1MLlAC9XPSaBPCHuVZZbgLvso3gW61z/V5gVT1h2b+nuTOl2LWmpOrbteBSledvGgGVvWzau2VPuZISHrbLVGJBt7+lGVxS97RKt5aj3WbpVgAYnYbqtNyHEegd38AFXcBjNwXB9TAiHt2GfwcMkgQHggksogbxqghYwgSMIgzm4ASFwAR3IkzRIgxbYNoG4AB5HghHQgRmogXIOgRawAAVwgRYQkxawgRaA/BHf5k2BZvg88hEoAR0ochzQAQeey2JV1guygQlI8qUWy7xi8nYuS3f+ARc43XrOX3wGSZBU06ZSgg0H6C4IA0MwAy6ggpAUVS3HGU0Xgt4F3kDd846G9EiHdEEIhuc/hkRoA0EQBSrwAiy4/34siAIs4H7ud/Q43wLup3M6N4MtyAU5h3Ms2AIjGAT172jx3wIv8AIz8AIqaAMsoAIzMAPubwSAMINl4KCBBrN4yaIQS5YiDo0YIWIkiRIlSb4kuUiEShElLz5+TFIk44skVrLksPKMkKCRu6wkUWGliYuaLi7cvHnhwg+ePnv+qOGzBlGiH2p8OPohxIQQSXGMIAFVKgkSJaaUIIHValUSKUhE0BA2QgoUEc5GYGE2wlq0ER5E2AAXg1wMFjA8UIBBr94NCvIOUOBBwYABBQofNuxBcQEPiQ8DSFw4cOENEBSgULCjyQcQCgAAmCwa9ADQoAOYHoC6NGvTqSOTdv8te3Zo2rZjByidGzbswosfDMBQgHBhDKKND3gw2MOGxXvz/lWwYS9funj30o3eF69g44s9fG8cPLkCCI3Ph39QADgG8x4gWH6wYsWD6XL/5n1QH3795AWaDwABBA8MqF+BD+DlQXv6MYggg3g5qEAECrQgRA4hWCCXZXLV16GH90H3F4cMxqWhiXnV5eB1+XnYIIRwwRAaC/pZZ591eV233QYnSlejdT3aJ110O0qXn4YNkqjfW0gqCdcGS0IJl1tpnZXClFdeyQJZLKTQQVopcDkWCxp4pcFXZpaJpgZksrkCCWu+CacGOJSw5px0lpCCCRaUkGcIZOIgVQktvJT/xAw1tFDCDzro0MMTUFzRBRWJdKJIIoqoMYcaariwSxI4WHFBnxbQGUILOOhQwghLMKpDURcUhcOiNQT1g623CnWrrRfkoOsPMuTEqwzC5uBCGTUJoYILUrggRLMqCCHFDFK8IEUO0s7wQgk5vMDtRQ5RFBJFFSnR0SBqFGFERR0ZkS5EW0DkUBEGYRHFFlHU64UXdejrxRtePKJFv/tioQUWVLSBhRdttKFGGG2YoQYmXsChyKRwqFEHHHOEkUgbmGDSBhxweJwwFm1oITIc0UgCRxt11NHGGykLzK8XUVDRcRZ1ZGFyFlhANEgWXChkxRdncDGHEBWB9EKyybow/8OyMwwRghM2YY0TTsHqtFNPP3ldFFGwfnBBUkidvdQHOEA1FQ5TVDUFDmS+WbcGLKwAJphhoaAllVhO2eBbO+LllwKHS2cfcJf59d8AjRcQ+WKiTS6a5YY9PpkCFpCgwAxcuGBBYE1MEFphAJxARmuG7VZAbauVFtputcUee22333ab7avFZrrpvlGmwGHNEYaccccDSSOTKiK4Il1GWodBjgoKRhgEAygYHGHffZdch9MleBmO0x2Oo17M6zfd8gzCgOSLzivvFgZ+dwCAGqg8okkiAHi544RLLk992JHL4JTEIQLWJUUO6sADLOAgBMZFSW+JwF7SkAYA6Cgu+P95EAYoOKL1wSWETeLQW16kIQB6aIJNQoEIF9AkFUYphFPSkpVoeBa/aQkFborACm7IQzOJJYh3W9OY7GQBC8gpTmyiW1cExbastEADPkiUBurkgxLQqgUAaEEIYNKCC4SqBlbYgQ5YYYUnmDEEF5BCDXogEikMgVWMsMGgQmCDEAyhBCEIAQ4SxQQZJKEGIWhCqELAii80agZfqIEOfpCEJjSSkUzYVQ54daub+OpXt/JJTXAiA2ABqyZSUMEoSzkDaKngBS6o1rRmcAYpuKFpIBECSJiWkXIpxF0SgUi80jUvIzDkIAMZmMC0YExAaAGZxjRmwAT2iH7FLGZveFn/zBhWBy3wKwr6igK/oklNaTLMDDRjGM20YAaUjQwOkmgEHLQwsmImggo3G0gUsmAvIzRkCw/piEXmxc+moTJZqHyBsrBmUKwpSwVa69pOGKq1XY1NbEohig3WNgKorE0rgZJbVei2phXcTW9a0kAPteQ3wKGlSfqJjpP8ojgOsXRHMi2PYi5XuckcRjKSKczhAkOayGUOMTzF3Hpc5zrDkK42HaiBDGoHGte9pne3s51rnFpV1pwOAJNzDmCOg7gOskB6cJMedhyUFpNGAAY8mEIEYsCHKdCnrNjBQAcU0AEYMJCBZG2eXvSKARiEFQNmW+vdVgBXwtzFRQiaUJHe/6JXBzHoMx1Mi2If0D79zAgGaS1hB/96HSqhNQIdYIEJOqCoF/TAAl56QF0lJNq01HWlFCzNKtIQmBIpqYPnY+ACVaSAKfDgM2Swxgd4wAP63JAEF4XOaEPTgeeFcC8sGEATyAAAFpxvQiGUEAumi0ELnOUBYPpLB6XUwQ14aQUd0MAD0rCCS1xAQmaBgQVce5a2AC5vaPHSa28oUrKAlIcpWAEKxMIlIIJJAx1IgZ3ORKYpRCUFA2gBK3bRAhmgik4aGEEVN6wBE9TWCjVAxEWs0ANWzKAJiORDD2jlqhJ8wRBW2OMTevCBFixBAwoogQmYgAQLtAAJSFjCCEqQqv8SsO0HNqgB21DFqBFcVAdQ1sEHnjyCVvWACUT+QQ+WsKhF9aBXOnCBFVyghphYQQ45kIMLKtmrW8mgB3H+5K9q8kkXhNJYUZOaFJIlLSHMANCA/nOgnSbLF5CrIhRJwkTc5ct2zQsL/pQ0vejVBi8grJzGTAQcbuHpUtwCEpDwtBYg4U53InNmWpjZGxohiZldM2UzQxk5aX1qdJohDNEwJzIBkc5fwwEQb+j1G+rwhkf8a2BRWDY9t1CvKLzLIURQgyDwRQUh0PIjqXxaQJt1UIMmtCYFxfMFhqWTc597V7aiVU9scAF3twrKU7noReW2pjrZKd9KJOKbyIJflKb/lLcRcCBjNdghIRHJpdFBzk0DMxjKbOByEScMcYhzmNyI5qhGLUzrAIAa0qBmBaygwmdMJ5edgkYYTagqbWp3usIM6HqTYUEMBmCBHkwBA6A5HmgoSFYSdLeILBitGHS+1+6ylogBCMAfsBMYskpvtArgQxIG0IE3sWAKaxoBC3owgi+cwq5D74AYxKDgqI/p6kD/AJSnIIbAYoAPfyiDG1hxCqtPkKxHGUETmoCEu/nAB3c7a0rR0l3Y+lB6ou0umUC6N9FqoAYzSIIMOmCCElBoFxcsrwKaIAwFkIAPH2jCBYvDWuYZRxg7GMDfFqtZ6WkFLJ/pgJt6iBYS7IkF/57/jCHuDloSAKAJlGhCYS7AmV18oL47qPkFLvgAHuyCEpfAoNzg8oG4JEVCYCnvW7q7wQmepbgSCmHfDM/fCR3R6h3wkg/OIpYaJhgF/R4LWNKyxA/vYBc9aMIM0mCFIVgBJahAC+SATBCCLNhAFtQAE1wZ22hACzQBKzBBCzDBoJjAEFzBEzzBFXRZDrCCDMzKCCDBqnBZo+xRHGxgDiDKHKDCDczBDOTAMViBFRiCDJiYDrQAJbBCC9iKp6hAEaSBC2BRGfzACLhAD0gZli0BjjVKEzJSo7TZD8TBlyFhCcRBDhQLFiSBEIRBEeAAFvZKGP5ADgALGNZEGajAsf+gIbNIC7UU2gxkS7bE0gucwaF5hEUkWkaMBKQ9hKQ5BKUNk8JgmjxNChVwgRpQwTJpAadpQahBAjLcASncAS/cQSUiAzLwwi1IQikEW8sAAiCUAihKgieuWjIZExywWhuk2imODCCMoiUMW8s0QiMcAzEcg6uFIibcASAMgyTcwTBAIi+8QSkEDCRIAyTkwah1wjKaGiQ8QsxAWy6AwTT+jCyt0jVym7M8iwsE1LiJmwqAI5+JGzeSI9YMSyW5wBgqmRUUQQ5cTQmQmZNBmbzRW9vUYz1Shb5lhd28yVeUxYDxkOFNCXgRZFyAV2G4RYYkjv8czvEURn0oiMJNHGj/yFRqCI9hpMbleNxTQUbtRE5OScZT2Y7lDM8AhIASYIEhUAEAcMEFccEupIAhhA72QIB3iIfMTQYJaIP0wQAGMMM2BAERBAEXMAMGVUUPacAUaF0ExMYHWAEXJMEpyIAdYMDb6dwlvAIoCIAdFMbo8cEpkEETrEIMjMAHdMAUnMLnnaWO1VXkmcAISIEO/N36dYAPdBeUDZ0C1IBarl/aaYBsdIAFmIZdvRBdCWYTuIEP9EAXEEEX1IAfREV3TUFxHR7/gAYLYNBn1Fdh8EmQiZF1wWMI6IAUfMEQmEANdN5M8I8wiNb6UQfFBQbi0OX6AQAipIECmIAPjIAFmIAJ/0SAD3TA3Kxfaw7cB/CBXXVAYASmDNTALlgDAJzFgjXnKQAAmbBAVXwGcq6fcfLXem1OWMBFfdlXCUkIA1HQ+E3J+V2JDKGFWYBGYMZAGkTRAOzCLnCBjClDE1iASIGJCRxYgkXACFzAmXwJmWQFvnWmCbSAAowAYTCBDvjABQKADaTj5SEBVBxoB7QA3+mAFRxKn8BhD4TARViADsxAEULZCCKBlDGBIGiDE3jEE9hAEWCbHHREtNTYHnEBF7SADuwRqhDSE1DBDyxBGjxoCciAGyQhowiFiVqBDLgKEn5Sl0nhFf5ACKiZDSyBHOhAHKhZHAhBHDgBFNBSDigBmf+egRBkgRBAgRTcAJvdwA1AARRgoRQQWrQAWpqmaS3V4RkoAREkmqJNhLqUi7zISzAtBL4s28DoSzyFQRhgwiRMghooQjspgqh1wiPeQScMAy4cwizQAi04widogiN46h0AwzD0oiQAwycMgyjAaimM4iccwieIQizigquKgiTAqqsBgigcwjLcwSGMwiRoATaw6icUwyiMAjDwAi4gwzDcQSncAS7cwR7Awiw4wiFowh18wiS6Ai6QwiMI2xsMoyQ8AjQsm7N5AUScAaGSC6LVUtMki0fIUrYRFEHFBP/x3wucEhz+67SkIbS02SpZSI02Sw5kRA/MSou1kcP2ABL/UtnEQlkNXJRyJZ8CsM1FYZQFhADHMlgJHFF1pgCD1c9XWIWR5VvJNsEJ8NEFqNH1mQV+gdWA9dBn4J0G9F0EqCSQAcAFzIEV2KdPNcEcXNAFWAPxnU4EXMPKlQYZrJ50PM5/rMd8EMZOXQ5IkkZrwEYKAIAidIITYE9ruAAihEAMNAEP+I41gAJVyYZGTgYAXIM18IAneIBssMAnYcBglBxo1JZrTIMteMLW8pSAEsYHTAELpEEOnIEMXEEWdMEXvMASzKAnxMAU8EEQzKAWAUAaTN8edUsYrIQtVAMAeO0umIJ1pQXQsRYAUII2gMYMUMIqDIAGyEAaeIJenKf0/wBAGTxDEXCMDWgDFTRBGOiAIaiBIVCC7xbB/TgBIWSKINjADazBMWBBCxgCH3yBMtSADn7GKlACkz6lHDDShl0ZB3ZpEFzBEVzBEjyBmp2BHAzBCwgCFQwB+fIBrYwAHyjSBVANF3zBBRhCE8hmXfkAgx2RWBywSenNnESomYSF11YY/6zJngRZC3jJdvIBSQ3AFFgXAMxFdLanlezX31CJDSiCIPCPxa6XBohnbSiASPkncCrwgdlfBAPRvRkoP2rAhd5bn3Ds2zxRkc0NViRlUtYJg3FFVsxNCJSJVdiJVdAJhH1YGsgAEcxAQwxBHDiKDgQBowhZfdUJkkEZj/+VwABckYeZwEx87EWNIKpc2ZStSpElgSHgwCGqgCBYjBFwRLuUixDQqBAYAZhmARDcgBJAxCYIQSKkKRaYwSYcQzA0QhiowSD0qdPkTBEQQRaYQRZQARbsUih/AaFiQUsIwRd8wQ2ArROAgSfXCxbAASbAwRZckyLcAilQAy2MASTcwSh2gii4U8UoAqyOIjL0Ai1owiHUqrQeAjdIKjXAQjLwwizsQSZUIiB4KzAggyhUIjDKqrn+Yi/DKqwKWx3gAR40gijUQSO8KjAUAzcUwyfsAS5Yq6ceAiZgA7CiAihOqyh8Ai+oAiVqwjDwQjIfgjR8QicYEzLAQRRsyqb/hYEimIE88ZI/8RI+UYER5IISLA1EkMtE3KGieURG3FITfARiorQbzIAb9Gu2qFKZtpkZYiGeMSydxRmXhVkjtRiXaRIj8V8NAIAhPIMT2MCU2QD2WoHGUoQV2MAhGsISvAAODBIlvEAImMASKAwYCAESpECeMNjcpECTWclwkjBaiAUKlCgVUMGC9lTJeQl4YVBoUFB9yTXOThxkAMD1PEBouAlhRNyOdGRoYC0AxMAFvMZIWs7hAMAN5EJyxI4FrMEzPEMa7IJrFIDOYSRoQMBsVFfu2AYMTMFsMIMygAYirAIo/AIi3MAvVIMhjCTuAIBfzAlnloAPKIAPlMYu/1wDAOzAB4DGBXAyFDDEETyqG3BCDlCBIfjAzxIfcWDACsDAZPyBJ+zCKtzdb1HXdGmP9gwGcMQ1AOjcGn+BDKSGCSiAqQyACQCAYA5ACfTAC+hAXJ/OFEStzi2VhICGhPSVnlhe4LXxCIhWCjRSCfgYAHhdaa2fXU0I3gnm5qy3DyiXBfABK/CBCTQYlxRRV+Peg/rAD6gAb1q4CyORqsjZeFsBK6gfU6YBFwDAKlT236pnWHsFWZyFgo+FWKxAC1iBLKiW4C3wf/mNmfgmcNrlASNYgz1whI4xV8yJgeLAhSIZkl1ohrWND08BEmBFlmeFnHC5mYB1nPTjvrEJWP+zSd3EXlJqBYdpHYQpV5vTm4cVGb1dBVTIm6qQeBKUAIW+gBwAwREsIhQcgRp8wZwCOhdQARAoci4AwSEKwSacARwIghkAARBgmxFQI7ycARggchIUjRpwARjkAr7UwRbkQs9MNEN8gbtEBBG8wCZvwSBEQx10TBUY0xsggyW0wRZswSwCAiTOgiaIgiTCgiNAQiwqwiZCwibCIq/62jIsQ7Be67Q+oyUgA7SKQimUAiRiAjB0YjC0AjC8miggQzrPch0AQiMAAybsajWZMzIoMy/sQa3ygitgwxtkgh4Awi28Qb27Ii8gAynwgi7Qsy64Qi3cwiP0QSbcQiIkgqr/JYIhTIMpKIPDBEMskMzNANNA+NNFAJMiIMMyfEIUgMFF/6E/QRu1CQIlq/UXEMFFoPLLs/wLwLzkOk1MgyEWlkGbGg2efdIngaEUgiDDCn2LNVIjLcH92ooMPMERgEEiIKMWKALOUMEcFIENWIAVzMEemYCncBETSLUG/EkLeKyQt6aCEWd01tVZ0EVYAEASCIIKsN5ZoNfmFAmOYE+P8AVzXMZlP86A+AVg5LdP4VTGCdXTGcfvDAAI8IB6YE4E+DYAfMBFkoZdAcCJN0EIMEMrpIE1PGdpcAE3PKdrNEEMxAYPzEFlf4YNCIIh+E4aaINgggYXHMN9mgYXgEJ1/4IAyzElJcyBaax4CsAVYX+ABriAArhAEoi9AphRETDDEEyD63LBACQBaf8s6QeKbOgcCG+t74DGYoQGzgLH2P4OBsUmHTAIAJyCb99tGhDwelWgDxzRXXSAH6hAEvj2y5mOzEUc4k8GQGBQsEGggoECB2zw8CBCBBYjZCDBMGAAgAEdIhhU8KBDBwwdLHxUkEKDiQ4mUGrQUIIEDh0acGggudLChSIfQpiQMoPJShwlSEZQmeIkxo4dHmpQoNSCjF0zLFjoIBMjjpYyWzSZswtABJImZGqI0CGFjxQmzE4loWGthRlfFLhI0nSHBR0jTGrw4UNDiJMWuHyxUMInYf/CP0mUGFGiBA4kLpfokHx3scopSDRMKaF5CluWMFWGFr2WxNrQKUizMM2CxUzUKktPKc0Sh+bSI0AvjqlbM24cuKe0gFkZSXHGOuQkHyIEyJMeUORAySEnjpAbN44oCnNECHMoRMBsugHEiBon588DEZILDBgqVNQoAqOIVi9a1AgRI3aoGLdJzVrppZdmJuGmF0WoOCOLLIzAopFGiAHmkGWWaUSUO5AB5A046ohki0jwwAMQPLQgRJNYpOmjDi+0aKOOY5aBY5hDZkHFEkDgMKORGLWQJBotBsHkk2UOKXIWIz8BRhJJiokRGVGOBKSOKeuAQ5I7JAEky2AaMaP/kmjwwGUWYD755BBaZqEFlwxLQYaUO/aYhRABCaFFE01wSUaaO8tE5Q1kMBkGGEUECUYNLaIwg1AvsCDkGUW0eMQLSMJIJJg6NUEFFUEgeeQRLRCFJhA9PI1CUkaxwMILMKJIxBZT1EjVCjXUyGIQQ47Bwor3qCjCCCVeyEHYHGQQ1oUyXMihjBxmkEGGZJO9oRJTrujB2R5y+EHbH3roYbIllgjBBu3as0GOK56AogcmBgNX3Lt0YCIIHRh74YcRcGhhhhlC6IkkHyIwgQWvTEghhRZq2KWJARQAQIGoWrBAgRzybcEEC8ayoIWMNgLA4YIEekABhjey4IENRKYI/wMAeKAkDQBOCIGVaiwaoIACPFCgAIoqKsBjj22uiGehhQaAkmmQ0Jmihhr6wAoLHAY6AgB2hgDooX22COiffY7gA493HsCDrX8G4GuPrQbggaE3UGCBCxQgYYYIno0giQ80akIGADBAwoRnceBWChdaAADqqUMoofCOSpjuBSPKM4KKJADgQg0bwqACACvmCMGHHUDqoAQAThpBB40GWGGHFVgmw+EBHpiIIRTizigChjvyobiSNGKhhya+iEFrooceuuaRR+b5Zw9sLmCDATDYwGMFRrAAlF1kUcZjO6pBBCkF+AoCkS6YQAIKKaTIoTsphIACCiXiiD8LIoSI4/8JKsx4onAkevBBYtFDkzsfmIQoCujAWhqCEQyYYBUX6MAAACOLAdRAGCRIAQpS0JCSOMyClClJwRgzhYLhAAc1KIlPNGCxEvgPJUwIgcRaoAONhQAJQ8jBEuIwCBcwQQfe6oHpTDcZyURGB0uQww16cIQ4RMZbV1gCEkYwAihWJoq/qWJlCIPF2kiMJGshzFDC0kXRxKQ0JCThC1vQmBHMZgpW2c1KpiCDGnTgNyb4ARcu0II0KEMBO6CEFXrwBOTIgRE28EIRbBCHG7iACl4IgxY6oQhFxKcT0uhEJzYVDEEQIxaQUIQjQOmIZGiiE5KYhi1GMQcucEEJZ/jCEaj/cAhNJKMZvZDGHYZRikUIQg1zgAQcwsAgLGShCAvKwjHasIVBRKENiCACEbZQhx0lCRjDGIYmgCENZJRCD4m4haTawAxOYIIZcDgGJswgCWCGgZ1hAGYjjsGlaIQhGPvRzyHKdAhgVFMSmQBEKUrxBkvgwRKSEEWLttAGLUSiDniogyWC8QszECMaW/gEHPAAB1HAoROQKMUn7oANUuBiD8m4Ay2IMadmJCMZjhBQLEiBDEn0Yhm4DEYr4hkMSWCCEKbgZS9tQYhJzCEQiVBEJ7TwhkRAYk9jIIUqarEHPdjpFp3Ak0tpQQqtYrIThDBRRyGhJUkkQg2JwFEYGlGJ/2NMoxKvsMUcigCGF7ggfcuagQtmMDj1QGEINrDBEI6QAyiE4AhSuMGwssWtOPTgBznAliTVgIpYOGEIQHCst4gVmSWUoHz0+s1PSqADFShBDUKwwWZ7YhaqjOAHS5BCEoqgBCHkoHBDgE8w5uCFPKCCEI8IhCIIQYUWFIEKRpADDmwQghAo4AVzSIIcfoCDCGAMBRfgAcYawoIp/MEOwtCAGFiggKY1wWMsWBsEgobeByzgAWHDGUVgsDaGtU0GSSgDFAYhiyCwBQDSswjUBsCCD5DAIwrwwM0qAgAIqCYCG2jI84g3vOINDQUVsYItrACAS6yiZgAgwQ5wUDwAxP/AFJQo288qQgkTG80QAEDBz1QMgAtEIA2y8IQB/VczhjGvaMczQXJbkLggx0F9IWjBRKwhDIclLyFBazLJgrYznW2gAAcxoAF7EIQajIBjApZBE75WNOKJzcli85knDDEFF4SAl6QbmA8GwAQfBMEQ1dAYAAzBCYvwgRjnjIYtOPGLG8iCE4j4BRS68AROGKEFQzjfDd5zhhtIYRNPGMINwiWEaGohDJtYwxo2EYSEXiEOXWitD1YIEwAk4QIWkMkapdsBA3aEBRYxicRk8AUmzCANwpHM2TSgA9GBdiUwcUxMwCiZJiRBASZ4QhZ4tUopvOALWRgCF8LQhBaACwn/OmgsEkoArh4u4QlPMIEOchAHKfjqGM0w7Q3iJ50cBKEHxeHDC54wAmvx4Yk9rMEPi/MDN0RXAbvgAvWguBnDyGAGJijOGmnTxsWEgIQ5SAIXWGGFGhCmJbX5rGYMR4LqPcZ/CmCC4gCw8SC3IMhyMAIhUOEEL1DBCY0QhCJu0SlROSEQodBDKHKuBUUgIxatwkIUIumEpWphDsewwiqSEPUkNEEFTZhBDjDXizBAAwtFKKYVEGEFKzCIGLS4hRcgR4RqZ2HsgzCDGcJQCUO0YhRpuMIXfmWEahchCljYQi6IUITAx/aZziQCIqgwiEFUgxNhiAYnIM+Ft8tC8YNo/wMciLQMUeyzSJ+wEC7uoIphiEIUgnJRG57RCmJUQhCmMEQliDGJSRBjGcUgBiaA4U5RKAITVo1CHvIQhVbNoZF6cIUxcqkHPdRiDMIX/iMSoQUv9N0IcCfGM2zRq6OjohOhQAU1MImKUSUCFVroQxX6EAggFAELYABCFaIAhkWUQhrS6NSpouAFLzwiD5fEhTSogRpooU4coRaSYRaWARiIgRtsIVaMYK7SR1nQx7AuJVJQ4UQkCxDCgBCMYBPOQAiU4AG74wzOIAwGIQ6ggAoSoQqEIAuEgDuEgK52YnBcQDLYTgh6oDHMqDRC4KiOwAZcgBW0jSyEImBO4mE05v8shELWDMICbOAJAEAHuAAL4qAFjgAMbsAJbCBikuALUmB4DIIgnAcD0MsDMAAG0BANMcAMMeAMIeDAMEC+CuC8dua9IEAh3OvA2GYDUuADSqBhfmZkIqAFJOsRSOsULoAKZqADgIbHUEzHKOLELGJkVgDCUocHuKbKHvFqlEdoqCwSh8djeGxqpicEpoELAIAKnuFluOAZnoG8kiDDmsAUAOAVTCxsEqzHtsYTwiwSWcAKXAd5eEYBmmAC+usBpgcGak1oDMIingdoDGIqaoDe9IIFZC0CakAGTqEGtobMKGJneCwhHkBkLOAHQuAKbmAIzMAIpKAaTqEFrIAZNoH/CjDhCILAFRXhGQQBV6YhC+AuDPIgGDBhDbbADNpgDbCwC9aAEzjQCRQJCq4gCJ6gC27gCW4gDJjh7Rhh8zqhpXgBECzhDhoBEG4gF7IACpCgC5KgBwaAC97xdABgJjxGLzpCL5jCBWogB2TBDK5ABpBFBn6gcgwhBAahtGbLtqggDuSgDKoHLYjiJP4mCZqlBEyg2dCtB2yACZ6gOJ7AD4LgJJFgK3Vgia4AHa8ACsBgC4BgEKDgCK7jCX7QBqogF+DACI7gfNTFiZggDgSBCwbAWnrg33qIrkKrWyIjiggDCRLDMBJDB2bAh6TIMULLCX9ADoTgBebKsaqlBhXD/yXgxYSMxgoUQAd2wQWG4AzMQBByYADCQBC2LQSogBAKhQpiQQsggRpioRWWIQyi4Ags8gqGYBDCoAoIoRO84BiowAKIIAxMgQu27YckYwS2jBitQBhOQAX2xeqSIA0ar0XaYJi6LgncwA2sYBfELguwwAwSzwroRwhUIAalgDy/4Azc4AWgwA26gAhsBQsGQQgUBD4EwQxmDts2CUBoDxhaQfUqIUGJIQxQgRYUIQqKQD0VzwhyYRPCwz/BAA8MChfIBBhmAZvuAA/yoEPWIAyAIQpyIRKiAA+qAA80IRiAIA8CgUSBLw8sIRLgbxEWIRP0ABuw4Q3eAEMsQflMZf9DGgESjOoNvCAR0A49iWmYGkQNwoBKHXRTEqGoCGH6mrSTBOEZ8oMQqmD6BKQKIIEWUCEUFCEWQsEJwCAQjCAKjAAMsAAVjKAKoAH+OqEPHmEYRkkSbqT2CCER3K8L6EpZygB9uuAFbWANckENvEA93AMMjOAGhIAIDIEZqKA7gOAG0CUHXEBbdGBwrMAM4iBxSgDcEm4lSABiDMYrsksmDMIExsJwxGIscDWBMAJWx2JXI4AjpgskrswgBOIa2yZ6GCZZyQxnIABnJFESxcAOyuu92mtnUOYNFwJ2GAa93kvElAcXASCy8CMRruDEuIC8nrVsQNFj0uASyEZrUCz/AKZHElVmAD6AG10AXTUCaIBSDYQLBwAgCwShUdaMyGToY1BsukLguKhABTzGvzzGGpRhBSgieRqmCV4GEhlmIiasIqwhwwBgF+ZgAELgCZQhDWYAAGYAkJBgc5iBC65AB5pgKoKgDGQgCHBDDJaCD8rADUYAbMBmaNSLBRaABVYgAkbgC2RhBuBxDozArGyuF1qBEOAgDyIhEYzACVrAr5wACJwgBIZgIp9ACJwADj4BnW5AFHrvE9S2GUZhqIoAQdqgEb4gDOqASwCgEYABGW4gCgABE9QgBIogF7SgDjwVCarlClIVCXxAWAFDG6aHFV5mKiSmBpjgYwFAuQqH/wV8wIBMoAUe5mL+xweWoAi+4LTiIGZLAK+85QJMCCwEhnM14CSWQAaHpQvCaRAuqwfKMg7OQAqMIAuiAJr0ABA6gRgSIQoEAaSiQA9KIREiAQwiYRM2QQrUpSK5QBBegIZkyBAa0Aa86nI4Z1NtYA6soHxKQAZU4Nwkg4d0QAZWAiVGxxC4wAakcHtnIAukYAiQgIekgH+uSAd2QweKo385K2ISp2HGYnYHQCdqECuj5o5yQrVKYCxYYDBMwHDwomFcDQA0QDproI10IBtrgA8CMxu1ha4G4RiIIRjaoHqlwB9Z4QuAJw12YRdYQQ0M4T16yV93RQ24wAi4QJWkoP8MrMAQbmAThMBCw8AMfIX9BEFT5iAK5uBENm9IFnQS3nYStKERJMERPkERcmENzIAZ0LOJaxMIoiBPtaA9HkGykmEYOkFLFEETKKSgOgEXHMEYcOEQVAEWYGEP+ngWCqEQ7EQV+OMQBIQaELAYPgEXHpmkCjCqQu8OtKoW9GBU1ngLtmCYGMSYohRyjKAIYMvrYitOwYBFWlQTMEERBAQVFEEP8OARSOEW+kALBAEM1GdOhQAL1SMSziAS1oAR0K8PXOEOZoEbYsGplDQXhMUIBsF63cewsCBzwqANqMBToQCbiUANBuELEAERsuAUlIALvHcof4MxwE0HWRU0gEL/JryiNQwGgxoiBQbGK3bVKOoZIzKIVgGGVnfVngWaaXYVA8YidhRAIEImoXdMbBTgDddGDJzBGfKLCMwgGhrhFzbhF1rhQRChFp+BbMBxDmEAbUoabTwgbWoGwSJxHLVmbE7MChTBCjbwAn4mDLTBXctmATpMXQHAEyiBvBomDbiABSrCAp7BPNLNCwTBpklGASYlFjrBAqjgCyLmCcIAFR3mCfJvM3RgDRZB/RRHYoznBBYGFGvAEIRAa2hFBZLAyCSmbcTrCzNXDjKYBfiABBSANSIgZFhDZEYmZ9JGZX6GDEQW4wznCgbghmctCJwhCHB2vzBADIJABrrgZ3lm/wNg4HZ4Jhy/cW26gq5RBxC3prH05wX0z6iocAgsQOwsVRC8ADap4AhIqwiAQA2sQAVcoAgIVR0HofFCgAg4gQvOwJybgA8497jzzHU44RoytwzAjbEsOwm2zCTIgsA2RwhfRgOmswUakHRIAH5bmxC4AAfAQBCygG/asA2JNaENYhxRBr6jhyMYwgJI4AOENRoV4AvwuyMSyAhNgAkE/ByHoP1sIIM9xgKggKkFIbmK4wrOwAgiHEOlYAmu4AekgAjW4ApeaABaALkcJo0UoAX85y8swIVaQMB9gOVa4I6+IDlQUAikQLkYA1x6wAUCiV4I6CQMxgT4wApkIMXVB//ehiCDBuYofCBeCkYlehWBRyAEwoIwiMIHWkMxagAHHM4NDMFnuYBp4WUJvmAXLCCK/E1bcqDcbuCZdpITJmqtqAARXkAWrCB9rsAEbCh+bvZYyuAHck0GiKyys9EFXOBZZsANkgVblOUFrBcJgkCx+CoEDMEQWiAHivg6bgAKluUHbIB+zwAS7gBO7kBMRKkWXMF5sUkRJMEMoAE7qgAQHkH5osoRDqFOikQTZsERYMER9iAbHEEVCiEbbj3XZ2HYhz2Q9yCQC3kWioGQ4wTXS0oPkgp/KKQR5kA9qYALrp0KxK5XTDkLOIEYGoFEyMoLoOH3qkCY4U0JsgAMuuP/UudHsJiDEaLXCUJBE6hBE0ghFHrOEQSQRVChCjYhoQRSP6jAsErQOqg4m7tgCSC7W7IMXSC+B1iuiMgcMRmDJb4ojGSCJKQ8gzQABZgmYByCoHGVKGTinwOmNTDihFTLYF7VYMiCNVgAoPv6Vz2iDceRWDnXK90nCHygC4A+zYMAAKzRYx6g1n5Bz2zmZ5QBFDzmGiqBw8bmEl7hGgJgIpgHAHwBBnLxZyS2bGYgDIzAr27OCUg7wdKgCOCVaKYrByw1DsiaoRtYf0ZGXRMMXtNVx/Lep5+16zmRbBQmJi/gaYGr/PgvEHQrFrwAAHDALb6AYZCWYyJgBQyCByaA/2M2YAVeLMHaUAP+4APEIPQn2wecwQ30grLHp/SDYGMTegXWxsCS9QEqUSAAgAys4AOqh8mOQmT6Og4JGjdIJ1WZwMaHIHGE5QoUoFkc5ixQ4igswAQahw8IWDGKIwRyzRDCIATS4BRU9gtIwGymwRAsgIZ6YAkGKCtkQLwwIrwoMwUkRqH32mNMIGUY2mPi0P5DInoEG3bIECAwbBCI4YECgw8GPujwAANDFhgwRJDYQUMKFh1gRBhAggULDRpYAPChgaQGMR1YiAGpwQ8TJE+QICHpx48PAFZYyXzJpMcSJiaWtBiy5EYYTJKAhPjhIkeJI4o6QYqqRciSHkJcCP85A2WJlaY6cHKZksKCgjQyrM0hoaCthbcRUqQIEcSFBhNDjBQ5MiREB7NIhBgxAqapnCVD5FApYiNEiBJ3fbTQ0MJCCRIpTJhQkSZLDx9lXCAp0cNFHB1Xfwy5kePJlRs3cm25sYbIlk1E2txYVsmJjSM3hAiR0qVMiCNSvhCRIiWHjB4ycpQJ/YJL1hw9auS4kOPHjx7eo7so87y0DO85cghRryTr+uHpm08vM+QJFOlXgB+xYQP2DSBHhAFHJdMw04YkotASSzKOOKKIF4nkAggQRiTSCC6O0OLIHrDA0iAuyfTSi4Yd7pFNhwzOcsiKKrJ4CC0aOjKLJrgMA8z/MJ8Ag8oc2phCiTJAKsOFFVRYUUQRWYRhRi5nqEHNI2MQckgeQCgiCBBqXCnEF1lIcV8OUADBBTCilMLNKNx0QkotY5CyB5tj6FFFIHlE4UQoTiQCiRN5QBPMM04Ag8kaTjRiBhi5PNGZDj1AMQQzVjwRxA9SuKGDHyMgocMInI6AAw4g1SDDCCWMpkEJJeDgwgU4oErCqXLFaoJcjmkWwl2xlpAZEymcWoIJJoGEKqo2XGAFACEgcUUQXUhxAwAAmNCBD0HIEEQQSCDCDCIAmMEJAC2JQW0QiFRzihhB/NIEAAMAwAIf0GIALRmeQAsAGZVgEg0RAGAAAQDVTHIK/wAeFAwAHwMP4MEA7RYALcPs2ivxwwFE7PDEEAMQQLsTd8xuuwxDnLG9HHtsMskRnywxyBGz7HC7X1hhQRE5FOHFVKRoqMke1GhyBBCJ5ABAB39hoEBBRhutwEADHc3CFC11gUgXQTjjjB12gCTG1j78MYId11b99QcRPUDCRkcfJFEEf+HAygkmINFCDznYAAYYvg3xwyA+MPEwCx5I9BG0LeTQHFC3ZvHFEEdj4FEHHyDRgQw1aOCCDj1Z8cXQf7WlAMclWNBBExpY4GnoLehgEdsdRPCA6xG0tbZBjUdku9oPPODBQLCXPVFDB0Gr+wAFTTHFCkY31JBCDzDMUP/rrRsdAUYsrDCAAgCk4SMAE3QAgDDKWHDTCBoAsMspH7FUehOGkOFuEDWNUNNnQXTqAxKZWjFDByVwnNLZGCkfACzAMAuYIAIRCEGrdMCoFjDBByOoQQoQSEEEQmsEXGCFswZBhTMwIQducMEPyFcC9QiBNUtAlQLOAIg3AGEINhhCEbCANxu0AFlWYAYVZsCFIVCBCwPUTOkUYIIkyMACOqiBDtRjAyFsAQw30EIikHEHXpCCFFKpAzIkUYo8vAEQeHhDKbBRilvMZghvucExwtCCM2xiODcwAhasoAZDUCEMuRDEMtpwBinI4DkflI5zrmAFLkDhBlDIAhbOcIP/N3phhtBQBCrCoIYwzMEMYTBENMwwCCIQgRNZ6MILkvACKEAnO2XogiepFgQztKIS2yCCFuogoDwAgxCvqIQlixAHISjBCF7YQhiIoYlOPIIUjkgGLIxhjDGMIRB6uFsohACEKuRhEYvQwyICEQpuBuKbUYgCFqhghjdgYhmtGMUkXqFOU8xBGYZQAxeoUCQkCYEIVDCCIqihhzHUwRJRqMMWBmOEMxhUCmd4gUKZsxUivAEYhyjGJCbqiDEYwxXJOAQk8NAIYCwCD5+gRiw0oQla3GIMwQgGMPDQBmIUoxjAwMUnmCEI4VhBCMwIQwiSUwYuNMENfCjPpvCXqVLJ/2QEOmgBF9Rggcf4wAQv+EGqRnCBJrTqVDpoigmtEIclhIBXpzJBC746rCTMgChLkMMR1HoEMBwhEcEAAxD8sx9iEMMJjYRCEA5JtRYgIghXgEIXYMOJLQDWDwBYBTMAwCz4haR5A6gYtKrhPghUjGMQ+FfKYPCva4CCD0drHgA027KRqey0qEUZy1CGMdZyTGQZK9lrO1aylLFsZCF7WGk5poAj4OEWpIAGGLbQAs8tLCIhC5kCImCBAcrADaqMRjCKwQlqrQQkI3BGF6DAXcF2QbtdGAG7EqI04jF3ABaIwAoiYILmViYORhACFQgRBiHgDRKlqAIWUEELQhihuf8A+EBT1ECITkRBC17EQyRuoIBD2gAiBtTMqx53QJDggFT4e44PLOARH2Bkw2wjQQkUkJm3tC4z0Jpe7BC4kAcYzwILichEkAY8HlSDB6FVXkGmlz1KEEx3D1iv8HJ3kOXKKw1p4JwFKEGJDzQBIxIZQBouYQESAEABLVFGKtzlA0RoQwHpWwWnWjKTAZThC55QhjYsUC0mLMsEZjADTHKgHFnIZAoTTknrFlLBlKQAM5iJy6lqUAYcMCGBLUjDLoa24uXGJXYWqMEPLsCFGQDgCU+4X988VeIW+CAFEKSzCnKwi6XaAAsQeoQmCHGGIzhBPVjAwhFacIMjRFUzCmD/RRKIKDoLDEEQNV0kX47wsxk2xgItCGyYhJOHUnyCEHrIAxiiEAZgBMNQR+GCktqAiSy8YBrTsIINjoKJMOxnWWawRS8YAQUinEGVWcgFEbggCDOsAQiRCMEcmFEEI6ACFYIwdy6OMYlWNOIZZrjBLzr5C2ZB4Qo9CAEAWlAELjQ3N1ooRSPu0IgtEGETV6jPE1qg0Cs4y3Bf+EITRNiDGyihPYwothWskATh1LwpTNGqEF6gBFImIQlWUEIoYs0FLrBzFEhPetJNwXR3ynOeYBBELMKJt05owgt1qAMcIrGGNoQhC1k4QxaskAUiDIIVZ1CCbRCxhSoM40WxoEUy/2oRhUBUIQp4wIQo9H6D1fjHBrjZRCS4jgc8rOHwYqANEVzgghfcYBBZGI4Q7JPy6PTg8pfnFBKYwIRcC4IQzwiEW5+wBPKkqnWvKsFjUEUUOdyAPzqAC9HMZwhWcCEENvCqHFq+hjzkQQ96KEUfqlAFIMhBDkNIPun508jXQ4EZhijcFWpwSk6EoZNmYMUVRtDlRcOAB3+YgrzsJVlo1QtaAUi/Zk0BitHaiwytmAb22AWB2qb2/vjP/8lmu9rW2la3/FdaLfMxyXU9DJM2DqEDJdACLZACHUA8BeMB8dI6I5ACbdEBXCALWRAMg7AFjaAvQRANrRAMv3AKGIApfv+wV3pFLdwVNkHgAxhgFikgAyRQA1PwAcLgBkSwBCcxAmdQByUVC3iwBZVgBk9QB3dwRZCQCFdwQy2AXmYBAKygDUiwBoBAC4fQCzTiCI8QBaVwB4ewDIqgCFFwBFlAXzZQQr70AyHAAiQgVgO0gO1lFm8hOilhER2gACRAQhowAkwABocQC+zyPK/TARSBQK0zAE3QBB+wEf0CA/ISEdACiUijiNfwhGqzAW2xAtrACgCQOxHANFE2ANNjAjgAADtwASABEQ6BARpgB8wARD5AEhDEKX4gBiygaQqQHZxgDTjBCWbhB0hgAR/AB0FQDW5wLV1QB5CgCYoAB1vgcXr/dQUycVSQYRG6cismEAIpgAIV5I0roAEkUIsEBADMZQLKsC5Lg0AX0TrYY4iNQzR1eECiwzY1EEEuEAK0JgRrZQIK8ARC0FwDUANN8ANHgkbZA0QdsCm/YgIlMAOrIgMqIARBN0NWcAYZtESlVkhc8AMRlgIlMAK/JFdVYAQUoghGYEMzwAomEARe0ksv4EtZYASb8B/m9AnEYAbMMghrUARU0AYeRwSIYBy5AQdwEA2G9V1ugAiD0AaQRwSqNAiDkEmcUAnE8Eqp4AaywAlmAAqVwAyV8AzBUAmV0AqYcAyNQAzAcAzPAArVMA3VQAnVIAynsAoeYAddIAY2EQRl/4AVUgkFRiAIWSAHOTAHPpIGSTAYgjEH1gEGVCAIVvBqLkBzCmAIhIAKhOAEVDAJo9AMxiBRSheakyAIKYUMpTAMd9BCefAIWvAInXCapbAMxQAIkGAGW5AKrSAIXhAFljANvWBvbVBvWoAghDAMydQHfWAJX6ScLYQMooAMgCAJWgcMcGAJXEQmyIAJloAHcBAMnuRJUgkcXOFJsOElg6VsYTMERCALZqANOeUEAKAGykBi9zgRn6OJMegDS7AET9AfNxAHcYBGBXgx0PIXolMCqAEGb/AIv3cL0dYH1bQfIfAER3AFFmADxccXfcGACmAWG2B/0PI59kKg+lcxFf9DBqBgBwBwDa1wDR0DAb5Aovo3ozR6f7eVMrrVWrM1gPxXgD66OwzjAQh4NBYQEWKAAQbDA6tggkfqA1vjBxpwLZhgm6JADLyxBsdwJqPQfteSgqp0DMVQCUxJBMpYLVcAAJRACGrwVUiAAU7ahxbACkoQBstANdw1LinoGEygASkhcWKhMcrCQsPwnLEgCYmQCFWQA2jUAlgABbQWcshSBEmQBZKgCIxQAirwBS1gBMswB4wEBS9wBULAgD2gA31jAj+QBCWwBG0VCVgABEDwBNDSjhPhOobYOizANjwGLdpACavQLw1hARcwDe0XjyzQLinwAEWaO7zDMKHoaLL/g4AOoatE8zgR0WEdOovYhSl2ID89EAQ9YAWUIANNAB0fsAqUwAq78ILMkjV+ICqvsQWaAAyK0AJLwJQ3wAXR1wOI4AJKhFQ54AKjRpEzkAM1gAMdMEGxggIscAEy8AIzIAOgIhcdehAVxAJ/Rq1E0wEm4AJJUAT5WIMskF4X1mt4oQMh4I9f8AxC0xbZIySLqAMzMAdzMHImlrAjMAMOewFt8QOlIzoC5IAp0C4UJBdE8zUFS002cAVyAARgQE1PgEhtmKpnYARaQAg1qwNZ4AZIAHlX4Bo30ALTMAlqAC1WsAzEMAgj0RInsTVbk1jb8AGpYAqsMADbdQVihwiI/8CenDAIQTA0fwstdiALXdAFM9BuZiALZ3AFNrBXZbATXQZdnDC5v6C3v1C4g2AoZGoGiaAGT5sEaUBzVIAKkBALsUAFEAIHUQAFozAHG4ADBvsB2tEdP5ADTqACggAJ1MANk9AME6VOnDlRzdAMvcANxXAHqoALHrIHjyAIYGAJvHAIn4CZq9kGbYAHVpcIhJAEgjAHeRAMnRAGYZAHkoAHWBAGjxAIWqAIX1QHXwQMd0AbHBUNeFBSeoAHs4QJmmAJ0rudcPALtmAKthAMhNAMkHALWNcLz8AIgkBvzzBzCsAFaSALsoAxGyA8G+AJH+AAMQAtBdAuMVAZNjCznv+IbFH4wQBQAAGAwgX4ORdzPQCgA0aQB804vMkwBqEwa3OgBkDQCbfgBE7gGHn4OSDjo/1XfjVKfh2DxEmsf/0Hojf6fwA4gFK8Mg2DfjyqMhxxrNdzNEJKPMRjECwAKvFiEeXjASchMWecghjACQMjLj5wA3CwDLJJDJwgBq3wu6AQBFsABdTiB/ISBKtANYRcBhowAH2IPWYYAohQuQAgBvaiADhQBlI5CFSzt84wALmIBM8xAElwDHNgCC8wiF2ABWELLb4GFAbkA0MsPhHAEqRSEh3wEq1CGkOQBYZgBmdQBocEBITwCdIWBYoKBl7QAlKQCFFgAx26sQpgiLX/6jgOQTTQ8VSIqADCcA1TgIhlIS8d6wYeCWMYcD0RYYgFET2ww44pUAM1sAEPOHHpYaGiegMUChuT52lIsARIUBPwEzYyQI09wASbMmZTkIe5qAFl8FesXBEAYAimAABDkgbk4z0+hRMzUAY6MAAxYA0l8AFWwAcqYAWK+AUkpgAyIDOCdhdsIz6towEUBD26+hHsyDqaURZuITopFjsKkDpx0AMA6mbOgFjEswED8TBu4RYpcGEb+xfg0ivWkAYDACyqYwIp9wJFAAaKMAdA8EZnIATP0V720QKGwAU5kAU30ANDoAaxELaiowAzIAtqcARX9kAeFkDyAzZ3sbZ2/yADZoAJbuCmYuABEIQ1f+A1N+EBsjAHiFRKbgAsKfsYTLALr5BLg1AJvUAMjWC9UClCtRsEOTBY32UthSsLvxANUolIKYhIerVdYSNxrsF5SIADmPMf/NEXQ1ADF+AY3gG7sK0D3sHb3sEdTlBJgdAHj/AIemAMmhBRhNALyaQJjnAIqkAKehAL0uAFanBgmQCGGyIjszALe/DcJUULwJAjMvUJmvAJjhALjkAIsUANL4Len4ALh1DeoiAKw4AJmAAJXgAEUaAngHAHuMAhs9AJjqAJsFAIjtALw8vcyEQNvtsMmlAnNmACIdoWA/DBF57CKdMEKICmyqDhdGAKz/+QBCRTgCkcWZFlWwwTziLDLthjAUURCNJACnjSXNowDTdwYFWgCGHAYdiTW6RFgCcDAzIqMQEAA+VHBuvSxEzuMasFolIcxVO8o7WlXAPwAC9jfzt6A6hABeKEijxwPYloFtHazKgcM2yoACGACY1ABG5QCcfwCwtXDK1wlbzRCLwBB3WADYcwUa3ADcugBZjwSrCELldQHMqoV+TyV84AWCMwKjVgDcIAAMpQDR7wtj8SAK4oA3obBDewBZzwC5wwCVuGAT2geT0ByMQzBSNwCjUgVgqglzLAg6WSBB1EBI+bq+mcA2wXcSUQAREkA48LAEc1Zp9TGZJMAgkbPUT/oysOiINvGDtJzbE+UColUBG9MgJvMQJJLT5SsAkhMAQ9kAUjBmbkMwJlcAGzYkBG2wEtIFY90AgVrAK2QA2EUIZRcAv4dQeoKQn3LQqxkAVQIAMu4AZmcAzH8IJM8AScVwN2cWXUMwX3qAFL9AU00yopMEAtIF7myNIgQTQ+ILshvwMjiyrtNUBugQSfYxYacM8/YAUy0ALVGNHspQNdgAPvbgKrOC0RcGUmwHntNQAlkGkA8AyVoFTTcN1ytQlr8II3QARQgBIGQQIksF6vQwIfcGGQQX3bCABMwOnW0lhl4AZl8LU6AAUxgXs3gAWbsAm58HBI0KXw4wdR+3rL/0KNLekD0NUuopOL1jKLSNADSLDJ13I/M6EBbsoJmNAGNzEIwcAJXToCf1ASzuAG3jMDRMB5q4wqoOaAVzY3JRCiKcCADkQacpAFcIAHmfAGN9AsRSkJwWDZX3TZlhCNNXkDLlg11aLZpcooWoEdDNQd2+ECRfAVNdMeoyRCF6DOF9D8F+ACeBUJeVAF3RQFohAIRzBOTksFx/EMt3cFawAJ2ICcoaAJpDAGpaAHySANgeAEjAAEbaAI8vwacSDP4a72/vHpZnCVUgAQFoYcGXJDiBAjUaLUKdXJ0aFZtBxNpAaLlsRkEvc42lNoj6pQNkyYiKDApIIBKQcAABCAJf/LS5QcsBxQAIDNAShT0nQ5IMDKli9fPlixYSdQnziRWkC5gSYACyWa2KIE4OhLbcpAvRIKNAMoUHRYQoABwBMZoS/pvAJ1jYwDX5QusaQDai4AX77S7uXLF2nflzsD0xQM4AEGq0+BwlhBWGVglSkLRNBQQgUfCy2EcpkGAESTJE0ucBHCyEYRNbZeAEDZQhEhW3NenjLEbBozHKwV1BgEhUgjTluiYeK0ZtmvG23MrNnyBg6cRm/uHJo0qVWwZcAOYTqGKRoiKrKeLDnDhRkiCz2CdOlSJogPlApWkMCAAcYfO3wQW6MUQ9gUJNxAZJBKOFnPjSDKkEGDEWpAYoT/ETTwQYMP+LhgCgB8kCGaVBq5AYogNBhpJSG2kMIHDCLYoAMWeljCAspaCAEJFnwAQJgaFNBAgw4s6IClET6o4YkOFGDJgsw0G8CpEko4IyEwgDjChiGWkGMJHZZgTcaROujABPgiiGAEC5IwhAkTLDBhRwZNkOEFJpoMoYcfknghhyIQQqSFFjSw4CUkeyCkkyP6UgDJDkIIwQIb4AgDjjOqHKEFIQRRgzUxd8ShBhxCSEHRCHSgZAYLcMAhhQhYANCFLIwAA4ssZpRBhiDscEMIKsJIJIcWFEjimE6EaKHJJZAA4JhnrrjhCSY0YIKJMwbJxQgilh3JBx9MAOAZ/y4AOOIGJxRBJQQbqEjihmUZweMRIPCI5N1S7nhjiyD8YCECliKYwkGmVrKBzxYQYYYZ5DYZZJMPobghiCAUJmKLG9aoY41lr+giiIUZ1vgGP/zA1o+GQVzjYSI2CQKRY1bxYb1BfBDjih4Y9AMJP0AEOYgrMK4XgBvilQSPNup1www7NA6CiGieIKIHJJouYccSmpYQTB+anrAEE0JY4okblDWimVEmsYUKJ6pY4w1RMhGFGG6KCQaTNt54AxBktKgDYoSJaKONLc7oIoceZOhBhyug6KEHF3JQwYUSehjiiyKOEKKIYNRo4QcdcPjgAxsuOOGCCz4AQJtJTDGFkv8ETCk9CSGAsKGSaWzhIoQnQmg4Byh++MGIPghpJoxYUGnGChvItaH4EEYoIQQc5NQghTTRTNNGAGYsgQkklsAyBzm4xmM6iXTRhRRqSEkmFPQDCckJ9p0IAaoNDjVJMpVscsmltHDaayWgEuMfMP/tLzL9A+BTAAiBAiYwLWgxyyqEgkDA4C8x+3vJBlDwGALGoAkGfEkauNCYCSKJNV8QywAcUBYAVCMNjlHAA4CSBCskQQXvU8lJUPInLAgCFXNA0qFU8AIr5CAJO4CKSVgYAvexpAWCmAP+HrCvP3yATLv4xSk4IYtTiAEDGkCEBwBgBx7YYQR8yEE1DGGLVtj/4hWtaEUqOMEJg5nhDFKQwp2uoAMfsMBIK3EDKGThnh4gJoBWIctOrsEKAKxAAzU4xQzcMAMWAGAV1bgYH/gQBD6MwEacYIYsBjG4CCnACtN4RnTq8K8RuCEOIQDDJ+AwrA/gIAJfAoAh1DCHZlBCRy0wgiJuoQgjWCAEQkhEJ6RRi2R0Aghg0AIpaKEJR2jiDtLQhDQI0YdH1GIRY8gGLGChiU6MQRdjkBIcPuEIbFgCCEDwQhW20Ii3AeIGaHqCF1BxBB01rgRPUAAX1DCEHPCTJfExCZIsYAVBNGFYHXCBDW4JgDjEoQdQyMESBiCDLwDhBq5TgzKpxAQbZGEL/wcJgQI6UB+TYoApJolACnBAhRmMBEsu+MHTkNCDK2BBCFAwXA/+4AsakIEGQS1aDYI0Ah2cYacyKEMZ3NAEFyAhYngwQ7VuIAcg5CISYKhDFJiFBCZs7QZqQAUk8iClTUTiBiZoQRdyQQUtuCITi4hEHuqAhy2IYhjIWMPRZgAAVuzCAjcgQsm2YIZGQAdufNtCHfa2hUhsYW++2Vsu6iAK7RziGMAwwxa0EInESnYLjd0CHNrQBTPwTW9miAZwwsCM0SoHDxJrRBAAgIQyEEEGXUCEGTiBiIsJpw11QCwytFOMYtxhGLxAmyTeEIk1gIhhNxhCCCK2iU3kIhfQgP/uVp8DhDNswTSJ0EIUIFGKRdyivJAQhClYATxCUGMZgCBGddp2CF7gwRK8wMUd4LCGNVgCD3DAhBnMsAkouOAILciBDOKwBCnkQAeZU5QOkJA4G+RAwzaoAZ8+kIIJfOAECUjACUw84hJTwhRzOEEKUtAEbRzDFLYgV4mioIU33EIS0DieDZzQY9YA4HhHAEMivNAGITwhB1kgghnuNghOEIELRNBwgx9UGQ3M7Al+eIIcnJCIZxjhGIoghfhU4Qhq9CIZ1GiGJtgXBkW4rwYsyMn8JGOVn/wkKBScIAEV+GdAB1rQgyb0BNOwwr48wAF+hsED0gKUZzzDKoVJAiH/koBnvtgEgB/4ghK6daQOlAQlEeDUEmwQBkHYoF/8AwoZdoFCL/pvBU2IAUuc0AxbcHAlBdB0oHv95/vxuSsG9PNLSGALbbCkCa9owjRSIaBVjGAKU9DAFDogA2uUAQlV80EH3MAH+LBECpLQAkEcCWEhVKEOQMCSDqbwtAkRgQq5AALTeqBdSChCCBZYgkGAUIUo9GGdV1gDEP6kxDgcgQtJ8HEOGAENUtwBEJDQgjT2KiUjYEIRb6DYE5QMcGl0AhAaVVYWIJUSkyrABD3IwY+MdIMo6IERunlJfNJUpAfw4E8dkNAIZsCHl2AACnBIbd9u0CQTBEEJQjCBFHRQ/+ecsOBeGFAABjbgQsBSwQpc0EELXCCEOFwhB05XQBBcUIYmXIIMa197UOnAgymQQAMkKAEOfiADN3zhBdp4helMoYwvdOEMUNCBEJ4DhiEU4QcKkKoQwJWIXqBCC1hgzZe8NAIp3AATtFAEEJ5gASYEwQSIkEUXOjCCMvSABWoCAClvgIQrtMAGcXhCgqDABB/gHglQ2MTI2sCJaXCBFS5IwzSscAMChYEmTmFJB3IzQZbsgCkpAEATDAGAFpgnDI2oRHXENolKXN8Cci8SVHbEghTMvVcyCkEkRPGJ6vQCGJ8ARiMa4YwWlMHxiigGKhbRtSe4AiCAggFUmOMBgP8ioIJYSIQqeJ8nYI5IgKE6YZ4q0YESGAFTY58xGANqmIRmSARR6ARHmQNMcJs60AJgAIY2wANFoIZOKIIXoJIhWJ4QKIMfaIEnGAJWyCUOu0FDaCIHmACWmANlaIAJmIAEmAPUYYAGaAAREIEJEIEAOIFeuQDuYYTWOQJoeAQsgIQqSAQ1sCcFHAZqmAMlCIESGAKuWQImmBUjcIRPAIJBAAbPqoM/aYEhMIEesQodOBQloIIo8IL4CgUnmINJIISJeAhHkIZk2INaeARUQAU1cIKVUoAC2IACqAmgyDNMIzZPLDRQDEVRHEU+GwAUEgo6OIUN4ouccwyhWAEeMIz/C3qJXyNFQ+iFORiCSfsflnA0DoK+BCIgW+iMxyBFQONFvwAMP0MKoMA6DwAKI7GKTCxGTSOgwqi5ARognbAh1rAaJHA3DTiJCPAR9JuwJhmCKpnB5fGBJsG+F1i4JFACIxCC9wGF61uhHHADG2CCIYCPAXhGkxoAKxCs2jGFUTgdAZiCFRgBFcAqMIiCBmyBR9CFQsiGR2AJKICGOriCAHwWPxgBj9EioTiaLVgD6gEADBADMXAZFlgBFuABEoiPCCABHliBmbwAPviAKTAJDQicK7ABWzCFzhAmKoAEICgBDeGEJpABK7iES7gGtRuqofqDB4iABygoH2GRCTGB/wu8wBBgKy/RERywgBRYqQHYFwBIg+vriqsYgA5gvl2kOqtTgPipOpPAgBQggRC4gBL4kzlQAxuIQcDahRboOgwBgNQTCl7TtAAogAuggF0cIBL4gJKAyW0kgQtAEjEhKKY4kgGYgQ2iS7ukOgVQlc3sAEdzAy5wg2HiAmWwBgvICZRTkSJxzBBAOaqTzdsaBC3QgkYwSiRpAaoZiZF4HheLABAoSxdzsWGiAi9gBCB4sx1SBkpIgx+wARVIAiogBkxohGV4hDHIAy8AAzmoAUW5HCvwgiJ4FTBABUHgAgu4gBpIgSccgDSgTidsQiecgBNIgxN4wiaUABRAgQ+4gP9P4RQwEIIfG4IsmINgEARBSILBigJpuAUAsAIqiIMmu4E3OjUqSIQosIEjIAgjCIMXmANWMNAWsD4JVYMwqIJAMK8+CARF6AQtCIU+kAQjYARGOAPqOp6xHKhMHNKU0LPBOFJjTFIlXdJBu4ANqkUAUIEsqIEbsQZPQFLo+wtkZNICKjZQ3ESggFIuJTRebMu/eDRWY0tNjAwFKNAewYBifDTFAMY+S9PK84FQ8pE88oEUaBIc0AGkmqgruII2iAYzqA+okYE02IETWJwX2AVD4ARDMB1CYIUcDAMq6AHWYAEXqoE0mIEIGYEgIBIv0YA/GIEB0AEZ2Jo4QIVYcIT/ZIAmRtSEZCgFSwCEUpAESQCEuXmDOvDVNygFXq0DuyqFvRKFO7CESLib6BoBPdJJqvOA+igJqmMRJGCYHyisLciDSMADdDkDwxoGMwgBKjADI6ACOOACvhuFUWALoaIBPjDPAnUBHShLl0QJENCMEkiBUEPNbRRNnYiMmwiKYMOzmojMo6ihB1hY0tTNCCiBk2CJNLiASXuJVEi2bCyAPNPEn1jTPttFaVyBhUUButREXjOKDUDZGjqJOjuJqwxYpCgSlOsXcSySu0SSGvgABRC1DRg/u8sBITgDxMsBLKACozXaHLAKC6iB0PkAEPgwEAiBD2Ae3QmBFsgMEDux/xO4hCYQAQcQASYEAMUBgjjAgX/xFBdDgQO9TsoEABQAgQVAAQeY2wCVgK11yigUgfwM0AYwgJSNnxRAgZbSgaVjBW4Z0R9rgSuYAs3QDR5IAiKQhWCoBFsQBCrgAi54ARd4EaawAJRNWbLsERNYguuRA5LqJ1ZghCiQA5YIgRxAhNC0s7bsiWEbU9u9XdzF0r44xS6FjGv00mP0C2asCQwogJbEut7tC9rlCwkqIPxp3pUwUgD6i0wcWE2cU9+1Rv9ZiYAFgGtQBr3YAAiQzQGAUwzQQ53oMyP9n4TlNQDggVNABKArXxXxgSww1OEysMLirTRwASfAAi7gGw7tTv9MwIT/IoJBAAAWwAAU4AGSjQ82hRHh1MNVg2CUcEmW8IEu8BgPABkQ6QCUi0ZS3FlrIIEr6L07sNVMwINIqjqUksuU8xKqSyFDmJkrqJptg72PDILdIwIocIaG2YJEEIIluARQSAVTaAu1260XIAIsiAMAUJEB4AEeYIERCIFmIIQAcAElsIEeiICWJQGZhVn+KVjpDSD2rVgzZQlrmAsbmkx8GaAjZQGjis0wbYld8wmfEDY9nrTqraFLrAkIzglRywnBZdmcAIATsAZMyU2Uu0oGu1rNJIGy9BEwDmGCWsolSAEF+AEq1QEpSALhowQraDELQAESwMzPiQGmvQD/FWgCWCaDEyCDtOPPtEuDSzi0JliAQM7ED0iCiU1bMUGBlF2ADVgAZEZmFDAAB9DPBjAxEpOAJtRbCajmBpAAvzXmAZiAGFiSuhwoJEAEQ5gGQwgCPRoAAiAAMZ2AFcLJC1i0xeS1Ih2gaaxLyahLMp4fMvaf5T3T3P3ntGhegB7oRyuAZ5SMaeQfCKjeQPMAL1rGnFuBnPCATIQAi14AHvCEGBhf3R2AB/AiZbAFG5gfOg3oZOwLjz7oxGgC0Rm2g04Jjo6MadxeGOCBGigWrgECRjiCJxiBJhgBGUACYA7HwtARffYAk5BWruyfq7zehC3GPuYDGbCXGsIAFvAD/6aSgREwiTTQhjTwaUPgAiL8AiuIjdiwgdixCqCORTLmxUPJibK0IZY9CRJoMuxoBFHQAnq5Ai8Rtab422zMiaq0ShbguRqQASJAhDBwA6swqQy5giEYBGbwAkzgguvLCdLUgB2AZWEQhib4AlgegQhIgyvFARk47DI4BQERkEGQhXIFBUrwhD/wgyUYAgrhgxNwWuX8AdNxziJY0RN4XxCID5rgA4YrATlQAbk2imxU42UE2bZE4+Y2DNn13U4EiilwgTgwgTgNjMZsCYEWIOfeRRuKn541gRyYgxhMHLMlATBWWd2woSVhiS94hiJgDfIlKMmID+aG2e3dHxtCZf+SHQDkTIGUncaANYqELoCmkOdM3ICWOsLAJea/PfAKP2YDMAD9TABtYNdLSAD9rGYRR+Z0vsTFrAkGvzp1RtkHj2dMNPFtFGSETmiEZTX6OdhplOc1FdjoPuPgLWljDO9QFHKCtt0B4Og63YlqqIaboB9g9AAI8QExeYDxRQIp2KnDQQKHltNk3NL+KYwB2AHR8cU/BkYx3YsH8ISl1AA4hYDDwABp9YANeEYM6BU5/keP5tSDHSAXwgAXOuiTYIEPUAJM6IRuucv6mLTSZAFEAIUgGMjGrrpUmSXq+8FpEAQhGAANcKGUmPOrWyltYGTnHgBhqDWrmIIYgFM5Zo3/j65dqyDzB1gAKkeJqtwJIbEA072BOJCwXkGJTCQolHgJHiCDC7iLwCBSZGfTBxhwCEcJ0jRLAscBEsAB0aZLGJHrQxlH0NSRmGSNzswJC+i2nsSjHjmJP5GBPWkCa8gRBhmBHhACKViCKUAUsuRtU7i0RI7vwDaMgZLNPVIMEfZS8k2JFUCBtEAggffFaOTxyOxFCBoBKNh1DRAMOx22NIYMNd5eTD4JE6iu4hkJHzkJBs8JfA72Gdi6yzaiU6ZPFaCCIojNpjDZwH5qbQxs/VbwJblxk2WJnGUJCEe5GsL5HJfGId0AAliADJdmBiAxvh1xZC4AYzZxTARkS8RE/6vv5au3ekFecKf+7zTFnz1OjI5NCaKw8Y9FRuCd3kEqcmFj3j1jCSJn+5dogUk9hUBDgQsAIcWAAPsYiwIYX2RUyyb4Acj2gZ3YbOHcI4H/xDRmNStWHjhN3r0ggzRYAACKtcEoAKIQWVaDoJd4aOgu6ZqOaYFV8y9vcpXwRV9kDcCH6efuCqOo2ElbgRjggZxcgfQF8398c7m0upR46YRWAAhoofjJCTcnCirf88b+gBz4gdukidz3+owv013U/Mb36KYGegIvCaDfWZay4DoTEzEhSyupLgvoSSb4AcYpAQkbgitYAlgZPD0sEhYRYxmmOk6F8PixgB8AiCYjev+QSLEhRZMmFgYwjNAjCJQ1Vfrk8VIEQJIvNrhwOQIGCBA1Fz9QsYJFiRIhOlooaCHLRQkbJVyksBBCAZQ6eaAAALCC1SUADIcyNDVhAABDpiwos6VCgYKhBYgyxAChJw4ocXLo6DlUKNKwXqki9QpW7FmqUaFCtdDCAtuvYRn2BKugZwqoSGtcaPF17ICpZAczLJCWYdQBidUWKLBh6gbAiQMgzeEFzJK1gQXTnUtVsALHBBZIKF3agQEUC1Y/1st2Q8O8bENvULDhdgHbjh3frs05MFmwQofTNfv7N2G0aAPUbe68bPOyaJ1Tr279evXg0JszD0AZO/jw4rFvD1//4AGE4sPrpi/bvucDGGXJ3C0/3iyABzy2T/eqAIN699lHHXQYCHMKD3UNWJcwoERjx3NmMdcTGZyYgYgdMNwXIQBzKKMgeOVRld1hxBF1mFgpHrYBgIshVth6BAqnoolDTaiiZ4jhh9gDDyj2AFsYfDAFXLNtYIEFHWAw2wBLKpBkBCmUAEYkVQBxwxE33LBGJGAIAUYURhiREhRQ+MECWxGQEAFiH5CAQQQPsKCmj1E1QYJiA8BG1FoAbPKINI7oUYUNA/xQAwApCJEIJFFgQYwhAETABCsq9KQSkiksIQcUiShhVhpUkLKHF2DxkEKeimFQmwIfJBZCDjbcEMUN/5qV1eMAPpY1Qg5xQGFBGtp4khZxZyXmIlKGDZWDEDfZ5tVtbRX5lmsDyJHHEZLiEEILR0DBUk9gPAJEVLm1lQIOPeml2EEoPPljVDhcEMG6SJEwr1wD8IWqYkj6u1AL03Bh14kaeCHEW2/5Wy9wikVAb2iNRYsCfLyxFm2eZj2pggs2xIpkXB6MpUAERaZZF5uK2YbsYZxF5lVjwOUWM8tmSSXzAJTl3BmNQk31W4zVwUZec5doQ8aGMhI31YTW8VdW0+IteF3U4UGnwBQPUFeAyGKYUg1+K2iYtNTFmi0dflbvGKJX6aV9HQR/yNCFBvKdTTbZME4d9HUDtPCEVv8mQwWZbXsSdvdQ/yUnFQCGGSajiqG1l+sKuio741koIjYb553DZUHJEZgwOsj/WYBBBx2MHgIQ0OiRiSVjxB5IH7QWaQILGOiOAQy7ixFBbRjXuxZbQrnGMM9jradegN9t3nlhN9d1l7EYAJmxyorV8MHCcEa1gQajj95BW0vIAEUQS3wO4IiJZ1/tiDpgIUcLRViBnyFhRGGDDVF0cssYjOCFUBjBCY/YgyOOIARSGMMVY+hDHwLRiViQYgxjeAQVatCCENjACfwThCJaYIMh2KAnSFLYwkxQQhGaDDG1UUwLTBCCGfLPgzZIgkhGCJIQOAxJCvKbHM4ghCoQAhX/SGIIE0zwpA4woYlMGEIJciCUCOhACnGwwTOIMcMabMsENbDBB3CQgySkBAxGYAT/IEGLTkAwCmCwwROA4IQWyGAEIahBEmRiAxMwMQ430EIvOgGEI9ggBCZ4ywaAp4B0Jaom9ALSXZIwiUhZIAVgLFlUWtATE5TObxwJgeCOhyzt6Akw/RmPXABABzKwCUTPi8uABnMeZVEsaGSwBh96YoU01KVq1gkAGVB1n8cprzoxoEQTQAQAKzxDFs4xzHt6UoDuoM1mUAMAc8LSmMM8CS5/EZBQvOO0cRbzbT2rjneYw5mzQac47SzWOXMkzwh5Rl0d6EEZoGAGUdThDW8o/0UpsPEGbDzCCTbhVpFUhrzOKJNYaVnB5E5Zo3fKszijfCUAKGGLoLDlc6D7F1xC14EkhUAOjDjCE4YQAiaUAAhcysMmhhBDC5jgiU8MxBiGQYs7FGIPtHAEKkKhhzdk4g2WOCrsLIEHS0QiDx+5ARKeuIQlDAEHP5jhGkqxCCeEAAAlBEBUQ9oT5uDKnQDQARKco5fMae5FUmGZOzfXAfV0QKUpSAFeOskQC9RAByEoAWB10IMeQOEHPZCBFHqQJIat5xTWiEGeBucisFigCEUIwQ9cpDWvtoAEOYBEBaPwCAg6oRaqMAYpSBGIEBxhEXpwhTEsqAtjqEIPY5BGLP8e8QhNaIIatKhFIXRRi1okwxGdGINQQ+GEIRTJCYTohBOckAhNKMEJaCxBC0owg6sKgQpKsMEShIAFNSgCFbFQoBeUsBYNpCAXmbjDIQ5BCFFwMAqk+AQkGHGDImRBB0wQLFqbmFIbxGEOM9ikYKVghCsIQQgyXVhULsAFF7yAClrIQxUAYdsxQMIL0BDCEeqgCWQswqlACIMabEBTEzwhDlSqwlAtUQUw5GAhUDlSUuZAmVAqwK/ZnaEOftAVLpjCBoSYBgBasMG/luARiXACYN2SpJHq5QKmGNgASHCND5TTFrag51RmlKzGWZOYEXASQ/dqghSQzpvP2WvJLJD/SCSRoAxLSMMuiEM9pLCiGYpwJd+aY4pmhCJzc1le2gKzWfEEgJg9gUAMxmaYB6RhWPR0Thp4aTwnpUkBrHiGFUIQBUIQwgtOIORCAo0dCaShAr5U9QA+kIMcLIGPI/jACEjgIw+IDNEPGAFghzCEJF7iEgmQAAMkECCkeOIaKwBAEyztFefZDJ43ax8JKLBo4sBJAyXQQRBy0AMmXAEKQryBDSIxUF6w+w56WIQgngEAhHZuMWJ+3l+acIEbD2AFJ0iV+5qkOx/4gAWpNpGxomKCmbgglBgAaZJYwpUT0jQFHDz1HJGkASv84JCMeEQsYjGoKjACCH0YQydI8e4j/zQxKSl2giJ6IQ1S1GIMmeiDE6qQh0isAQ+8gAUuYLGHPWQjG0SHxSxwoYpF4AEPi6hFbPUw9D0gHRZWh4UqklELPAxyEzfwgiDwQCu7JCELWXABACCxB1WoAhuR6OpQHhDmtChAAziwAROWUIII9OThdi8Bt2SSpE4CoARRuIUeaqGHQDiBCjicgyEaHlldqeVJ9KKLLUwBgLXy7HEFgMDQVAYALkTKePyGDfUSczq4LKEKqAiqE14wMCyAgSW7fJIIhRCFd9OW7Q8cgyos2IlmoGJUxniE0BNvDOI+IhBHsAAAEpEILCgiD48YA9X30Aea2tuVC2JIIgHwhWRkw/8Rpfjh5u8ip4d1gL0t/ItimACFMshgrioT3Iu6v1ahRIt6jSvAAshdj6zAmigGFyTTM00H8+SK9fRInJBMDcjGcDxJCCxBHPgVTkRBHxBKEQiCEdgASyTG3OUHdPAaAPCaVSTZSgmBICSBKVlb48jFk9hAM3wZ9PFMWKiOD7RZVBAIVIxUB7DZ6HxbZvBNNY0IYPzQZrHE4lBHsZGNOj2TA1xFowHAFFyCGGATom2HAuzA9zzAtzHBbFRSswBADgCBFzxCFAhBDvifgCyAo3EIgQyAN5HBBMhhQ1kAEOQBhpkBM6QBGZTG5fCHgkRACfTADyCBm4HFz+QLCrjLbKT/gA7kwHIVkgngQAlwUupoQO6wgBiwAAsgwRUgAcH5ABJ0ACKwwhMcAR4Ew5N1EBC0ABUIwncJQceJzsMYTnQMQJSEAAmQT+KoS2dswAOcWZzM1e4AwC7swgD4wBOcwVNdwRCQz8qMIYRB3IpxEAiO0AzRkA3IgevQAjXsTwh0QAsMQQ6kFIylljFEEBBUgTHAgiNUEEgcwRHIgROARB+82yJAAxhsghw8gQVqSVPxQjAUQyPswSzMAiwcQjEcgiMQXfBNhCuoQiE4Qi8UQzHMgjE4QkQ6giZIwyJUQSAwQh68gdNFQiTkQi7IwekghQn4AACEQTMcAiTMkSEIQuNs/1YauKB0IMYkLgFepcEXCIXFSVczzAEArNnpUCMGpMAT2AAqKAIjRIEceJUYJcEPtBUO8sxmfVOKQIcKCAEh6CQAzAAVKEyL2EYHsJYTxBsATMCd3N8QeEEV8EItOIEWQBdN2cAgJAIYVAEhHcFE9MEibGBJEpI2ypQ2BkIVVMFIkpw9jtASCKQJ1MUZ8g8cQd9U0MHYUAcMXEITuKHPBAYACAAguJspMVRzQIUJ6IAMBIEPlIAMEMEgtMENbEEbnMENKBGfnEj+IUkIWNwP2ADEIIaasAAK+EhutBMOAgAPBFMNGNIIjICQ6cASjEAMfMDD9GBYbo683N0MCZscSP9R4e1hH9yCI0CCckEfW7HVVfQEr0EA6GnGtKHN0+SKimBA34mIV8TkDJFODz5HN43Ums0QS4mhdDwACZDAB1zABODAg66AW63HNBBC7XVAMXKOW31Tc1BAfFJHBDSBA/QSdZDBKoTotLmNfJJItRFLKuENNiUAjQpAdrCojEbN3rTKXdRSAPSaqtXFAkBiPVUUnzxA8HSTDP3ANLjgBk3VDB0BHMiCD+hO32kAmt2FC9gCL3UBFqiYAjCBF3gB/wCBEIwQJ0FfEyiDfLBmjPymAlwAD7APNtFI/o0Fp60Fj1mBQnCQIfGRBiBBDhhBFETBYxaqJkyCIHCVIXnbEgD/QRQoQid0AhiA0kiFQBy4gBPsXibogTEcJh5UATYE3yJkgi64Ail0gjR0givogiqkaifkgu4pQh04wQ0EAa6ugSVUwiE0givcQSNsCR5kArGOQXkJAgh1giJIgzTUAimogisMFywwHhCcVCAUKiEJm60+AjV0gg28C38KASpAwre+jHq0ipsZaXOQgC3o2Ay1QAoA42BsUl4oo6XYW1g8xnpMhQKkAJqsSpzsTXQQx1z5B8D1i4vdHCjBEgCYQjA4QU+0QBRoFRCk1BGARD0OwbVkAjZYySDdwBCszujE0CEdHNugAAjUC+TAmoI0jcA2xxScgAY0qALIgBlsgQVc/0EXXAERIMIVANrhMMQHNMEPpABf4AAO1IDK5sjAhlOOQIXF4cDCzCHzPIkJaAATrCLGMoIThII9EhIqaB4YQINmnhoQfMQRrAt+iAzbnqDT/GRVkA8LfEAdTVENqEAOyIEOgCC1BIiC+MBKGVILAGN2IIk5ypAMPZESLc+ANsfjHBoALABGbOVqHkv7XEev9Rq9OO4vdcfAkgEo0AE5SZSMXsccmEIDJEDSWENQWAcMSO5YJVpPgIA1IE1deJnsYocpgAJ50OFdLQRZsEUH4ICnFdkN5IAMCWRlyoENNMIhtAIx/EIjVAIndMHmKVRYKMADLInfwmgsDaxbXVTDuP9Srz0A9LGFBmhA6kyZ6qxZTclBIFBDMzBeQA5bDwiBGRhBHDwBYGHXvCVJjwQwC2jAcPJRNwEAKNgCKNhAHpycHtxCapHCJPRCLcACLcxCKTyCI3wCNZAaIZDrJiCCG3RBHZjBL2wDKKRCCqdCKrQBsUoCHJgBJ7TBIPzCL2ACJ8ABJkRDJwBDLGBCLHxCMkgDN/QCLdBCLNCCJgBBHBSBFhzBAFhVCcSB/tpAEUQBNMjBZQpH+uUL3PrILvLiw4DAnrzgOf1QE3bvjcQoKhHj9bQPf0RACAjbSulACmgAmzyOBcDukbzFXy0BE/SE6JCPBSwBSqmUIcHSX7yafST/D36azTgR06uFxxR8AAuoSgfMTShqQDOOgAb07kSdSN+YsX/GiBx/oxz4kRyUgBxcwREY0ueEgO5FAjQMEkjUATboQW1BwyOY1hh0ENcKQi9cFgj6iwkMwRL0wAgkxtq2aIigngvkgBihFWzOgAoooE0grQ38ruVdHkMwEQkxQd8WruoEaDfSsZLNkMUJW0+EwDN8WaAVR4jyzEVBsnVsgymQgTBMQelWh4riIXbEgLQJhk98Zj87x1duiDx9pY5c77zShS/QAECXhSl8yCXmRZoljkOcQbawsjj7EABsi5K1BK4GwSYEgY0tTsN0ZY6s0zsZyxREQAewQAdAGy9R/wUP8EFisMADfEANQB+pRYCREYKK1RQphgASTNUTZEEiBEIgxKI3tZMHsEgEoAC6IK0GWIAHDMBWA0kHAI9U8KQVxIEVFIELJMET3AAYeAEkPHGDDUI65kAXWEE1aEMlsPAqMMMrpAIzXAMivAJgB/YWHBUmtMIrtEIrTEJgs/AlBMAlrMIqXMIfAAAE1PQ3RoCgyuT0KNSaKZkLyIEchGy9FOMLJQ5sHATqyYWuNQTyvNlBH/TU4Ag7RcdmPQxGP6cy8C5R8GegkQEvlYA4U4tehBlDuCzCXZpsv3Y/D8AIsI+HKjd8aIALzIAO3MVk+ccG2YAL6N7uOTX/XAEjyP8BIYFBYF4JE8AFF6jBIhwVEMhEazWQaalCRI6BHvTBl3xtLcvBwrLFA3w1M7ctkFLHq31BE5R1IjduduyV4B5SyXaGlMREEvmmD7bveJKQsA3BPbKCMlBCCDhBHrgCKvTCI4SCUzMCDwHaJVgD+HYocDaHB5zCNtCBHVwCKNguAIiBKEIBE/gNCziDGGTIeEAAekBTI7fJBZSNc3BET0yB6CZBM3yIib425VDoXZCBKXCCZOBM06KxhwLi5fIJXpEgWK4HGQQFCSSBCxw4VECbFRBZW1AZ/ASvdlRbmjl3KnnCkavMV3eAD6QOH3gCJs80EowAEnBiEOhAwfnAFUT/Vz/J0ZXcAFXB8ud8W66x139c+qWryo09jCL1iPXACQqQwAqgADESI/vNdOqAIih+9cNs7/ZGiSnqgH/pwBVcQQisgRSEwBUEwRVMA2CnQiW0gguXQiMwQzWkgiyAQp7hTVwF75OEDyGvi/WIb5pBt7U7xyRbDV1s1jxLCDYxR4onSgm4p1fItMr2hC9cQgwMLJCwyQWQt0rYQABcnrJU05ZfO77nO3jIQBKUwRVswhZ4wRo+wRy3FDQUKphAA4Y9de0sXiioGBUQghEAQD4uAu24QiBY3xgkAxLfQiy2wA3gQjH81h4Ygy4EgooRnma4CL5SR4Bje7HEIXaQgbt8/8U5klAiQy720rmCtIQMjdAIfS2G7xcX7IITwO/JWdAjoEIiKBdpajspFUs1gA0AbEMqrMKMW6EGXMEZaAExBAMRVEIlMENd9BqkGXR00Cd6+O0AQED3sU1zkEGC1AUxvWzSQMDMZnV/SwfxXHdDmUgPWoMg1HuLc2Uq1ZMnJNOAIgZNhcAq7uUNSCMT/KnJNOC0B8kH1BJLq7RGQ4wCkI/qtIAV6K0OPMEO+gC5BcGWRP4TMNgVtL7qN1Uk3IBL5QE01AEW10EdbMEmEAEUfBsSJKIGJDqcByd7kQB70XTqpA6g9vmlfzULlGLWPgH1T1UyC1YPYGcJ7ODoMEER8P+mLYTBX2XtO4YBJvwCM8DBG9TBGsSFa6iofWT7OHmGIouyvt8/KtFhCDRBvQIEgAEDBCowqACAIUE2WiAE8JBgAAASBUIc0kfPmChOLIQIIUQIDgUEH5YUSDLFBxIDST6kpMajhQgpImx4CIFgS5M7efb0+RNoUKFDiUJ8qEDDEyFbolRZc2NIlUWLjjQEwAWVCxs25FR51EeOBQstQoTSU0uVI2609gRadIvUMFyk+tgAYEHHjSpAGEWJAi1KohAVd0psObDAgAAFANC5tGqVnZ8bao4k/JNlTi6IABgkOCOLnBYWWF42WjJn5oEKTJQYYuNIbEY3GNmIGaIZIQD/ThIlUxXIxhxMfY449AmDBQANp3icVJ06Z1CdRan3nE49enTrpqsfjECChUEMIzMriBDCSpqijK2n3jmwIvTnqAdgiNChg4IOY3OAuXEDCCAsyQOI/wo84okhhgjBBBN8aBC/8cY7iML6OvAohxIswKADDCzYAIPyOLRgPxMskEEGCwhpxgjYbrjiiSeCCGKNRn7ZQpFF1DhkixtmpBGPSDa5YYs3jDSyjkzeAMQMIoL4wI1TyuiiiysQCWMLKDaRAgghIgEDjEhyEfMMMHLJBaQwN1njKSZMCOGJG+SIA4r/sngGkxts8OGKOOLoYYkWSiAhAgsopG8Ag0JAZRJB/wboIY7/OiivtId4QIElBTCorqQAruPUp09BLYoiioYiSIc8anEElioQjQDWQm1QJAwb3OOJIINaAAOSUMYIpbaxWrBK1Adq0KFQ8uC7daANQADgEkosOA0ikpSFzyhRR92W2+pWq4GILQB54447VDHGCQVkMsgGsT6NoAUqYtEiED2CIeSWUEJRQgf6jjIuhNHUjYC8k1AL9SFhQNkGEUSE8QBXF17AIQVtOy0AggISO2qDDUr7+GPu4DOvoxYKKqEEOeRwwolAAhmDlEkIQcgmADxSwLaGngAiEDkO5mmFNBAJ4QsZTrrWPe12ouMaRDbt9lSo37MYKAj4+HkFMv/oKAmCGB54INMQMyspgjTIeK8nTwGYYxKStFP659QKoHDCgxI1tKMnmJBxDQHv2IMXPPDoew08MlkkECdic2IrGxQ0YT919yPRBDFY8OEJRgjppQonGPRhBA0AsEY9TfF7Ewm9zzAQED1YduIJG4Ro5hlARFmGm2UM5+UObLBxhRdefLcEkDoGX6MLTlJJ5ZVJJnnlEgD+4AMhRGQ5AworBiEilzM2CRCMKADJY6/YgKgiD0sWyYQXXA7phQonqrAkE0siCTCKPPIHosIBFrjJbUnLDNhCECiDmIAJ+aFQfkIkEA0wqAQKeJBxpFZBCwbFVERJzYW2sog+1MZtEXj/QMF48gErqIAnBXhABHLgBWiE4ha9ykPiwCAEgQHgAtOIAbVW4xnVVIQxiHHbwZZ1F1tMYwAp05AQl0W1Cz6xKAN4wApW8BANVBEAt3AfLUjRrhYosAhqeIENlmACaplkAC9IRCxuEYjZ2CAJc2gCQXbgCeXMwBa2aJehPEOYIQKFJBjAwB/+YJ0NUFAoA0gMQapBCRcMDABNmEP8qpUou2ErJwogiwtEY5C7HKE2K7rFGAoBiz04oSGr+YELcBCCZIXgfHJAJAAWsINnVWQkSHtOdqDYy6JY4xpnTORD+AAKMzjDJDG4mga5g7b3aCwCA2DFNAAQgfH88DrySVQK/3zAhCEkyJtPQBCACpc+PGyiDpGwhCr2kI097KEQeHiCE/rgijHoohDnqkUyaAGJQIDhCEhwk1jWBYBTpKISoEBEG6JwAyNkAQkmeMIVbtACIfRAXQ7yQQiGQNEABagKpbjFLUrxBj1AIxaKcIUxcPEJXOBiD7CYBSxeOow78CITkcADJyrBvFG8AqjPe54smJEKLrSiFcdoBDdsQZYrPDVGRzhDHt5wC0xAQg9VQMYdhvGJQxyiGNyYRC+GIY1PfIIQ0ujEJo4AlWsp4AEl0QYlnDO27KxmAB14kA+GsIT9pEADOkhBB2jCAg90QAc6gJxlfNlYC0JgARDIICAHQP8ZHCxhDVG4gzQ0oQktDAYokwWKAlyABcAwAgxV6AMYGCGHECirWiVJg3oskIIfJHZqTYyPH+saVwDkIAdDMNRqTECCh0TTscldz0O0sQuBSEQHuQAC4xIFgCRwARKQaBkQ2tqDFPQRUdWsAcpKYAMqTKMJqFHXeg/iLsaC6ocIi6JA2GMwAHxgWur6Ygsa1F8TDIuPYknZEMAUMAAQYhJF0OTrjBC/UDBuuASVMHlmiUY/7rKuvFTuz3oJARhAzCSsMMUEGgu33YpqOixRIQBcYIXO1AfGY7NwojDQICa0FQhriEQV8KC+RThFcJYQciYygQ0i68IV+CzEknVRjFH/jMJ5h1iGJGCYDOLc4BeVCAIAPJAogoTAFKagxDWusQoZDCACGgjsEjzKFyfoS19jkLMxjKEKVdzhpbgw5Sz4LAk8/w0ZmXCFne38zlLcoRjEqAOb4NDTbYDiF2aIhjFlEYYb1AELYNDCJPVHhSvY4AZDYpkWAIGH9n1icIDQRCkCEYo+LEIPmjiENAKhBSwIASIeCQEfkZZh8yAkUTPJ5TUFwgI55MAjGpKcD4W5YWd3S7TPtiBJvgYACCgAQEdgAkMAoARIlEIPQFjQpLDVLTQrQA2mcAJPIMBDaTtbbWqriCFs0ZkWAOERWRVCHCII2/muBgcmGIgFTCAHMPiM/4jTLiLUDhOCEjjhNQvS9VZCABsgqIwRfHkEKrzAsjjrQV9OUAQqpNHGPuRhCAIZiw5EUilbgCLa2dplyJz4boZr07exbaYzmSky02hLkYxdQhw6Y6IOacAPNxDCDcwnbhs7vAQIausRztcHR9CiD2PIhDHamQ1TvlOmfH7nHlSBh3YWQsmFMEYmqgCNPKghDJtABi6QEQQf+AAJPijBCBoUgQchYQSeUUANluADKCiiE51QhCBQ0QlpkMLOeqgzO7+uikLswX3F0HwxDgG4YkyCG4eg/CzAWoxWlL4YN70DMkQRhlyoIQs5XoMXln4EMQHBL1qAAzKqEItGaEISlv/AhrkKkYmKwvIJu6YCIagAGwYt4QmjGQITRjOWgwjSMk3Eq36Y4Nf8VEogg625zclffvP//GijcUIzBFHxxu3a34qUmokBMA1lnARs8Rn/+aOoSJLkIAqwYQ9qIeMeARpCoIewaSIeYrIeQAV+IARwQCQeAsBa4zXKbQa0wWQaI+ewg9oW7oLy6k2SDepwQA6iLnOcIAqSoRZeJhlIwVdqAfLaqRZqAeTGoBbIDjhkDo3azdqkY8ZOY/+UawhDhcbEQzwIghIm4X8M5jqmYRKcq9yq4wKsIL0QBZNozFDwA7AsSg8O5w3YriosYAiOABqMrA+qQA8WwekcR2WOwAb/Mq7qxsAY5OwRbEoV3CkbLu8Q9OwO3mAY+EzPDuGscEETOkES8qCtGCERnIcYloEYKsEPUMMCNCByRsIHloBCLGAJNMCMACAFJoASRkHdbAAIbkEa8qyzeMEVyiUQiYEQXSrsaIEWvooWHMERXiqmjGHQYMGl3oBN/OAJyOUTHGEWNAEX7uAW3gASFEELjiAEHApMoCEM5gAKR8EWJKEUIuEJTKAHhGAJdm1yDsIEhkAI5GAIbqAETKQElmAdSYPmjJD/5pEe6zFqWuAGTGoM9iAZooAKGIQJPMJESMgnPMwHeU4+fmJjcII+qIgh7XFb3EaiQi0KgCAOlgA+msAa/2CgrnbOJADLArItCuAiCgTFHYlIJ2DgIDmFEuiqYIqwgrCFCxKBEU5OD0jhDnCRFB6h0GAhI8bAjV7L5yAyIpsNAJqhGVDyUzQsAlDGBFKgBDpEP0THEExBPeJrIMIDAF7Axc5oiLDFBpqh3ixACcLABTrjIGyACXygBZjgCpbAcXSsoiyAr4AgD7SuD/IyFGzA4/rA1ern1RaBcdJRCNDn0O6AFJIBF7JqfTKhFAJNFyIzEwDhpnAKD6iqeApHcPAAlFzgC1YhCBxuMEKACoRgWsqjA6KyHN3kCqCABfCDvxRLwlrABhJBCL7pBs4ACySB1KQrF+CgETCh9IABE/+A4RN4ARiogRC+6hj1oBRy0VxKgRcw7xNKgU0s4Q14Z/VqQc6CpG+AIHbKMDeFAApAIgQm4clGIRUCgA864Cjw6pByaQAIruL6iiZmogS+ayBiTtomq1QYkCgD1B5NhRuIAQDw7gokDtSqgOoUUSh5AsR4wBc48icWIIiCAmNOBSYFdJh0giBqhj+txZIUoB2HoAUG4LJsgAtsoSt/4gGag1PKLcU6VG3GT7RAUCjeyyjp8TCwg7Ii4CEKwFRyYgWaMOH0z5MAAD/wY29e4AkAIDxCBANKIEZMwId04Ad66EICko9gzCAswDYsQAhyAQ4TxALCgBY+oRMqMsfKBwr/qEoPiKcUAAE7i+wOkkETgKETICEWCCEZDqEVGkEUNAEQIEEahgEMdo2j+gISmmK6qO58pELQlAQQ4AAQJKENtoAIbsAPgiASnqI1z2AL0gCoaKACSKBBdGAsigAHhgAD7i4I/gMJriBW/4NN0uk/YnUJ3BE3bQAOziBOoCAIngBzurEDkMACmOEQnsLCdiIEKEqTgEARgOEZGsESSkEU7kASAMF2hkEUAMEYWCUZbmEL2OQG1gBGoIKjQuBBPmAnVvLEZCzo9hNABZQ/ORRf59HDHuLDNEBLzjVJsEF4gMAGKiwoPEAYIIMHNMaJIosoYGABNjRfL+OP/qh5uGX8/+gARgvyXtFoAGqgBro0xVJsE/NjKGxhFAyhBdIgmnSLw3ppAKyBEpLAmQLII1/WJJKAEFhBOsAPbvigFehqCoHoufTPY3PFAq5gEw4BExQgx/5jL2IEquBE6hbExhLkTbxJDmLjCF6DLQcgGBShCLzgBRpkTI/AtR7CwDQpIP+rv4ZrtDhKE0eCCNbAD7YADm6gGy1gE6LgDYRsKtagBeJAD1zBcJHMcI2BFubgITCgDJzhJQlCkEwCBQBAAK4BFMjgFGThGuaAGOBg0fDgDYyMfoyBF1RBFIBBFIIHG96gDoquQfgLTp5ACUqgBl5gEMogWwAAA4igDohgEh8CYv8GgAVWgARW4LsMogTioA2sAAlKQgFygGDbSk9CIBeagmUYgl0tYNu6Vm8ATGRxNOE8lCc61vzMl1vQd2IRRmJ5wgGs4ZYQ8mZNQgw0AAYwAMR4Vwwa1wMgJn9HBcUAoAAgNoMKOAAOWCK6rFMAaX59tFlRQ327xQfhtYIoAgb+YBVAQRh+4gBoAAHQVwFwYB1H0DWWAAg0ZD8i5wcmRkNaoAi4oAg2sGruQgG+gBVOlPwk4hoIARrsa1tUSD+sqSP0Qs704CyA8gaWAAks8QE8ACcUcABw4mk81GIUQG4BBH0ckxf2sBCy4RPQ88laAROE53AWQXDOJ0AAJI25S5z/1HgvGGFxXocv34wvcuwILIALmoFxLSAHiiBBeuAKICRCroVaWGAKphgArKARyjUIEEkIOuEseOEIHuIGksERyuURxqAPgAD8KuJ/S2J4EyUEuqANUuEZBqAMkMAPmKESfiEaouEXuAGpmufJJgEUAGALdBciVmAEloAJfplLO3knxCAIxOBpeK4jyTeRDGUJhCAPSEEROsMGemAIJgdudW53d9TmCrhefSKCQeWb1/eBuYUxLmAOimAoo0OQjnkn7MAOhMEOCAkGVBKBIcADAsCJFxBjUcMTmoAP+KCKFOmTS2IBqigVJqEBSmIF4nl/fQIUbnlrjPIAHmAl7xUF/5ThChdYnKnjASj0J2CgAi4BFCogAzZWn9EmNToiHV1rWEJAB5ANB9zlQo4gCiZ5o+ULADr6QukPlD1MDP4AfwFgCaLgLPINGtAxBDqkA+5DbHZpA75mBb6GBXjgA3hgCphlPjuiBBgBMAh2CICgx5Jsydwppg4BjEehEjDBpkrhcOTMrRPXFYgsDecnEyIz7cgaFvLalPJQ7RZhNoAAGhgiNT1i6G6AQfAD2LZDVJCgC6CgYu8iQE5UAebGUB6iA/bGBwxWKCBGAUbgeTUFAC74f91gFQCAEogBEZiBGc5G59o3gofWgQdgCnpgMNJMCqDCSp3DaH/mGu4vQMPZsf/aF18TpQW4wBqQeZgEIgI2xmMvQwY4wQzaYBBkwQwaZhAGwQ26ABHcQAwGOoNArH41YAQaOigg4CFDmwzIYJ15gA8iumo8mssaoxqo+5WhGxGgwBni+SYUuCcwJmOEFDOm4AIIpgQggRTA4IsIgj2E+6ZvwgHI4BpeYRTUoz8b3IIowp5P+lRggASm4A+s+gP4YApWYCm11EFKIAegAA4SoREEARi84AbEwgSOYH6qQLXWx3SDJxMKR8gER6cEExX02AIWARvSTheEzBWWTMmVXBOkQRVqIRS8QAlCYGttY9f+hdfs5khxZScoIRU4ACI6hCT6+SGsgAtO0/9uRaP/e2l4cToIrUMlzW1SnsYDWCCo1xxXpoAPgmAEZsQPrsAHyPsr/Qiu+Ohmao7BOQV9E12AK2KyGLyIIiK4MeMoqPwFx8BzTsJjcLa8d3fQAWAVUsEHMBehKiGhZIETZGG8ZaG0TUIiJAKDESF4Hw0UWn0oPMAXmuAazuYSKLwnyMCO5GueyXsB/wAROCEatkEWEKGQcjqqJ5gx1DdTFECcFERHkZsFQkARPuEWmrwiLZwnDgjcG/wgPWBT+rfcMaCj51kD3NkO/pkH7EAG8lsMEtBjIoAPZGAEWCBRCEsHmCAIoKAHsGcLhCAMtABTiQAev5QJzhWkhE9gMwEP/GBJ/3a8IR5qAKywJLIzD99JFXSBi5d8yVRhDGADFdTAjICNZD0Gbng6bgDAF4Id/YRQ/kJLw59ooKtFU3SJwyKABX6agjUoHfeiQJLDA/RdA8TAcgjCkB9AzFfjAQyZD9ygCdwgu8tgBOQrk3TFca4g7zTgmjiEBUgg51qivnqQwTv2MEhAA1jAzs0ttxo4vre8koDtCOYgCXxImAG4shJlhOyjAzTgCoAgL5NMF36FI8QiEoZPD45gCXTAPWF7JwzBEEwCxHICBjowAwDAE1LhlkF9G/zADZRqELqAu0vCDhBhGyrhFZDqyTz/ALYlWhpgB1phEmz/FX6BGbbhFAaaov8fYAroQPjpwBdoAABAYRQ+n92A2zqYuyScf8ZkLAceIRn24Cz0gBFMFNLHnfttDgMqoRWuwRfsQBZkwRmsnqGVvn7/QM2UPvP719wPuVksqVWVY9/h6jV7oAN6oAcAAkkQP118DGK25QYSAAwZDhhggcmTK2siRXrTZosfDBGZKBgAgIWPhgBAArhSJ5NKSypdZXK5qAqeKjZChChhwsJDkw5LlnxIMqjQoUSLBn3AA8afKQtgQIBgNKpUoR56OlSgAEOHFEyWCIlTokSPJRiADuDjxpkGDz66ECESZCoAE0CqAMkDxAkjIH3wLFozQsOHPyTK7hwQgkuan0AbYsD/wOLDiqI8ByjIIQQMmCqR1qzZtCbIE8MKHoBsLDe1agAW4oA5A8QjwwIyPvBczRAUKCu2fjA2WRVA8Kind2I1MURPsmRVnISwIBRkAJLTh5o0DmHDgwcRDoNUICcPNl2uxoyp5SgZIFJv9PBalKnKk0g3hjAx0WIIEgsdWJiGfJhQLGjQgQkaYDVAAQUIZ1VDp/xSTRfO+OCGMG5wEsQlrUzySiutXIMbQw/4goEHEPDwhw/HFONhJcxwUo0spziDSIwyAADBA3RMMQUfnpDhCQ8B2LENJ6s4YweQSYXI5GoKtNDCEkAM8cQQH6GG221Nbslll15+CSZJwpjBiRnb/yASjSwYBMHHB2KwwEKJA3jg3XU++TTAdElw80xJ3SnQQQc+mLCEBmL4gIEfYvgxCCdNCGPdAB0gwcIAAhHRRU5X/tSQnQDIAY1Kor40TA1RVeVBcMOlpuVpREEwHVTE8cAHDDDwgOsftiq1661iYGDoYwylGoAHThkrBgxy0TlACiPg0AFWk+pQnwmVmSXGFA84BUA0xzRCZiXBYGKGG26gOEIEDI0QRxR64BFIH2PksYhfeAChAGNY7VuCEIm4EJRZnMplHBMlHBHHEk9AwQR/YU4VgJZBVXeKNvkNYYFODAFqQb54hvhYByWmuuqwqT6GcqrCMatABBosocPBR/8cYYMNM7egBjHLjAvHDTvhKagGGhgodGEtY3ClAsz+bNKCAPRwix7GqKLLIk7Y8FELkfSRRxXQcDOHE0zEEQcQQIRgQglMDHHDETe8fUNFnQURBBJhmdBBBFdKfKcyylgVgKx0bPMHScqimtq2ygo3BQ8jgTIJKA2RHGmOQZXMEAxJ2uGBrrZirlp1XBL6hA1VttAxlg8XJfrqrr8OO5huIIJpEGJEx/edlTVo2bAOWRZoVmIcGgQURNwABy2C3ElSncYJzHynDFkAxhjG6DIG9mMc8btRKoM+lC+UxABAAbkbRYnkJK0QpCmvXCIc3yY6NTJDXQyCqTN0B/sHHXT/8GAHOyBpBBgAAAYgIDQB/uExsnoACXBAAguwwGU4KAESxqIDaxmwMNAzCpCkEgc9mEcPpQhEFezCiI4pIGMsxI8CbECKPYiwEKEIRF7s04HzRY9pJCnABjSAhA4IhRJzKOICYgcSHS3uFdpIQEMscATn5CtHPhhCCeyzhByMpCQQ4FbA/sADMcjKd5RDHAZ+VRUNFO8GUAjCDejmBx9oYAR+SIEJ8BYCINThDZbozBqAoAhgSEISx6iEQ8z3kAjUQAbWQlCAOoWqSE5nkgCYjknYBoT60O0xSIDbFbSQixuYIF8diJkFQtCCJJiCCzbYyxregA2X4MEPTNBBC1iT/zqTPEAynRrAA0SEJQzYYYtDAV8PnTaAp0BgADyyAx/8cApEBGEtZ6xfamDwI2HY4Q/IEsMfuvgUY06sadFrXYgKZAH8tABB3/Mdg4xyHR0GpQW2IIQ5Y4fPfMJzKmPEjaE0AAOVrS5Ah+nBJrawhTrUYQuRqEMkglATjUUqekaJwAM2BQAb3CIZetAFLKhxBydwKQa+0CerpCILThBBFhQSw6oIIAABaE4MmPKB7QCwjVTodBWdekAKNICDwKTgIyV5gLaiQ9Et8eYFUQoBI/LQB0ass2M1wIIQnHCEHNzABtLYgyr2sAdj1KI8Y1jEEeRwwiMw4ghgAMIRDORIif/lSUFOE8opUhGGOXABdjo8AEMOsIowwGETt8MR+GAwhR1BwFi2msIf/rBNMPKADkSJJAAeOxzQkYxyGEDCFa7QAiZc4W1+iMp2WCdPhgQgYgXoIq3IcAo71GAKPKnEKN4HAGISZQA4uUIVjgCENdjgBm8wBi9csYacAEAWvYHIAGRwhie0ADVm+VlDptCFYwCjEXIkyaoGAAM6rECc/9MSCxbogxGMwA62a9ziuhS4oFxiEpe4J3VUi1+T4oYMMhjABhS0LwtEIAIdsEALQjCEmTkhELCYxR7GEALr6nfCq7uGLciQ1IasYhKmAIDHoiIASg7FvqvZHQA04IMB8yT/BmV4gqYMbIMhyNg+PvjwlorzkI9YwAaBGIMryFOFYdnKc56TylN2C4MVIJYPAbQGJSpA4YAB4BTM8MTkHnBkAFBiEpQIwjGOIYST+MEPK10FpEriNLrWdbfb6iDBppIxGyyiDzZIgQoBUIVa6IHOLQACNCDxiChUIRCBeIQ0HmGDAbQACkI468zMNgS03fGOOahgBRFUkoiVTzi2Wqx3uZQnoVQHA38YgQzYq94A3g62DKEBGTJwKhg8gE7GSpVSHouBWxXuvZO7XCQ9rbL4RrJkZgGWD2RRDTv4ggee8AQMUtsQWAnH05xO1TJPUwDFeYAFiwMKBraxDYbYdATf/xXKpJagnx8wAQBQiMQiJLEFhqCuJEQ9Qylc4YqY+Bkakchkw4iqAB8o6g+/GAQAugApMmD4sUpW8pp3W5QHHLFLJoJKF7/rKk9JjMSx88DwXCpQonC8fMYpMKGAYBG/DDp72JOqCSJMGdwBIA3KCMEOo4xz1jXkl1JBAChG0WF8gqQJgnhBhq3zpCX0QAOg7iWOE1mCPOThCH64gh+0GUBhaNMZbohtl3ypuBg4wMi8/lLGkcoQO6RUFjeowx36gA1A3KAkp+7hpkceFAXIGtrWKQoXCBGLWCTjEYGIsAJQsIIOlAAMUA3EEUqwhBGE4AlPuAEQbAAGLThHB3GQQ/+kUfeRFa5wqirUCQ8bg7i0o5GoTNoOnZaJIwM6QwZjHkEXukC3gYzgdg/xAAaEsQpP2KHs3sUyqmRtrMeiCLLcJH5lleLN4WHgGurLXEAbBKbq2Opyrx7xaisJ/klOBwaIMIMsBlE8KCgqKNcAkbnLwgQmMF0BYICD3H8zgB5EYhNP0MkR3P0SmVBWeMASeGACbrQFcMAJiEBuDNFPzYN9+3R2nqIaD/EUUwBrzeMqEShqsRMAGUADUGZAtodQdhAimmY4jDUcNvVGLdg2TIA6GoR0B4MFXhAHQ2ADYaEAVBALVCBlOQeEWzIdYmCCQic9D+M8GgcSpjAJItV3AED/AjnQBWPmBjEiDAWUOSPgDPcDF9YUOzxABiU1YRQIAIOgBfTxWUHgBn/AAtSxgUWxAJ4wcQOANB0wBSRgGsQBbXznEDYgBEYwXanjECSwMYcRVz0hMGRoFWMEA940MnRyhKkFARRAB0DxAJ7ABVxgCHxQBjJwKBrgB9vkTkd4CRhGHLDya7eCKygSQDCwWg/IIKsiBlvIdbTjDAvkgN/kJRAwcUPxB6dwCiSxCpUQOSSGdwzBB9K0CZsABWugfr23LJDodKqjACkQFjuWByoRS66gCrNwCLdwCMFADJXACbLgDAwhGh6hOgFjYoioO5zCh15ydkfnJdVxAKmgDQFA/2pzxHXOUFhC8XBF0T/XZ3aSEi0mYQSCFhM2oAZWUIEZxnP0GIQTCSbxOBW+lDSmNkrGsUJ3VAI2YQM1FhXn1YZR0XXAIk5IFpBGwQMUYGQOiGWrsQu2sAvuKD3xaJE56RAuIAXQ0Y4QmF8MYVFYknHP4x17Q10fs4G5QwapoBtklExvKBdNYGU78QG00wIlOUTuFyZdpIrKxwM0cFvVEUmPURUYMAJB0AVm8AuV4JaVgAh2gIXHKBcHsAIO0AAZYE5dtArbwAOj+CUK0AWbQATMeAU6UBxFcQmvUH0/sSnr2BAKEAI2ACVQYjMEmAmWgAc3QATR8AtrgAjH0AYv0f81e+FWQ9AC0bIv3sE8GieRRlFXudMD0GA2ZWM2jBBpkZI7OmSRDfF91cFxrQUBdBADFBCREOALQEJZYfIQEQMSJqADOnAEfaASeyEHD/mT1tAMDkmR3emdUsE0HfQQyLEEOKEAhIJRTDI/+EQDw9ckD/EAFyADQZCWKOYDiHIamEYFUdAyiEhQeMKbHIh9iXiEvENvo4c6vblzEamU+rIBkAmUF8kQbEAGvxANRBiMHmBJyMQkINFaB7CSEPcwjOWVMHANpigcj/ErpAZZEqIWugU7BXAAIPp93nVrhpKScuGcZzGF0SIyCXI+YjAIvzCOg3A7GLACK6A3IVADKdD/HUj1EFIiBECQA0CwCSckE3jAUFuwCUyAYDO2QkyABPdZPEGwWZaxAVhRAhJFUNXVoFZhGSjQHSDBCtuZYWDAC7qgC7WAPcYgQiZ0BFB0QpT5EUigAzXxHDY2UQQzjx1KEsm5nCZDFb4JfrixQpM5BIxwQpuQST5wG9dCb4/0naNKqielALZgCzsAAB2wBEgggwU6FZnllSWSZV0CASswAB+wCrqBAKujAEsQBD1wBSwgQV0hBx6BA0PQSwNDFBdwASEgCGrwgxAolTGHY2k6ejZxBHqgB5HAPQDwpGa3QhmDFbkUIg+RA5hRAlgxVAxRAyOABg44Rkv5nrUKqyYl/0By5AMrZQagkApnsgpFSJf5NEksQAePNQViMAKPpYu4UaM40ir3FR0PgIU9tQEClgIpUAMukAM1EAJzepEF8gRx0Ixekwf3glU2dzkrWxUmAQWbQQiE4GH7QrN78zFKeZSVmUtacgO5IARLEAWoqa15cG+1kAmLcDb5UgKYoQdkNQaFUAh9agyhQLWBEApHUAV6kAl9cASopJOvGaEN0SFiaG3F9CXUUwqREGNjWiKjmGMZg07pWapzS7e/YxkpAEwiqkN04AlQ4QF0oBS44k0A9AcCkAAVIABfEpMDlWM5FJkvJwdy0Gd90AeEBg1Y06HVKmF+gjQRkALR0ikcav8SUhAFfVALYBVWY6AXzUAITqCoXJICLvADClADTZqerikVqbNCEXuKXBIANJCBN0uvKPAUfHcbHrAKp9A5p7ANb9kFN9C8qUAJl+CSdBs4ehkAicsqBSBrQkEEyzAKqVCpEgpPOcauNpECLZACDvC6ogOhDTEEgKAImzCpRVEVSsoaDGFHH4kgoXeIiZmYDCEyPrGa9wpnjusTeaAKUMvAjkALY5AN2VAIElwI5kHBDJw9YxAKaxVpIeAD61RiPnFazOMBATQSqdAKr6BTOfUKlfALshAXAspXGAB5TzAzNiBRQKgM06CydevD05iEuBFejZMkwid8regTTTAKk1D/SQP7OtthXdegDHMwCuOwo2ywHRb1ABYADlXwBnchDZAACahgM2ZTF1YbBXkADX1wQnoACV4ABGDQB4twuTxBArUbVHlMAtfBoKkhB4DAwLoQCnkABgt2B4DQBJegyIqMoqvxAD9wAz4pMGBIiDFHHMz6cL2ZO74HALoBhqkAP6gST8IrIkuzuanxjzm3AHTQi3IBFWQwCsqwWiGqGmpXWk4Mnj+BrZ47YGkqcQ5ABxTgI8qiIJfcJDAQA43ThgpAAjiRTpKGNx2jQkRFXRJjYxlzPg87FC0TrkIgB2AQBY+gCZ1wC49gHqHApwysCpVrDFAbwQwctRrsY5WrB7cA/wY2s6Y2xnG5CgKKOgDOcAqyAG6/kAqV0MLR4MIGlBaWLMM3dhmLBwbKioSr8QOKAAlO2NBIWJS903Ruqk8TyJpGAYuu7IBe9NGZEwO4OgBsAJQ64BwpEAJ2xgZsgAZosB3AUgL5UA7ioANFoAiOMAuPkEdbJQjLA5JMYANFIA/CMgS1UArQAacPUwNKUBd9wAt7YENxLAlYcJ1eUgA6EAU5gH+WoYjTuhosXRTxasCRIkxu0AUoHIzeJEAbAYmjbIiiZ7Ng+8MTE5TJFF6EAA3MWqo7sQEX+wEfkAIPyjd8yBNiEFuH4gaycH6rMAiIgAhpcTtEOAUqHQF7TLNbMf9KSCmq4Fkn53pR3CwEpVALQAAAVEALuIC6fdACj7DApBALqIAFNiAHmTSZfdDO8KwKxhAIjAAGkgAIriAvFfy08GweixAT9bE2aPNhWsID2vCUnVI4pYoVzBmPEXBFYFACa51PO7FLN+Ydhf2+FJmcYtgkJWoruMwlUCxX3UPWANAEF3Czv0PLctEDUlA++/11JhECd5AIRYUE6R3CGxNX/ymBWcIQ1mAK8DOteyiLqTwU2WZUjyUGiXRH0anXey3e0QY7B0AG2ssldHCi+Idlp8wldsAJv3AMqVBIbknQblnQbolhQMEGRNkQc8pCPx5gALDDLfAAt0RvHvZ0Obb/jiaRQ9eRbT4kzUOQSZYHBCYUCBjDxWOgCaTAC996hFBNEvkSA6swA4ugB4VQHty4BxEcwVOTDaprQin0vrmjYwkWByHACUFHYT9pdk4yBJqi5Pl0DaYgrWN9rpZx2kj54WGy4105voYTXkkx0vLYKTumDLbACufqqRKDBs7JEGq9Gi7QBBlN6TzxEVjsOnQCAxGgFZABJxsgLJoLdgiuO9cxr4cxYI40oUWhsIgiBl1QhKmBlry3QgVGrv072je2T2Ebe0XRWkh0kxAaXmTgfCSxAE7jAE0wBfJVk0EBFdNxAKmnnkHRBdHQBURRDYq87UKB1iSxASRAAqWhLs1z/545rAO90AxJkHdm8QBJOgUpYBpaYgEVq6A/wQYREAWuUAtxoJVy4QuXYGUb02d56lWZ4ARX0wd6UAvOPQQ8oQ2GIBUYsASWFwVfnElHkAXcQAy0MAcBkC+7AD8aEEDZHZR7zeL0Xu/lOlS0niUQQTMhQAjN0At0hsMs1POWQc2CDeIh8iPV/pCqwQZWYAU5TL4VKWVlPVD+WfDLgkatfiWPEa98Ayh685xQ+qaUASgFxpo8Ea8RowG4ZywV+SQRMM3/C54DxuqteSc+9RggKxQEAACXYAo8xWYDsAA5+p4kcQE4wHp8jRtG5TE8YA0Rj32TMAq2sDooDArCQPOqAf/q1PqDSO8THRDHTjBvFzDqEgY8wfO6kansALAOi0ApfrVatc/Xtk8DaUAD5RMAC0IJ3OCDWZAIc8ytyYDVoicEORACTjAGrG0UGFB5Ztw2cWN5c/YIQoDDGwMAjh3sDJEKo0AJ3jNtGuqoQgcRdoQVlelmi+4YOeB5S6BWerDAhVALyeAIj3DxNiPRS492AAFA4ECCBQ0eLLjCFx8ybtzI2rYN1DaEFQsOGDAwY8aDA9CsGKADSAgFFk2eRHmRo4eULV2+fIlGJhsevzit+MZCwwAPHumQATCFixZJbSwAUICRyYAvAjdqfNpygIKjGAeiMfFEnAIFLYYsBcARpkH/jlZfYgirkaoFrgap9sihIWnJtGE5vmplJy3GjQMK8B3w4MHYk2KdllhClzBCvnbJshQIYfFki2hSRrXLtYUNGyEssOXK9XOIXLlC2MVgmKDZsQjIBn5J4RINqARZ4LBgQuAwaYzSCtHyKBBJwBrrCuxgImlYrh1ALx/oi8y2awTJNTqm2qAHDBggEy4gmbLFwBFS5DZRQs56HTpKOJ08wEKIIZyPBBqjK5QTaaQCLWLkCCfGI7BAAwvyIAY+eODBF0/I0Cu+AVhY4SAIumGohilwcCEJLbQ46kDCtBvLGwBMrAcmNgBggw3LBlqRRYFiNMkDBWRIpRUdX6mEmFQI/2oxNYzQcFGjHNowQzkTlmBiIAsG6MCxCCJgbLWyprIqBTiiyKSUWkjhpRRJtKgij01CJJGgAEyi0aI1DwrgTYKqUkAHI4rIwYakBjBBB+WKsyoqU6wBQLIBIPjLKRTYaAw+FluEtEUDf/jB0YHkNOlFgdDoayoAOshlkTygAUMIFgxKdDtNU4JAvJQsk7RNg9pkbYUOSjAhBGhKwcMJJ44AlhFhhdXjjloWacGptsiC4IBWW8XMJFc1mhYl2Wh7ja8HItBghCk0iOCBDuSz4c9AN1JAyKf4oioFE2r4gLWBYACgmh8lQwMDNkbAQDB9YzQLjZ5EPEjWsQALlKuyjv+jLAU5FlFFlTGcsMGJIeprIVnG0mjCAYI/BhnkwBR4IM0EYWDQQTK8WRiAVUPuqLCCCkCIjuMsexlmjnJ4hJlUfmnlFXtmQAOCGFLhAYACaPbAMsNIRLcDBTpo4UkFSIDaOKdMGGFcrvoVAhteeNGjbCfQUSSKIZ5syWCE3I4PgDQEyQEGfTgiAb5OFdCAhAh2+IEJH6yOgEgFpogg3WjZJCxnA1/WLISKQwmkijc2mStNBD3gTiaZNTcwI1ZsQWSAb8SpIhNdCjEmm2wKgb0QXXTJb4wxAHlkjdUYXqxag3w36VqXHc8W4T0RRp6xddlkAwZvWIiABUQaaeSLLVj/+OYbDCAo7irKiBcZ9BEFKkGIPAJhxIYWEkfYIk4I0Rhm+edPyYMRRkiKZvpRAh7kFVcdgKzAR789YYAFHXgRpl7CKHRhCTpV4p1dBtOogjhNfPsL2ZUAkJsW6OAHUuNLrsY1gNSk4IEouSB8lvQEFj7BB6GhDKbYEIF1gKEKTlBELxJBH4yMsCUeYAEUbhCE7mDAD3YQQ3fEAAO0wC0lRZIZAAxBDnCMQAfuGAIQFjEGVxTidbGDHRfHgIc+VOEGT7CADGRxBfcUqH+ReckDKOEJDC5mVS26DQnuMQh+fOMKBGmawNjQqpm0Cib9Qove6hgyC5SgBDYogWdatkhK/1byIGCIQojsaMmPDZCT/oPJwlIIQZg5kZKNoYoCIjAFE9wACEgQxxKeoAMWKKYiLUuTYaa0hBv08gZHQONyTNmS1PigA0wIASBgwYsq+GEA0XtjZTYlEyD6IAhBgEIQbKm3AAwgAJDp5lU857KBlAyCNZCBQbziyirkJxt7eJ0rMoEHPADhBkxQjFW6sUn+vaQA45jGJ1FimVeMoh+BYgMGOpACFjwgoTCYwh/s0AU78EEMEPDGFJpBCAEgYJgFuYAbgvAEJNTSUgINnXFGiVKWUqYHP9BNSz8ZADKs4hSrAMUqxFANUMjUQB8VKFAtIlRLTsUCyREHFICw1LWdcP8sEcBBCjBigSXkoJchWIIcnjCEJ9wAHMT53qb6gpY2DAMPQcCIORvHOQAEAF8AgIEY5IWQpXGOSM3rRtNaNUxv7uUIQKhCFWzAnFS2QHK/+isjQqCalVJGLAioAA0q8CbuVeRFsioAZKLV2AI9QBsm4QGEBuIBMfDgD3+YQlhMsYxRTGIsIxDiFaLkU9rW1ra3TSludbtb3h4MMBiQAxNMsLiDNad8UcjDDYYQAiQsYQhyOEIIQvCn8TAqswVwWgc0AI8r9CRx9QMA51jiAQiI4Q8suAYoNNWNbrzMiacgAxN+0QRf7NN7MRtIBEKgBVLAAhakeIQTgBAgRtQHWJX/K2OB52og8UBNfwBIwCtAkQCBKLAlDziA/rRDXIF6ILUEgcFpYQAZ8bzMwgbBAGyJEITettjFLy6qSQYwgi+kk7P7OzGMd6fjRYrleAv+2NQikJzZ3vhtA9iARwYSDoE8IK8HCSSUwysGFjjjF5UIxy/OwQLLQOAP0TzINXiEj1RMohpvilGOIwiAGghBCPZULmCrAI2RyGEITkWhRex7kYpIxhcCEcCaXVIAGBiqI2omCChSgS1KQoBz3plRN8BskQ74AADM+CyPNb1pSnqSYHehhNIOogArjoDTIiKqT1O9W7EAmZIrerCMK7KBVKRKMhBImkH2fJBfkMETaehB/xnMcOVK4OUVp/jDd2DyJmtoY5+XPVAEemDLXEIQlyqRmWX2+QDuGbnCbYWrHei1gMG8pAuVqERPCSKZEbhBDPITWHTSAYMEgkcgsbbsqfW97xfjW2v8BniBVl1bb6OUhCTTABKYIDXu0YgNQHuFMGLGqQACKRzhmEI8zvENHySyIHFqCaJh9G0CrUnkk5S1eMyhAVzdsjGWKbegxwIDeg0EAjW9hEnsEA1MYGIQ81I0GWTBCT/MDwIwEEYlJvGKX7zDH+FVtqf/HXCqV/3UhvG31bU+q62PJ+uMK+dJMBCBATChB17pgQkYpSk0mKgD3TiVyzYiAytMYQUrcCgg6f+dEpEvsMd1ufEDYDCE2WZLYeSc4JoLbhAYXCPnBKEDzS0iDE6sghOpoAj9aOILB8lCLxAYwTWJqOzhzeSud20R6mWyes+tvuuvhz3IPP312Nfe9ijtjg9ysATel0MH43jPSWZijVRcIggUHUESQSYnOUFgAVw3EO2vpMpRTprPBIEVS6t1CmKnYgR/8GkRSX978pff/JoeuPwkVfLzVzJdeBbI+EFsBzdECGanSBqY6z2Wr2PmSjowNRHJiKkxARDincUzEBigAzuwA0SICKBwCalDCZrpO5JrvwukOk+SQIKhPQysrfTzwKCqkYKQPJjYv5fgAm6wBeH7mL54gET/KQv4o4w6uYE4YCHeA4fgO7wdcwlK0AZQEAYe8DjC8IDQyrWxqMAQVMIltKQk1C0nfBzaAsH9mcIWq8JFgkIVscDFWJOoMIvloR9PcQpxOSmY2AVlmINBEIRnMAMmdMM39MDZg8M5pMPl28JNy7FW24s9lB/M6DbeIgMIrMNBJMSZKsRDlEIRHDmCMTlEJBBNQUD6CcTd2kCDyEJHxMQ7zMQ3vEJLqsSTaJFLrKMsFMXVgCIA0AAZEAccSINIBBKUgKIVkUVZPL3Us0UXST0ikT83AoBd061JHItVKcWWWJUBapNO3MRkVMZllD0mRMbL6AmOYAEiiIYwGARZAILU4OgAvOMnTvrElpA06yuQDjwJOrAZeDuIb2TGdWTHdnTHrZMBFpiQGXiCFhiEFygpDUiNd+THfvTHfwTIgBSRYwiDIegBAFiBLYiENXgCHxLIh4TIiJTIiaS6Z3yJAQi2MBAFRXgCmaPIjwTJkBTJkQQ7kjTJk0RJJRzGlIQ9g7FIloTJmJRJlFrJmbTJm8TJnNTJneTJnvTJnwTKoBTKoSTKoqSkS6xJo1TKpWTKprTDk3iTqNREp6TKqrTKqxyPpMTKreTKrvRKcPvKsBTLsSTLsjTLs0TLtFTLtWRLfQsIACH5BAUHAP8ALA4AvgC3AFQAQAj/AAH8G0iwoMGDCBMqXMiwocOHECNKnOgwQEGBBC3+s4hR40CBBQAMGDgAQIABHgtytJhSYACTBDuaFAgAI8WbOHPqVPkPo8uBHD8ufEnUZIF/BU7SdCkygAeWTIX+hJpx47+RA4/G3Mm1q9evH18qBBCy50asJgMQPal248ujRHsG0Ep2btmRIyEUKPBgbwG9e92Kzdi2oIB/hw+n3CiApVXHjhGDnexVo9aNNXuGXGu2wMgD/x6EjoCCNAsSETSs0IBDg4YSGkbEJqEB9YoVLBY82A1hwADPfgts2H17BQkSLCI8WPCXAAQCBB4nDNCYp9bohyVrp8x9IU2oVM1y/9wMci9xEjhGjPjQo737Hv/arx8xEHWE+xFYDEyePAUKFink999uBC5XAHMHFECAggwGdhRc1/0DmmEBREcQdgh0p2FXFiXlYVt7AbZBBCv8w0N8NcSnYns6tCibawSp18MI7tXw3g8y9IAjjjn22EMQ7g0UwWUKEiDAkRJGZyEBCWzopIZtzYVUYBvw8MEHOrD3zwdb9sCeDGC6IAOONdhYgwwulOHCP2XkIEMQUJRRhhRQdAEFnf9I8Q8UQkBRUI4aKLfBPxBkNeGTiCaqExtWQRBAoZAeVeg/CijQgQY15FBGF3me8Y+nBBHxzyY9IBEBoaguoOiqrFJGwAPO/f+DQQcj5HBGF6CGekYZfkSwQaHC/cNcq8QWq5MCoWEwKAb//IdcBB10oMADCgx6GUJBiQeUWdwKtRhW4GoW1rYzGWvuqjZZtZVBHlmEF1K//QYvW0SVJFdR2aoEE0FYXXTuv5V1a9BMgxFMFlk9QUBTWTWZhJLBkW2rUbtCbUXTTSwlRpDGHFMH8MdVsVQUZnE5htVJgcG62wLD7YbBbiSycJvMMq+AQmgPxqtWlAMJ8CBS6lbHWGTUtavYPwQUjZhH2YGsU74dybWvWT8JhNJv055G2wgkqEcffTqA/Q9rtd1X4AIoEHifBinQ1hoJ/6TgAAq36cbccwUIbVVSSLv/JVnGoFlYkJH/NNm3017ZhHBZjBfgAQpTfDBCDUjAF8SZYL6JYw82ejnjCEhw/Sy0+JW4JZdTTCEzCcYZx8MIVv4hOdcasPBf2g9sEOEB2Rk5IXb/ZJjAAYYjzupcyG9UwAG/dl3D5lDkkAMUfpYxkPRtvjl9nHHSOacU30shfhl3EiQDFOfLMNCbA5V55T8GKCmAkXkbbz9EAbDxKN/JJ+0X8n/hy3KMwwIdyEAInrrVGW61CVENBAwO/McLpHABDcDqAM+5nwa7o5eC6O4BA8DACGQwgzMoQVRncGAuiFCEfwRBA5U6CgYXJLgN2nAyjCIIBAZ1Khm4YYGb2MSn/8rwBAswSzh/URWs2OWvqlhFJuu6oRS5k66WHGQxDxlMVQw2MMwIbIqIy9ZPnlgxfeEFZUB7UGZmMhWIkYuMF5MK1cBYLCs6MV8MoVdIQnK1mTzMLQ8Ty1SeODF1ISRddETXFRMCsYOVBSgKUxhc5IISeg2GaFErzM66yBWNaEwyHEskRGASR4mdhS17bIq9LkZK5LlkYlIyJBZZSZFCbgeUt1wkZES5k3appZJuSct3HtMUBwFtAB7wDVYg8LIH4GZAotHdgjYZsY3x5JqPOdouq9I0Xh6klcRsSb1SwhakLGc4uknbP/BzHwDRhjZTeJtyCAQBD/TGM2lxTAAhYP83VR3FQk2LDhaB0pjDLMkiAc0lL8slGJIJUyN5Yc5umhUzFLgmPTj4xwhKoJ4SeDQ2tREDcpbzAMD841fDuc9qjoOE47CuWQswwAIOUMPpaIc6SZmfQi/kTY+M0YlyAcpMkvKbHS7gNBsdQXpGEDYdaFSj9MEBbVagnAXAoGYkKg2AAOSaCLDOdivQTYEIkCAFbQsuLOEbQQdyqI1NKDGE6+nU0krKoyCMLIWCWdck554g/CAIOfjRD3QE1cJKNVAReFlik2McEvDApTbbzXB+JSy6FQcFuCvpSf8HlJoeiXdI+2zwRutNiUzMcVcJ4KB2gwKXTk4HNdBBD5zqVKb/IkEHoatNtKDVAZlNYT5eK5Nwr2SjDwjXTDMKm2x8tZcDWAZ4AzES4TLEgNJ28kOPwcpyWLAezsEnDkHY057++oOBlHcg7+lrDvwKWPGuNwfXk0EccgSF8/4gbFTF7AJUFd3QQgdpxbMuh66CvKQBa4fOxEENggBe6rFJfDnQ06Y41QU9nUEKCDzDC4TQBQRy+MMD8Z6c5jSn6LmwPTX4AAlYhhTnQlfAq2IUo14yEoyM5C+DusoD/mMzm0VANyOKXA28RiMZYPgMIB6IEDeBZCEIQQoukB7XNrABmsJ4igBEml0eRSi23JNZGjCy+H6IKyHmKhdnAMOncjCCDmxg/1gJujIvzbo/vXRwIBjAAAnOJL5bfeqBKxzIFZCwzrwsjy9yTnRWlPiADtRACl8QFREcmMIXnCEHGrgKzvDWVkULGDSTfYAFUvBoIlj6H0RY4RbOIAMkvCyAolkABETj6SvvsFAbYFbc2PSDK/wjR4QeDoPMmcNae3qiyFotrSciRnU129jQ5uS2ogjUasfFkNGmox2nnS0xtmuu2C6jULNtrmYX0idNVBdcrnaSUwbVJ2JRCxcvJkhyd6eK6a42u4HGlqsROCTDZKPfDElvhh7yi/Y2bb7PXZAHdWhv7ubIH9l47YZnxV3h9ldmEq5wdDO8Wyu5osPeApLfkKWPmv+BWJQQGReQHJzjD8E3td84sm+ypS6O/A1L2I2SoPr03KddDLp1ojcBb9vZCK+II0OGEoaVxTGI9NsuyxV1jBU020OfDsH0JW8PEdUp5RzP1qMOmTFWnYkQubreuon2WpdMqNdOniMPdvOznDIqNuFZyCvzSWtiKyFsL60tL/IWAvf85uO0OynvJZjCfBGLP7v436uJS4MEvme4DOWVG1myUgIzSvLeGckFqRb+jR04GxhAy0hqLaSMZzF9N0w2M6a0UAZ0oFPkfFQ+wr94S6ndsWx3Ujqou9afdAC5ewBpSkM30+jG4U0n53auNXtZaic7itEbdmqa+5pbbDNe1GT/1ZCCVwlNtmXzhJlXXVOb2sjsVISq515MPsmUhGjYBLkM9w+SmKKpXSuXl0jwFhai1xatFCIEkE7Kp3ztlBquQQJIAFI4MAWZpgE3UyAYcE+V5HV8sQDFYTvnZEz9BRRY5DPZpzThtn9SlHcSs0sjAUB6cQA7hlmm4SxaExuhw1Ec9U7/wAKnYTsssBvBYU4Echq1QYGsg1nCcgAYlCC4h3nY4TGBJzg1FIDGs3WdV3bU5EXAMS3KdxoUKBuwoVREllHvpBoRAAMktUOhsWMkQiIkMAXHURs3o1/7hTdq0Rg/4zM9UyFSyBjAMz+HARoG1TdWeIU+NTBxty8O8xeh/2EctYEE6dFUIzBo8PEPsOEaVFUgdOOB/5EfKWCEtIEC/mEzmbUAzsFZbzUxTVNQniQhsAg88tMkKug0LPhFMDFLmuYBAtRacageWQIfs3WJX/MPcmg7ypF++dFOoQggKxAgzbcyJLUgCTIpD/JP29J/mCeIvpMYxPONCRBXUgR1ZbR49eZI/KR8xgGMwgUkl/gPg6Vcs9MaiNUB7EQiKbAajUUCmEUgwjYsbVggdsZZalUdLhYAzmURBJAhxHM41sVKJgM0/wYAvTFrK6AeNkIjQAIkvwaPfjUQROY1tEE6yeiDxzEFPCCHL0UgA3EbcfhYckhVZpM7kxIr1AEBAv/AO+LIkLQYWnLWbohEVCQhJV/YfvH0W0xVJijCORoVW0wlhvXYaA+gH0gpOZKjUR+AlOphXGUyOerxW6wTKDnWWdwoANUlAAhglt0IizBnFLGUMx1IIsYhObFlXCsSH7KFBBGYAoHig69Dl+vBHseFYjqSI4OVI+6hHhEIf1lRP30DHfNDiLyTkzBncVPnF6jSWhllI3/VA3HwD5+pIoNVWP9QJjpSmIU5X+3hJm4CXvTFkZYDH6iRfKqyJAZFOL5TiwmXZd2SRG9GAoIJWH+FPpryD9LjJr8WBG+ynOjjJ5oSPdBZPdFTBuEVXpbDPqW5HjwAAiQgOALwHDkZnpX/ORSXUReOMhAWCZxnAifSwybU4z0hlidz8mR1Ij7iw2F5sglSoJ/yWZzH2SZiYl4EEVbRYWVxNp6jxFPKg2O78QGZAyZu0ibWUwYzAD4U+g8U1mFuUEJd8AIYKgVnUCd5Ij7itSeewil+QhA1MAVpsyBIQ1OdhqASMXzLMygts3o1gxy/NTsjQIEsQIEa8CVi4o49cD7icydCMBCc8ikVVqKBxTV9gTR4I6OUAQBsQJEUWU7BwRd/ARh9MRyQmDqToycYikB6kqRKRmlKAGEfkBv5F6NUChbFxpb7gxiO4nW9MQCzlho9MGYZ1gVMxmQpBCqg0gUuwAPSBB2TEqfE/+Io0eF1/XIVl9IDF6ApZIorA5FmRKBm/9AnJNABv+EcLsqoxKI/kjKA80cp6zQCaXKmmCoqufAPnNoDJaAs+Eeq5sIGbJAUETMpChABNeACP2Rpg0oERvAPubCmS2AC6GkoGYSr/7KrSGFn5hQBHyCsKLRAmppA6pMVQBMd/AWtToNoBBJmHrpAfkIEW5BqRBAEwSalcCquAMMXbEgtPtCnnkIEQjQQ61oGPZCBb3YgWhGu8goyLJNntOICRFCsqOZCBJFsBKA7BYs4fVGx04JeZTBBcDIqPWACzMIbAxGlczqx58IXY5ljXYOJhJYCKYAByCIci0qy95Njy7ZOQg0yLbkms4k0HC+TEwEBACH5BAUHAP8ALAQAvgDBAFQAQAj/AP8JHEgwAMGDCBMqXMiwocOHECNKnEixosGCAgMA+HcxY8GNBjVq5MgRgEiTAjdi/IdSZcaWBlGmHCiyY8WbOHPqlNhRpUuSBEGaBDBA4IAAR0uG5HiSpdORSoE6XVjAJs2FP7Hu3Mq1682TYEEqRVmAZVkAZQkW2GhywEY2/8o+WLACxYq6ESI82AsBQtq4RwMg9RhXIIHDEAj4JUDS4F+BAgIIgEzZq+XLE7MiFVw2QOe1BQpA+AdhwwPGKCL8I5GCBIl/SEhoGKEBCRKBOP6t0Lu39wPSpjfwnttb4IIFMOjOTRw3svPHag3TnAxUQGfGAbAzxsx9K9SLjuNC/1CwVy8L2VOmjBiho0aNfx/+rZ+/nsQU1yx4b8BgWuBd/CkMt1daLPw3BQ8k8AACfqn9FlcAo2XEmADOcTSZZAEcINABAmjYIXXdhdidSWsNVFZpKJCAA3sj9KBDD//8MJAOSyyhAxJLsNeDi1e4uOM/PcgoQxBB5DBkEP8UKVAQP8jQZA8ywPiPDhoIhMICBiyg3T8EdMScANuJKOaYBw1QVVEFFIXBPwOgcF6Brk2xmgYRaGDfCOnZp8EKcY7wwYsyyFCGFINCIZAU/0DRRaJndAGFFIpCUYaROkzBwgPM/XNAmGR26qllVYkWmkChCebXPw9MwYegUkjRxRn/nP8BBRECEQEGEWeU0UMJEWCQFoScfirssN2xsUFpqCqgQQ5n4ErrGbkQscUWtPbwgAeikRbXARsQ6+23lnWLgYMOHsRff/0tFFNCWT2l0lLwogReSuuOZBW4+A7bbrtThQTvVUMJptFamwXsU0waDUUvAAETphJ0UhWW78SW8RuUu2AFdlRVBofUsUxTWRxXWaGVbPJgIh+kmVT/3kvxy0GNxBapaLHJpmeOhfZAATv79dtc/6QWgWuu2TmFnVWeh+oDMGAampkCl0VAAcchtwAEB/yaVoWEkRTZP1+HLRl1YVoH85gyy9xYQWaiBUB5eUVw3mzrwSYQEjr8o8Hee8f/7dsAfg2w1z8w2PVP3DDIvZdpBWyQNQQhkRzaqRx9BplVFUoGGXUachjs2Vz9dFFbThXVm+EkjLBi3R/00Lp77bnnp+quyR33PywYvfcISLQ4+3o7juAeHz3UsKN7Ao0g224rLCBQtwR4qCEBk23H+WTYg57vzAQ9wOd6OggvQw5FIonkPzIkWgYU7HfhqKxdbPKPo12UMRD9Aj36j/3rGwnF+JMykkAuEB8UFGBCXMoQl7THwK0cxQOVMwjkqiIYbRXmaQBQgAL2h6guCKFR8ovVQHA1EEJ9YC5l6VADV/ipbBVlAAoYwLhKIAM3KEEJJPwHGET4DyIQoQxLYMEA/wAHucREiIVI7BTlUAXBDoygVuyDwhmkcIUOdIBcpLLgStillanMRGFQSaIYvbIvLnZkXiJZ21K6ZpM1qgxhLIGjy8Y4MTgCxV4XwyMaXSIYtmxGjT852LtElxWQtYyO4CpjxGaCx5QcpWYzY9jA2pI2hZGkYxF710AeppA5OiVliOyUS0BWGLcRDIyh6sxM7qjJiy1SKitTWUTatcZDhnInKimKzRSClsil8V+sDONV/sGGkpmpcRA4TtOcNqpVTqSNa3MOhiqUPRDdkiIfg0ok4+KSR4aKTWkKp5kGcKxyPsBNJDjPCljAzgKxk3C98UuaIlY9LlXtAA84wGhm1v8Ra3rEnwUB6DUhEsaZocmUERSVPo+FqYZGYDck4JOe7FOCKZSgSnYqEG/6Ms5wAmcvCyAO1iCAKawVwEPVMwj1LvKYv2ynS9jbTmfM9sqBbjKLRDFL12o2z9IMLgIoaI1scKCe5JXgNnpiZ15Q0DSrNZSkII1ASC/FVLktQKrJPKlWWVoA6zAGYoaRTFWoU8GyVsamCOEexnDqGLSQNG4RaE0JVMei8OUNRiPww9HSCVSp7gVbPNsLU3VzF78trmei6tZxrhRPqo0MbK/EnlU0tx0OaUqgaAUPHy+SFKO8lU/pic8Twee70dLnA3rSQH4eoJcrys2dRzuPnFaTnvT/rOcDuPWTehD0GtUMKEKhyR5kRlNBsE3IsipEa0622c2B5OU18nmPQN4TJBfpjW8Y3Zts9tY7IB2vB0wKFJR+wIcY/egf7zFefAaiAOhRj3pgGoiGpPMh5XInK85bwep08KIfxSFJQAJwHJhEJENBocCSYt/6CAWpMvQvB+uTwf+CMOAfMAlGPwgfbnmwAsPElyOdyw6F7CsitJRsW6ZJjXpeZLwhBQpJOTAS/9BnP0JJyn8SHpKkIDVFRAnEfv9oVZCHPCnxkuABxyLN1KRDYphZcmby5Ixn/DLBUvkFBuncU3oGYqhNSEF+m4BVonB1hjK3qgzvOc2GPtdkJBYT/0IhgdzIpjYqzmqgB/ZrFKxmNasu4AqHsepCDnqggZ1t6kJtti9cRvOrUxVAARjQwAcG1QU3wErMAjmDEQ7loggogLgHgBBcEk3qgcBFcL/pAA5k8AJaxSqEuYgWEYTQAxaQRlRGLLWuSeWg0XRAAzKglat7GCsojOBSPBPNsQ54xF23eYP/8IBpoF0lggRBBx2wwAM+3a1yOfvbA+EPkn+jmuVyUZbCBLezRTYvQ97xKh6bIyjVDbPJviRi8Y4jy2qa1nl1ct70vsy60krwNKpxbS8Jy+hgMpbRKXyTBg94VxSJbo/42+JgLApz9X1GeQUyLIvcpr4lfhNFnlFdY//J5iM5jkl3Q1yXaeEkRopLcoikrCfOTEjCWGLJfjW8YbUEih9BBkaLeZLgAE80v1pplUKmBDSkG2TBfg6vdQGdX/e6uFY23rV1s1GWUnHLLo+y8pu5bTCje0pN0n51XkaQ3zfduFqBSXKtfzKOj9RlzHQJkqRE8uE0oWVBSBZ3Wcrd526E+7cX/kmZWSyXJzllUxjGc83iLDqhKWbJlv24Zobs7nNf5NF1/m2RQ7znaXS6JPkYlNAQRWdEgSprU7NMTP2jW9wsnRcZkviuz7wx0qz55xHiGRLV7GbgtBlSjhnYpe5Gtao1bLkg8EKBMYU6J03mcRLTTFUOczpwpxD/mzNrsDjSkmPo5wiaRpVYURHnoXXJsnbduc4V/AzJp6rg1rJ/gHs6bvfDBCKIJjZgkx0qRR0fRmKVdHqTNDCkMhh+kTULwDMEoFgbYBd8sgJIY1H3oQGzxU670RsbEE6cdFLEEVIhRVIXdBCaEzZglRHSBCKCgWi6NkqRtxFp8ULZ4lP/EFKHoxspwCd2ojyxIR8YpRvs5Bt9EU7KRhy94YNOGFJ05jXfl0UsqDkGSHwWR2opA0klYjoq2C1AtRpKMwUrkhsVhV10MhwhNReOA1KmUS5T5T16IYUboBhTwyECAAGT8YJgM1YdgR2XM4gqpVxNsW9tQzM4OGWmoRdy/yMbSIADOHAbR1UCRsg36/RQUsUbPBOHA3FOhVM4tHdOc0EAE+gXEAJZ8FIVYTVi00QQjOE52hKLkIVW8rKFgiQzT9OIrLVdqTNXODICVzBa/2BRqpUf+cEbvrIme4EXhWVYerEBE5g1JlMayXQaB3RiVUgQ0/Mh1NONkCVc15R4BTVJDJMmcdiMueOB+wUkrRMfH0Ab2CUbq7UX/EEQd7EnEcVaizOCyHKNMHAXAskCKLA4WeMZCkGLG7JAHgJfDllqLXF6NmMmUCU37HhbOrBe8yEfpKU6e0UnrLUfEbABHQADSrNOSsVaD5Ui9jEF8Ugf95FObRgmzWSAoUaLYP8SGZ5DIbKodCynNkZxQYIlUbNVN/PhIi1iPD0wWjhgJ3yVjLiDTugxG/LxB6e1Hkr5kkaZTgLhV0m2QJqShZ3TIfOVkz3pbF9IM6BBMqXhAT/zUHDyGn/yJ1NSl9Y1AheVAnSyl9u1O0W1lMUTmDXAJEpZA8TjXckjH9D1G0fkHBzymFzyjQNBPcLXb/xEdmbSLSswV8LTHoEpI/9QI7ZRG7PRO7ZxlMUTBDsCJT1gJEESIxb2JKp5PgH2iQvgONFzWfWVITRVmQ7BFgRDMnuROiyyIwT2mkgiJQJhXeDFmkQSBAemYAkWYxIGnU0SXukzEDCiXRHlAAlkHWDSJVz/klyY5ZurRCKpiALqUQMtsppEMmD/MGA9cGDQKWHrk2Drs2CPsp9ChigQJimJkj7VuSQWBiPSdSWFER5ZaJ4UAWe3hwIsKTw/UAOB8j9J8l8C9CiIwmfuE2SFMikLtqGLYihcNhDroz45kCRLyWHOExp0looM2qAXNDmBBVq3xZ7F4yQ6ql5LaZjOWTzu4R6CYj+RsiiJEmSGImSKAikxxgc6YH+45xd7WJ4xOhFoIh6AswEe4CvRJhqYMi7lgULhVBoaqB4tUl6Ckj+y0mVI6kNnIAQeFGROMgWqET3RQ6VVuhVVATkj0WiRMzIKGljnxAJTACNS8KbxIytEMCub/5BDOVQGI7AzL4WneXoZrOhLExRnEFJnaTIF6XMGL9AoIpRDmSYQHiQDx3ZAWaMplQouBhFqf9EZxBUXqfIDg3KoHvQqo3ppQbaULKAAZbEpm9Kq+YKQJ4YUJyI4KzACrOIGH6SrjQorZCYFQYAE/AE4SjZ+xDos2aIQrKUBNeAGoaqrzvIPuZBpQlAGftABXBpq29pAbDBqz/MATiQDukpstHKuRGAERECtHQBBGZFr79pAPiMQHdADftZqPYRptNIFfNABVNatA8tC1LdtGNABSCAFPlQr5tpDXUBoepEtO+iHE4svUKVBv6EDZfAFriY/uYIE7LpsVIYqzVayMD5jjfeoN3mTBGVwAzkAKTALrBdkjbhns6DjU/txEDjwGtDVAaRyKgMgr0bbQMEhEGuCEL6VLlMbSldbtBUREAAh+QQFBwD/ACwEAL4AwQBUAEAI/wD/CRxIEADBgwgTKlzIsKHDhxAjSpxIsaLBggIBBPh30aFGgwE+hgw5UCRIkBz/bdTIkaTCkQI3VpxJs6bNmR1lHuyIMeOAkAB47ixgciXMfwUEJmUJIKlCpyUZ6pR6s6rVqxJhFhW58ajKAUibDkxaYACEBw82oH2wIMKKFCxQsCCR4l8EFgihciSrMikEpBCSHuBbIIBeAjoDCFCseOBiAVgjS544MgDYnwB+Gt5Y9t/ff2rbto2rIQIJDf80nE79T8zdCGsDFygguwABgQvQLviXG8KGv7RnzyYw+wAEAgcIHNfLUIBepwQgR/8nAHL1ydgtdr3IUuCAsn/Xov+AgWLFCg0apuAQiGOE+w/u/63Hcbp0hPsPBMJGG4E83hX/nFffaSSUoIF7U7jHg3sjfJDaCrDx1hd1zB3wD2ICfHYhZAdAlt2HIB4ElmdqsSAggz3800OKKV6R4j9LqLjijD3IEISNQQQBRY425vAPFGXsmAMUAvUQRA9x2PhijQKNgMQ/I0xBAgr/dFhddNNdOJCFIXbp5VhIdZbUiAOUWaYCD+D3QJkPBAYBBht4EKdvEJyVpg58CCTFP3v+04WfUHQhhRB8niFFoFIEKQMfI1Q5EHJfRirpZMQp9ZdhSG2wwQcyuPHCGUScIRCRZ4BKBBih/pNDDU8qEJhxBez/NumstGZXwAO0bfBPB0iUQcQ/oRKxCRFbEEFEFz2gpmsBGxzwW7O1RittZGrZlaZAp0XQwT9pkcgQSghNFVNLKm01kkgEuaQVSex2N+27IIqrUkIyfVRuYkyRtFVLBjFV7ksxdcSTWEjBa3CXU8kbVULmNnxuwU7ZtsAGE+N661oYe5dRUgoTdNsBjR0sMkVFjSsuWE55UNhsAv0m0Fp2QUhgCf9MUcIU/8zFws5pYvCAyt/9BDHLgj1wG7S/3VYYdV0d5OFiTEf9mE6PqQT1yNmBe29GGtN21lkLxPUPCQQigcOTBqKntgY8+7wBBkm5imZa+UWQG8YFKOCBAhHY/+WW2mSTHRdsuUWs0m3yTmVhUog5St3jHmKd9T/foZQUnP9QSXbNjbL3jw4j1NAglB/ggAN692l7FwksoJcglI2uWEMPNfzQww8CydADFLgP1MMIPTg4wmkAUpmfQJAKMF2HAlnIvIW3ST7tRuHJtQIJ8NWgfYo/BNG9kSsG8Y/4OZTBZ5BB/iMDFDgG4aP5ex4KJJBS+Fj+/QOtL8P+//CQXwGDQUqGAsAl6RmQJobxC8QgkMBLLc0z3FrBCC6Qgz8NpAubwKCoLLjBQ/GhByyA3oUIIKsDmrBLfskVaDqAmjO8IFUCKZWx/pELYJUBCXADjHKid8IeeklDZxGIBv9+MAND3WAgMYrAbxbALGfxhjlCSVdF2uXDKkYmcfRKiVEiskUq0uskJdmiFQ0IxpSQiydiREi+hBKUh4UxIyv518PsJZM67oQj/eLaGL+ERTOOS49sPIhllPIVPy4kMRvbi0sGYkfKzGuP04uKv1Kyr6a4649aVGPBwjSY2XxGOERjDiYd0jFIZkdeRDlXSFIpMIiIBWUQmNjdctOWCKAANrik0ss0NsqDFMA5GXKOKQ3YtKNYxjJlWVkDNXUx/jzgeqpZDWo0gAL7wAAtngnMT36izFcBEIAH4BIEBoO4eUFGXtZxCA+1NMyHsASRRKEcBMDyScPEMlb5yadbTlP/AhLYbCDo2RkL+vMAuAUmgYQBDQHYUqWvRayYKmHMbYDJsYc6JlxQ20g6s9TOcDVlm0SpKFIGcBEPcEs3tmQBXFZTMySQbW0m2s8DFBAnry3gLxbaTcXQck9tzuYBB1gAecxDVBQANTBhakxSriadjUTvOteJ3jo7ysiqsotyEwqMWtACINal4DROGsHZ2tMe+UjpNAMt6H4U4LbjoSA3/yDPNfmzsxW0znU3i+aUbHnS/GygK5GrqpYspCELPU0ggaXqwB6J1REVQGVoIQ/ZEhQfEowNSpiVj3zoQwK7qgkDGLCLQCdr2faIlUHuoV3wPqi90VlWAys4HrceNViZ/zywedQxrPMSS1WKzEYj33nZM1962hHo4AO/04FyQSdW1PyDZu7RwYqkC7wZ5a5G7FMV7piUotkF73fuMRALOkA45HmIsBsy7IYc11us1OmZU6CscWk0kCMdiUg/0h8UgPSjIP2pDEH4E5EEJZAuzG98PhqfqkYVhDiIj3ba+wAImIhYLClPAMxrb7wIoqnj2RJ7DNKeiL0LvBoEgcSqRe3NcJCgHuTgffz9B/zKZ76BEAkKPvrBFCKAJtsAcCMF1HCt2CBFzgSAgfM6skAYuDKOKSWBaZpCDWSQg/hB4QyBymAG/1EqPwnBgjn4AAtEKeQ9FmZxlVJK9Mb5ACnLQP8KbnChoTAoBRmKqstS0B0LuoUUpZWZqgVgA22G5i0WjCAHnoKhnwYSqhq+oAs5GAGuPLND2f750hugjQK2NQIp/ApUXD5DLogVw0YpYCDLCfKlMW0cXGGABT+4MxGItAVDXaFbBHjWYNpk6VULWVeeOfUDOpCfEbhgRVRO1j/QpJx/hNY3vo72QbBJt4LWRGFYjKK0o11K7vzr2xLZ17Z9GMgzqrFdqjTJTh6Gbm2Pu1Zak6Ig+WWUkq3bXnA8t73vpW13vxuB4cpiGT2qr5UMbJEUSTe/6H2vUv4bIn2MYr4Wgm96O6w7FZ9XYZoiRoc/PCvfEizFRb4Um/Trtrb/XTdDyBxwj18a24BsZMKq6m2CgEUs6Ua41tQVUoiJpSm/5SVVIOryMtfrjd2Jo2A/YslB4vzmOe+XToRScrKAcjYDUFlgCHbIJHu9K1P9eE8E1rRypZLfOYeju50yok168u2CDlM+R2pJw3397imPHssJwtsyJz3J6PpW1NO9FKhY3Tdp2SrGFo9NrBLMjkTHLWIFKHaPuNHybVT3vA1PN8XX0jz3AVDxfNlwjgmN79SBAG/7DvGqib2P3jlmPEM6m9+spURu+fBX6RKgvp10N74RjkYGyZeJKiWcg7EQpqaS2EZKhfXtLFnaY/LYI8Ny0BfqvDNN9NVopsayb4FQ/2Tzc9DNtN2pBKwU8hegnACk/HHzlgnU5q/R1f+5juiCiVlgCRjG5ecA+XE3z2QapUUgB8I2rLNnaOEq3JRQnxEYNxWByhFAXREAE8Ux9Kcw0JEuUoU80jYSmFEYQZNMbhIc+fQAciEXgdMkrqMaO0NsaLEBZhEcTvEXgcEWAQhB39RJ7ud+h8NYzdcchnFY8GcdYTdM+Dd7e8EUY+Js4RE2cjE20zQC/eRSLrgzauIqhKEWt7Ib1XJT/Xd170VLsfQqF5JQgmR/kaM8kwd9pqR03FEYx0Q5P8UWcaFSbwFWBjICGnA6asMzBTVTdPIsoCEhJXQ3WqVpdtF7RAVb5v+Bg6CkExvIdzKhXul0Nao2TIuVLh9Vh2xxFynwFgJRAlTYXC7lUlPggvjhMwqQN7qyVbKyFnOFFlCxM9GUHtG0M7ckUwRheE6jJZc4HcL0MewFSd52EQiHMh4ANm0RfqthIEjwJGGFA6ADJaohEBCiJgLhM8dDHv3RN3hxF3Z1GlKSioGTIFPgIJY1EEaDUSEDOfD3OB1CjBzVUWjUEqfXf76RGyugglBSWqglVvIhVqUzTWyzH8s2NzAAGyaCGi9FjkggXyjyDzXwD8KTGka1S4L1S9TxNBgGZJEzj25ojEfRdB+RTAUAJ/lhHuuoWaajWZ8TOg0iVurBOqmzFnX/tQJSwgOmNZM1IF0Q5j23sz0EESXr4VxvdTxOUR1WIpIZdmHCuG0muUqVQxDYVB6BQwKnJTrSJTwI0k/okQJ9gxqNwiBIUJYqkpbiIwPqUyNLUpEMQhCWhRfcQjEEACkgEx0WmCXIwSGVl0Uh5RsbAAPX40+mpQNwmVyfo1xoY1xASSPWpWA2UgYAJhDis2AyQpFp2SRIQDNj049VUikaZVjEaF5/eUgQyBaTpR6NogMucgX/4CJxkJYvMj45oiPr8yPjgz5+UmPog1/qkyM/8AO6IxC9E5PH9QEO8ihPRZoYxoanuRBsYBADMFyU9ZMrUl/ZuSJQ8CJDkj4FNj8G/yZjlOlfMqYnQTIkbCkQOXAj6qNg3fMDUbJJZ5gh0fFLmRidT9EUcgIbeVgzAlGRs7NdNtI9tkllZZADbGkjunMk1ZUnCEqZ8wOe5QOcA5GgujMCSrQBH3Mbd1l0+kl6BKFVoeV7nUUCPAACPIA9CzI8B4kBd7Ez5BhTz3QgfFA+fCIFicInMtYnNfYPQqCjCRolncUWHbp3IVoRlyEcsjF8wKVM3WQYS1oWMBo6MgA/fEIkQnBlgVIqf9IFXyYQZSADYvYXJHSXSbphIbUZjKRMPhgTSDUxKGCl5mMoWHanXWBnv8JliXIkLRk9+ZmmIUI9grQcwdEyEjRlZfACfv8iBRlUZxbEZZ8WJKySkRciQoJaK0d2ZH7BQ1iHglNwAYsKKn9yBnn6pQKxp3nGh64yQraRqfBCZL04L7IRAcaWaJ9iQVCgaErwK2XAKBbjY7AqMkQ2aEjlGxjQASMgAy8ELDG0CXc2asZyBjLgB6d2HMmHpMNKKxrSGQPgMyXgAi8EKqIyLL+yBTUkKiwQWs0DQMC2rZJDZJnmbBrArP9gBIxGQ1sgpiPArlyyQ9oKr9FyHNUGJV3wBcBSrsRyBkHgA2xFG7LSLCUksFizABXzNpfFqGewCakKBRqQFsxyHLNFYRQrObfChQKhrG8mpgQGGrgCbJNGsiU7Mh5ANxolOTatWQOWhSataDEbIKsza0BzB2y+R5fOphbvGrRjdGqzRRMBAQAh+QQFBwD/ACwXAL8ArgBTAEAI/wD/BfhHUGDBgwgTKlzIsKHDhxAjSpxIkSIAghf/Xcyo0WDBABw1DgQAEqRCkglJomx40WTIijBjypyJUWDGlRhViuyosaVInQ8HFCjwgOi/BwuQbnjAdMOGggUICgUZ9aXEgTSzat1KceRCAAP+CYVwlOm/BRFgsCBB4p+GFQQjyI3wYOnQAgHwBggwYK/YvAHIFhCA9wAEAXsRJ8aaUEBDxggRc51Mk2RfsR/DFgAAoQCEpf9QwEChgfSKFW9ZqE5Bt6hQzwU2dJb9T7ZnAksXxO58YOmD0Q9Os1jBlsRpuCsWLCBAcCDegwEcR/03OC9B5gUdR6bMvSBKnM3DDv8gW5vpChT/jKdvq0EDEhwa3KYfgYPEFBIRNMhlmvZo2hVr2UfCCASO0MMINfSQYA8M/qPDPyNACOF9K0Rw1oWfHUDdP8wFQAABAxH2j2MHeDjiASR2p+JMbAR3GlsFjnAFQQUe2AOEQRAUBBQ5lAGFFFB04aMMOQSRA0JlSOEjQTL8IwMUQeSoYw4//CBDHFIy+EMNNUyxwlCOCUCAmGNqWJCZK6Y5GRsi6TXQmxDkFdVmeD3XXJ2vefaPXAgSKYUUB/nYhRRdCPFPF2cUOmgZBxVFHQHTqSnppDS9+Q95GzY1hQwzEPHFQUCecQZBufxjxD9EvNBFDRb+c0ABBGD/SumstGo1FAQLHOQGQWcQAaoOCgy1Aay2MYVdrcgmK5NvGBQUAQsEKVBXpAy9xNG1JnnHWEvflbRTt8qGWytkkGlrU3NAaWsVugbtxS1G3ob1U0chZSvuvRG9W1NN9sK7UUkqAVzSVK95sMECB7OAAgrPRgAggK0eNFRHfjmUInMavlmuQmHiO2nAzTW0WUGddVbUZwQ9kBbDJECb3lpz1eXBZnECYGecBJFV8oZuIvYcpIYZFitBdm78UXMgCiTZiARp53FXB/lkkHgBeHBUaCjApYHC8bkFHxLFpVfhXFc/UJvBZJmdVK4FmU2Qamy9F6MOBeIwhQYkoActrERj/7V0dM6JSZCZKTr99Ex8CRxeWCijMNyAU9BXEA4Q0ldfe5iXMAISBNKtIIML9iCD6EHIUHqOQfRQ5EEEEtTDB/9MUTkJqTlw4WDVjenqQQJoKPjhago1AAZmW3jciySAwNYHBTI/At0xjnC3akxhIJcGBjZJEBT/+MgoQT26wOj4PXb/zw8fwFUUc7AWgCbw8EdEs82ByUndrdQ9gMIUH/zgwgxdeEGiRgWkLixECkEYAV2GxTZZxe+BlImKzgpgPQ3UQAq+IsKoCLKJf+SCCFs41BL+oYDdQWBoEExhdyBQlLo8xWwkqME/jvSPROkgBW47FkE2wKZ93YQnQITXvP/Ao8IiUiYkG9lX1LzVrXph613egg4RjXi4jGTrO+b61rYEtq4pAmUkLqEXENdFxVn98FtHA49OdGI0g1jxfreClaM+A5sB9OWOAgkLFstIK6Ph5CZP7JdD+FIABQyrKWtjClIUqcir/WNmfZnOZSJymBENJGmD5ONj/vUTe53xjx/BSVTydLAIMKxCLwJQ1vbEFIR15jl+wYoseecqARwmAO/zSGOY9hhNIoSL3toYneg0yYIc8mqqYQHe2kKCFJxnPw8Ilmf2AhibYQZ/Q8kLzhCjGG42TZZO21iIxjmipP3Mlwqhyk3mdCmelewpC4DBPyqEH9TAhQX7wcBQ6Ff/Pw91Riolk2Ac5ZS2pOhvOCwwaFHu0sYNRecjiOmQDmlZxn5hRSiXKqjDHAeX9CwzPluji0E7kyehRBMC4yFKIt8Zl2exBW8auM8U6kMfEPAgb4tMyDgfGrIT9Y5DRxOA4eInS5xQRSx6QsoCsraCFICAIClQJu1GgDeP0u4+lGuZ2ZpSmwgsFQbxzBpC10MCHETvedFbz1scicKJcvOnu/MdUIcK1xQCLCGasabJQvOsyZU1QpP7Bw4+ICD8yOWe+GwPW6YQOeZ9AHQ1+AEfemAl0TUoQbD7R2YhxJa+hkY5D4AU3wY3kBIdBEW7Sy06HcIGojBFYRGwj1k1RyMC/3EOCbhFwj+QoKXUPel0OTBdcEsHBRmU4XsI+cGNbnQQLv0jQQaq3AhIoBuBjIk5171OdnK5WogokjgjeKzzCvQguiXouTlqUpNyUCQsma4HQeBDEGpwuiYdFwpDwi+PChJc9hLpv0HYEkHg0j4OHUaC3eVK4gpCtQLYcSjBaUuFHmDHCgvvMzODgLQKWYBnTaEGMiDSkrb3Pe79A1AoNqDrWperAidYXBeZpGCsA5WJ4eWfxPmwC6TgBiEU6sQnJpSPa0jkP+WgBhowZKSo9eIH1kmWUcGOykjwgRrMIAlE8BUBgzSqXpkKVYZC35c2pLMma5I87OyMAljwARkACv9VGzxUBwsSQiJ0oQfNct8JCcBdM6NTTxtQwAjKkEFedXALvpLCFVhgyIS4z88vDi2HKKgABXSgB4SaswfLMAIGTkc2unkKpF9Mwa2m7B8u00H/ImQBg7XzHz0ctazLggFRZ4VcoQTjrHcdtSF28iUmaWOwychrj/0wif9KF7vQBcYmthEoxC62ipCIkD8qbors0nUnU6LraEubK5y8yRZBRu6G3lWKXvGOTlcyy29XZCPw7slO/HVXckmtWsNOZ0O97e6H3FuXTHwTu38tSCViZMlzukuvrZKRkfU7IriGjhsFTvGABZKNEqOOhmRjm3fCxsEW5gm/H+6QN+raUlz/VFfKESIszxzMN4tM5CIfgLK/5NXgFus3EYPdLptc0eLAtLiDCTmAuigyKQwrW8QOsgF5kQQv/I5KihAy0YW8aagqZAzK0wX0rpdLM5q532eKV6GsxXY4FqJLWWwzsoZCxZZwL1HVGWKpWWO710WlDlj4gpDOICw08zw73qI6lwUWpemb8Yq7WB4YEJ1QLyACXNOY9recS7zJ4r4TWDgjEHZuQENmMaWF1vIPZ6YAP6xpyrAiST+fd945gWlXdRbjN516c5e/XJrSsm5xnHceLA4WjDFRqs9m7YkgpSk9apzZGrZXrZp7YTLj3QSYutN497e3pPaXph2njclERUy3/7qhYjWHc2YAHHeWw0pPOxS0rGHRFAoASAKBpw/EgUR7JWHkBDRcJXJtr6QXz2En6fR22aFdvjQy16IRz/FPNIdM6EEQSac1z/IAkHRHE5MzRCF8tzEUQOMZMXceIjgcYLVIfUY0BiEiStNuQ3Usc2dskIFHYIFU41EW/wADxhNb+XF6MPV+ioRhtqFPZkEdw6IzENAbveFy5vEwqLFY9cFMgcdC2FF3B9gcHcMxzCE4Lwhj2ZJ333EroLEAXONRsdWDbLEndAFNBuM2JfQZS/FCFmIWn4EB1qMamNMeOCA3BGI3Z4gCdTFjUfFQHdIx3UdOveMYW/g0WLRG1uGAZP/nfqXnMiUwBSVwVcVxN/qBT2pnFr5xNQwjT2UhF8MRU5OIVp2DIIBVVRkHJm8XHULVNEkTUZJxgvCDFeCCgiijNsdTHC8lWDEVU/Bxh2/TGmYRgZr4MKhGOwNCXgZiI3RDIwSRPKdhFq9CHtTETkojVIBTIiTyU3VVRD6RRAyYYaBxHm1BEHZjN/QhOZRjN1DFMHLBNqI4HIwFI/xDII+1IMrVIMulIPioA23hTHuSKw3EM69ohYMRJlmIXb7kEnqEGQw4FinjMhDyAZRTW2ZlVoXFGuxBO9iTVs+DXsqVA8x1I3HgOv74jJVTEG2BHvvRYpByIj2Vhb5TJrLmF+P/wR9ZMyArCVgZKVh7KDc6MJSUVZROAl9WUl9GIiUoaVkFcSASwlwFclUpoBwhA3fX1Ts06W4spDJrgTcFUhB+8A9LwIz89QNG8iTGxT341T2MYlxlICTfsyNREmBGcj7KRV//MF/nsyCO9SXSl1qC8zvf1iIAYh8EIkP/cCCtY16uMzo8ImLHRRCMopRweVz31QXcY1/FBSXq5SSfGWCjIyENoTuJyGszozIWgpjqaFZVxiXPM5Q6oCCmYzqlIwM1wAcE0h5IEFOcE2JtOT76hVwF4QL/ID49wl7P1RZP0T4goiGn+W0c8RpEyEhJEVsgwDzF8SyEB1tMYUiV5gEK/+BSfVJclKkkQJYkQFYQUpADb+YsfxcrWEdymbRkekcS1CQ8DGVjDjZ0BTAzUdFX8NUj3/MnQYZi/2AoCYqeMmCcsJMrZPEq9FkRAxFrG7IQEqRNsPRkREEaCNIjPCYESfIjP+JjXgYqZYCbJBAWunEAKDShXMEGgDFj1KFNUDFpSUFlNXABSTIDPTYog3IGUBBnBSEEUhAHI4BDT/EU5EGLMLoVWDFNcWKNabMCPDACxvUCL0AESjAqQVoQo+IrBOECNTACKIAB6Pd4J/SktLIzITMnG5AfbpZlL8CeBGFAo1IqSiBAUiADI3B4/xSdbKoiCHajEaADMiAEWXYQXcWgaV6WZUQgBIpJHQE1qOKypvcznghSBlvqZR0EBWKKaKdiQBt2Qm5qqfcyMU2Haj9wBp9CZJCaC6VyBkHgA2jqNq8ioaiKL61VG5/BAiOQA69aaE/ZAWgKAWmDMUaxq/dyAMrhchDQASMgBYmyCXNmZzI0MZ9xQrbBrPjiKEgxdpe2Yz6yCRqUAxrAFERxSFHxgN56qW/4AM3yAB1gIT8APilaAs2SfjuEf++aLI4CGv5xfDOlHyVUQv+qQghLQmZDPDEREAAh+QQFBwD/ACwJAL4AvABUAEAI/wD//QMgsKDBgwgTKlzIsKHDhxAjSpxIMSLBggEGJsx4UWDHhAAChNTokaPIfyIzlgz58aBJkhVjypxJs2FLgx9vYiTIMiVLgSpVDvg3dEABCEYHQHiwgCnTCA9QREDxoOqCDR4EFvgHISXKoQW3JhRbs6zZszGDjgS61mMBgkbXtt3w4B/dfxH+wfj3YAPdAgM2FCgQgHCAwxkTHxYogLFGw/8ILP43+OhglJgPClCJcrNnzo7Rih5dkOXbxEkzKh1c98HSDU2hRoDK9wGBykfBFt4Kgazdo5Qpb1XQNyqLFStIkAAx5cOIDzh4kECOwi5QhKALJxZAeDMBgQQa//8TP560eYgXT2ql3JvvgX8Lqv9T/g/HPyQ4kJDQsJ8FCRYsVCWggAVNdZwG/PE3xQgMjtBDDzU8KKFAPfwzgkAfkDAFCfMJtAIKTQm2FQEHLLDAAeEV4F0A70EgQGMuRmbQd+fViBYbD/inwYL7JaggDlPYp0OEPQQBRQ5lJFlGDv+U8Y8MSf6TgwxNOvmPFF1MCcU/PzyYQw8y9BCHDEH8YGaYU3IpUIT/AUXjPyg29p5Ac9po552YLRbAAIldhlthLuVpFAQRAEiCgzUgKcWiUvwDxZJWFiREF1K8IEUZLlBZwwcORKaiihDgKeqoaB3GW3B8KcDCCD908YJARJz/YdCWBYHxjxFbfEHEDDXk9d13oZIq7LCkAccXBho0WZCs/2xBxBZdXMECZQ9stUFvC3BF7Lbc0rSUQMHypRAGYTmkkk4e4ZTZRCP95BW63cZLGkcGgRbougu5qy9OiYX0Vm+9WRaXT0RpJBJPGGmEsLwMV6ReREHV29PEIom1gQJ0zWagxilUl1dle6Z0mp6oMkTeQVup1NjK5W1Wb8PdRnySaaf5q9K1lClF1wYCbSDVA1BhBZh2lfGUcmb2BtAVZQccdYBVrhWwQAFNQ9Dbd4Tl2VlGLndtL3finQyzWf3yWxCfoTaVLdCFpqBBBMn+o8EK/6wwN3J018WVZb2V/wjBAd+Ki9dsdvPXoA5IjKDDCEAmiAJyUTFVwJu/BgC2Z+VhJsB7kh3QWHi/jn1eRm8N5gFgSOGMwtzJTlHCFBsepzELcFenAQ6HQ6i7hBKWKYMMUy5JJZcQ/lPD4hYav+k/H/wT5AgaKrcCUzxDINl3LDL2ngDffS76tgDsXIACAxC3AVRA0/3B+kBCj0SQG2pAewQYFLCzXx1EwOE/FZbx6KOXOlJBXIAkAjYJSVOSQQ2mIxgC3OY2BwiAZL5HwbRoi2gqWRqgYIAc/9TABWV4wQvO4AZGXQkKXRBCo/5BhGV9iQQR4NltxhMqsVXwhudp2lEy9gEXvIAIsTKCrP/O0IVNCCQXz4qVDDRglA08jWq+waEUbQQBnrGmABjAgA6YtCVmuWEEETgAbDxVFzGW5mU6odcZp8hGUqnxOgqJmE3eNTOTtOUnG4FXG8d2rnyp6zo9gclB2pKwkIAFX4BUDx4RRjCS6HGPZfnIG9FoNpd0hJA7UclplDIovnkqWzyzTagGY5SCHZIgWwmJvaIISVHJkSEUcxdbfFK6gm1lK1GhylSSM50VRMCXdbkWJ1PpFUAhslwGyVpoEMIylrVyJrGUo0+mWZqUGAUwgPkHxjAWlV+iQCroqwyfTIUYxTxEgpx50ddCY0OtccZyz5RI0rT2EwCIhXT2LMhf+lL/xaoIBJxVCYxRtENQVfYJnlkbiamC07SnWY0A1rulJt1Jmc8wUzPxdAhBDuYWQ+4pm8G6YlV4dpcFoK9aICNMAbISHGVWxjoog8DUmsKUBcAABTBwwAp0SgKdgsg6g3mlva6jooxM0DHhyShIRMIne260MlW0TraaIpV/sEAqVxUQTeEzyvZoiz3XClXT7NKbqhBuP+1rEIOAhAP//OylyERnnsSzFe4gJKnh8ZxSLZmYgrWnKtP65T9SIJAE7c8+QfqHGOx2HHH1ZStXmapAYJAX5ChnP2plkA6S974LSW82a/tNtsZjudJiDyNce4+K6CQng9Qpng8bSMXsaZlq/wlENnRLntz2E7vZDIhAHPTPhqbwPucYV3dm+kGYKASFGhjEORVyLoMy9NkPPe6bJxKOXeFEHr3C6bub2ytF2HCUp/gSQftJL4JYwB/2xo1/EiLTlIKQA/qS6R/2VZJ+65vcglToB2uCUA0GLGACOweG2v2V55I6ntC9SbwzydGOoKecBI2AB8xrnnN/oAMAA89JZfidDH5QAwZNAUEIGkENfiel+gZBIPaF8ZY8LJAwhalIJZ5CXqZGI9CJh3MQPg+fMKPSwgwAAEe2n5IFs4FrBkyHuFlKjqbQAz4gKUkmvFQOmOQCKbjgIJfi0giSla0ZXm+oQXbjepKJEmW2Wf87Q/FAjjSkAQcBD0uTWtSjHNUoKQjBDbJK4aL+4YIekEABI+ocmtNMQd8oTTtaCUwEVNxlKbjhHyKkFJYa1QVYIZEISvDypiLgm7Eyeq8QpQyw6LKCGpQhCS38hxL+kcJ/TOofZyACErcgkDKMgFxihRMbTk3sfwy7LgpIwQjKAEQW/sNWRuR1F6CABA0oIJlTe22xg2y/kGLg2kgogxBkRQQjYroHLEjbUQggmKhtm9j9DFxd9ieQRjHBLrbRSm949u5+uwYDGwB4WfqokJz0++CAfFkc4Wgw2bYLJRsVJMJxKEmJJ/yM9PLKQqipL4JPnFseR4jBF63QjmgcM/v/8slFZFmSj89LkItGGsYdPtSYrwTiK994Wwh2cpdbhJLYsfhGRM6ZQE7sKzwZikTbrDWJxXZhPjdXugr+x4L36yQ8Z3hScGOZrnN9ME6lzNFhcsiSRb3qx0zYuiJu8na9JJNaMXLAAHYt12i1NQMaQFbeAoC+U5PpDmHlMk+dRkHK5SUaJ6TGraka4SClWlH5h1Sk8iGN5SWYnCTKnlDS84b4xpnNzNzBTW4wWbId4imZ5sRq2cS7gLNtKPgPVcKy0qG5k3QSMQzXuCZ6hbSz2OpRpGyvo/qxCGSbAprKL1dwHKeQMqhFVozNw9InGBXEmQ/BPqPlAnGYL570bM5m/ykdCzTKAu2xf9I9YuQ5HpXeBvSDv2jvGTP9vao+8QQL+/OdwpVQDk5Af4FNuqd7MMEZZJF6fTJ3DjR3KOMyZmcQn2FRv5dRHBcWgTRb2FRFdFFFCkAufKExIdJ1h9EVWXOAnFdkA2EYKhUq1SJTMoV+l0EZ0+c1pNUy3RNkiVd1HnVI9qNNLHgqT2FSffEXIUOCEZcZowQcSlcYoVJ3D/A0d2ciUmgi1rMegqcZEvQipOUyEnRqM1NLgAIAXfVVGygQVlEbVfF1KfMvqmZq/0AuR1NWdxcVeHNZ0LMh00EVOHOFRHZ9fjh/4CFeF3EaQ+NUgzFKT1hSTkF5vtWCO/+EFOxBI9ZSRaPkeAVgdwKCAsLVHDjgHGt1YskSAU1xG9Hne5JhUfBUEA/GbcJhSxdhPS/4AHuxiIUCQ74kG74VIGYYLKESVbghGJQRSoCVAv4xXYszAokzZul1VSzQFFcDR0ZlOd4xHixjVKJ3MhM4RbFFEnxjFdlyU3UDN27DISRQAvthVXQDIJooi3vDF7ChN461FwDiXnWmOA3yDzpAXPZxWRqgS32xHodxgzPSGH0let5VHgK5V+mBNvBhIpKnF/OhHK5jYQUxBfPBfCelNvzGf1jFfMpxOCrWA5u1WQVxIQVxjoUiH+AiiaomI9jTNZmDV+PhOdujbW2EddX/dEt700+DkxcpQG+t4zzmiIZSdnlmVTgJsiDP8Rw98AFEAl9dYjxrciEVgiGeRVg/RVNSCAPZolLq5DLd8R4LNpM4uGYIwUlgMUbVESR1FjdzQzsmhYvT4h+4Y2IN0gOIUgPKhV9FQiZhUiZViY8lFmDNkzzT8R+9FDSk6EAv4iJ5tTncQ5b91hH/shuXyGpJmSzmiF4AAjfulYw68CBdIppBQCaleZr7JRAABmDwhY8IoWIWsj4DdmFAMj2ToyJJlQAyUpPcc5BnBx+aaDe8VW3ohWLnGJpeAjwIhCRPwiRRUgZdoF8rhF858ANQ8ANBUJVBoJcGASF8QGJ8oDsn/1YXWehjeTWTv7KKv/kAHwkkciMGClIfBTEkXKJcSLJnTyI8T8I/A7ZivwNiNYZf+GUkT0Ka/DOaTEI8+IhgkRGZ2vMiPvabC1Eo88g6vOQAG6JiAyaYxaOXNcAHmwI9s4EBD5BFHXAosElfUCAD/yMlVgI8MGoQVBKV01EXEHQQEcRgEtoQRYEUliEidFg3AIU+MTRS93MVATNnHPIDTNJnV+IkjVJAOeBlLlClKxQm0CM5/MZwOxoRcaE1YkFKOYNSXLcbwgF9gDFnGgAm91kGevakW4ZABtFnISaSHRIZDdWFXWpBBYkRWRMUKKhSTAcBj2M4duam0+ko/uM/V/+SQm4gBPXmJC5QAzomNVTjoHtqHmuIQWo3GQ/ASyTglDIgBTNwBjNwJVKQA/iJJWfwKgLRaSEGRgPwhOCVqW5EGJX4Zv2UMSDgajPgBpZCRCq0LLUGK8xSIW8TbCvDh7ZaI8NWECS4UFFBAivmQ18wa7KyQswiENsqQlIgAyNgo/fUrPHiVeBiHf4hAzPwAroia1ciEEJgRLFSELriax4IUZNDrgzDBr1ohp/aajNABO1KbpOyCWeQawJhBDVmbeDCG+qpr/JySxjQARogA8DKrQYRayx0BkGABAIXKhCVahBbQQPwbRZQA5XCrS2URLkQLT5AP7xhag40sqLDBt9w4RoBV2/k9g+bkEQWwgJWBB+XGLKjRbMw0zQE4BrX9g8mQGsF0UKtqgOS0zMyBUVGKzphxRfBggGT5ijdORsNC3lUc7XfQ4nQ+oECsQQCMQUmQByBQVYPSLZjEyxDwYJ6QzcdwG9bKrd7xIIeGBMBAQAh+QQFBwD/ACwEAL4AwQBUAEAI/wD/CRxIMADBgwgTKlzIsKHDhxAjSpxIcaJBhAYBGNwo8GLHgRw1AkioUWDJkQFQikzpUWCBAAMAFJAJYKTIgSMr6tzJs6fPfy0L/luJ8uBKkAIHvCxQYMODpygirGCxAsWCgRv+FYCglCjLlECRisX4s6zZszxzqjVZcmhQjQNcDohbQCABrXNnBlgaoO/evi//xdWasq7QvkARd9zKdIFjxxDqGg4gQKCAoByDot3MWWFhAEq1upRc4MHVqw/+PdiwgDXrfwsgLDgA4cADCP82bCgwIACEv36D/4PgNEIEDRqQjNAwRQMJqhFMb51N4MABAgT+DjQ8eHHlu5YDZP8Helm0+LCd00v06HEA7qepF0iNgOFBhwgsWPxj8TyCB70ATocCCSRowEIEHaRQIAkjNFhDDz/0EASEQfzTw0ANjqDDCFPgMMUUJPwTogYD6ReBagqs9gAMK4D4wFaWXUaAAJIJcNcB/xwggI7q9dhZXbdtINsCMDiwwgojPNiDhFDkkAMUZUBZhgw9NIgccj4kl9wIVcqQgwxQXBhEHFTKYKGFDfbwQQ8P1vBPg0gggZxxCxSQXWU5zngARxBkh6OPgAbq1lCEMVXQb0DhFtZfS2lFHAk1yBBEDlKcUYYUQggE5T9RRplDGWUIJIUU/3Txz5f/7PABC3XimB0Bhgn/KuusZ/XpkmCCbdDBCGV88QURAp1RKqmaDkRELsAS4YYMLGRVwAFbgUfrtNR2xkYBHihQlwI+9HCGsMBu8c8WRBABhR8sKODecHVBEFm18Mb7U2pOpSYQBgOFSEIHGCiAL0Q5mcTeR0hxNKhCN7X0FcEMy+uwekUdZPBFBnekUcVtAaUSWEZpvJWQpoX81AJPscsUYyf1dROhmT3sMk8cS6QWSwELFVdvAhGXWlPE8eazUi+hgVhmmmlGVsVAxdqyR5U1/fLDNYW1MVwwSTbXaDlj6/PJTDG6l0aBhRZYQsLBFt0KBDbHIIEkVHVVdn2V9w+elVFMMGUYXSTt05zl/6RwR0rBR5VzC5IAogbGwbeaz8B1/S5v7tXLn3MaZLihDkjogOEIb3pIYFXw1QkjbyyFxVd2dRlUd2UF2Cie03jyfdZIV88FGmg6K/4UfigovltTD6DAX+ZLPhhhD18GAUUQZQTRBfNldNEpFAJVuOSFZ+rgx4bYC7RmlVU++EGGEUCwI2U77njdjQLxiGPsssNbNW7uFoCBUgM4VdwD0UUm08lAi0zqBPgAFnBJUjnoAZSoByVJKS8IE4JghYKAQDPVYAovihVu+rKn+HnwJ43azkZop4AIfEAGD1pOD2QwKiFIAVROAhUUpNCFLrzgBcBSQhl6YAIFaIspuLGTrf8+SMRA+QZGKWLBCWfwBYGUSyBd2ISwxvUPIuTABz7MDRCLyMVquWcADxhAihTwDxP0IFQDUUIQfGCB1EQGN0KCEUMyYjf01AwhR7ljF/dYlohJ7GAfoePBNHMSkBQlZUdJTMGKYjQ+vqxmbbFb6SRpMY0VJGGFxMlAarc1rtkuJh4xDFGQkjJH8i1iF4EkWEp3SUmSxjQRkM+RZrmA3rmRMXGpySgHhbSxEMQwsTIlxEyCHs8chZWL6o0yfcYVxT1GNaXJYG9e0pvgCGdgc/wjSOh2mEUJsyeYpBnNZoael8iEILkUDDM3kL+eRQZ/M2FD2YpJT4dsZJ5iqePc9sn/z7np85sTWQuhiCnOnHAHAIgylM+o5gGvaSdpw/GMN8sJPKnMEgRTAEHbVrM3vFmmI730Zz/rCVCIAFMm8NxObghwG5Mxpil22k1ERcMbZxUKpIlhSVz4N7kGGY5ALOhdbAjQJzvdUzGiVKlWWCcjuX2kdY0s6XbERhfRDOcxC9CPakgGGxSsgEiOyRG9BMgXRapsL0Di3wquhIQOIQcHlOMPf9BG1xXAIDYd2aAlw9K0y/iVaIkpj9OkShaGtateaOvQFEZgOA8NZCqJyyBMjtinyNhrdxpQEHMsl8Ie6GBJZ9LQP3BQIA1EhX+6aUpu2JU0rr0UMQKILVBmVJcZ/5GNsH/kmDJhopoXiRGMHYAPfvjnW/cwxTQLIFAJkICDOOFAQzo4noQoSN0v5QCCP/iHm2qQoSSJNkkf2O4/NtTd8X1gfCOIAPrC8irRsO8g8MMtRNgwADbA5gFVYQF8XLMbMLJguUua0JPA1IXlyXBKoEpwlMA0kOVJKA4XAu2bONdd8f0DvT4lgVWu49ccWUZHfPKTfNFyraY45q74HcFza1ADHTzIQixmrC0fkKLV1CeOJRuIAiVFpgr9g0oTCrCQQduDK3BpCjx4EXa+Mzce0Yh1I+5RSnqTMtLsxTyJ0s4AN4KbAZFgSWCi4aioN71/MK9JoOKUmnPw4+XEcv841/mN+ewb5fgpajhXHkqjDBUBEvzABZfqghCi9A8pzJB6/2jSp0JFLIKUwQUy0AA7I/qs89TZlJIhq2jEqJr68MoNSnjBP87gBlJRCtGZOgMRwHXDKZFApjnb26VL+lBsDUCJZWiCrxBRhCqKCgpSrOIURYUEC+SPMUOctbLpOxcPdEADZhKWEoS1iSoiq1xu8LGj2lUnZXs7a3O5GrdmuIlkjYsIXWDW/d7YLjl+e9ZOUY1DSvAPDMRRnet6t74FUrKS+SstBClJHZG574L7MZCGnGhuJZqxqBb8ZUbDpt0iuahDIjNmBdUYxVYSs4fPSpXo2TglFbYxienRkGf/7XjHazJCj6Pl4N4sZcPuljGB4YTglixdW2Ymkp6nROYu10nEhdKwiZP85sbcOLKjCYGnNJ0007RJwnXu8KDj0SL2VIkmxSkwIEaTZCTzagRQINTVEAeOONsrTrE5c6vrZC1FW1krD9I11dRr7PghQQqqcleBZKW/etHl0CZJ9IYYzalBRyUxc36ThuPRIFsL3AaiE9SqfHVku2HnTKjc84T5ciHBLNjqWuZ2lrnl5BajGUXxV9W0tk9/PGOnMgV/zXpWXZt3I+lA4vtwjvk+5A1rS+rwsjWb7uZF2uIKBAAgT79M9PaFHxruEcL7j34b44yspEcovhHe4MolqVHR/9b+U01r6h76IPHa8IG/z7/Ktv3Wd7lXMrlJXHXlnUv3AEoD0FCvJeYusTIYQ0cxmfYsKzJLRxJLDwArhiE3DrhwA4N+wjRKdERlwOQBgrEXdEEbkAMaM/ESgHFPLsEo3QGBgGEnpuFVhDMFH3A4KxBL0NJPsQM/Axdb52Ejt1JnqURHK7FM53QRslEam6ZOrnUyaLUUKdVNhQF5YNRnhLM2zVEVJ6IVsFI3d9F9OBF65FE35EEQiKds06RMrXURdUIyD4AjH+N1tRFM7/EPGGgoOTVCBnE1PIUDHvJcJVAgQfUUTAEt0NI1IPgWEkMZccM0VkUxX0hY1DQTWvGDdv8BdiOzVVbxGKaRM5DYUr8RGIxCTZO1OyxAOcx1JUBlHCxyJCxCJCjwD7CicCMxGZexEQ5oEDjiUZCne6aUMVHHiWllFWv1iXPVNicSOk2nfB9IE5Ghgd6XO1NBODhQAiPgjFPwDxpAWiRghz/1D2slVCdjVb8Eed74F3fhNK6iiuT4XlJ1RzVjWUFFAiDAIc9FIJxDIsIzdjAgWcsHgi/xOHcnFY31XDhwOUhQJQShA0vwJkhAAiWQAgdCMpW1jQR1MZSGVoPlYTOyin/SPoRlEx2nFE23IiTAA/5IAsdxJZm1Av8QFVyhEb9RTQeQFdhoHMbxidPojDqwJjXwAzj/GQQ4aSHYcyEHiRwogDjRoTir9Q8KIHseoD9c0Six4yo4CF+yBlABoxabpzW9dRU+1C/GkYCJE25VIxOywQJuNQIpgBwhoCEawiYQskISIilmkl1owiWW8yYX9lxv8gEeogEvOBVpc14k8ADiAYvm0zrSUhl/EpUZ6RZTNoe8VS/21ltRERUwEAFbkRerQXaVwyFpySXX8wPUJSkLJkMyICnXE2GZQ2ENomPhdWEX1l3eNQIYAFWxFURPZj5NZpg2Un2zxoSW5Uwnkjg6wxUpkgIT9lkBBkFMIiVQsEDSAwXSk2ZNIgNxEGSg9QMb4gd0KRAW5ibdZThKRhl7gjqx/+VkBKEjWmh1uiMkrREywvMm1wMFYBIlzgkl1FWaxyMDVxApDfZAkyIh16Nda7ImnDNh3eUcKQCDr/OU8WcZtFV6ClEapSEbRsIiIxBeLeZiCIQqP8BdIskvHcAvMBk8BdIDfPAkymMmAyFdESIQxTMhAjECcVICIGIVFWkjCWCY/MRhF+mgZAOWRGWG/HMcpYUcCxJGHOkU9pN55LcXCpAcSwIFPwCfiRYlE0SaZ4I8ngkmbsImH7ACsKaKgag6tcGjJlVWuOJ9QONavnGE+OgXJzN5X1YDELRA82lo8OljYJKnn+IkP6ZdKbAzq2hUT0amFDGASeON9aSJ5eQUyf/xA58yKmJGQ5yiaD9WBpSSZqYSKlTiUzQqqCNFqGaRZ9yYj6LqErIBKV7SBd/yLabSYJZ6XQLBaF0wA4X2QoVWBhPwIrbSLroJqqF6nnumZ6oxAjLwaKQ5KZf6Qp9yKmxWaC9wBqImEAmkAR0ANBsALU9GZ74KKEGENRq0AXJlIiZQA1LwrG7gQqZWaIIGLv+ALErAKTJwASRwFe1GVNtaLfRDU+8EGmI0BTKgar4maq1aKtU2ELnwD0ZQLi9QBhowALASg3d2r/ByLZk4HFfjAzpQBi/gK8AyaolGPTU0agcrLr0mA9Vqr89SANoqsQ5zRAJxHHwwA6fwBVmACEbB4GtnYGhRlCwJCwVM4ENx8TgxyLLxczNzMQI58ES+FkVTtAXiIgU9oAHqsm0pS7RElBVTiwQyMLC+Ni7kcgZRO7Ve97BW60G8IZxiZEaVYiqRIC7kIgVXwAKDoSiVhZhlKy8v4oaQcz8dEASGNhDkYkUGMhwyxRg7ercvA6HukRr40gFn9LGmcgUdQEaqoXwY+C6Iyzd09gCPGaRa5WLc5XfHhy3/sLKZGz+pkSK99Q8nkh+sqyKnC1D14S/2ohMBAQAh+QQFBwD/ACwJAL8AvABTAEAI/wAD/PsHgOC/AAUJIhx4kKHDhxAjSpxIsaLFixgzatzIcWDChB4PggzJ8KPBiQILFICw4cGGlg9cPlhZYAMElQUCDGAYAGFPAD9LLhTYsajRo0iLFiR68qHPiE//DRAIoADBAh6w3lw5oEDXgjl7Cux5kCzRhDsdjuQ5kKlDogGsJp1Lt+5EoCOpun07UGVXDwr+WQUAoarhnEAbNhwrsmnBqgMgxIQRYUXlFBFYRIj5YMHNrWH7shW8V8A/06YDmLbLujXbqv8g/JvJufaCzrMZcoZAAHQACHFzhkV8szYLFhpIkNCAhMQIElOeT2GoIYLuzZ4h3Nygcm9bxQ0JnP+WXVaA6gLmD5o3fcC1e4sId0ZWmRUrzc9+ZRdfyV3l7eVTlKDBCEiMYGAP/4xwxQg9NNhgED8EIcM/CPbAR4M1IGigDgz18MEIGkyBxHTT8TDCdM+xgMIDEcDAwgoxbfVPe4KVF9uMp9H43o6uxbXAbf+g8A9yzn1g4ocfRKfcizEq8MBsEUSAwos41FADhFDIEMeE/wThZYRXGphgEAP14IcOBf7zgXIroLCAYOKNRYBqRB0ggFw85qlnSTVaJddvcQWaE3A5TQUBC1N8YOUPMkDhaBllQNHFJgNJ+g8UkV6aKRRSdCHFGf+ckYMMPbDgZAHtATfnnqy2yhpVVnX/NWQNM7iRxBeIEBHqP1JAQemkZ+hKBBhEnCEDEhoooNJAN4nn6rPQ7mjVAwp0sISkm+i6hUNlDKQAeb2h2lu05JY7l2wPkDcQBkFqMJB17GK00GMkmWQQvRDhFRVD8gkGQFoJyZWYuQS/RxVf+YL30GPeMeWVX8u61N4BGxzwJEsY41ToWD5xrPDCfK5V8MgYiSzSWPre+91ieMVq1kHCpSTWVGIdpbHFkqUbY7oH4CkRY3SmRzK0ACQ0lL6G6RebVRjfOIB86r4V6GIcD1UAZP9gEFOUUaagQQr/aDCllNilu6xsP+E5cFkQpXaaauqdt9rQrtFUGwwrrKCiipRZ/7bCAir+nW7FOB0kYwGcZabB4gUigYQOZ+rgIIUGjsCQcsllxvVms932Y2cWL/2Zdk96ltNBcbY3J2oB2Cme6nS35pdgfuJ3U2xPssjCckg4mCGZXCJIoYMXBlGDDBL+g3wOEjrY4D8//CO5mNRTbrmBU5BwXGfpMkQooHi2zpN4UcdO9Ekxx6UwY3JNJVVfnUXgXIY9NJrpQF426mX9W2bpf6RlkEHwPvABIf1DPHeakXfMx0COsAF83wlAbzYwAAxY50BSeMELiPCCM0jhUkGAApksFapincEIL1BCF1wgGJsIplkNjKGrILATBWBAAz341D9eMBAi+DAXWyCCEf/+0QWHyGZiBXCWDJeoJ/2wZCAu+UcJgtCDG0hBVznwAQYw8BLBzOQmbOCTYxRyr4OFLCMmY6IaN3IWgyxEIR+Zl1r0gheECeZpkelKV2aHGKa8sSFLSeMazSXHMarsJCZZm1M0tgCY3CYmb7pNTWaCE7N0DGl4yeRQGkOSQe7IjE4ZDUgE6ROkoex9cdnPBjwwuK3QcGM6qdrKQFkvjizQk3bJCxmPZseO+WQq7tvYw4TTx7KQxWam8ZMyaVcjeeGyIwPbF0qeQi+gXC0o6qNJWaaSSTFaJGAqSdcjLbMAKT3ATbczGdDMAxfF3PKZFBHZwRByzbRIRUZZ8YB8YlX/kKn8yZ2LORnInoY4rbGIa9VRUWUWsCLOEIAAp/MjT/C0mopKUAAVXRk8K9KyvnymNxiLydKWJZoaHaAnqzILzQBpFVY+AAPHeZEGWACiEJEgbNob2wNWMBuR4qlQTdHoQFJDVIZYZSxF9Rk8F9KV4kgGJpD8xyMf+QAYcM9sDyPM1FISGageJ0QDwkGBcFA5HVwPB8kZ0nGmdFWX3ERHBzzmAXljld5AdFUDOWlJ4SYAAvR1brjsp04g8C2b6IxptUlsK23Sn97cJjN6U9xySrAhBjnveF0aHgF7YKAP1QAHHxrBh0AwAhBMgQcg4IFqlUOCNkFyMjG6EY6U6LaJ/7FHAHbaKE/kA5Z/0XAge5yJTVTCkttsAAURSM4IzNogBlEos8iDwpUYMiFS5eBSyGvQhHRgVuZeb3GLm0KiRPuBgTynOlFiQUw2MKPTvcWvtp3RX3WLlAfWBAIMbdMKBlQDyemgBv/gA5mo2NwpJGd3yDFQDX6wYD5MCAo9gHAOopeDHvxAQ5XLcIIs15zk/O1HBwhXTwalPoHcFj0hpq9dPMAsrgzAA1AtZ2K785dY1a4lA+rBlZiXA//lj4oEBrCFEXRh/FGIgGr6GwJP49eh8iaMKt4RzQSVEu+VRThsSwlLYgIdyckgBznIFAAxxavrjsp/YYbCpbqg5n+UYf9UNfjACrjzkPJFeWhQjhmhYvMSl7CgA70ToKTK8KkzeOpSjgoCAAdSxCKGSgpScIEMRhCBlqxMqXdeY5O9ohN9bnEEZXCDsELlKUepGQpEyFa2BrIt5WlgJsxqb6Zn/WI8PiBRMpjBF3y4K2CtOhf/wCISrMOQ1yVx1sh+iFXYpQAfBEEIDtlCEBkihSuwgF1H1Camk61iF6IrMIHpQbdA5RAp+GEzK2HIAXjDbW7vRDuW7mlmyPqDC+hAAx1wklHt3O5+e+9JSXmjvQQpVH8ju40g86bRCK6WhBmEtwYnmclGQnFOynMpZdytTnDC26KFBOP4irieBH5IfI2SjN//USRYRoqTjPGHJsuSJcpKKU2RHwXhiWEYveT4R+9gvCu/cUkj12tctypRIWJRZDuFWkebo1EoHk/kwbo5GjjqRTifYSxnLP0k9t5XY2TR1zHbybGQM9zpimG4Sdzic4n0kzTq+noriVtJw4jlZUs/ZFAhkneRL5Dg7wwkNfvCVdp1VQEb+BZNfnNNoODdncns5NnRjpJQ5iXn8/pjw1t2mK88rD43KfuIGcNRvU8EPX1JpnnQ886qRxkkcMF808m4tqcM/ppX43hKYh4Xx5P+jNWkCKo0RvzCVSRov78zNf9I8DrSHCjA3LhUiB/Qvn9cZWlcSSM9xz3ue+b468k7/9xO0+5ACjQkeuHmYK4mmp14JTKBiqVRSTPLCHrET/OB5IratLeGgqY77qUeAugQqEF+BNh6uFRztEdzbbF77+ct8kFPhAEzRgNQMvMvRZN7gpEVVYUCejMlY8MCC2BVu7F4fHFUDFGAofQxKrY2IFdKfkIWNSEVgfEPqzR/9gRcVEM1SRcSTcUfupMZmqEZYqMZMEBVX/RTE9UQGWWA3+EsUOiE9OUd6hcXbmVYBbAAM+gQPtMdWTYW7jMv/eQBOfMAX4UcizMQ2uM3m3ExI6U+eid+PGEeCIQeGGViEkQnLRhLYLFlLeFIucNnUVMTLTcWxCR49yEZlLE7iwMdy//xDzigHP9AAimAAiSQGT1FgviBgqOxFxJEfkGDUTWyHks2hUCnH0UHSSyQG+ckVdwzGywRLoMSc43xg1uzOwYWIAEyAiVQAmRFVgNxYIHTVreBX2FBJ0RBigcEgIqhI01Ihx6TgLBhHzFhUJUhJTCwIkMYJQsgOC4BcyRGPjV0UFECXkhAVgUCORxiXmY1ApF4YMilWC4BUTjzJhBFOysBUgSwbjnRM2OhVwIxMQjIRGnxFxvARVsDJFBihmTzOetlO+IzSRsQJZboNYxDWQxiWVR0YT3AIRl5PZMYiTflgf+QNyQAAivAJiTgAOiUWJ7DbhHFhERBUQT4TJ1HWAX/gAE5qYMDsF7pcioxwlg0VBxToj3LsTgYOQJ+wCB+wFkXgiH1UyEakiDlpSYf4CGdZSAmEh0gQAI8wCZDWDqec1TIWBblg1vzRV9FMwDQFx+x1FR6dEdewRL38R8hkmH04zwP0gMQojw9cF2kIgMcyZEbJjxqUlOL8wcnElqWI14JxSJURZbAMRYQIDRomSM4omISeFQrwXjaYVeCoYXfKFWMeCA6RmBlAmRdgiBAxpfKIyFBMCo9EAdRORDtmGEgqSaK2Vk4YGCaAZkLICcAZR52gpbtgVs290BogBBsgDiI80RvIlOmiSAX0iU/8JQGUiCVo2MClDxlMmFUNCHR/wNgBkImanKejPkcOdUZIMZ61dcTdqIaldkzgEV5baF9IwgDJelZA6EoVqJjVoI9L6JenDGJpnUgyBMh1PVgZZIgDspZnEUgvMgcreWNtQM347ce84lX9sl3T9Izg/MPUqIiKtlaCzU4+qQS3NFVXDYCGcIoo1IpyDM8QsYHDfpc/wBgcXZak/hhfuI2ONI6fdWhx2cQMfcwe6Qxocd+8yEQT7Nlt8YgxRNmyTOjURk9FWKeMSpppNKfcvYmnHgnCUSkGiGDMBNBMUkQ/xIyVnFcK0BW9eM/XQBAkNIlZxab/wBm3aJmUvBm1ZWjJzITD5VbeUimNuMRPeFPJSURNP+EAVNgJcgTm2EWKYe2p2zWY7GpaG3GEG0mBdelA3MmG8eGHvxmqEgRKN9zOuSxEzC2U9EBqWXgaJDWKbziECEkp0QEbdQ2YToQAYinEqYxLqaaJ+CDqqLzh7tjOQKUA5/SQS9QapHSY272D5twBtb6D7lgrX1aAyTAXhBlnMPqKnf3G7IlHxjQARogA1cULMXyAr0SQmTCZrpSQj2kPEjAXu11dOEaLc1JFYlRQQMiA6Ayr5ViagNxBqgGKkPEQTKQLPh1QLK2rwRzNYVBUA8wArnmBgwBbOQGBQibasFmQj2ABBigLMMXsRI7MobyfgNgQzpQBjz0ENUKEVLQAxqesEfh0jOlmrITCxj/UC1IwCXsCmz/sC1b4K5IsIrtxW7CyrPmk0cKALTqSilnsGrUtgTvk4+88UVO+7RPogCAcUM5hGqU0moDET09aRUUA6Jw1bUjQ5ezIRcW4C7X5WhEUAZIkDUzoZPCBWtuSzfP6UJ4sgL95RA9YAJO4kIPMAD4+rfmozRyARMMYTmawUUD0biOu0TYBnAHCXAcERAAIfkEBQcA/wAsDgC+ALcAVABACP8AAfwbSLCgwYMIEypcyLChw4cQI0qcyDDAQYsEMWI8KPBfgX8D/lksAKBAyAEQCH4EaTJAgAEBAMQsGLOmTIo4c+rc6bCjRZ8LOw60KZKgTKEiBWLsWIBkU5kzaxYUirSoxowqm2qF0JTrypA8w4odi9CiVJpH/8kcUJItzKEFYn40GyAuSY1A1R50+qDAg78RHkSAEYHFgxUR/v1d7FXgTZEfPwqwOHmoAIMbL5PdzJmlx4EQ6h4osAFC6dJd/3ld/dblzQEfIWD4S5hF4cIsNJCYomEKDt+6/yFGESEwY48eCnj97DGySo8CVhaYTCDAZQKfKYu8LECz5s7g967/NRnSA8jzBZKjNKkcNte/GFjsHkFixIgPI3TY19Gjx7/+QfwTYA81/PPDf/8UqMM/+TGI3z842BchDrqRsIKFu62goYYorPDXAn4VcAB23EHAHXf/XHbAPwcI0OI/2IUnY1gD/IVChxGQoCMJLGi4W48rsIDCA1wNsAFsA3VIQoI9HDgQFAcG8YOU/Q30QYEDjcDgP/qVoME/thUnnwMLbEDAdNilmdJAK5q44oxwdvbRUY+ZBVcAoaWk3AIX3seHDEHkAIUUhBL6jxT/QNFFDmVA0UMQ/gE4ZaNllHFopQnS98ACBEFQ3UpxhirqTnaVBIFg99VQxgwvEDGQGy90/9GFFLN2IcQ/Z5yBqxBSlPEDCX09QEBKJo5q7LFykgbfP1+WoSsRW2zh6kBEyKCBYQOJyNVoyHbrrU4eEInBBrMpkNg/U3zwTwf/KIBBcw0BJe9URYEkEFsigQXSTAM5ZpRaG30rcKhK9Uvvvz+p5a9eQiEZUlOwRQwBTLC1VdNZriWsF0I3YdQUvKAOLHJZ/wI81FEbnZWWwf3e1W/Gdrqkb8Id+RuzVdiJuAFpG2za818XFfVdigdNVtnI3sp170tMu1WQnmBxNbG9JJkcMFIR+7XYbB3EV9gKuqXwz22KbUokasqJpHTA1qVI2dvfYRcAidMNFCPSPMU1EEqqLf8AAYiLbXAAkQs8MPhoUpt0Xo2zPcBCblOUYB8S9lW+H4M9VF4QfTp+GQFiQaIg5IYLLAADp4UfAMHqBBFwgOAfESC7ADEe0PZA3XVHQAID8Y43TlAl5VRJTMc18eoP/NPhFOmOUIMONdQQYIH4TU45ElOMQCAfAlbZQw4yfI+gfpX7V9AU6GqgPgm69VjcX1qdOeKL3VmHYkEI/O5tScRDYDP/IgmN2uxSF4o9ID4asI/0wAcFGUABCuALQoAEZCBI9QBKgfKPk2QgoB948B88QEEBZDfC6ZhwaPpL4UPYUBeDQCwk7qoP5nJAq0PxqgyMaiAULNWFMnThHz8E4g3/fzCCCJCGRWhSoRJlpBzlKOAB7kpgD7rwAoIo4R9EUIIRtvAPIwAxB1OIgAJSMprR9GWJaISTeZLXs7EpoANI6A8UpnWGMvSABf/YQOs+8qZ60eSPfoQKyvyYxkJ2pmAbY5nB8LIxgVQtMg8LiUD855KYdGwoJSOkIZU4r6IgBZELA8tLPJK1vhhJau5pCcM09hOz3EQpeTFIVTbZmYBhEiuenEpUHqPITH4ESeRxykwEmRSa9fKPKaPlqKqCyJfxspgA+ORZhgKTtVyMmPy6ZdUamcibNUcrOwORnubSSrURbSEoVGZCUDbNZGbSmfyyWSXnGZW4gMVfQLlZXXT2/4CeBWZID4DBkDp1Jk/ZUiEHvUzbDqrOhRBlby2kWL4Ylq2HARAmdVHKRmb5sAJgQGuAwcBgvpaY4hCGMSCq5DP/WLfqHA1354QRRu7W0INkrWLs8Ujimqga5mDyJa3xiFwGEDH4CAYDSO0Abti3pMiNrTjGIdJqtEKxurSQoUWDznTmJtPKGO12DbWn8dyjmo/05W8QUJ04u6KVjJJSNaX5S48exxve7CZCltMShdgHNjAVZjFEOitBOLUp1Q3rTB+zC5qqAyOtUsc7uOtOi9K5RP5JZ3XKIRJKTrM6VKaHPenpmUgLo74RUA4HlCOf9rQXqYGYL0uwJciS1McsHf+tYCArcIBwbrsCGCRvUywKrojq1jbJ4E47NK3pyWyikaoOTzWAgUGPRoDX/HygSTWoEpa0hLn/cK8G4WsSlYLAH/sQhLs4YN9A5JMbHpFADDrqUT9N05QzCSAlBDDaic6Z3wPwzkW+Uy5CN8YeT9lIR9lr0AiW4DzVUog3UM3NQBZUIA6Gl0oGIpB/zJs52I5gCuy7lgbelzwRAdd1K8kZ7bZjO5e+SMA5YUNsPgObYJ3qxmizKkwUNzFy6SaOkApUooIQh+7loAeAQjKCplSQGjgpc/dRl0dkx1XNzO0ydYPxWF4CQJt1KiNxiahJnlg58AbBgQNZlBR2mCjw/SP/fFLi4A8aCD43Q4Eg5LVQHmMXu2JpeX8EFCBoWkgswchnQTIoA6IMgqhGUVBAgqKUou8MRBf8wwUy+IAR2aSdP6NRK21V3BNZMIIfyEAKL9DVGWa1aEstetUESbUUZMAHJJzxsAHglqcbChMPOIxZqmoCFr/gqljBWldgKMisNbCB0hAEcbuONgTYEJJ3MasMScDiP3LhKmlh0VVF3KyuRxjtaM/3Zx6KQBx9eBAiuMENSzKNntZU7l0/IFx/eeK4RCplU/cACew6jUfOWO+CF2Tf7TqgTjqpMYM7nGP1+iS9NpqUvcFycQ9X5kHZdkujpKyqFFOPr1uiL4+vLOPf/2J4IhNZks/MhWLkmVhymGOStMxyuRdHeXhAebBFFqSaLnOO4rLVlOTsDCW9ZprCKJ5NXlJc5zjZOCAZmk2mAUCSejHPe1jTnqY9xjFVd3qdolkVrEK9ZKxcOSAdyj87fRNi7KkqVHYZFYpWBCsjOTvCekmVjl8NmuuECyxdY0+bYBSfTw/a1F2oFZefnerddCbgAXZygw2SuRq95jDVvrCrsLSJZkQsV9R+y/tlfCm7vIjNWf6vfAK+6RxhiHRe9ze//IxT59GoH02/dk8vRS/DDD4zKU/5qtWMohoV5jsVEhmu9GwDZbLRb7PSRL3FNCGU/fMriW9yu6vl5VaNqP/VgR8St/f++A8zzWIK97ni3NZsROKW3hJfEK8utP71TtlR7jI8pwB9lE3zE/1HPBXXdw0TWu8hGIYGJisgOqLDGKCWMTdHEAplEF9VL/mVZQ2FeSZzdVzWEuYHQx+DU54XTawnFAgoWhHANY8zV8wyNh8CPzsDdwdlXKX3NrfEVdVBIsllSMF3EhYjVGABKok1cKREF4cHfOiRHFzROIEhUggEORqQAmEiJIvxOulRMaHhEmAmVAwRHXPjEjuYLUURMmH1MJBBdJ8xLDCyJs6REeXUQnDlAafyFx1QhY+zPl/CPiBmIZ9jNquDGsvhdgSEZekUHWAIhoyVJtaRYtf/t0lvcR5uSF+IAyIEMIPD0lZc6Bjp8Q/vYmifI2K5oT5fQiHUNQIlgAP/wCNBQmJ/sRwf8w9+wynS4VMmlCJz8SnXYTRE4yK+uCLZl0KWpVPYsTM6BTv9FCI74xVt9Rp5NBuhKB+kqAFIkEDXsyX/gARIkI17SFu2AVAPgAKKMRCmUzorUDqGg1lbcSYwQm5glSK7mF9p8ohpVBKxCFd5BFiboozz1UQTEwC+9hf+lCMJdIrXMwJXgJD/kJCR0gMLojkQkl7qhUdjIx/C0SEbAgMwQI6yqBiq4xFlFGahkV/n1CIrMlmts0kZBXcAAIv+ky8vYTxURR5yBTY6klf5/2EfPXAF/UEgA8E9AxI9UEY+sLUbCIZgDkACdDAFDpBbJNCUDZg8fqMcI8IVLgGMKYkdKQFg/8AAAoAAAhBghSQXxQNLA2hVTbEphIECunEfOPAB/KFhDvkfIzA9GzZB0uMkEzaXEJmTq4g+wvEl8rECU8BeHSKQnpJWTaEdLtJTt3gZ+eM7+dNQxOOBHRN8arEa5kiYHxAh0KNhB8JB5kM+ceQ8kvJkVHIgOkA+z6MlWsIbBaE+dgUkf4U2WjEZjZhr93VfKdIivIMdk7lrGvVKVYMkinEhBXklPpld12U508g80JMg3FNBB9KTB2E5BgFi0xhhgQFqJcSOdiNTaf/SmL8YjPUWG1rDKReSLtnTG/aRPcxzLYYRAT+TI7sxEBUWKVJSnf9RIFD2aFI2ELwhn1AFGHwCjCYSFzu4YrbTWN2hdwTBBtBVaIDRgAK1AKJTOoljj+7RRjmiPQYiA6I5JVOiZP3xA9kllwmCIAL6YfBpISACIw9KO43pUpoEoTImQLAhF12RSm31fVf3SICRPf0BXlDSQAFyZgPhQeFjYSH6QZDyHygaPQhhZSKSa/QIoQVReOcRk6PUGvYEk5/hARsgH6z1KDkQBDtEKQTBQa6FZObzPQ4EKBHUQQXiIcY4Ij2opQ3hMS1ni84BFmxhF8c5BZICQZM2K4cyEDj/NKdQcmRnFgdu6qiJIpphlIyuI6N9xKcTYSdMgScqgSddAQGfUx/XJaKKZiu1QigPdGeQIqkXJEH/YCmNoqhCYCmZsmeNpWucyhkrwVVSwyYD4C7sggNIRmmKdii9wiiPFgS0miiLqqqz+g/q0lbDwlW9Gh4Syhyiuk8JR1qQpmpuoKqN+maKYii48iqXFgSaVlZZZp7ZCh7eakAPQAJ/kgOp9g8vUEVBtGiIsmq5giuzEj5hNGOXIWjx2i0tlxyEwahNIGxE8AVY1AUAS7G6YkVnIAU9oAEKoEcsIhr3mLDdggYhAQEKUABRNKuwUhBEcAau4ipGQAS5oK9lMAIftrUSa5KpIos3KGse6zICMvCy2sZFW+BFuIIoEWAkypGJvLqzeHMqT9QBI5ADXXBFMjsQ3gZEzBIsfbMnTvs7sUEkFekDPWApF8uyXSADUwA/BYA6bfu1SNNPAlk2gqEBVyAoV7sFWeBuMsACeiQ4inGJcKs/HiW20BgB/hEoOxQEJqAAT3QSA1Fig4s3/dQunkgunoguXPIBX9KxZGoaHiBjk6tC/YRwepQ8QVI24zi6yoRwOhEQACH5BAUHAP8ALCQAwAChAFIAQAj/AAMAEBjgn8GDCBMqXMiwocOHECNKnEixYsOCAAoMKLhx40AAHwmG/FfQYMl/Aw1+RHjSpMWXMGPKnElRIEmULQ8GKMmzQIACBiEc2FCgwAMCD/492PBg6YMFGxbmzEmzqlWHBQZ2DNAxK8mtGQcADekTwD+PXs0OgCD2AQYFGJh2aNohQgQWGiL8Y/EvwgMWbjd4KDBYbFavBX8eBGpQQEkBN1lGLgCZANWrmMX+LJox41mgRUObxch1wD8PTVmsYEFCwxQNGkbEHjECCW3btGHr1k1CdYQVwFmggPFvgVIUTfsaf5p0MYR/BwgYtPyPMuN/AigTgPxPuveD3DHH/yToESPOjv+eQ2gKnMSUKSN0xNfxb0QNHfdr6B8xBclsJPTZ908PPdTwTw09jFAfbf/goOA/SBgEHwkkGMTCXRi45VdTBUBQlGMBgBjAASPeRGJCB/yTgAAHICBAeOLFyFAAEGTEVWJZBeDBTwMVRZJPoD1wl2u0BdGDDFD8E0QOQQQhg5I/yHBFDwcaZKBBBAZhIIIJBjEggv9MsUJj200nXXSVyahmjDsBeV11KUIQVXOw2RZlGTn8I8U/SUKRQ5J/PgnFk/+UoeehUiRqKB9TGJciAQcIIN2alFZqkVoaGaQACyPIUAYRbiBiEBGkKkGEEv+gmguqZ2gqp4cQnP9p6ay0wmRUcgs8AMNfPvQARatEGLTFFkQgUsYIGR60wQHN1erssxEx1VSGydJ04wCdEVaSaR6hRNJKNkEr7rgv/SSSSCYNdBlOkVEFWnXVgeajjwgx9ia5+E50rrcKpaQTSYmlZG8BUC2VawQLXPjbXv+ssOECoe0kcWMUY/dQeI7BmC9FGWnElUZjnbWYQYyZ5YFZIWU7mJy6NhVBBzCz0AELNLPgw16taaAazXY19UBoA2D7Y0EeHjCvdxoz5FMAlmHMdHeSJr0xyfFudNjHWHu7Fl1DkoAEDrYBmKB8IyT4zxUHeXmQgfEx+HUJGrS2Gs1zAzfcAsPBkOuuD0D/IFSsPgFsWYjdFR4piZNaPF0CU1/6XFPLqRb3a72RsILlDk+7gV5jUngglQcaSOUPBP4AJuiff/ABQq29HAFTSt3FN18QSxf1dpC+GKlliDeO2Y3ZHkb1c5+tdZd7ZffAx6BQlFGGFM5Dj2cOTPaQA4EDYj+g2gYt6eSXKzRHvAAQpOn7+QqxQRLxij2gQAQfIChDDi+0+sI/L3Rh0J57drEnQv67ngai0p0CHCBW6EtgVQYAlwFgAAMmuEAZ3CCsfxBrCwc5QxmCAJi+EQCBCgyhTF7FFAz4pQMNig+CRuADCygFKM/BwD/UN6OzcKU6IEFPZOAlwh6KByhiAYBp/4R4I+CJJEcPQRe6fCjCnIDkiQLBFrpSshN/tQRcLpGKQsyFELMw8XxaEQgSCYKT0Zhxh+6KV3o+SBQfPWcDcuoQD81yL6l9kVYrKaO3AncT0txEXnFkygYW4Be7+CVzVEvMTvrYknWB544PMQ28DuNFoCjGIKa5Vh9LVh1uVecnbOlbATKkl7tEAAWe00tS/AJHkOVIYlxMCE/AEyLKFCQ8ibHjxjbyyc7Aa5GYoloQE/OtJR5mZSXEwFyUuZe65OVCfNnLagqpgKV0qCi8lNho2oQdyhRuln0ET+IW45jzgcxG2IRhaOjlsa3YBIbrSc1d5rYb3bwmTBWKG816s/+hpvgNVkVh1gMyh7AFPMdoJ+GJYhzjk+yIszIJkA4DCkcAxo0LZZy5Zo2A5qaOccUDA3CLW/DSminArT9tAx3o6DOgCPUgQgiJmwb+MdNT/gMFY8IpTv8Bg+E0hThJIU51nmOuE2XslikySIqAklTsCIBx46xVSagYxoBdC44+g2ZJaRMgKvVAB15tmw4ApKAHFYhKogubfzSAhNbkTKa9Wc1NWZAwvjXlALVj2oh2wjuKUk2pMGIcAhLorz2KZTAuY80HaKOgxTI2N6/5TQQqxFUDaekgXv1BEAL0ICx11iAj4CfMIhCXNnoIhvAigHVuMs5J2e4AEYXkQjokLZ//rQcCKwOoYYSIyQ28jzW0oVKTrieDIxGouGitT4K4hBAFuac+8BmBg3iwgtppJ2rRkW1FzLWjjWDEJ7ysVyebQgLG1sBISEJSGZrXvBxs8EkE8mqBlGSQH/yjuEGwr/Wq9A8QNEu1BODd07RbLggoJqMo8Yq8GLOUyU6hQE960nrX697/rbe4hKpv9wZF30INinvhMw50WORIAv+wRJ8MnIekFQH7ICkHUjhDqxC1J+ftT09C6MIZ9JcoGeggL3AEMIsUZ+KNSUcjzZmCDmTghvt9ASHB0rGOg5WqG7tAIR/McpFFeE0PwEUBYarBBJPwjy8QwQj/IMIFidAqKCBB/4b/CHKs4LjlL7IBdrHjVA/+Jyw1Y5AIZZDBB1hwzQ8asM5MFGSuDiKkmT5JykoKggbeogAIQOxnzUK0DzG9gbj45SA84Ke0jBIRj6Tk1OHStKq7mBVffitHQuOXTfa1aiZ2ZtY2wtZoeJlHyfSrxLV2VrdE0q0w+tKMiywjaQq7kpQFu1JeRElIylNFPY6k2WTM4hK7+Gx8aRN4euS2SqayQ/H+lYefhBcNu/27cXvxXOqKdrr+pRB7xcto0TktvXRS2Iqxe4Hz7rVJ+Pgve4fG0FB5HFKWQpS1yBso3Il4iAiny38nRN78luW9CvKudf4MYkzJVVJGbpCk8IgqGv+DjMotLsnr3PBf6yrJm5o6yQLAcZA+K6QhexbnVy0NlhYjnOKSNvFyI/rkCj6JvDkOr9EkuOlsKQqmXfYXyWoAlRHgW1CKYq5k+xohGaP31+9IkKyE90Yk65gkyxPthJ5FZQWodKeFJCQM0CwF0cx6y5biIbEMEeYJWTl1rgOZia+8h+C9iWeYbkmESDIx2CL4yEDmAUG6JUPLvAsLUqCzhu2ln3zn6E6EBiSKFR7stFw5jJhWcamG1yQ70grXD+Khg+z6u8vuEWLjOa0HzKUuMJsZbAxCAkP6jCmEuSZIsBYal3BR9RZT+S29aR3H2E5F+ULDjXYkMlBOJz2gub3/Nj3pIZ/9BZo105nObDZ8mrJm/RuCo741Y5BciZzOPLQdxaVvGe/UkmovEn2tVyleUTxEM1Q0kmAGZkkSYzWIJST7hBcyBRsoBSEKUgL/UF4GIVM0gwLFET5JIWJKMVCQM1COAjipVR3kkx2sBx7vknLY9x3PwiMJJhrgdSNy9BxXwxHSIjnvARu1EYSPJR/1UYRFKF1uBRusIRwOYxDE0VN6wxzFoRQGZTT1gibeBBlZeBLQ930GYVGzckU4BDQ/IRa113egwUAQCISxUQK4MSDJAyB+QB9e9Q9ESDYG8Tb3RDcNI1erMRweGIXVpRTEswFIEysB6FAYE33pUTj+/0YriZctXqQWZXgdQFFb+zQbjAVWAzIg8gE6ndUDXjI6oMhSOGBSU0AhvaEBKwAbrQgcwLEAu1Jd9leFPhErOxF25bRIKnci2zFRtzOA4vF416Zta8F7CcMCqShdI/ABPfAB+EGEynWEdohZfPAl81VWZFMCrwFXrUFTFbIzxmd+0eEjPwEiIAIwtpQdkAFbAsAAEedtZGRsX1EdHvA4f3E57xE/YqUD0Eg2i6WKM1UC8QE6CAIm2VM2jAVan8UfOBCOPZMhPlMURNEdARYdCnUiIzJkAuAisFUmg4U+N8QtBQFSI9gwrlEh8HGKoaWKYnIh5xcmwWUQxYWQPWBfB/8RHwtiJfxFfHZRF0tBaTDEFHLiKNixHXqFOynCkXVGaiwGixtSSBMJMiyzOXwBHwqRJ6JIimujH8tlNsRXU+5nOaxxOSiwAAtAHWVSGSsIcTRnYjriIyvjd+ukGYnXTv9QTREgBox1kwNCPUsiA0EQB0eSPTx5WfWxQjtZVlsyAh6YOLgjNetWZzRIGtlETIlhYFzRN3/hGvElinxCPe4VKJ0YXweZXJ9DIDWgWaTDB8pzJSmYO90UVauGduixSJYEJOZyGBiwAvCRIFmiXu4FBVKQJFKQA+l1k9pjX6dJOgaRJHyiWQbxOoyhWtNxL+yGTou0SAa2GLu5Hr+hjGX/UwPD+Tw1Bj2F0j2k0wOE6ZcDollMkic0iSU/VhwBZh1AQZsWV26Bc4sJSDxxAjszVY1U4inmmSRCYChaCQXnBQVN8g/ICZ2HUihXdo0kUDuNcWj7OR4ewh1DOUoEhARitj/685zFmSd5giR8Uij+8w9CoCdSIAMyEFrNYTS9uKEyURDq4yZDBS8RMAX6MT98dgZS4D/SY2PF2QUvmihS4AIyUAMroABA8QBJRRlviaNV0XjVMVDlZSD38wIvACphahBKWqb/MGNn8AIJ+gOysQHLoh0DhqVrch0h9QAz5QIz4AZJYGb4Qyph+gKowmZgcKY0OQJ6YYggpJ9yKh5swpB8bJGXLcYHe/JkfBosSpALB8FmZ/ADSKAABNQdsQJCiypsj0pTIyAFboAqBoFmFvQPuRAskvYWi3FAoyoutddpGPBgMvA/VGZBwUIEXTCjUxBnRiOCtfostccYL6MBezYqCUEqZcAHgBEUJXestXJzCIEw/9ABGrCrZ0Aqr5pmx+IXcgIdBGOtzsKZI1dCBrE6mLUEKJSXUYcQk4mulnIrI5ccA5VChjoXofcz9koufCdS02khfgFnxBOw5zN3MxEQACH5BAUHAP8ALCEAwACkAFIAQAj/AP8BGPivIMGCCBMqXMiwocOHECNKnEixosWEABQGyPhvI4CNAg0GELix5MeFHDGOXPlvAMSRF2PKnEmzZkeDCFPqzAlyYYGfHgpAELrhwIMF/x5s+BchqdN/EIYWCDAApkIBEbHa3MqVYVUABcB+rBqgQEGzYXMidLlxwM8HQgtggLABw4O7LCJE6NABQ0EMLP5paFrw7s+vJkt2rOr231SzAkZiDRB5odZ/lyVTvty1s0qXbF0aTDuQagAITu/uzctCwxQcI2L/k40E4YiCt3FMmfKPxD8WwFmsQPEbBvEVKxImDxzhAdQFBQ48LkBgJAEBqLVGxoq1QGXM4Ll7/x7vMiPoslCDok76AEZg27Bhk0BCQkP9KSSmfMCvwXaPEf/pcFuAt932DxJTIKGgBgxqMIJrv931wAAUuvVTXAdEBcEBRaEFVUGU3QTBZQJcJ8AB46UoEVgBeBTWQGGZ1aJZEAzwgHAOOghgD0H0CIUMUAQhwz8//tNDHD8EISASI+Ag4H+zxSYggDUY2cM/NfTwQUEOFHQdAf9chyIB1HGm4pmePXaaY2Wh19KHGETQGgkj1JBDQlIUBMU/UuwJRRlElgFFFwURKkQZZbjwzwUk/AQBmI4dYCaalFZKkVAJbfCAgzKUkQQRX/yDyD9GEPHPGbmY+o+qe74ZnVAErP9n6ay0ylTABkU5FQGDMnRxxj+5JEQEEXx04JiXcNWq7LITQYBBXVyddJNBJ4300bUmIQTSSdJ2xC2z4IYrUWLYllsRWgJgihpaEChl1LHHmjWtVeLW2xVH14Ko77FsALVBAUo90JRegbGAQmAHNwXXVC22yBBMEIM3bUGT2mtTAGiUZa68bkLAUklVDUWXpg/0FQFgwDEYXMEJaYDjCixICIEHFL5IUkYBeHCaUQssgCKI3sn7EmbeQXwdxRJbnFBV3t5s2mI5F+ABXaoBV59rJUg5gg7/CLhEQV/fxmTXSxQooA688fBaffUl/A9yvJGQHHt3LXBXUkI1jJ1kmIX/SBlkB6z0nayYnaj0TANEFZcHDwxV82Eir6dXfvHpcGVBV16OUBA9/BebbB/UYGBBcg/8j183oiA3zMMV9LOHmIF5ogAVH76VYlWl9bTGUpMMXGw1/CDD8P/kUMadZeR5Zw7DB/GDkV1zXdAVPVh+pZ9BWCk6U/+CCbvt4DsEk4xT/eMBQjK4kEOeX5j6Qhfvn9GFFL/+04UQ9f8jxD8uDKnAP7kigHQ+FL4C1kQoA1CASxTQAQ0E4VdE2EIEC7KFVRGhDCNIgUKGYsAOzmQpcFFKUk7Wm4QgwVhLwZvIUqiWkPSkNPOqlrSskhIP2pAiGakhS7i1knyVJiUtqiFD/7BFkond8IYeiZgPe1LEfOHEaSFpCI3OIi8PFYAtRwwfTDhCL5FcKi6oQY107IaUoywFLT8JyUccZpXaZRFNXdRWERMSR7NkBFMA05VzIgADhDiHKc4ZChsrwh2WdMSNb0RIWJ52E5Y85o478WJLpOYoCt3FLs1pDgs6ELOCrCACc5vQItcYxC0+sZGWoeNVkHZEbo3yJuaByQAAQCGrbASNdHHWAzDQgV0KbJOb/AdfhEmwFLBGL4a5oml+OCOOjOhVsusIerpYu80ckjIh0qK0cKaR85UyLEORjoQIJicWTME+DeoP6f4RN9/Uh3UwkBDN1HOsMJLxPQpTSqwg5f+haSakMpGpDlYIkADaFfQfCShcvT6GGKZtCyzn20C7JNSa1mgga0z6XGyYpIPaQGk2XNtobHRDAhIAp5ygJGN73vY2GNhNQ1GBzlDI1KbtaCYzhwSPISE1O3GVC2S3ZJF67nIwtk0hNnTCTW1qo6OxbWmj/yiBgKI0gg9UVTY4sE9v+qNOwUyhNc2RUAilMhUTFY6D1AlA4IomTev8U3Y/U5pYppI7t9CyRhD4H0JSAAL+6OVkArPLApCzAvvoIHSdS2znsISQHmRJercJqULwo5egKMADJCOqhOz2AOnQFCaoERyKSJRI8blFY6YB6rYcM1FQojM2/+mBDIQEhR//JKkHtnWeY7G0ta7N5rfSm0IJjlog3GgEUgg5GkJ6WlqITAUsimwT0x5TIxjkZz51om0OtlsQ40HhTv8YkgwSu4Ql+KGjsgHQ565gJM6F90qi4wFSYBKrdMGruTOhq8akyaZZglYpIGSKBphUJeMVLwdB+G4O/vSPICA4ew1usJASIqgh/YMPAuLBCjoLzZEIDb+WKovHlsZaoU3heVJ4wRnypD9CEYrFfZrf/Apyhv2V4T8sUAAHwRSrf8QVxBbDjmMopAAM3GYGbvjHC0I1rDMQAYLAUsKqpGyEM5zBBSPAlVmkc4AeA/mIiSMyC3rABxkkuSDBAhZCnvyPKwQG/wPRCWcev5xFR0mUZB3wAXgRUsEJDmtIyXoUB+mcRdT8cYT/SEGB+wSFPfUACf/DgI3oQgAWEjqLSrFLyQrDzr+cZShsiMgWuwUSJl761NlSjLWyxUOenDqLH5vXzXDCxXwpRls57IliuvVqZZV61t5ardO4ia9VN2TVRNRXHHs9Hhn2kFrbYqK5VM3rYq+xfCuxCmggIERmd+anQuQiRnC9bJ/EyzHqctRPDiAaD3tbXKZWZULYlcY8QmABuAqYRM1XITW6SY7v9gwQSW1rRaKbOhy8d1I0FYENcNYp6xLIGlEJscmgMuAzybUQI3aWjieOKHcTmN2aw2lFYnvZsf+WNyLpLO4WulwjF/9HvyoU5okeJQILaEpenOPSu3msYSjflxwLafFTg3uL1gLRSaaLyivKqF0tqRHAnHMjpvxG572JAAoaxzCg504iZiq30N8IXSeWpHyLEYsLP2KWoPxkA5hNiqabY5e89BGYu/rkXehy2q+Q5NZTjPh3ZA3zfRVdi0V0qEjKJyMQIUYg7LozrjBgFwzAQJPkBA4nSWcwpsTT6YlpGNuhMhLUQEpwrJT3NUvk4YEmrV5tD6pJ0qJK0zCNliIuAGc1ffkOyIlgwPyNYFhgzIIAx5ceUMAVcW8acF7oQ947VnXYZNOH1b5vCGGAXCEfyyGfpt7Nv6P/oxrny8tbbU7pZJBgBKP+3tjdl5KuGXQ7LrQ+FgQ6PysL7bI5b/Fg02/JFSYCaC9UQWvPRUWLNCNUkUsSgjIscDW7MQLDxSQJ0iT/ABsXyFUu4zIxIyF9tFJI8Q/35Ec9AxXek21hVBbTtx2TUUheIoA8hhA/tixikRhQw3bogSlilRfoRFxbAyBIwDWXozlLhQQDhh8lpQEw81f/QBxa1x6EkRoFIRUS5SEjFgDTh00AFSKuByYoElc9tXIqQkTkcnboMRQeKCdKOGCwNQJXMAJfIz24cTliMxtlk1EXyDb2QXxMKHxvwxsL0IEa0lmKU3otYlP6h4UIsR5mUR2B/xM7WDFaNLhIUBNs8xd5D/BJ6Pc5H3AlHfVbYRM9s5FROjBVWpNeW8UgMAMcMPNVSxgz8dQusqhuh4h9FINNOSVGjhEZXxgmkRg+NEJXH/JLqlMfsfEBlHNUDoIDB8KMt3E1VPUkVuU5IcUkJWCEA1Yf7OdVV+dLC+MWQSFiZEIdHLMQZ9gRRxNXM2gv12KFUJE4msIUMNMbPIBUV2MfKaABqqNhhXVU0LNbWVIlBRFSZ2NCB4IQSAhIz1JJIkN+B7AAGxJG0TVigONjqSeG4BJUMDIWQfEscrKEYvUACjAhd/ZLK0BcjqUljvU8mZM5z9M1H3U5W/IBW4IfxNEBev8lVnyEApfHWdAxfcvli2HkiJixjon0cVLBIj/RJk53GAD0ACmwAvmBklbSObnFkv/wA7tVEDNJk1WlJVtlUl51VH8wAkfFAy9oJus4IhZJaDl0LQQxcUzpGHjRj0zCJFbpYAmWYCyJW0GQJVFSNjsyVV1TXAjRiTT5AWh5LOlSIobjhTJilCDWFo6xkU+jJmjxAPlhlrDVOTLAPH8CKP9QBp85W1qplSPAUb1lOVmiUXUiW4ylJTzgABvANyUSJpSBIoTTa19BGvdlcFMnHK1RJ6WZYNs1JMeTnAZmJKXYnDpwBc2pXlfCOT1QW/C1HyiAFGQygEaEcUrXEUJjFqL/gTOgwXAn2YmOJSTMYzyIIgWKwjyCopUwiTnO4yN7CV5C4lhTQHLRQQD19WHeKUVDxibwwnh0sXDE5BpbY5XD05590l13AiRAMpoMJiiimSh8sCgkoE+ug5sBShNuYl9v4hYDQDK7QmY54CsqVhBSIARS8KKI8ifzMyj0Yz95UgY/MAINFx2RQjQY+aESQT4OIzIlugIj0ClS4AZn8AJE8AKnIj98EqWn8qQt2gXq0zUkkEJy5p8ACqRcEWo5KBoGcgEIIWXDomTw4ytWtioIYWUvWiXKB5lkglxeWil2NQAsMAJ8oChOKiqqYipPxmYJ8QKAggHK9yivUqe1ImKgwpFAeVYDntKnpLIqqEIEadZgT9ABNnIsXKao4mIjAvMbOiADklpBFGQqZxAkHYBZmPKbnrosA5B8SdEBFqABPfArEpQQfUYEdnAbcPEoD0Cnr6osDkd+ApNnQVCjbFpBFYQIZeADeBOAw6osgYRvIphJBQEohPIrvyIFQaABz3JvRDGty3Kg8nJoDsI13/UP0FoQcKdXU9il5DorspJCTZEfOkACGvSUAFMA8Dqv4CJRAQNAylEQChOPAAs+d2FpMhEQACH5BAUHAP8ALAkAvgC8AFQAQAj/AP/9CyCwoMGDCBMqXMiwocOHECNKnEgxIkEAAjESLKjRYICOGwceBBBy5MeBJA2mFHjyn8aVFWPKnElzYsmOLj1yRNkSIcyMLFMS/EiUJ8aMJz8WwAigwAAID/5FfUC16oYHHa7+uzogZ4CvJXWGrUm2rNmMSwMMIEry6MC1B9PCXVrAZdMBBSAU2PvgwIMFVR9g6BCBRYR/Gv4dFiyVqtMABYjWLRmybuS9mP/VLShgqMiNnj+fHU1a5UmmAAAMSH33n4enBaguiICCBQkNuHNPQaJhSgmDtgWSIIFYQ4oVEZI/OOzasoe6EKQKPABYr969kEluHjrZMssAncEX/+hMQAB5AQLRiyzN3iFbgpsf511wdYFAFik03B5RUL+G5IaxsIJ+xP3Dnw4GGsgbgSRMUZCDH0wxwoQjIDGhg4g1phdsRQVwAAH/EFAAASKCeFl5nRkE4j8CHBDiQeq1J+NZHmS3mWaa7aUXVYatQAKFNfTQQw4y/JNDED1A8cM/MggZZA8UTojDcB9U+c8HV9aAQ24kYPnglCssQMABMZZHQAAgHjDZmDO26WZTakEG31uQbTbAAFQVRhwL+k1RgwtFllGGFIOWkcM/UMiQ6D9BFFmkQUGUAUUQRMpQAwkRLFCAmiV6GKOboIY6GmQC1bVBCn7KUMYMQrxQEBFGEP9BRC5EgGGEQGD8A4YSXfSQWFd1fYijqMQWKyMbV0Gg1T+D+SHFP7EKRMQW0/6DyD8dYPCPXgds4KKx4IZrVnRRXZWVgMJtEMFVG0DFkFvrAUXZep7BJFRbKJkU1Ffi9mvsTSwVNJRnHboHb0KgvXRaUj95B92I10WHI7lb7eXvxRDhpJJJbb2HL08Ch3yRSE3hWBdGmbHBRmz/KKCttnk29sAG7T4FFr8QfRoaep9i/G9bkR2cb1dxKnWXWhAoEFueDxhWmAZ84pbCP1MHWFhhKCgms1NOaVbyQPFtSwAEY5PIaUhjxauiQGf27DN7Q3UMdo54KUtVbSgMRwIOUY7/wDcO//wGOH8TXmlQhYnhtoKAhgUW2D+1rfAPcSSsIPkDFkd2M3hox/iVAOMJAOKnBxCU4plvk6aWZhtBgNc/rzvluut3rlb7U1T9M8UHI/AOZQ9Y1vCPDsL/8EMPwgvUg4E9IGhgCbiRIKDlC8AQmLuWNyhgBCugsMD3m4buIYtkHlTeP9+mHu5XcK61FrzQXfWAnzXw0UOTij6af6JEBnH88TrgDRIsNCHhfQBKBUFgDX5QgxpMqHIGiMr5NvWVyKjvgmSRk1qaopoCPMcDkxOeq15whn+8oAtnQOE/uiCFLhQECkRgoQyF8A9AjWADsalLi3aIwR6Gyjp7UYBA/xTQgQ6MQAZuUEJBaFWQLawQCj5omV4MIjEfWjFUMyvXQSIwAuGV4R9SuIFAlpAtBShLU5oK2VE0lpOdeEVkAbuiHNsEsHiBRm0XGQtbjLKwfW3kYy654xx9CC+AzUuQD+nJSw5SFLmlxC2PHBapvDPFrg2Sjm1k41FG9kaE9KQoCxEKyEDpk8mUrC6wUZNf5MeuqWhxIJx04yVLU0eO5ZGNjBRlh+TmSa/Bbinbkkq3MJe75WitXK7jGljUphOE6IyZs5SI0DpGzZagDZp/hM+cSpUXHRUTAxgQTFRg5rjr1OhmOWMkZ9IzlBSxxG3RlEhXMLKWOOErNTlJyWoEgv+XArRLflFhwQNqU5gO8OkwxgkQBgRaTryQhH1xI0jswoc+EanJdNuJo0bT9qJ4NkQ7QFsjB1mzlKeYNDYQmA33UhC13ORGILg5yG2Qg7UIRKVUsFkLBJBmHW9BTEcs0RypGEKQM32uM+gRj0hW5FGffIQ17ynIjlKq0sWtYAoaQAIOdsOffwBOAyW4zRRwALiyTil6/8CPQCJgPcx1EypQsU9bp5LDywRgpwPZKcHWKTHTiS6OaBING5pKGaJFpnZ5+cvdBDScEkjob0gogVaRkCG/FW5wCJpQCfyGVelVrnL/GFBt7jMFBxFuOGHSjF425yIXMXVYoAssi2JUOhb/EaS20IwnW7jWTZT+U4jJCW5ww0kVBQQmOT+a0AELcqAEdTFBBoGSDvgT2bXa9AF1y8tDt7WAlCpWsd0V0c48BR7XTidELWqqTO7UwTvBbqhdi44/m6Y3CelASD1Y0v2SpDz/La95/Plql3jAAxAUGLUosNxaCeOjySHmOCEqj3hE1yLLgG5bSVWvWRa2S7osjXEkIF4P/HckJUFhSIdiEpKO1zwdTNelGhjBdL2EoCkZiHdRmkLlwnS+84kuOi4CHTw1bBYOBm093sFLniJwmwL9I3lGkgGRpowoGSDpv/9Y0v+U94/lMSrFTdLdFMKkKaYuc8hENhZIcfQ6jFiH/58C6QDzVNVCGpZQCniGgkCkoOcuQIHPfN6zQGQgPW+hj2xoSm+aB8mG1tg1NgqIwAVm8IIkEKEgKCTCGTRtZyGc4Qw0FAioDYWEDShtRJ5B86IvacE6vWYACtDAn8rghhd84dLQ0hWuZ7VnP0RAiGoi2xRXTWyEYG4DHphKB3pQhhIypAcs2Aq3WFbsagvEbtIpSAd8MIIyuEpW/6gWIsoAzgcQwNDps/aqZwaVpbWMKikgwfJ+kJiCmBuIN1W3vhsjlauEU1sVKeTG/rjvgi+kjtek1xvxtTCFGfySnNRkbhPGsD4ixSNuierDxSXwnczLjoBUyCMjuhJSCmwlIf/fOC03ZkfA6kRoHDH5e4iSsJiP3CvaAdZGBqtyikRcbTi5eW6devKZ/8Spm9SO1zAzSc2ICDOYGSzPey5LoK+n40i/ZSj3JUqNxjyQOYJ6/PKyFVZmkV3A7ArVEd5Lj+OcZBWvpkJ2mUeRfc3D29rAVrK49+IKRFvsFU3INs72NWJz5PaKKi5DA3ewB41UwHJNsvxNlXDatDF655pDTT739LDI68XmaE/yNXqMRxRkSJGbZyxzyg15wLgY2EA4DVJMZDMdnQ3hWcBC4s591yssHiMl8PN1c4fB7pfWKe4DjGtce1e+Mae+6zId8kx1bkTVRAaJwqqZcMFbM5DY2Qv/XkAIAbu58vlaYyvTHCP9evYyLDfypDt7ph7spzn+dIETSd63R6bAp5/iJ3nHtRxXEwFQUxj3sRwwcF3YdSd7RCr8YlewoRmc8le9p06DVxCvpWEeQxcukRYcJCfz5HgAsCF5YVx/QRsFaIBPE21pVRBXs4BVUTv+BzLz9DD/YB9iQiZm5nIJBxpI5XkbGE0nASxH9xHuY08faBnKckYPgByGYRy54QNUqAE+cBhYCIU0RRu5oyNqVxBrERk7gj7l0lp2BSfeJxpIBR6lMhAZZn+DxEvvhRTuoxlPYUYbABhQKCAw5hti9YIu6GQocDUC8QDW8xqspznXti3ydR1p/yGGQgVLsBQeBiFkbhgwa0gQU+dRFlRPR3Ya/dSEfwEDVnUbMQY9p9UbieFY0INVU7JVlBNtV5NvOlKLLjIVgKFaUMcdEGhXsjUZSZWJSDUe55NuRDhKbTgxsKFYhTEguaFZOEBZkrVVI7AbfONVXiIlMaU4ykEV7TZVsyEQltM93PQwAqBXdrSG62Ei11c+njcdcGhFBFMydRId3rUApSghFMI3lHValnWNCDJdzjMCvwFW0cM43mNTyZGD0dZku4NaMNCGeYFXA+M5QhZ/6IM+FGYeaaIeQzhHyzQUc6GLebdYDRIlgONVnRU9YbUfXZRZy+M3SEACM9kbDXKTOv82OXwiVoBTICgQFc+RIxoBFsMWTOH3eWfCgzzDg+SjaISFehZkHcnHGFrjIMPROAq5HMvBAiiQGL7TVcNDXYQjEMtFOBVCOJSVVoTRAcvniEMplfZYfo5hMRmZlEg1OhrpjtWmOeUXHyCkAB4ge4FhXHfiFB8EAeHEAiAwIVCSPA7EPF3mZcvzJCOAZf9QkweIAlARFRNZKnkCAyxQPYb4PQugJujhWqeZaDDSWur2GMDSFURzHSWINHixFs/RFFThIxJSJcRTA8GTZcsTBwfhZRMyXYhxkyAAAnRgORFZFf+wgGnlI+MYWt/TkdFxJqhTHh/Cg6hDdQUxWDWST3T/wUlTyT220TvI4z/5YyRBoDxC8mTDwzth5Tc80FUfoDexWG8GIiGUQwKlySJpooEUlCbQ8ZFUJ4fv44Hlh4/ZszvIY2VNMilGwihCEgc9YKECMV0EGT0F0kX8gSUkAD1pKTwUEloOsIPBUlFjAzoEGo8P1xFdRxdP0RiFkSr9cyQ4iiQ4amVHwmI9sCC4EY3O1Ttg+WTIgzwGQgIOsAIwcD4RpnDj452JNBlxknZDNUTc0yWM2WX6RSRRdihBkCj41QNL4CRCUplnapwIsiT+9UCVU2YjwhI7VUVSOhFGxhQWBExqUYsY8DQG0kBdVgNFQil6BgWG8kWJYmVbJhAS/5oojiplTQI8b9pR45GBdToTcNIdeUUQ0YFYzCKYBjgFy6Mqg4Jn/yAoeSYQX9SeioIofOZCgvIPO3CfMxMf2nmpbvIweNF0d4Ujh0EcMvAsBUFCLiQQLvRnfcZCAiEEwjoDltJvIDI2TmeMuDojbCAn8dFPXXFAlEYEbiBqroJCLtRCUhBqonYGeIZnMvABQkRFFFit/QISd8ICgjoD//AFboBrSqQEmnZptfKv0qIEZ1AG0NYVG1AiwgavGNOreWE7CsACR/St9yoQt3IrlwYGuBZuZyADJYBdIVIX0rqJCisug9VbmIMBsGYCFRKsRPAF0RJuRrAFTnRpJ+YDKKw7HWVjHyN7QS6iFx6AAS7TARrAbK5CLU5kEETwLBqgLdNGNjtrRZrSLltBGDrwRdXyD1lgtIPWMoW4LZvytBiELOw2M/1RtZmWCwJBLeHWBXKWF1KLkWDrMxLjjbkjECOQAyi0ac7WBTkwBWxJdjgUtxj0ANgme9LBZEhwP1BwBQfBbt0kuD6Ebe8mexvQkH6zkHknX/kGuVekLc1Html1ednGufH0MlsxEwEBACH5BAUHAP8ALAkAvgC8AFQAQAj/AP/9AyCwoMGDCBMqXMiwocOHECNKnEgxIsEACTEKJDiwY0GOATgWDGkQAEmFJk0OxJjyo0aMBQIUqEizps2bNEX+04iS5ciLOnfqJBj0olCY/wooLQChgAIIGwpgmJm06kymBQYoNRmg686PDAXgHEu2bMaUIdOiJYrQK0yNBTZAeLDhwYMIdvFGiLAiAgkULACv+PeAhd0HTQcEUEwSo2OEAK7KnBxAQOWvYneK3fyPs+fOZkOLzlh1MUymC+ayYLEihQYNJEhomFLi4Ot/t0eUkP2PRAQUvw/b9fBUa2SZTQn8O/Dg3woYC56nXmDQrefLnAtkpto1M4EEYhMI/xSfebT5him3NoXwr6mHDQMwKMCw4V/dvHSF1y2Ql8SUDzgU9MEIHxQ0Qg06IFhDDx/08M8I/5TwWgodsBCBVlgdoJSGkwnU1AEHLABdahAc0JRAMe1EgGUCQMBiACuueEBnM55n42gEKRZUewtEN4UOPfQQRA1B9ACFkP8gWeQ/V+gwwpMljIADgQLhMOUICfYA4ZYjTPFPBB1oAGFvsrFGwIqW1SiAhmumWZl2N8YpZ1eK/TNAUpEtxd6eTA0AFQYddOCDDjLIUEYZUiQqUBn/SAFFGVDkEGkOlJZRaQ7/TJqDDAJdMMUCBRBQQI1suijnqaiONqNySTlFggwuzP8gRReJnvHFP0QY8c8W/xhBBBFg5KJErmdIcYEGG1BHQAAQBFBjqtBGex5T9bVXrQIKmBDEC70S8U8uuL7QxRR2FdQUVdKmq+5Y9TVHWF2E9eYlBnbJha5CPKG0kUsdAQVZWv+uBABHO65rsJwFG5USWww7pNJJP+3bkkAhzXRniu0pdeY/yv5DwAEEUEcde0l1ZXK+B6dMkUpoHbQWwAKDJTFYVy2XFF1Q3QdvvfEK9ACGJ6sk80LoolzdVyqrrNbSD69UM1QL3LUXCylQTXVvGkTAQtYWdh2Bc/8AZ5hdWG3gwVEXPdaqxynGFFNlPGX22dyVsSjATHeXl7RoRKX/dTGPcy3A1wpT4CDmk/8UiIOXJIzgn+FTOP5PgAFK+JqFYK6m9T8WatD51rA9GXlsK6AQtYnOelWQZOxRpZRMHr8J2lcH1I2R3XubB8AAvO/OUVbAa/V3VhnftYJ/A36gwz811MD8D5zK0IP0AjnopOOyAfdA1NyPyD3H0Ymo1woswMBXc4Mtt6LNYh2QZnlr0pj7uiKZpJjrdiogdV+gP+kkkUT6QZGCEIR/FFAGBBRIDZ4UpCT9Y3mI+wcSHqQl5iXON1E702U64yLt3Gt+IKQJG1B0v53MxC4sGIELvsCtgrzgDGf4Rwxn8A8hzEoIMpTCGWZwhi4IQVYyuMBg/x4wqpmw52MhTOKpUrc6O9EHdD0owwu8ZYQtbCFXv3pBGZDwswcohwDsoY4Sx5iqPVXrhP+gFwsIJQWBXOEffhAIffhDALmAxWhIswgZ95iqhH2FZR5hyx0L5hGX7YtiQgMLIfmYNDyW5JAr6ZcjS+KTSg4tkX98DExOtJSqKEdDEFDOCBkZJ6O05ZHoaUz9JkmSvrkSbSZEkVLiFZXmFABU/InLubLCtI34xJSkJMtLCpmQRLJskr5kWCvz5ZilzFKXG7AjYnKJM5/16W1d4Ur9FqI3iiGkm8F8CMwOopazxMyVIRnYQGqmFAiAqi7c6xF1jHe+IQrEXszKJjIXwv9Kim1mg53ZZzjRo0imdSVFMrmKcPSiNa2xADe4CQzXfBYBGNjFoknRUcW8MhPYmbBZHFROZVwEN7F0BzRzQ2lntBO3gULkZTvRZ8mWM5e7SJRqr8lpQxvKudWQL3t7wcv2EEPEpjzMbR/aUKsc052YmBQ02FHpdZRjGVbBiargcSlpvJkWPUUNBShYwfFmgwMkRG5xjnPcFGajATLhIDY8iI0GUtBQCx2GXnGJ5j8UcJ8HiJVwHwABD0CwAgekZkarkupBBFBVtVlmsR5jrGJdeqeqZDSU1JRaQy+XU8+tpmugjU1BIBigLskGNl76QOQG9CQedIkHa20rXXEGxoP/mlQ52sEsbltFlbtppn1fWRZjbye/2WmVmI6xH++WyzsPMHcAzn2uVjDwjylEDkI6aNCCmpeg7fZgQT9oYAksVzW8QKBE5wVl6xJ6XhGVTqzNiVrPOPjPxy5HAOtzn81YdVyKaDIyAD4khuzSuBF897tBEKAADeigBl7hSSOADWxQkDW+kAAEVhKtvAhEgg4IBAUkKBCZwjajl+w2VKApsfue1V+cmCYyM/VTXGDQuObZ+AfhTVKQBtjgIDVYIAbmEoMYtKAHYS1rJHiQiMMWAZC16LHOWlOUWeWsFp+nTge5U2W17AH+bO+vU3AthKAQhE09KgeQgtQ/oCek8C7J/0EIqQECMdWlwCzAyStdUShhZGWl2SmfddIIQeiTl8hND1FdgKEPcZipGioqUYmyYaPaKBAX/IMHX9uAhjbNxD7z0TTNtNMDFGDkMjThBS9QwhS5FcMuyFAgMXy1QJTQKBnogC4LAOOyOujpFiPlbwqIwBRkgwQZuOEfX0i2twoCLl/9ows/QBZ/khJKkvX62uZqzwDmMx8M+KAHZ1j2QbrQgw7Q5SDWxnav3cWeatUFAxGwABJy4GpcXRERL5CBueNCTXVjWy5ycVddIkAvMX23BNTlK1Sa8x7q+vvhBslPXfTnronsUyfDhLjGh/ZIlviEmNUBJr82zkeRj0RmBP+jJCYzCRSU9TJmJJfWxSHpsnHia+XJhGRLAMbzmJ/Hjx4PpNAZsrRiorzoGeeOLHlLlVH6/KV5PJrOfQnymy+EYDZvIuxOJKqegZHaoZp2czQa9aeXHTJS5+fOjVl0kL9SaBi52Cyt1R6O2SeMdYcKL+3HlY5AbONA9+Yix6lKg/pL5TBHpNKfWR+o6J1PRYVP7972lZ5/c+P5WmTEEDlycrq9kAqDXUL5fdmr5HI9teyTcfSZ8YSAU23qRmZj+IXznLdkYlm2ygHaZRX72CcuhClXQeAjl5Nls+r4Ors/Nf53QBoeYkWJ5EZqBrJo5rKvpqtKc+5ikKe8Lmh/D8v/Pjmj/F6HX19TF4lPljKjBdQlWXaJWnMAQ/++9GX703TbYmCJkGfW3W2+NUuXsUEu503Mp3LQV3lfYTFMwTHwdBhTsxdJZjUT+DX/YD7l8jMDsDsF0BKVVTKw4zYcUjswYhkw4hjg9BAp2GfJ9XwLaD/B1yN44TU41VZJ5htd0xzmIxBCRTa8hDYehT+YZTIvYoLGRRHLYhAryEgwJTAn0VEdmCJQUxiAEQGvcVpVIxAPZYV11RuswTkcUy/OtIEmxBV6khQz8jZOdTsnGFAQsYYCwSIq8g/igW0vkyfUEjV8IVGdlVMGsRqegxuxwRtTcxeHkRjGERMwhhXWRkSg/wKCXnE3AHVKeVRSSigQX4RfS1hy50RCeWgXYiVhryEl1fVWcuU4EpZkhZNkGsA/QYWB9PIzu+MntPRlYjWIJFA6GbQqvqU2vkgxcBM7uPNFnUGMx5Uj6wRjfkIAQwUDtygbo7M40sg4GgA5N/gki2M5c+VQdoUX8oEB1GWIe3E8yPMfJOAAK9AjIBI7yyIZIiVSGNOLHiQQKwYa/GWMWkUUr1M8hLEAYQUbgzg5uDiIAHmD/kGKUiIlcuU1uWiQAAmQTxKQ5JNBSzEZtZNbebMcHYI0MuFb60NVNvMsVMViTNgRWkFtYJRZD9ABe8GSQbUXUnMX8LaSrPE4pJhdQP/WG1KSPBDGWtjIORUCJnWxS6PSIY7xSe5kIkU0dxSDJnLjMVAZP5ooIy7VN1FoGtLVXFnhJ9AlPF3mAV85E4TTJQ/iJNZTPdsFXt8lEEhgOUGVH2GnawjVFMzyMdFBPsJhdygiWQGlZ5KlXwXBX8f1gTvRO8tlJ8vlOx7gOxBAFF2WFRb2JB+AIAeyluF1mWtmQc4DYbDxG/EEIiHiTjQlEPIEHTAAHenTIzBQEO0TZbwokvEjmHa4TlS3UcdxPxehFec1fywwIMyTIDj2A5kpEDkAZw/mJHMVGChwF+HzV4MxPiCmPRLYG7iBAmGjPm3SHhkpZRpyX5uocR14Emr/YxIKFVYF1jzSwylFciQJViTWgyXYGJGwUV08qWQE8gEDQlcCASCi1VYrMCP/pJ1+uSzuM5Jm9xAd+GfU8gAhhp7Qg0DUIyRxIAMT2gNv9A9LAGEQBmQaamMEskCG8zVt5ZtY85+hxFgzsmcrRSPkd6D48jd4MhkL6hcQ5iRAsiAH1mBx4GM82gPCiaMHciDNQ6IKWY34WSBHmo4nClyYkVsb46IPgZsYUzIWM3yExhrXlTh80J5xIBAF9A+YkmDCCWcKRKYV9CAGxjzNMwUpQEQasj5yAydQujKaVDKV9Ra0uFA/xQcygGaPgmhSwCgCAQWcAgXQ8w8I9AN8MD2M/9qn0cM8w9Yjs/SkRiSbc1oRUxoTdIkVzJIi8qEAFSIm0HMoilIQbQQFkQIFBYFmlBKok5YoNMQ8KKBpXdeUKHap52EaHrAYxLNcUuFXkSMDUoBqZ/BCiQZrz2ZDPuRDNdRDQuBDM9AFLlADH5COX+RBSYirqBJgUqcAI3ABUtAE/0CsrDZFPuQGQvACQnAG6yoQ3MKsZaADLOBuKJIx2pouzeI21nIXEOICx0YESWAQ3jKww9IrZ+ArSmAELyAFOTACX7MhRUSS94qvRmQxCgAbPioDj1KsX4AIvqIr34IruUAEZ6AEUiADbYWG9fpBE5suFXteZoMty2UCNeAGjLtCBLciELmCrGewRZZ1Xh/Dsi2bMk5XAGezbYBSAjIQbgKhK1RUPSzgfUmVbkM7P6RnNvChAD6wLbiyKwP7D2XgOfRxImJUtSC0oMmCFaPmbT+QaEQALkSwBcXSAyyAAXMxKnpptrmTS3R3T4GiAT/QRkwrQ2XgPITxdZaqt0mDGPCyAfTxJRpAJAVkAveERlFxIoo7P2zAM47bucajAb5JaAaBAWzgdJkLQuf2gfShRs95ui1GL/RiEwEBACH5BAUHAP8ALBcAvwCuAFMAQAj/AAP8GzgQAMGDCBMqXMiwocOHECNKnEixIgCB/zBmZHixo8KOAkEuLACgwD+DBQKYHEDy5ICTAQIY1Fixps2bODciNKhTp0yMIT8qfElwgMoCG1gqGDDAw8ACAzZA2PBgA4YHD/5V/VcgZQCjF2MOBEqQZkIBOdOqXUvxZdcCWCPIZRFBQwQWKPBGWIE1a9y/fQdAYOkBasqMRjeqHDtzoIAAjw8EIPDv8djKBNFqZsu5c8KfLFlCgKv1wd27KVj8Y6F6hYbUJPamzpt3BQvbtvfeLc0CK4aBGyJgpdoBNW4SA1csWPAAwoKUBdCKRYj2oPTrPak7/ncAs2fPIAcY/wQgfrzJ8wBQZuw6cPToAQ9WkNAwZcQ/HTV69PjxT7/+/v+MoMMIBGown10PoFDVBm9xxRV7SDm3gHPNYQXDAtxBMNoGlAElwGMCSCYAZQQdMGJl3X2n4k1uPUWVbCSk8M988yExgn8AxqFfEPv1MBCOOhDk448EjTDFga1NcaSSt6EAwQHRWSbQYyRCwJUAJv1D4opcerbYWBBoFAAEJS02VQQ9yFBGGTO48QURLxDRxRn/CPGPFHjmqacUXfzTpxsz/LOmCxfY90CWBxBQAAEQbNnlo5DmNOY/RCmgVQcsaKABEjWo2UWc/9CZCxGhGvEPEWe8IIUOwrUX6auwfv/nlHssYWBSBxr0IAWpp24h5xIsYMCglcTGauyxNVFl1T+//aNAViu06upDZNEU0k8eIYTtRzIh6+23BPHU2EFiMtYttt1mVNJFYKn0EkslwYeUU4WFRilXLA300lcxJTZWudmB6621YV1G0XlcHTXVBgy/+MACwsmFglx3kaBgBO0RIBW8JpklkFkMgUyudtUJ7K1bVZnWpAYoxBYba3c9UNxpcq1mGgx9MdccXA0O9nGZYy5K0IQYPniZSiBa5xABkEUXsHQmVySTScQWMNUDCvz2wFV9qbzXCiiAPTEMt00RIA4CjoDDjCSQQGDaA/ZAIBL/2CVX18w9V9VoXon/dRSjBBywnOCMPmUS0wilWLJmkHlXctQW/eR3RkBB99U/U4Xt9o0f+PdfEP+A7qMfA76tNg5tt62BfAai3nYKqbdNMVYo4BzBAhMzJ3iiIGqEpWVaigw5l0At5q/BEMR1GwsjdCpDDjJAoWYOZUBBvfRByJA9QT/IAOBA/PnXafZ8/DPFCjA4BsHv0aWI+PDwT8QGV1Z2XIACGzRfhhsvvHnqqS8giBLOQKcCEuQMA0yVFFxQAxI0pzuNOlz8Jqii+tWvAE4ZiH36dCpejepUXUBCvqZFwRJ+Bz6lsdpVCoABFkzBR1DogQ8sgIFnPcVKIfNJQi4SLnX50IRA7AzB/wK2kHSFC10w4aG6sGWSdV2OKEEEIsgwwpMjVhFdV1RiQYwHFaOxh0H/qNflxkO5j00uil0al0a0qC3GhAwkcMSIYZISFQxiUF+UGgxh3OIUkpAkJl4xGBHRaBNx+USJAPvhQoiSJT+WpCsMUsD9Ujac0mBFZ31x1lu8Ip7DtFF4UnscIUdGli3G8ZSOPE9zHEYxuuylNneJVgRgcDecTciOgmnMT45WRMx8rIyUG8viMLMZx43SilhMJruQ0pe51EUusVnBP2LWAdN0rWs4aw6tuuIBdHlSkVqqTONK9sthFhMikCGRo44ZLsNc7QEwsI1dUnMa1riSZixIQbTARv8XvPQGKxCwFbH0KEe+WWgFCJXPkcC2gO5Ex2mKEeVZMvOxpJEFRFky4VuCJhW/rKYumvqHNOeTm2jpU5+3USgOeEACHGhKA/lkjXxSZ6CXwtQudLFkzqoCJaupZDFV1NJGTYKlhHlnOufczDlL6JH0MAUq5PEAUxQAgWdVhTB2fBhCSTAFtKHtHzUIUJBqoIMedE5ucvtHCWoarb4k7z1/9JtGEkXXCQFOqCkC5GRO5B1icgctBEBLd9ZJwXZtxJGANErHENOVqi5AoSP4AH7KmiYfWRZAaCUQjTSlGwVlZWKZjIDmEnpNreDsH7praEa6A5nfmchEWgoRiiTKTof/TO0ijaWK2z6QNgHpQAdLuMKNMNsf/YzARvb5xwcCZL63fYC3NajBB6Qb2RSgwG4rWChCRfuARDUtIx8qmWQIsr7B1rYi9tMX1TbgoBfJxz7JDWsPQBc67+XgH/zB7w981Lzi1oAPPgJwfgJUHwKBjrdTwEp0wlTO6DANSmiZ33nTIrzFUA1Cg8GAhjU1XYKUQQoDATGeyiCoNV0vByiuXvRUDIUSg5W30lxUh7RE2Akjq0w8XO/q5DNdF/APIbz6RwBD1QUhuIGAqRLyGY7chRlIoVAo0Ap3uKKoRNm4hAibygAUQILlCkoKHybgCxA4EFOdwQh0IkIuQhUqJSzw/wNZGQ2UCndlNErYi1ZjmLNYMJ8e5IBOoRqVqYigBFRJYQrNop/V6lznqsFnyxjoABK6QCojEGELA8mFFPzwrAtnhdE2foAHpkLq0XgAKylAgo84SOQeiAFjVsszqG0cFYJgIKBbG0jbkiscuJBaKhmdtbA9YKtE16SUBFsjKIVtY1A6O1s7udYSmR3Eal2GjUYklxLZeMQk+nGQ1H7ULxXDw6A0RNoP8cjU7sWxkpyETOFe0XSmba028nDbPzuISAiykq8YJjT9bhe/zMPteEtEcsEcd0S4rcUnGk4gXXlXxNVbr4hP3I8xWbbBFQIynkguLA0/JRWx+MeObDJftf9Oyr3ceS92mxGJyAY3sw1Zb8Voe9lZgqKDHmRHqkYlKbYKzbs2BHCuAI3bNe/lldXI8X1rnCO7fMsDBCMV9irrAQQoLVa0wrMwYTDjI+uJyLAj7KCW8uYSyRK/BNMVW/VlAzpDgYIm9srdYC7Wo/npvAOmcY2L8umQ23cRRQ6WPzYyNJS8JsVaGQF9yvKS2nyLUc4IeIn83eaVj5/IN48uxHdt8a386DRVA4PaifRhO/MAg1gSE0TqOyFd+anlBAk1Xv7y9jaPIudF3sXk6YwudqHNK1GrU66V9tEssVq5s0MWtZ8nkHsvV0Vxf3um8ZXR53FPXGjJZ5jWjWamuUr/xB7wz0y6dWNdnEliIG5h9/Bb7+Blvu0xH//G2V9K54UKqeOCGhKwhp7TxHjTJFJRFi3/cDHWpGCNFXFholiFgTkSggK4AzYOsBwLQBmLNUX0d3uWEVgj8l0CEViZJzDv4hdUYRrykSnPhDHOZDcBGFN0ATbWNTuZZGtdRFVUFRdb1TYg0DbK0VDRMW8YSH2KEYQdY32LFYTfRVuBJxOiwSApExzXVVObxWevEwHRNBtWOBAasBqxMRdSlj72dBcylSl5YRfSdIB58yRQ4nWLQYTAgxESdSI4hEMyRhkpAj+PxHbucYJbx3+34X/9VBvLI3cIBQJqA184UALzQRD1/1Fg9eE28yEj04Q3fXEA7vFTL+Fx9IOJmOhTHTNOQbgl7RMADnUieDhlw4Nh/CYYTAEfqqdhzZSAXRM273U29rE2XxUgvPU2QTICawVTdwNPD0NqJ9ctZSJnznEAzNgoeec3DuYTgVWKrzUQgaWKTOUuX/GKKzEYUtUU+seHVpMVWFhgb3MfnUNZPVBWNwJfSPBS/qcgzLGAT2EU76JooyFUBZAozeEgBMAogPQhxUJUQfhagiVYFAQaX0Ee4hF1HqcSYcEeGYQV9OGL+VED4VMDooNZaeNSbZM7eINazkF8JmGBFliSC1B6D9Men6g4D9U74XSQsQVbJoSML7cRDf+ZHj/hdU4hECjoQgQSXReJI/ohX/+wBASyBEiQOmZzG7qRUGHzNW3DUnzxF6WBMxdiS8HTHd0BWAJRjVOGh0x4Xss3Fv7iHK6BNjogWfehajfiOT1wBT5iIzpgI8rlNkfCNry1l8/1XCs1ejGTUAgVNrrTPlRCJaYoXl65cXj0baSWXSOwW2+DXHRzWcQVIEPCXL+oQckFX2FVN3ZjhUdCUujzHCaSmAdxjY7xIavFmPpyW8RCFRb4IqzhNj0wYOPDH3GgPfhVPvwRBPnVOQTxAaATVgNiPgNRH3/wAfVhPsrxj78TWDTZWq8VWDjkmk8xcK95WBhEFaOlJNMVPf//AD3YM57ZA5w9sl89UD79sV/qWSQDAWDKdSRV8VDp9DGKMhmmiJ0L4W6JoViypxLOiHgRgCklMAIyoD3QsyZSQD054ALjmQMtZj3Woz28qT3dEwTQ8w8JGlYM5SDpdBlFxZ/p5iCWc3uKZaJHoQApgKDU82F9wkF5AgVSMKE1CmYktid44gI8ClYxQALsJWOLsj4LRqIUZjmzNyZcxgfRJQMzUAYv8AIDNGR0UmRC0Cd28gJFRidjdgas9g+BAgLTZGVbIgDXaaResmivSB4RUAJtkgRJUEBjRip9MmZ2iiqpQmgIlCpe6gJ8UAKSxCFaAiVo+ihsEGxagT8k0ClR/0oqvHIGRBCphTYQjvo/RAAGqDJADASkYCRnhXosXcQUxdE8NtIDDDon/WNphTZARmAEmHYqZ1AGPbAVQoOonxopi1ZVUgUVAyAcClAXCLomn8Jm//CqlpYqZTAFknRDdHarxsIGjLKPT3EobpcpPdAnhaZmvXIqbjYCNSRn+2irzvotcdYUq9EBVyAFooIQZyAFGvAS4Eqo4yowbABsTdEUVhFpMtAFhbZmmEZAVxABVIWNeTiv3lJ17uFrz6IBIxAEQkAnvuInPYBoA4uwBhs18nIo//AiXTie/wAFohMbW7cAUHix4IIVqucsKvssGANW/4AEHWAp5HV3Z2qy3xoSUFZRVVP3acnBs1khrjaLsSo3ALdmbBMREAAh+QQFBwD/ACwJAL8AvABTAEAI/wAB/Avwr6DBg/8EHiSIsKHDhxAjSpxIsaLFixgzImQ4MYBChQkbCuQIgGDJkwNBFvRY4GSAAR4JxtwoM2EAkxw16tzJs+dElQZNGvwYE2RRjwcLDFBQAMO/AgUgRN3woCpVFA8iPFhR1eqDAUoLMFV6U2FNjQEEGFT7j61atj7jyo0LtGABg3fDRu1a8MG/rH8xRKCq1a8CCA8wQICwoMADqWBbFi0Qk/KAhC3xQi1AYOBAygMJEIRbszTFtDnnql4dtqCCB4QfoIjwDwWLFRFy/4XRFXDWCLdZkLitgfbwf8FX3F7BdcEACAo8/Lvc+8EC61WlQrgpIO3Ku53v/v8TPT7oSoTdxXsPEL78gdXwdZYs+DEkgPsvkf6DALZqBBIl4DDCCDrUUMMPP9TQwwj/9FDDPzogMYKEGlSogXILsMAXdrx1VVh2UkUFFQEhHrAABCR2RgBUARQggIsEQTDQAS0eJMABAnSWWnw8xieejFL91RUKK0wh4Qg9fPDPCEHUEESD/wTRww89IOSHDkxGCeU/fpCgAZID4rBkD3yM8MEUJJBQlWgCdFeeaDi2CUF3QHa3Y4945tkQQZc9JZBCjmXFwhQ6yGBoGQUlQcQLZ5zxAhFuOHpGF0ow2sU/Lzw6qRCOdiEFEV2cUdAMfPBxwRQLLNAZjgTApeersOL/SZZ0CgzgVHSCCYfElKIW9KhBRORiBBGNdiEDCy2meFOszDYL6wYH+BXtP9c9wEIPUIiayxZbBBulBpyhKG5nzpZrLnwyerCBurAJhpxW+20g3k8S1afSSCitNB9K+yI133nzniswrCNVxBBOB4F0EkpH/QuAUmA95W9IL0E13bxhjQQTTDb9e/DAIPck1FAeLTyyQ1CBVesA1WmFwnW6aTVYVol1tcBr8kbW4k08LzvRW20V5OpaQS/kWcghN/zUfgN4sBdVf9GW29RcffjVP+ouBgFVVe1XwAb/bCD2AJeRBVNUYMnLGIoL/LMCCgfETS7PNpp2NEQvhtYWuXt7/4c0aw/nJxVBU22d11OKsWxdBCv84/IKJAy4xJJY6lBlhCNoUJCRU0xRghgs5IbBBhiExVIA2+283V1BUrbdPzjG3RZlAXjA0HttptWqjJ3JuLRafP+NZ04C9XnZwwJ1EIHyEVioeQkaTDEggf98sOCCI/gx4YT/kIAEDs6PwMI/X0p45IAF3dZb24/BDm0BB3CG44zs1ThnW6jRmPfQwgt8fEFOk8p1uAabvzhuCjWQQUGCUAYpQOGBlypDEHLwpILkQAYTlEEZcsDBHGzQUIf6BxSitCAS4OYpnFlRewpCnv65cC6oY893ZNSBL30ggWW41KOUAKoXSMFTofoHEf8KwsMvEMEIuSCWEs5QhgswCHY3otELp2iuFK3qKYiZgpKkUJBGicpb/ziDFGTwlRSiiIpoLJeM8vIAxzRFARFAgpTKAIUe+MACBWRMXnx3Hov8iT57MopN0kjI+BQsIvcaWV1Soh/64MQlBelTSIIik2WdrJAvXORDFLaRhzRyISjZ43TsQzGOxfCRNuGZIDHZP0WexyWJ1ORByEbLu/zpLv3pE+sMyBew/WlwMOlZHzFyJ1bu5GP9uo8j8cMwWMYkbZdhCsu2RjOsVAUFMMAmbaxTELDBhj8PA81ADuYzirglaPwDmtGMKZ+SAbKYKEyZUhBjMyHRBmxgK4w+q4P/GBFtZmclKSc8gTaagAmtaOa508fuxs7TQBIhG3PaXhDzDxj0RWoWlZlVsnYYEcUTMqBR5kuQJxnJPCVFbGvM0uZFGs/IxE0SIRebhBa8hkYkP04bAFW4hgK3oaCnsylMYLi206j5pTpdo1ZVMICB13QFLIuBHwRMtAAYXOc6Vl3Tduw0TPQcFH9HMyhq5tYd/tl0JWVb6XuE5J+uYMA/tQnd+ExIAulpDgkV6l73RoCm6E3hH1NggWCRWpXn6Ix2O6vRQVoVABrhbjwxiiFY21QQGTV2abxj4VnxMkrM1CQsG0sILSsWmMdYJ3I6iJDlkNQgB/XgtQMyHxK8pIHQ/1VlMwVw2k1ehzrZxW87wL3f7l7UIgHc7y1tatVa+UaeVQHPrDY1y75Em5/iAeBskXlACnyggRJAL7U6mFzlkPSgf8jWQsPBDXAEWxzkQA4HU8ABCcBnwrc15wG/ldFjDjDVM95lrWnZ5S5h1xbcrXWzPjGJXnbjFxSYUAN1jRyYpFTehuigIHhFwhQqJD0/VAl9fxhBXSuUmw50QDjBqdYG5nQjtTiWIO95T/7qV1YEq+YkEHuYYauyAOWkyUwGMlCVtPQkGUBBShMk4YKe9OHqFeS1UfpBEGTQAybzoQc8CCzsVGiXA3TGTcYlQE1t3KNbYtFrAQ2tQrIyoARqsP+BP/yHFMqAqIL8UAp45mIDG9iFPUvBg3PWswwuUIMPYMViLnLRV8k8RTZEjDrTUQALYEACHL7gC//oghCE+AIh8lAIxBriDHolhEu5wSBnWCKeyyCDDziAMzdiD3QZTUiOWIxlkRvyBWfAaiPn4FNnWJQQi0CsMBZhCz4sgw4eIGYUSZHW0KYMf10nL6ikygE84IMLutDpMAZbW1sIo7EaJ+YwQ/vcDTnA++J3Ir+MQAZD/EcuChJuIULBBx2FH/zQze9uRmsBJvoLAfwCOWw9sCBdqCMLMHAigxy43+hmw34iebU+rYBBH9BAB3CGF79A/OMOwafHeSJLQE4ylkH/KTnIWXlIiMiyLv6ayb88M/POrhxp8HSIvRw5SJjXXF8zQQjyYnLJm+dJ5X+0zydT8/OUM/JfZctXdSUTUD/l3OgYafkmFdbI+iQMYU432uEk+UeGtWgkmUFYUbB+kasv809lvym+UuIQ1bFIPH+azGcYSZmAEp3obPcjvfY0FJPnq2NrT0lYauVSz9BylBbbmu8GUBLQ5Acp+jmLRGbNdmQejSjKXGbDGHKZR5MWLNQRm5CuilTUj/LsgG/8z9AZeJqbXCZAWZjQjxLJeZJtL26ETU9dFoEFRKCnR7WLPyUazEpaRJ1q+dg5bfRx3OcLls7MvlK+4hedwkZssrEK/1Bl47iuYYf1LUGsJZ+PN9pT/6DqPPfhMYJ6sewUNrnZwGDCJjXXmL83tZIXUdEz5RQR6UQ08bdoQLOAb+E36PZJoGQfYeEBz8E1CPFWb9UBpKMVTgEbD/AaBLBuHrUsgKJYScEQ4hF9ipaAMEV7C+iC7nduSvMnlJd+hkVN2NEXNKNRXQE1YgMVrcMf/EEWlvQSfmIZdnFSnJFC41RTHPGCrgKF6FRWwCN/lBdJ9ScVvaGD/pEbgMGBVKEAYbMA0NJ9GGAr/PF7pmc8RtgnbfOGMGAA4yJFAXNOdgiDDQhWCCh/ZmM2WwhUteGF8NKDozM6CnAYBJQYvBQ2WKOGVf/hNAEEP/hVALzRNjCAGNHCIpP1O4oFfYv2Md4hTrPDeaxUenfhNAZUfCzQU+pVfkLyVq8RNhooGI2TPsenFRkCHO8yPkISIiv1F6nyALyBFdexIukBVvdTI3kjHuBxE6IxGpCFGue0UJv1ElnIGH1RELORAurlhTsYOo7TOCvgPAbhJbS1YSQgBsrBVktVM0glhInFVdDIWb+YF6XBJpThibTngA01EzGkHVGBEL1BFW91HbWBG5ADYQKyJBiWYeb1V3+wOekVOjBQGOsChPlxNpp3FnPSWI3VkTImNKhxWUfzUtE3caSYRpjHMST1HEyjhmEBJAexAETyAQKiA1f/0CCTUyU8qSRIggTfUyGD1RVfEyLhVBrgMXHn4ZH082xC8yLGZSdSiTpu4jvPRWBntXbq8TDfQXPHE3xVIWEEQiCvVZY9cCU9cAXacwVIYF7oZS0gEhWMAXAGYCL49RiQAXniMh4e1R7xY1w9kzo7U2MFVpg25kwJcX2mZIoPwy4p0F3dtSs8+VqWUyVSMgJLEFudU1smtBVZYXyOw4peEjq5wQLXEVWLYUVeAzv6poR085oFEWMH8XBk5jCJmXeQpJFKkRsa8JgBggQ6gAPmgwNLcGEFMQJXEFvQUyHDcY4SAl8pYCTTMz3dsxzW8YbcJHknEi1xIxXG1Xj3sxK0/0mStZeYT6E4+sc4DiYcF4Im0sMgBsIg8ok9EwI9JWBXG7ZhA1KWu+I5XoIbiSEzvLEYj0EAXtaRnkFZbRJ9UlQnfFSeCdMSUJWIq8g4kEM+PPlEB/EDBnEFC7IEbQmUDDJkfqAkBcFhtbU8LBA9mZM5zLEmuiOSveNS3UEjcDJmEJoUIQJSMhItaSKdDyEDcUBl/0AlOZmhx6mh8okENyRk1tOkDMIDw9FGS2OMrUIe2+Fl9TM/OepJ19Ui8lRZwogVPhZh1aMg/0BHMuBBU0ZkGAQlZIJkBcEHIARCU3anGFQDfAUveaFCMPJlXNqlHfFH6bcfDWePUHUXFWI5E/9ER55ycFDgQHQEBXtGZ3TmQXvGQQ9ER5zaIIXWOOJhoG/hZUopqMRUeHaxMxMHAddlLW22pnSWZ4wiKZeSaT9UamfgBkLAKC9wapdSq10wA6umAqbyASDQOGfkZfxFm6bqE4HTd0FSFVwxKOXVBW7wKEbEaUM0q16Uq7sKKpvCKJHiBprGazLwAx9gQlumrM2aJ2yAgisSTwMQASPAoWPUQF8Ub/+waWEURr4qKUJEBETAQ44yAy5QAyuwb+PhlO0KKzvjOnfxGheXQJ8iRNfaBTkABR7URZ02sEYwLGfwsQN7BjNwAY1zoC3UsObiO9dVEE11YjX0JQrCJDnQKIzmEkahNm8DG0Zl8AMawB7K6nYq+yqgsaObsTVUwQLvJme+4m0BG7AvUAY1kCqw01gSN7QhU7TzIpNu8wcK5AbCdgabIG//gEREIATHoiotiLVTNC6MAQPSIwOnhrNkm0RbIAVXQDb7sSIPyrbCIy7x8xiO0T050K9EUG/hFgQlABXx07gG5bcg40924TsboLRGxkVkK0I+wHCt2biQ2z8i4jtR5ReaY3ByBgVAqRXy0rgk8rn9Ax1AUjoPoC7kgwOW8wM6YAId8Bce5bpptGIGsS4eN1ckwIj7MXK+S0hbkzUYiLwXERAAIfkEBQcA/wAsGAC/AK0AUwBACP8AA/wD8G9gwYMIEypcyLChw4cQI0qcSLHiRIIHBTLUiBAjgAAfBxQEWeBfSZEISWIs+PGfxo8fOXK0SLOmzZsJZ24kWBJAgZUiRXr4B2HAAAUbMAx4UODBgw1OC0aA+u9B1akFSzItEKAr164jaQr4N3ZsRpdh0erEybatQ4El/6E8WMAo0bkQ/nk4ucHDhgEFFAz4+7duAQwFuJYM8BMs3JZZefrsyjhhSbMCxxYwu7BsQc+gyWYV7bY0zQF5SxYY+m/BBtcPFsR2KpvqPwwR/rFgoVsDCw1TfP8jwXvFFOMrDsauWheCTwAQEneNSTlm2AAEMpt0udgk3IRjsWf/1WhWgOfPptNnhAlSoHuXAwSKbAr4gQIWJDTk14ADyQgcBfXQQw019DDCPzqMoCASGvjGwgMYsACDbDDkdQAMEwYXHHErrLBAQdGNxNUBjMGVGATl/XPAPwS4dIAAAQiwmXkCvfgPAmMlQJp6PN6Ul1wlQdAifsApKOAINfwjYBA5HCRDEP8E8cM/CgZh5AhWKsiHgQYmKaCANUDZA5UfjDBFBA9A4BQBLRJQAJs/BrCiACGi2OOdeHrnnZAQBJCaAv+sQAKS/5QhRRcvEPECov8Q0WijL5xxxkFCdCGppV38M6mkBZ3RhRCLzuDCDx+QQNYBBayY56qstmWYXs0V/yWSCSUUdIUUm2TK6BlEdEFELgct+kMNPKCQqputJqusWwUs8KFVEGzwTwQj5ODro/9sQQQRZfixwWupqhjXsuSWS5FTh9FXkFUs5FYQVNJGNNNKD4EEn3VoLdSeufwqK5BH+sLUEUuNxRcfACJFB5iaBUSX5gOo5qUABICKxNhkJj2nFkPj9utxQi2xt953CJ0UgMEbUGyffblZ8A+g/0gb1QHfFvXAXqgR8AAAC0zn82jbPcTZe2hxdt1BoSH9MY/sffRTYtupdlDNr1Hd8AYnArbXSXIRBW1BdlVsEE9gm8Snm85i13C+QH/XotJJYwYejC6N9fbSE2n0NMbQ1f9FlE/vQhDB4AUNOgUOCiL4jx86MG4gEgUhMcUUYqzAwgoRPJjY1h5grFpdCUvXZ3TfUeYVi2GVRTedoaWoogAMoH433hERJPJcBAFm1ADuSqWbbiTk988UVCo4gn8FacAggw02OIV/kCsP+T8M/gOcBtZPGwEMEXS4AgwYQPVmdAKQSKJ5osFYPnqfoUjAj7SvelJ00Vq1gNQP4DeCgTKUUQYUUCiUFAoSQCh0AQr9818ZcqDAf0jBUFJ44P+6kCko/K8MQchgDT7wAR6swCorkhN25GS0+JlQInkhnVwUkIJ2aaAHmJrBCxYlgydBIQeH2sSkIOWobe3Qgf/4QAT/3IQqNp3wiD1q1rhks4IPyMCAmvrHJhyVrX8A6wxl6ACIxIXELqonSCkLI1MeQAId9CAICFzCPzoAlei8ryAEYMNB6MURgrTHjiLzoh7x9C+WsO2OgIRMfAbClaDNEWR+DBpG1rJHEzLykCmxHUsCSRKiJSYxC/ucJtnGyUc2clV09CMgEYmwspkkKAeB2WDq962nxCwx32pKw2bZsBINkpNA61hDkvZJiAAsIYMc1x0n+RyUwPI23/JLVd6Fpty4xllPCZJJEoMqErnEPZ4UWko2lhO2naeXOWnJvoBysnKiUjBRCV/MsKaAaG5tMIBBDFMUNp/qOCZfkqSX0oh2/80SuidF5wGNedCHPnAOpJyAK5nU6JcyxMTML6iZmAICk5iJAuaUs5SVXTLGNZc8Zy1CghpRdBIjjhgtPOlLadI2g5ASftJvskxTa17zFNk4RWYxw4ACMOC1iW0gcwdBAffaxT0YVAVCRIlOXQTSJ5dAgHymiyrbOqYd9RUNLuERj57mdL4d6dFkgPHTLKOmnKCyoIUNKsGgDqQgPxhvetG7nIScwjCuPFUx2HTPWEdayLyABaUh9Gvdujoa1alUj4yJi8FOtrfGrsspsYlA8II3gg8kSEkBilzxjtcgFviABR2IAAYwQNfFpNAkD8AQZFPYHT0xhk4lctF76EaAgP+qqqAF0VHsdNTFQCJSLroLzAPQNFyEaKAEyqPegZBQghIoaHL60UDmdjO47V0uUPlBAhIQ55/jmep7E4JYqmTDnEseoE/mI0935lTbtdTWoBa5KEqs0prcsGAKieMSW/8xpYOMoHE60MES/KOBEfyBrX7A3vCC06DkBQ+/z23QCoyF1aqWj3V3Y10KZwdfeYUEk0QpwGski1/EEUhJZwxCDxDI4oNAKYP/eNKYkvSkGgehhjLIQf90nOMn8UHFIyiwBjrEFBahikXYQSn8OnyTV9kxTt5p2ANWoAEO/qCGDCzDGdzgqUsdqlKZEgKXufypSL0AiAPswgANKAVrlaH/hgQqEwoWsCJVLZnJHpMmwoZb4B8w8FBleBQRlKCpLuBQClCIoBAI6KgzJEoJRDACEST1gjJcgAQLEEBtD6AqPHsxL3OBSgdIcOUy8aEGS1jCFVZ8Bh1OKlEI8eEZpCADITor054GZ1yis6L6oQUGPODBBfp3kAoWJBeSLoii+DCFNBGAZrnO9V0/9A8YUFkDZXBDpzZxkC1swVbwFBJROBxtg7oGArLRyrReCCUpEmGKQUCCAgCwgU4vgNzlBudSQJQynwLvHzUYQQqWWRWGyjHfCFeOv3EyL7TgMeEQ7ybAsjmwAdjuZPDRmz4jHr9QvuXhiTQIXUyZEb0ZhOIc/79TwweWyKb58ZeAjI/UEgmWSYJl4ylvSx9P7nGRhwwkIvEIShCm15MFhSvzoQtlrnnys9Q85xbpeUNWUk6DBJ0uoQtxiJo1xrURpWv8TAsu2Qd1iHhyX2ALyUjmY/G/gU4BQ6mYRJvylK38iJ6vAnvGPMp3iqC8wztfZB4dwna/oYRiSAlf3WlD05hRGypv+1xI7KURe1nkPSb1tNRHIrKVPOckhgFcURCzU6oMt+4RcM1PUfCAOcdMqV1bDHUsA7S34PKbVi3L33s7eM4jNGhPi5ZEobL4d8VsOfYTXxjdCAACAGBFOM8bekCjk2/iWbEMmfzkgRQzeMZrXUeFl/+IX1+YS1KzAGwAAHV2382Uoqf6oimp+uSPzbE38mCNEVjU5jNR4hcEoi9TF31hGMElS5gUVV9xUF4RWzmhGmrTJvkyLiilLxuDedzUSE2DeT5xUfLUFHnhAdGBMxQDOs1RgBbzHfmXUIUEOPhXGQqBKoW0Oi1VUk6HUhYYdvaHRO8xLjfjgSlEP5uDSQM4MSeSUSciLaqBGmNzSwmoGFDzPlCYAXRWFncjTENDFjdYgS0SIwfxNi3iUvGDcV8XYmmSMjO1eNGUF/VmGCdiUYeBEFbBU7dhFUzhAfOhME8FIqMzT+cVVRyxGHSzIm9DNFx4dlY1EprGfuRySXrRF9v/YVOyARtUES91pxuDgwEdwBumIlfecznJkRvDZVR3VX+J5ScLWCL/lBAkshkMCEclEh5UlSIlFSNcAYZLkzVFoRVPJUaQ1YvTQl//kAIrkALR9R/PMzwHMjwkMAXLeDkwUFpL9RPOUUuK4TT5ohM/IogmEUKboRgtxXRpISfb4SaadkRCETSM0SdBqDAb2E7TEiiCgjgKggM6kFlUQj3U01n40SHP+FRdsTCmExZ7MVIWYxkwgiKsiIV64R0w8iK1ZR4tkhfZ0Wuogx68tTTQQRDO8Y+VN5A/oTVNkRuDQyTz+F9Ksj/78w9qpF2X5Ru+0QF0NQBb85EWVxRqEi1P/7Uil+QnaOFXAzUWp5WIE6kROrk+5fheSlOReEN54rRYg2Q7WnEYUEFlwpgCBxJgIzBgyagDSMCV0MMgv/EgvnhXWzRlHbIAQrUA6GY23KFXdpWO7kEi2ZEdY8FeWGg+LHKRL2IjjSQTBwMYJdFOERBaoUWMIfAPyFUCSxBg9ZggxqMgyJUf7bIb1bY98GgcylMk0cUbR6WTcKEq5zVL2YFktfWFZGEnMkIaCJBbBYEj+HZCO3gv02QUG1AxtblGA2cCx3Vc9/iY9XggxMOM2MMbkqVgwrMEI+BWB4I9kuMgdPUjRsU90/Qm5wcnI6ciIlQQe1mXXhVx6kRawxUBKP8wnpxZWQfxAXxQEB9QEMvlXCSAXOyJPcz5lVTCPMHxG83DjLuBPVaRkJq2PlvIJvKHIrQ4lyknhnKBk0SxAHI1OcUTBAUCcFAyJWNyBUqiRm7Fnn6QECm5WRCmIB8gJgtGAtKBGXN5GSAyfy/yJorYYT6hGvDTFJZDWf+1P0nyD+kpAz3wJDlwYzGmYuwZpCg2IDWwJQOCYzh2Yyr2AQE3Au1yJsvBiG8jIxfGJrqUczCxGiG2FLSBApNpKv8xAjKwJWh0EADUP08kA06SQUySpjq2QBDkP10QBBj0PzK2P/jFjEWmnQYqbmXXECD5dVu3RVWhP1jyRHR6KGkWQWj/5kCGomYOFEGHgigRFED/YECYSms54AIycAETEGzJ8SbvhZR/GhGFtBh4NY6odV+Y5UCI0gVKcGbboiieMmaO5gYzxKiTIgQD5CmLhihcNgNSICo5cGrFcgDPVo6lyhZ2FZFrAz+SFWP9E0GIkiiw1kNn5qoR1GWT5ik8lCiO5miW9gEb8Gxk8ZrL6haCJR9rNAUD0gNX0G5nFild8EQ58GeWEkXeqinIlgvb8gIDhBDPRqrp2iMl4oQIY3EDwAJjQqddMAMyMAM1cAVL0AM5UCn/kCm8Mmj/AGuU9mYkgB3IemQFqywnwRoe0E5H8VMPID0Vm2hAlCng2mj+qgSz2VYDx+Esb1Syy8IGcgR70aIcw4UkN/oPv5qtm3Jsk1YGAechO8uz5sIGqdIxV7MAKxADduA/ZyYplvor/sortNZsyAq18SNHzzZLxlGkUtBo75YtU6QtZ9ADBLE190O2eJMqD6AzB/Ah9zECWsYrufBtCHEDGkCE1XRvdrs0Zfh6dEgtQYArm8BtVISPvXa2JJu4/bKWEONKuGEq8RoHRqskPtABE/UhiHu5mMsvHXgzDXUbg2JcMFNvIZa6JzQUEIAYGHC73TM80jW7TUG7XcRTKgMhSEUTAQEAIfkEBQcA/wAsIQDAAKQAUgBACP8AAfwL8K+gwYMIEypcyLChw4cQI0qcSPGhQIYABggcEMADwX8DIICEMMBDgX8FLhY4GaClQAAnLw6sSLOmzZsVB6AEGYDjAJ0iIRSAsOGfggIYTp78twEDSqE6B6xcybHlwAJWCX78d1HgVogC/oX9qHVm2bI406pF+JLrQp8nOXqASbdlSgAB8La0WvBn3Kg6BwJoy7EuTK1YE6Mle3Bx2IIfw0oWizDAY8prM7/duXTqyqcII6xg8S+FBg04RmhAknrEvxGwp/yTPWWFbRYwHkj9PFCrXbsoszbsrFjpQAIzxS5FvvOxZOQCoGtem7c6Xrw+UUpVYPRfhIIpInT/+NehQwQN/0hogP16hHoSt20vyI1ixb8V9adMwTGFBwnX/2lgm20PoFDQA/TBgF9uD+i2l1gEhQVBWNKJJMBkAiBwoYaTTechRFvptEEBDyyAAgkklCCbDjX8IEMPMsQRRA7/0PhPGTmUUQYUMgTho4898NFDEC7KkEMOLpThggv/MKnjkzzyGEQPVPawhGrwPWBQAQdYRoAAHzH34Zhk7gQBAUINJBRSEYzAhwsuQgFFGWecQcQ/L/wjRBlSSAHFDVDkKMQZ/5zRxT93FvqPEgUp8YKhBS0QwJdilmnppRN19o9IBwy1gQIYsEBCDQUFMaehgxpkZ51ErCpDDSRo/0kiprTWStMDGzTYlJb/rGfqGVAk+s8WN/rRwQZCdUoAl7Y262xEDyT1gAdGYcDrdHhxxdJhPlm31bduESTTs+TWqhFKMD0VmFTS/oOBVCBhkOsAThVEFEm8FlbcVZCJy9hS5QZMUU+DcdWTdpwhVYACHgywgUYpFVAVR1h5xRdLmYFpVnIbL7YxZAdJ9pXANsmk00omeabySLMW4IECEETbYIPffYcCDN8VhAEE1OqUUcW/ZXudSwwFoKkAWGHm3MgJaTyQyBeSnNDBH3Fk8HVDHUUzigJq8J9rr6X22tiqneYDC6NFsOaaiZX008wRlPhAzFrO7ZVIMA3VGXAsgf9pmdFG/3MA0gIMfoBYURuEgEGXSU1TXiBJ/MBJD6BNgn7s9VAQbJr/Q+o/PegAG39IsPfaHwXph8TXs8E2wgev1/DB7D24zpp6oi2A1ZeBY3UAAX+DCWanjpN5UQBpikTzbSPUUIMMOOoIxY2EqnqoG1J0IYUQem5/6AtuPNoFFNUX1OcZfGovxQx8yHDBBwvspNXgxdffEBtcnrnRQQ9oUAMf7pld6UrwhCtMDwpCIB+hDEWELtTpDELoggty8IMRbGABy0KT/Ta4lgLoblOV+wcSclS+gxBhC3fiXl/mVoCicPCFNyGKB5C1gRkqryCfQ0IEIrAUkQzlH2ywiFb/vDITTaXkapCDoRJpMq6EtGUp3QqMUnpCxSNC7jpIbAvTlghDLIIkYV/8BwtFsqkfXutABYmJW0DGRRieLCNURAnM2DWrd9UQZgbhToNkSCKJRSxbvkkawNg4EQw1po03AdhGDqYd3UxON8j6IsRWsoHfYIVifNtL41RSSAh1DGRn6ZjwtohIt7yEijCJSuQkFscjcmsvF5tJEwNnkHE1MThgKsBYkEYWvnwllAoxZOM22JaEkAR5UukJBA6GlawMZjDC6csAFLCBT+UqWgor4tCO1xuCrAQxfgvn08YZPDYKM2R/Y45zXhiYyJGkjCtZE654FQGc7fA8KziN19Lj/zXZnEY2BWHQ3IRSHY8B0mBsBBwveXkchQCuiFvR5UMpE7XEkUwgriRIYagoFQjATAE7fI/X1jMCHfxDB7XrQemQUJAS+MAHJmABC2YWz6SlESWeiplQ0tQX5E3NN74cy9P+tqnmfKkg0cFMQRb3D6ZKrS10UYpUHnDPCKDgRCMogXpwoIES4CBsosMBV9XDAtGsYFoDDUm9aCYg+IgKPfUU4wFIkrf8QeCuwQHAMjUmmb2q80vRuVDUDrC4xXXohV9RZbx09ilq0kym/5nC7P7xAcqijgSz+Qd/uDqCKcAGs+n5xxVWip5esUADovqHqFDUH8/WJm4zQ2pLLhSAw//NVrBiod86LVNKh5DEZbM6kWc594EeFFcGBfnBkAyi3IL04Apg64EfXOOa6fagBlXqwQ9cBCMZeJdItatBZzUwBbJGYET/IADwCDA4ogqPoL11iEYPpleAaWkFXxsBlYKgoxnx6UY3KgOA5/QkKejIwH3q0z+y9w/tjU9O44swFEwVBBn8QHbyQcngRHLU+CZyi7Q8wAEGEL8IsMCzx5WCG4TwAiIQ4Qt4cnGLH0WEPfUJCj3YHqG6sImCPLCBj4rggmlUWehIx8PPelBf+rIBAFhAA5rLQfZm8F0kWPkKPSAfQoRFhFwk6gwy4MEG1CuWLx0OycVjw09AYpKSCOX/kf/wQQmW0IM4/ENOZ9jEAv/hhjohqlBEeIELZGcg3qAZhrNCI7IWEAHJ8kHADrRTsAiVC2IZpAtdGIG1hOLCQ5eymrprEAagTCcX/9mEce4Ad87Eak9/ukHdwZVMR4CELE/vzkjoAGkMgqZKubqU0pqhBx6ggAfgFwTpqdu9Ou2QbBVkm2H8tbRlWZ1aWufZGM22dY54tWl7uNoFoy8trQ3KL4q7mN4O2CmdvRTsMPMgxEGXxJ59xTUOMd3PaqJSoipFqfh7kAAjo0HwJpgk4ttWHB3IuoQNGu08jCl7zNU/4qele0nFKzbd2CCndvC0sKQwUmmYyx7m0Z1QK1ck/xrA5AS3E2Q5bKOwFKRCuCmRswwz3XnZ6MlMYhSSqFyM/5ihxMVIFMnpDSVtpmK1dzKcmpvlMuc8rKuzAxd///YoKj9KUh4msZ0e5pUPCku701KWqFP07EqN73zdjdOIAQZZjvXjT9YEuLr7pjdBPCQhH1L2swvP74Af5d7diC6Fr8yPTxnR5Py9m7rThSeYNDRCt2SQaoMYqZiH0DkxjyFgasVpiNWXu19yTDLmPC+v7M02XYKYoSFkXYssaO/q3hteKwf0gC9nuT8fPFI6Ky8pQWV1rMYTgnIEAlGFIzT1khiE/QRenIkKHIlvlbZ1szd8jRBCdll5kX2y98gZmf+vi3fxgVALJh7p1DKbaReAUa7Yoq6bGLWEgZcFHV7Az3+/YJkVJVceYGghVKE0Skn1GCeRVJn3VBGDTEbjEd+0LLUVSRMnRrkSN1WFNqIhU6NhH7xSInfFSqMnHHtxSw5FSu7Fa7OFEtwHJsAzKdEUMFiBN6WXGPHkQiViYjhoOV21GuvxVSN1GmjzDzCwAHvEeoMREyM4eZWXdjOhMZFxgAm4hJRhGTeHHONXLl3BbRRTMDHjHTuUT/p0GiOAA0hgUia1OQYhU6e1Qw3yTYADPM2UJiSyLEohcEwHMsP0ID5lekPlSQqBHIYlMD6jSAUXOXvUIGB4Wv9xUiVlEK7/kxpIoAFn4wP1tAALoCzfpCZGMXINQoRE6AHvpC9rVER3SEucgktoURnIAYWG1CxWky7aIXwZQRIeRVUrkAL4hRr7QV04RF2wUQKoBYQztTMM4xchURS4AgNlVVYmZh8wkEaZuCkEsSYKlxy+gzyzxRd4yHKHIxlhUVg3JzUQExVURTMRkAIIEYabJTpjiCIkoIErgDOwZos3YznuuAKuwVIB9YxlpDyeWCJM9xu0p3nDQxnI0Y1IZVhOpW7egjXpcjIjUk3fcSxUhQE7VFa9Ahth1U+3QRo5E4YpQAJcpR+rURCs4TVqOBozpZK2oR8yFS1BsRKryILplFsfgZBo/9dbcREXz9YgM9QguzZcvHgQYHMQXWUQKDKUruU17riIneU6UCkG+oQ2aFMilbReVuiC21cQh9Mlh8ZJ8AIBF5lPU7AexhUEngM6aokQVvJcJTUC0PUamrNSzkUlzkMlzVMlU1I7r+MeaHNWZ8IlgLM7jVNbXBmOatdOniI3K4A5efkPe/kPMiAlPgKZPRIkoFNcxaVfFzYlPeJd3wWaOWAkn1lh4AUb/3RVWqI7wHN7LEdmBxeDRAFxVtWDjVgqMzJhOQKZOyJgPAKa/GWaOfIkxJlgBgYFXbAjfjJhOBYEWOYeGhA3JwEd04iY0wYTPvRmJFJ0xkZezRMnPXJpDP+WYHySYOrTJ9jTBXkiBQ1WKOx5Z4dyQOPjJ2XgXRcAH5eoS4hjhx1nEPjDE3dXVDe0Hp6DXKNZEOHjBkD2Ag7kBn2GaQzKoKhiPsjJPVKQZ+NzBheqPUriXTUwBSjwAFbIcv1pEzE4FkYDlKMiA0yCJzvGKAXxKA12Y6M5J+9ZEHoWo25QKA/UBTMAJzyAQYF1ZiVaE0GUNPOzUwbRJjpQa2XgQOqpBBwaBEtwBUtwAzTynq1yKD6GEFKQA5XFKx1WpJkxIZAhhz4jFeMhA9kzaN5Vhk+wBHZ2Z3dyJ2fwoJDini7QA/AhOOpVOGR6KVYjFArAHV/IaKfFBKIlIwv/1p6Hop6m5mdC4AZlACv2kV6BSitsgCwnMZvacRIdUAK1hmVycmeQciiEYgRepgRn8AJKUgMrgEFEmqmYInAtxBsXhFnOQyOGcig56mUGwaoNNgIzhUHxQ6vPwgbLciC5go89IGB5ahAodBAywALv0kITiKwkMzOjUQNBYCc4ugUoFAkGcQMr1EKeqq3kEjMkUhQWCWXZswmbIK7/0GMF0QU9ACrIQgDxc4XqWqvcAXfuwgI4MJl/Yq83UEKbQgAiCgHH+q/O4kNawh3yEio4oDkYWwKqBjMelCxlBLHJ2mkBO2z3URAf8FXyYi/wBrIkQ0MzRDnNmBAbx7L1U2wKBZB3NREQACH5BAUHAP8ALBgAvwCtAFMAQAj/AAH8C/BvYMGDCBMqXMiwocOHECNKnEix4kSCBwUiJMhxIIAAHwcEGPCP5MGRI0kOgEBSAcsCHw0WDIAxYU2LOHPq3OlQo8KPQEHCfAmgwEEFBQa4LFjAaFKYMAcEnQqy6kyDNxdmfSjgX9eOYLHK5Em2rEQARf+FTFt0rdqSVqsCdfqvwEiZKgfolapSIE2SMD1e7SiTJlbDYQlvZMhRQIGuZiPnHBmz7j8IBR5A2LA5QgQWnzVomCK6tIYS/5CMGIFjCg4cGnx4fvDgI02Qg283hQBBsc2CkL1idFw3gN2rjGcSWDzWsuTnBanOBaBSgYINGyL881wwwoMIKMBz/ycx4sPqf1Om/GNB+8GGByxYrICxgsV2DShWaGCNBLYGFimsEMECBdW3woEIskDCgd49sAAMD3hAm2UB9EbcYwf8Q4AABwSnIWQZQieiTh95UMBm30WwAgnkjaBDDQX9AEUOQfyTQxlQyJBjEDLwGEQP/8jQw4//BPFDDjfeWEYZUkix5JJNOglFF1JMySSOPfbQAw4kRLDBTAUsd0CYHNa13IhojlgUbkwt1xQBBWRo1Gfl9VCDDFH+c0YXZ7zQRRk0+sAEEktckYMUQpyh5z9QEPHPC4oK0WQZLshQwwcLnpnhmWl26mlZmF02Zl0DJPXefqsh8Y8UZ2zShRD/EP/RZ0FGnEGEEf900V1BnH7q66+SbZDhAxho0AOeRCQbiaPJOqoojO/FSQAEwFZrLU/UAubBl9uxgMJ2BC7ALUQ+GeTXVNG9VdJJJKWlFlQFmXTtvNb6hdxM0sFUlEh6PfVAQe6xhNQ/JpZqMFpyoVRZTWBtRe/DF52bsEhTBfWWSQTFpLC+IAVF8bvIGTWWRuU2x1BXX4mVmMpYQSZAAB5CLJlQ1MElVXQw0VRUU3U5dWJm/7Q34b//oBDePwtgEAEGQfNml22CIcbmQuWKPBDKXmUNc3Iww/xyyibLTFHClRVEbWaZxZcfiyOQ1xqXJGjAIglTxM0ChHoVXGFTMGf/y5uEQj8QIAn5lZSzUdRattvPTBnX1QFdB0aScZYREMCml4N4mYZiW7QVRzEJhDhn7y2wwhSq9fABkAi9qOU/QK5Ww2o9pKpBav+QUNB+5tWgehC+B18DHz8QbyfwPehQ+wgapPBAU4/ZFT2cHEH+8kBwdu4pYU79uwBt5NVwpww5/LOkDJUuuaquBbF6kBRdzLDn/Hu2r6uirkKxSUF8utrFJjlwwQ9qwAMUPMVlbNCeAifChgZSLisGS1F92qMBJjwBCT2AwkE2AYUzwE8IfOIT/17wjx9waQEL2NQCV5imaQHsHzCYQg/4oMH7EWETjtpCLrZQEEf9owMK2Fb2/1hIxBGNi2AuwcB3NKCDGvXgChqwAHbc05QNhOk3GdlI2bJIsiJ6EU32Mhe+5PIWtKjrJEEBiUqeUirjLGwsDvviAksWnbAUJl6JEwlLCMYUzGRrXRRL2G1OEjY50usmGonjQc5mGAwUACkFYNoGPMCUeBlOKhyTztQUkpVORgRrhTSkVu6VEaPcBSGlIhUbS8KSjKlFLkCJZVvg4q6ZDNIwZIHMylZGSFEyZItlxEhMJmeb21RFZx3DjUDWNLm3PPA4lUmkTxSZtYZ07STXY5lNrklKUYakKoB5l1sCaRug1KVm1OHZiQqyAQy8xz1W/NfBSjVLZXLkJhjJJ3L0if+QmHFNAC9bTgAs5xxf0vKgpTobtb6Xom5hwD7x+Ydo5pY7if6jPjDQS29uozGsLBOLVQNONYMDNn025mq4rAnKBipK0IGTYCcqFW0+kwIFtWg1OECCDviDgxH8I0ArQAFmmrKmx/TGK3bx42XE5R4URuBsJ1GpSJ1COZFRiyCmdIrouEkQy3VoQ/+AXK86t0yy2cVgA3CPOz0zN93F7a1ye9vc2EMbzrhzAI4cACUvAzj2eEsDcNPAgSAUqgVAwLC0eRBDqTVU6HEEAm3B6uUyJyYBgDWsmM2QZeU4naSMhGeqTChngkYbBE3Bp/8YQd0WpDu5xa00biUBDnY6ghL/+PQ/8kHQgUazGtWuRgcfuNRqpqCg3KJgAXZ5bIVYCgHiYCRE0DXoRUxiIs08gDS9pV3wShgkhAShfAUBkpZGUDvYFSl5WvoBj3qUAxm497066pGRfqQl5X1AA975hxUVh9KXdciUY5VuRNhgnL1tQFwLYMF/dDcCPrQ3CDOCQg3LYD4p2Mh8V3oShpnUpFXlqSAd1OA/9idiXXUBClXqwQCngIIvPYall6umgMmCEbpYplTXeV6OwxPD4LrXBW6YAaT05IYRKqpJKObwq4QgKT3B6lVU2pOFLzy7Lr2JQ5ed8bWsdhAB+NEoC4hA3ViAGhnkylLuXU0JkPCEK2QQ/4T7c5WizrAnJdC5STnA1AMOcNkAa3mBx9GrXp53IuOQxAclKFQPcqBBFMs5hCRMSJMspTs5/dmgDcTMAUIFsPyMwHdQKIOiGCWrHBphC7aKlRvK8AGkxenSsD7IOlEgBi2JuiC5iFVBtsAsRi3hHwpICJdjLeBoHYRpGvhBk26gwRtK+Ao+OAicpuVCYsc6Wx5Yynp4gINL5Tdo3HpAAq1N7oRQa687KVdNzFnudickjK5M1xnRSLaOtEUq1HT3wxD57nTFpaNG+ShaoFIzpriLTfnWNxiZM8p7wmVdB/FAqSSeyqb0xZQMRwgdFV4WeL+Sa5VUHCVJYqICSEgBaf8FDD2toi6OKpPj0OG3QwyDOFnn8bEAi5Y8ESbIYppz49aE+Vmo9pOkRBwz7qSkAiaUFAhsq+QHg6VccmYvfhJymkIn1x1fqUmVoAQzA5hkJLETtJWs5CUGSyZavhlZsWw94UE/qYy1LPOG7AsqATBR2esCAUhSEgCYaYvg1U62wRSHk2Hs5j+zhrXGMx7WVGE4SsJJz4HgW5YuLWvkRVqQcfMT7oTcmuNHP1LhZNOQkSUnm8o28VkuE/NV1zxKpobLyGyt9Lh32eNPDxy5+3Lyd+HXQLK6JoW1nN4kS+7wly/rxp2zwFnp6C1B7/h+sgz02jOKSizTlsCo5fIcwXf/uwI+fur0a+T6NfmX6GlKqA7E4Yb3zcnm3k9e2gRsRNTLOUsyzrugk91rJDInMiYQIDTekV8boAAYEGyphBgdtRGI8X771E3yZ3+cw3lw9EXUQTOWF3yMtTmaUYBD0x4w4BkA8hnrISAoOBOqV3gsRxib1HuHcTUTaDICOHxYxSs0iH3WEhX3BBWbEYT/oh2fsSLxoWAWlRr+EQG4VR90RXUclUWKcxy95BPXQxMvQxD4V2DFMWwU8mKLNIE8+CsoURiM9SUToiLyoSASJVuokVo+pQP/IIcSpTYOYkzTRxOL8wBnYlXqVFAypktcyIXDFxwRGEqWNVAspUAiQzHw/wJTlzFTKIAfcgOHtuVTqpFaqsI8oEEb25J2TfEV0rMb76FEnqEddWVL1AJ0VoNxm0MXBZZcYAFKzuEy/iQzkcUWQ6EAs7EdDJZaqSUaNTVRqzUFK5BtBfMzmIFVe/Eep6gi+rEg4KEZO3MZEJAhm2ZY0xIqfEOFjNQbK7E1DfN+kIOBiUNWMSgvJjFFTEgCxdUlnhEezXMaB4EDKRABC/I9SvQ8EgJDD1CCn+EZK2BbOqADXOJaK4BCpGU6D4IC9DEftGEwfPcUgAcAHmAYKXN7vLJZBIGNRCQdUrEzpoId7tROU/ROtCEf6YFaPkVc9bE56EE3B5ICppEqrCEaAv8yWAehIFPAA3TzAaeVHqRxhBDCHjDANx2hSx6CjdezHH62QDVhEmcFSAjxFNSSWAdCN5lYOyupHl4ZN/9QAm+TWh9Ah6PBIixQNwcilJ9mJ3YyPOqlXrMjBqQxGijgIFfBewbRFYkTY5rVbly2LYf1ACvSW+VlJ//wAUYiXublOjDSWwmBBKf1aTUwQD/QI5fJI8ciJEICO+m1mKtBApD0h6OIEBkCAdNyi9amTgfwHSggW3XyDzCSmTqSmd/FXj3CXT+gJUASPD7iXoCiI5SyJC6AYTcCBRAmX0FAXzqAXwjmM5QjHKj5akLXLpvxPUGjOz3Vlj2AI3HAKMIZau3/lSMXliOA8iRP4iSTQiVOsiTsWSWroicSxkHIGQQ7NQVe0o0EsCGoOYaxhjh7s05EuCI6kJk/ACWrQmFQ8p5UQmEz0GFN0gVDlitTtip0phAcdGKMUgbudSn4WUmUlXUMQWASWJXbsSJ0Ux4+dSmVKQNQ4j5+MgP/AEKQQmdDViVQdmQF4UGbIAX7swYctAn5s5i5swGlkprUKaIQIS/LV1XGAT0mpyKf5gJPoiuy0idn4AaQwiRQcAVLQCiGYmJE0AWy0kNnwGE58AM/sFP5uACbtVlKahHniBle9jJUeBDgswLcKQPseaYuwAc94AM+YAJrdgUzyj6LgqiQoitS/zADeVY3fHYQIRKnkSEnVzSAoCUQLOBToVkersEESxCqcXAorqJrubIqiUJCfSJAuiNtfKaalFoWHWFxWGV0Q4V0ETAobQYkjbYnT7YokaYnTmJmKYA0YhKrvzKKX2ZFYaeACqY8P2KoFGqlbkAEL+BDRqAE7XMBSFMQk4qswDJQvcGNmUGYPACZEVqqyRIrRuBD/6AEsDICCXkACzBu4Lplrxg0BUECH8AHNaIoIrY/O4QrRJBrHoQe/0IAfHivYjNu79EiQeA+ZLprBbE/qLYJNVIXHkAgXsiw81IA4qI0+8GnyYI/PPQPkXCyqaGAktqtHgsxB8AtiWMsOeCu/1nAQzjUBTKABEwTNAoLky/7MCJDOv8gshjUpSR2BUxgAT17jSGysEELMQW4GSaSbfChHSXUA7cDTxlCOucYtTIDNJbxHinIA63WNCeyX2DLQuOGAVRLLDkREAAh+QQFBwD/ACwOAL4AtwBUAEAI/wAD/BtIsKDBgwgTKlzIsKHDhxAjSpzoEMBAiwL/CdyocQBHgxb/DQBQYMC/kgX+QSiJEUAAAC5hynz5EuTGmBkp6tzJs2dBjANzavwXMmTNgykHFiAJwKPTlx4D0JQq1SVNghkxSo0YUqKAf18HChDqs6zZskwJxiRKNGtNl0OVBiVosi5RpwPswowKV6PArmzjmiVL1mDYs4gT30yZ9wGEBywiPIjAovIKDSM0IMk8YkrlyhEwPHiwoYBpnFTVDt0oIGUBxweSFvz6NcDhjGPBFgggezdBAr81EpBaYOyBsMjBJl7+kGZd00lNKhiAQfTo0RseoFixAgSJFZEjSP+W/C9ChwjlF0RQX1nDlCmd3WuI7HjBAhijI6Ag8f7Ph/988PDHe/x9h8Jo7bGgHQELDCcAAV8dB+EB/zAwUAL/IJDhhhoy5yFiJT022j8s8DfCBzXkIAMUP0ARhIs3QFGGDAPl8E8PPfwjgwxB1BBEGWVAIQOQRAL5jxRSdNGFFDYC2YWMUDwZ5JNQ/BPEPzV8QMJJAQAHnAAQgEWhhLZ9aOaZvOWUEm+rzQXTa9qxUAMUSUpRRhA5BNGDDjWUUYMGgCLRQw5dCHEGEYgOBEWUUZbxjwsy9DACCRFAsEGasQlA4ZmcdsocGwNlKhxvBTxGAgtTyCAFEWd0ccarBBH/8QIRSvxzRi5nKCGrDBc8cMABwHkq7LCcBgCBAjeW0QURRvxjBBFbbEHQJoiW4QMGpRJQQGyxEevtt2eNmN0/CzyQ0gPu/fPBSRtYaulCQAkm1FUbmSTSRTS5ZJJrvA2wJlCAgSswsYW1tNGabRZUl7FhtjsusiiNFNPEMF1k0cWCqXXUwByf2Zde+XKklVVV+YVVRoVhJe9WWvVEm20cfaRyQod1TGzFbvVlMExbpRTmiBgM4MFk5T4AAwwrwHDfCgu8NFNqF288EW1glemVWP98mVJrJ9Vsc084xXTudUYvsAIJOPwzxUAakJCCBilQ6vYKKYQ2AAT+7uaSa7sZ/9uv0Bh89h0LBz5ArlRjpQRcbCuptNJueWvLb24vQQAABAIl9aWX/1AoQIcbYvg1TwHUlZe9fEPX7gIZeNd22/CdCN8/I4xA+4n/9fBfZoD6kELdEXDHw38A1sBHDzUkz+PyQezo/I49LP9DlissNVRYXh6mKVhUjz4wXHiHuUINOnzA5w/Q1wDeFHzSKMWR8A/0PpJn/FOo/Ybi/4+jSQqxqP3/2EQXBDiQLuhIBskDQd6yxkDvOdAnGwlAtw6wgX01RSSlMk34JjOC6D0BCVdYFKOCFAQp0Il+SyrDBx6wgDHN7IEw5BQEFpCSAxhOPEjIARRgBastEMFW/9jCJv98SK0gfMA+BADWpmLIRE/dDSUP8EBePKCADvzoBv+4ARNMoIDplOYkpbIhSC6SsTEGBWApa6IamVMwjQAlcx0RiL1GYhOngHFhInPaxNoSsDU2MV45uUnpziiziyzFWP/wQEqQ9UWW6DFfM1kLXP7ixqv4cXRFyVgaQ0aSp3iSN2GjiihJZpCQbQUiaWSI1y5JkUy+kI/OiVhJ7sWUUE4yZlSxSigTssnAQKR7KosZ5QiSG1Y+xCMKidlJ9pZLUc4lLpy0JMqeKTWK1KY21LwmNGn2wlQa8yCUfGPYnlmQrfQrkXWxVHZe8w8Wks1yqBGZQ5LDTXCWciEP+kqwgvX/TYSsZTWdVInhsnOd4JVoPj4A1HumcKr5/KMD2MHbIQvZloSlEjfKwdo9GzKc4iglc13KjUj7qTF/kWQl+RFPBGDAgrONAAe108A/5kMZFIRnAxtQAEpCRhDZFKQAVKQMC5S2KVFSDjmBNCSbfPPR4uymcaY5SUKyJ4BVqjGaTVmJpSaDHhaYwDziQYF+VJoCukWABBjwQNAkRhKV+IU4F8RAB1BVOxy0jQQosA+pePOrfxztrw5IWtFIo5QBLABvoJRqRhaXNQm2pqpV3dCGrLrGvLTpdJbNiyxfsx0HOKCha1PbQtfWmdLCxz8j4ENnSEQi7diHhf8w0e4+wIfj/xkveTXAHfFOVLva9eA7Uo3sPjtHzMki4CsaAh1JIfIcS9V0BSiQ6UBQFKlI/QBHKspBHP7xAyvl6ApIAGEPBLWEK/TgCi9akQjV+6IyZHd/TGrej5pHo/POJ68bGE6XJGgbpxKAABCozRKX2xN/KdJw0e1gD/QkwipVaUjz25+jJuyoRfFvSUuKH5LguyQTNsp+JjTgkoYkgxjwoGmQLU6YjtO1ARP4LBdbimX/UcGmbGABJHnAACazgmSlUFkz6MIL3JCkIAfZTlAwbxnq9A9WifhVIt4Eo5AUBB3Mp4InGQ6wvPliToFqLnB8JnAwMAIEtlY8oykXnEZDAh/FIf8H7wPxoqhUpRRKQQY/GAFp/nsAx/Kzy2pkw1IwgjkIGDoAHpDKAcr1HhOwQANXQlKhTlhA/BlwIC7IQW57HJs/A7qfGszgAX4Gnkf3QFmtgnKimnwrH0rrDH7Kqws/TeufFkA0GvCDDBC1hS+4Glo/HOIP1xCEKyBLp8DydK0/fbfTyXUJPFLWqqTlQyj4wAT+AlaYBmK4ZXvbXKMhAGm2+oAtEQRZKuFbt7zN7oKQxjGjOdZOAHkQV7b73vYcY01QhkzrMcQ1+F5uJqc5TTfx1CAyLl1UAd4mnAScY/QmZznduNG5+AuDJIFOSqLGM0vahIwP91Ab963YOF5Qqob/lIsHEinLkUByKrskIyXZ0seQ82Tgwex3R/RVk6WELyVB+/kcOYmaN1IcYKphSM1trm+Jz7whKHGNIsO08k42JZpVcWbM/lkRpjen3iB/pi3PiXKSlK50FMt60UWpTE7iS+JL/zqXSYrzV9pdJGcvadg63sxmtmnrRwlYTuLukEImR3sZfbG93XjIsf8FaqCMIMGDMpXUoIzwYaeIUKgGzIzO3Zh9Kactk2K9rIu9kqc0p0Xr3pXH+7LwguF84jW6Soq+2N8nA7Nf4hUYwtDLL4OuKN7horOkFl6bYimT8rUHs7GEpflVQ/yy+z3JSt4ykhvDLHUye7qVT903TnuL/+uTPhuNGiajNXuZ85Uj+8Mom8CN/whcrEf8NZVkx1GsINn2DwNy9ZmnlUdIU4MQVnN+7fcb2KNPlLVGglR9znFxDkNj7TRUoYEBwaMBZ8Md4AEeLLQS/qJ2miR4CeEbzzdxB7F+BzgQwNElcuFRKvhiUhMiBIVm57GBgHKD8UFTkYEB7WIaHwiCd6cbGvdTNYMy60dMAnGAL/NniqMRh7EbxfRN85cX5KZSlNFOLvUPm6GF3BYZHYAtj/ODzdR6SPEYwdNC2zZ7qxSFxBFI9qdPGUV66Ud7EMJKTJEvBAEBosECC2BTlzEFmAFTODA3cVNWKtVFppEmVQFwbNIRef9RHS2VNO1kLomYSxo1eUCRPewngH1xeJGVAF8SWX40etgyGjtGIpfxOhogVmOFAmX1itClU4rUFBaxLdDRU02hAHvYNpOyiuvRIJYHAQCmNPihNAvQTvcCYBtwEt3iNxexclRjG7RRVZsie/1kEfZiaI8hV+iBAf+gAFY4HtuxHSugUqb4iPsyhCIBiY+mA7xjIC0EJq/xWt3xHnTwHjzAUEnjToQ1GgeWZUaohMFijQvoQG9xF1xiLyKRFzo1AKXhkCzUWYA4H+BRVg0FN5cBHt/hHrXzAZLCUPTRgfdhOKgyBR9QO0GQWsmzO/6RjyA5BQMCKCAgGdrSX9hENZz/Y34F2USWlFlskReDhEEzRI4kADsksC7/MV29tZSqpVqZwVoYyIdIswLwUTw9wAdGFAS1JQN8wJU/wAcXUANhiZVdWQMyoCWU+CBlIlISRFyS1SGi2GUhoXMWlG6jMZUZyYsDkTw40pc90F3Tw1170kFcKFO2owM6sCfIs2DoEwToMyNCsjzR0yN88A9YiUCV6RkK0CD/xXm24SCaElJhspPsFiIIwlIkYDso4iM50F0v0gNQsGBBciM0ogMFcQW2qSdBsiJFkgNAIkJA4ptwViQy0AXzxSM9gAMfwDTHKI22sSkUUgDDIYyf125UOBreWCLsgycWNmdCciX7I19Q/6Aiwbk8PNIoSwZARzIl8qMoBhQl+zNCQgKWE8A0HlWHviGdpVKd+IYxhtNtGnBd6OObSHJnNYAjqgJEdrJhDIphkvY+Z/AC9eOeljZAALQk9bMJ/6AivBID1WMa/1U1A+l1FSEUAyAeGCkecbMCAKCLEQAfKcI/MwA/93NpICYErkJnBQRlQmA/jGKjMgIkukMCOqY4fUaiOgEq+wJGjwcdxlIqj3EZJ3KgP+CbRHYkSeIkO8IHTOADNmJAh4IoYkoET1KmJhQkfzkpB3KMLGYcSEo6SdiEjQgmYDGaj4ECqjKeMtBb7pGakbECkzEFP0A/ZCpnVBIEHTYjkrKcpf8RVVkzHG96JmHSN64BGXzogxBZOo8BJ212Xk+AXh7mYXNWoEnyKMvpGMDhVC4WqWbCOFJlEhiTiD54jGpjZT4AQjHyDw4mQv8gBKUqBWewYbajHzTEgqz6LaCyG8qaGgwCASRQlI/mmwOUagGUJGfgBgPxQ7ZiQDaigttyrBwjFZNaKulmQxCAKqdmQkQgQKwyodr6Q6zCKm6QAyvEIKsKrt8CcI76D9sRAQqABMC6LEImK1tgBLmQC4mioayiQpz5X2mIr1/zAILmGCw1BT2wKmPKLGcwREEELdLiIjjgL0mURBDLRAiiAVewLK7mQwYhLQSBBBbgjSuxaO9Xsh18A1TUYWrLMqFZEC0cayVIEDTmQqvS+bA2azNF6gFN0W0d0AE+ED32Qy038oXtBGDp5lNHOzoU9C6vUSqlEQEjkANXAF4d0EWkcYwzu69ZOzo7ZouOMY//QJXrUgNl6y5J8S5ry0TL6LWN004wIFQoMEPslLf9RFDdphMBAQAh+QQFBwD/ACwOAL4AtwBUAEAI/wAB/BtIsKDBgwgTKlzIsKHDhxAjSpzoMEBBgQkxDizwL8AAi/8AAPAYQODIjidFlrR40uLKkS9RhoxJsabNmzgNshwoEKTGjgVL6hzZEuXKgUKJhpz5k6DLgQOW/uM4tepBkBKfPs3JtatXpAdNMixgkurUAQUgDNjAtsAGCAUewC3AEWMAkFgRKm2KU8A/v4ALBvab96thrgAKoIUL4cG/CBEw/GPBYsWKgSwiPGDx4AGMznHTFggw2mVeu0D/QRgIoXUAD2TvXmU9lS7H20hJ6x49VWtpqyAFrC58uDjDAYlZRl0+8IGCxrBVb1jwj/qCBQ8so/inYXLBDhE0TP+ZMmIKCRLdIa/ovJnFZA1/RsQfQb/Ghx4jevwLUqNGjw/29deDf/7R98EHJCxAVwB+ESQAAQ8CRsBfEP4z4QEUGqdhVw9EwAIJ5OXXgwxxyBBEEHEEcUUQ//QARQ8oBgHjQCaaWAYUUNwohRQ4QrGjjzz+4yMUQg6EYxA5QiGDkicOWMN41x1AAAQCHBAAAQUIIJuFxG3o5WFUjQYBaR1RlRxHaHWoAQn06TDCgRpQlhllJLhXAoxQBJHDiXvm8GIPPezZww9ulvfPB1M8QJeFBRBg0WpfRiqpVxyROdcBca3wgQw/yNDFGWd0sck/RPzTBREvDLQFqUQQccY/Z0j/8cMIK0CwQGuT5qrrhiwg0QMSHWhQwggywChFqQMRseomQXRAkGhTQbrrtNTeBAEGcXnwlmSSXTYCCf+8FZpjCu20lLkmvXTUuukWRdJJ1cYrL09BEdQuSzQBBQBaiSnmEVEfqdQUvEBpJRRPRwEVpl7zNlzTwSYRFZNGItG7l73POmWUVFaZ1ZVWDTX4F4MkO+xwYmgpFtcAEEzX2QadrcACCpVllh252M01l2lbIiwxXwzrVLCWAgBmtGB/JW2RliM3reWEJn9VgLbXEkTZZJ1xhkFnW2+ALbaKLrbBbZUeBDN7MGPHHmhoLUaAZyyIJ/cUGsTZgc3OPTBAdp/J/0WWVHcxWGVgDhIEIYaHR11TxTOVeVZzLqPwAAoogAsiDuR9MJDmOvj3Qw86uKnDsCMssQQSS5SOxBU9sF7sD50GUSOSPwiZgww5lHHjP2UUyWKNA46gQWdTTiXcyI6mRpCVilOrmIfnrQBZBJWrh8IK591n4o7/SDFQFwPdiOMNPXYBRaybfHo+FEIQSWT4QuqZp5L4JRiBggQ4WnSWFmHY/P8SYQNcWEKXMXXEImaBAAwcMJ4amOgffuqd7pREJB19z3tukIILpCCDD9zPNv4DoAg1RBXsjeAKuvtUqbZghFblAlajYlX3akAC4sFFQSPM4Zca8w+5WOgBt3oABv9GcKQeLKEDHVjLATYwpQ1ES2gYU57G6iVFHVqxOD/BCkbu9TOtiEVdjetIVMKIFJhI7IpWRJe+mKIupWxlJMiBgEgE1kZ9CcUlZzQXwtCouNOABWgHm2JixJIugxAyihv7I1gUYiZ6RaRLfHyYI8t4kTq6SyE/MyRW8IUR3HgMihABGSQHAhiSiSySC6FYF7doMbFYbDbKe0pTFga0rCwyZKQ0JYMKJ7JTojIhgQzLu4SyKNHQRVtr08x6WIAdGCgocGOy0lbsNTFgKhKWpkxa0ZLGS24yqGy7/GVCBgAbBShmA7BpjGYi8BjKbGcy7GTPepypKGyNpjSlodgmDzL/RsYhRJSfPEiDTmmagTpolyUT51RUMkZy/cMyK7ieh9a5ta09QFxwQYtu7iiT3thGNQVcwAEUxZi7aIQjrWnMRSEwJbekzJNTmlDyDtgbmvoSag2SaSSZIxoPOAcD6Kzo2rYWF5W2TFEXlYsCPIAQmK0gBdKL6OQ6EwEY3K9DWbMMiD5QnhH4wavkIQ8PxmMeDaxgPPKhlWYkU7aiHQAwb31rhvwHtRBGEiT9HORTOHK2BdxvBQ5IwT9IsAKzggsE4PrHCBR7KMXGqW5TgGhlQvQmro4gCPnxDx9GBKMexGFEnfrcDzy3WT7IgFP2WcEAPtIoUobQLyGEWl25qdCG/7ChOcyUmQnfNKBODYpF72NRi4rVouK2CFCBQpL8ducj3jkXgjeKLgWXJCTqCvcPOFjBAvIngCz9hUqqKRjzfFnbibDBa+EZQQ1gd9p/yKAGLTqhf0yUA+e670c8EkL3NsGj9UGhC+0TkqiK5D4jUfBEJxrtgSIq0vwFgHmqcZSURlnexVkkKiBkFGkKiJm4vcm9ugvfafGTHxLdDlB68h77uoDfI5UICjmobw4+V54UXBRLjRIOeStMLTboBlJuUVmapOc3nXFkcibslHuZxCTf0hd3p43xiL+lKExBmMc5DMAAUbKof2AoLjwA0Gl3dAYhgI974IPVGVD1ghe86v8MGewgdgqAKSyL87YFgYvXHqCBE/0XCqUK9KsQkYsWkioXpSpDDSLA0pbZ+dG4rYEbiPAFZLkq0KT6xxa2oKxNQIEPLMBWy1IKaTtPrUNAfUsEZKaBHvAB0K1yLgaeQ5dbiUZapeYx1cDm08csdiAlkIw5GRNeXOca0tratRMlycouUfjYkM4iInlSMVa6cp+1hLYO/UjNpbgyKvtCjc9WSbBya1tealSjt6VySDw2riUS4yRKCMbuYJ7bONJ25CHnGBKxmIUoAH9JubV4xj3S6470vndOuJ2Uavf7X/taiUY/QvHkAPwqSoliJqe9kGcrfI3nmuRFNNlFMXokNvn/GrnIZ5ltUH6cIfmmol0o5jNL0jQ1q+T4F1tSqYVN8eUPYTjHKrmXd8XG4It0pbft3WzHIXAjVPQKXogGFo+j0ScaW2VStp4wpbcr6fbijVl8/vOCBLQiVSy7nQO5xTaC0SkZp2YhESkQsizsNoXBS8ZsOU0qUtjq22ajKxNTldEQMinnogrWkSNGlZHNI1ZJ+Nn/qcie/JNpUNQK0/peYcBX5ccoVcwDPOBTi66tNQvaimk2RjDO25EvqtemLinvkoF6vnkliU3A8Jj7RTEGx0lt5qozA4OBFN/Lc0l91Qse9ZErvfmydwrRSqb5XPqFI4RB5UmYkzKWtSwu7IEM/wY8pNuIVnUBLKBnZ9RizNUzUmFWCUldptglwmC+I9MvmIOSx78DTr+75TVqb3E2kOEeBuge7AQZfcMZ7AEB5sRa7qcxY1dsZcRRToEVuKF/eid9eccberc0ZvEg4RRJ0CISBWBOPbQe21En8CREfeM3GLAW9zR35wIvGUgXznQWerMl8MJSdNEWtlFM//ARZkcmRNgTlndLWEYaaGFRMGNV6EF8QsQ1eRMXMINOofFRg5QQ3/cWQLR+JCUaFjElKvUAdUIzCqg3ChA2dCEXKHArWxZM3rV5T4FTO5ZlcKSDVNVD8USFW/McSBUaoyYa2LJa4aYa14ECmsEeC/AZPf+UM3Kxfg8VWWhVN+JBN+YxBZUBGR2CPeghOS+VJWMCIf1DWzhVWwLBWrdBTg21NmdzNo6hNtdBLg41EOiUgudhVpu4NjIjRHICIvRBHyQWjMR4IB8QH1PAVVzFB1PgA9gTfxNyfafkP7A1EHTlZVcEE4oBboT3dLdxVF9IOf8AAp74IeboHpcxWG9CH5r4UJmhW5XBHcSYH/fhHwMiI7/1OnzwA/vIBzWwWcXiJDyQIKNBilUyghgiMhjiP3a1U8jxEnYXFQgUFwsgOZSzAog1EN0hVr9GEPBliXVzjv9AWcH4H4DCB0HgW+41IvtBX7IjOyYSOzWQkv5YHjDwFhP/gn27BCEKWSXYeCE8thUYNhUX9RnXAwMfUjf1gVwtAjv/UDsDwSIyUlyAwjqtg1zJJT97kifisx95ImV6EgRl4Cky0DvHpR+ElUsEsRqDUzZUUWdAxwbZUVgG0jmeBShxcFwvkiIu0ln6gSI/wCcvCWM40j1C4j6EaZY9kiRLIpUyAEGAwo7aJSUi+Hn+01o+CXQFMQBbsybDgpV/wlko5iIEUZgwViRCIj440j7mQ2A4omKe1iM38pgUtCefcyCR1WA4ZSUVgikEIFeaqRNUlYz1USj0gR5TgAT0SF+54z2mMhD91T48omKvsgllMGBn8Gc4Yj5JkiJ+EpMKtgKf/4E4mMcgbzVTwclIA7CGb5EmatMa4TcFS+BqtxM+4NM7eXKVRKJi/yAEO5I+owIFniYkPIIkEKQnMPI5dPMyUvKbIKE/6ekQEvkRBoQUafEoleIYHUICOgBBp+VA+CEeyhk8wugiuZM7MDZBWwkjtyMj9LEmnIGTE+ZlDxKhFBFxkId3rCUcVnhRmiEehMWAjKgZHjYi8rMkp/WSgrInKQko/1CTi+hlWdKQNtoVvPFlaLJaftMR6VRA2VEnIlIsT7YfCPY70bVBLiBlo0UC0zEht1elE6FlwkEaGOISYvJ0nUECB+JAOVIG3EMQvSMF+iUFbfYPqfICXfACLiADw/9jIcYGp1/CBmFCJUaWHclYltcZKqACYADmKmuWBP+gBKFKBErwAmPJByhwAFIyeZAaKXDBGrdhqa0mA4K6ZqACKrFmBJlmaKbCQSSQqlKKZ61aLQvZQ40RLC5SBra6ZkSAaEbAaaWCaKDCQSPgGHSmGlQ6rM5jKyxwWcfiKgOhq2eAaIjGKluwCUTQBT0wPGnhqFCjrSbTDSNQBm7wAhnEYiwGKppWEK4CBUgAVK+KFNkKrz0GGRqwiCwQIrJzKvu6Kl3gBx3AEcWjGo9KsNWCTq84FRuwng9gAiOCI8zyBP8wbByBKbhisSYzLu3aGOC3kkbUHdXRrhuxGsKKsvImIqm4AimjZhDxFBcEwZk2K0LE1kMDsTUDcT/TEbR81BhRwVQ2ERAAIfkEBQcA/wAsHADAAKkAUgBACP8A/wkEILDgPwABCBpcyLChw4cQI0qcSLGixYsOBxQkSDAhQ4QIG4IMkJBkyH8BUJ5s6DGlyIMYY8qcSXMhyI8lR45kmNIlSoM3CwAoUODfgAAFPHYMWRSAwpoPBfwTEIAq1Z8+oWrdKlBj0X9Cww6AUAAD0QcFHvx7sCDtP7JkC0CY++8AWLIBIPhM+VTh155gBX6V+JQnSqsFqwYG7JMA4sFcI0McUMDDAA8FvT7Y/GADWgiUSR4lChhhUaKUiao+DVogYLBpN6+AgYLFCtu4V6zQcFsDiwcYMETQTdz2ighFISiAXLCoAAIC7dY1KECqVMmRb4I9ijKuXM8C1f7/QzF8xb8RJEaoH6FD/XkcU+L7/reCxD8e60f02P/jR40aQfwggwxBEEggFP9A8UMQQfQQhEAyOBhEDgH+898HK7SFVFXQVXVAStAJIN1zUwkEHXYoXsTGAyxoQAIS56GnHgkaTNGeDj3w8eA/ExY4YQ5AlhFkglB0IZAUUnQBRRn/MCkDFAz2cEMQVzi4Xw8j8FEDHyNMQUKGSel11YYCFHCAABA8d12KbLZpVGJv/XQaWAckJVdeYD2wwhQjNBgElAhG2eA/Bv4Th0BlCFmGFFAw2h4K/xBAQJpuVmqpTGzM+Y9nCmCgXxlnnNHFC0T8U+qpW2RBxBZblHoGhSOs/7BBnXVeauutUJnVmVy8BvdPDkZu8s8WUlzBwgAbQDDppLg266xMZaU1AHA0ATAARxt5BKdOKnFU0kJZ2fTsuG4qxZe5OuUU7k+uqfSaSz5BVhhHSbXLLrn4RrSTSN/u9VBCTb1JFGwh+XXuRwNtBBO2hUV01WEQV/XaYRJft26+MxEFwT8Y/KMABJ6p9UAEnXG2GchwVQaaXiWRpBJMSQ0l8EDMwQuwanOtplpHZAWmsc71NidQmVNNLBjGEgVwrUCYqWaZ0gNcFjVoBaRWddWYBbYZC7ixQHIEEfwDdgQLbLaW2P9wrYEGf3SJxHofCFQDj/vp10MNd+P93911//9DgloLSPrVxtAR4CG81g2tONIYseF4phgcsNsUOHygHt8A4v3D3RZeod8/PfzQEIOkC5QDjzyeHkQZf7LeIJR0BxGH7D4u+MHtU+jGVgHVnalYhyKWKfzDjKPYkkkw8fVWyRHQOMU/fH7Qg+XqTYEECxZ0wMLbSGC5I5N/Ukhh6HVfOQISSKzt29oj/EECyQMXYHjx9FPE+/3/eICnBy2qV0YXSRJCF0L1j1AZ8AxEUAIC/0GqBQqkC2WogXkOsKz6WRA7JOCDDMowIB/1QAYDHFZBWnWGMozgAR7YQGBOdMEWaqUAKrzLA0BGH/uYrgdI6MBaxvIdCLABYdZqGLj/GsatlVzMhUiEiEKWxjCnZEUh59rJt9wVkm9xyyBTTCLGiqIUoLjmJk48SEIKdq+99Itd/goXvFiixVt5S4zpimNWJkbHxQgNKwn7iUbaSC5zwZEic7yXvYQCFoLcKSxDuQlS7OVFcTEsjxCxjhrxWDE+4kQjTimKRpS2yKPVSzVxmpPOegYbbb1GiIPsSdAe8hXmYFGQiVkTY9qokaNQxlo9/NjHTGYQCJhshm35DF7EOMW+DOSMMWmlHV3GTE8GYH4uWZNBBiPNC1btLRvwwAwxsJmQmSwtlQlTmLjDzI6ERWmFhMmb4JWUD83lZCN7AAo2Uza0dEVgaJnhDL05/zCZcfE61RTkGhmntKwl5y2xSWHUKLPQa9lSadd8E8g448t6csZnnymAAgbQMW62iARe4lOX8tO++PApenCznHxmyMXAbIxw05FOQRJHU6SBsSVD8UDVQKPTiXZTZGoBGwvss7YplIBGNPoHb3hjG/LYZm00QgKf/ICluwWhBhEiEOoi1IPT8eFuWZUBoUAnkCmggIIncsyI5hedxSWuhaIhiWrGspYNhC0C5KkPCXDAAxzkh6w9AB1JuxQjgVzpsIE9Xep25COxBvZ1XS1QDxQUoAhZaAQf4MFsFlAnqVBQRG8BrWOmE6mAWrIhbFjB+ew2N72Z74OB5dEVYmegJf8lqkkFKdKREqSkJQGKdLP7xxUIlKPp3e4DuVvBAw5wpsSlKU3PpMqHgndai2h0LV/bTNQU0BltsgB66pkboWSQA+J+tUESmhCSpPCrIi3qH11gkHD9dFjp1UCqOCABC6rWAW6SZVJfqWB1t9LM0uRlkX7RSDxrM0+ykeYsSu2Tjg40qCst6B84GkGVpIejPxXoPzxYQHR4N+Bx1WtDqiyIXjb2gPR8oECNYtQmmISgRv2Dvet9QQgFcoYiIWgEGwgRpUp8QcoIRIUb7YAGsJqkULmKCGcw1RdMJZBS8VhJOUAumExEZEvKBTgaGAEI4dukJQHQyaZqVS5yUUAZaID/pcqqCwu7fFo2CMc3CsgzBoYKo3+weVXDIgIUkLDHjb3liHRO4mCKosIDjEwDG0wQhXzgsbQA+KWJ7vK0lAPOrSmVT2HbFSn/Rc4yfhGWmU71LNH4RQNn6yQtGwmiU40veJGTMftaCRhZbeqCzZrWlRqM0dqVE3f9UV2vLDZLOiJGYLvpK9wRikKcuGtvUXuOK2mXdmzya2cT+CnaoqK60gXHnhjRkQMBSVBo9hBUevsihYniuIuNSjXu+ijb3mQiGfluroQbi3LcNsAnqTDtENI07P43JP2N6tPuJODj/pexBWPIdMeMXRd3d0U0nmyGSJJ4Fox3uSGOrVZTEiSa/3yTzOCEFaY0fCIch5M0AeovPi4F2SY/4yxraZTTjOUymrRTM/H4ciWyMZC8rlhKAqqYEtESYPs+jcai1nPYBCZZISPAauACFpftS51yuli9YRnznshSTotzjWmRhk5rKY0snQFZCuFegAVsQIUwBNwGFrCAnB0gZSQpZsJe48qGMaaVrvznQF3jyqKp3TmHaTy5xIInke1RLTH0TGyAeTK5wAUpQldkwlJ+tFfKsiOU0Wn85sTsl6VEfnbyGUqS8kyJzbQqf2khADZWFmRhwJv6RFmyUBMm0CNFik0RCjrftMfZ42n2XvGALylaNrgwlGZEaQtRzKKaYZeed2o03P/ancWGFVNmA8iaez6TNcPlhHMoSBmNt5S/nasxFDUHMXRe4rcW5c4GBgDIAjDANZwRAZ6BfrIRAV4DAxQldYwnUNKFEh3iGJL3LOgEQykkQxQFATqlU1GjNKgnFgSBGbyHFp43FyeyenBhFtylgFyzGzViUvLxB16yNpMjgyPAA/HhNWoxMIrRE03ndBG4MR8CHTJlYkhBFpQBF5/hAR24U1OTeuHEUPsUVCxCMmzxSwbRTcHxANqjNm+zHkHwOSQVPdTDJViSH2YFAXYReEunGFLRE4Yzh9NhhJGCL3ZycPb3hD3FUHHxd3enQp5BMurjG7dhG8MxHLjhglyjXzX/wj758ViBlTcBwh9YFTpfJSCwVQMfQAJfYneLhDhB81wSKFqRkgCjVWuJREgbAQE8wyudQTJlo1wKqFTpsVojZR/PA1IukjZQJVKRSDeTWFmFsiCxVV4B0iDlVRBzgyGysiEz9SEm4lkLIVoJYEHn8lAHtnnDMTK6QQJ9RTmXcx41MALidR5+Yx/24VfrAVv05ScJ8iS/8iCDAgUf5GGg4yOgcze3o4PKNTBUIX4kIRXOcSZnMlOp2EI/1DMbU0/joRsx+Fd6UxDmeDfuoR+fUxCzdYykIz5PIo8Q8iCT5SfBRY888gNaUo7I9Rt9dy/QhCbDY5CglWgr0g3esB4W/3IloCM6X2VYwjVZQIk6UPCRgFIQTLIQZdAoZTAlsxMHgXUF9AVbOVKOPGCIZWM4eSEiuAeTwWMXaTJnmfYAYcYeZNke6pE+5gggBTFZH/krG3RbBmEkZIYgBmGSf2Il6HUlDXJcycVSxReQdcEhIfIPP/RubBABHTNUa9MiClgbYBNm/zE3RAljPWKPy6hYRsIoXfAkSckgUDKJiDU9nNglXgIDV3MakyI8yhIAZ2Jo/ZYZtUQ13VE1UfMVupGW/QE6EWKO+vE2V6ABVIWXnJkoUAAlwJWXdSM956NfiLk+81QrLwWWr7kQYaEp2JIctaQnXvONIqVfU/Ab3BQcLf+iATzyJDkwlHdpjOg1WCMgEN2DkV3yjwZ5hNOZNF0ndHFidarRd//1d3koF0OVJVi1I8L4VfvBVRYiVsiolGWAJVOAFpKCJvUZGWGCFd1naKehTWJgjrVFnIriJMWZA4mCY0hyY10gBKzTA8pFKzM5oZGRKUn4fAKTFqr1QTmAJGeQJElClwB0Zm4AQC+wQGcgQOt1AWwBHWbiopWiFyemU5uhgFi1KAP0Ag1kKqGiBKeiBKaiQAaEojKgAzwQQ3eopLjyc8hyGS3CIGVABKSSpURgZWlWEKHSoJ24XARAQaNGpraSMonZJ/8jBVFGZlVmKkZgBMNiqBDCG0UBHbOpIh56Oi6P9pZJmZQb1ChyKRC50CpEIARBMAVmcadv0RaPijRTUFzleDkOMqgjJBAaQBl2AWAVOKq3AhybwYK1ygKi40Aa2TG8Fzi1Iqv4sjEYgGl5hwFIEATstQk99g+UpkIE8AAEEDiBAazksk++NK16cjeAkgM90AERMC0BRlrUGqwCca0gw02FdR4dwClH5kPjyjj2ZGiuqUPhsU+x+q5Io0uFKRMBAQAh+QQFBwD/ACwJAL8AvABTAEAI/wAD/APwr6DBfwIJIjzIsKHDhxAjSpxIsaLFixgzOlS48aFAgQMGTgwAgGRCgQZNlhxoMqXBlQdLctRIs6bNmxZREkRZcCbOni1ZFvg3lGjBATwXIvR5MClDAQWh/pNKNarVqT+zat1qcEABpP9CFiiAIaTBsUcHqC04tgCEAgHgLgxAl27KlQpJNmUbUy/TokU9Kj3rFGUAASgRc13MVeDQr2MBQPCKtAAAy3Hrygwb16jbDQ8ePDYb9itbtQU8FAjNgoQGEiw0TBmhQXZt21NYTCExe0pv11Nqs2Cx4kHY0gUPWyWA8EBVAVAFEFDMuLrEkkg/gn1LAMIBgQc2FP/E8C9CbdckcOD4UBuHhn+uC64gAf/fbByzR4zowb/HD/9B9CDDPzIEAYUMUBQUhAw9FNSDHz0EMUIQ/9QwAh/6jbDbCgu4NZ1VhxEgkABDgYfVdNNJZd2KiwEnWwkraMBCBK2NUAOB/wSoYIRB/BBEDQjKkEMOZRApxT9SJDjggVAEGGAPE+6HBBK0afAHfiTQsQKHEIj3gAcbvPXWWAJAIJ0AzhV0AItsttkQXHCihNZRLo2I1nyz9VDDgkSWkSCTOQRBZA4ylOGCoWWUIYUUOSxKYA72kbDAP9+l6ealmC42lgdhsfCBDDIs2sUZio56BhEHGbEFEVv8g+o/N4z/wMIDCzAHAVFsZKrrroyN9RZRZWHAAhI9SLEJqpEYhCoLA2ywZnhq8irttD/dGthBEWAQQQT/iJYTRDotRadIhsHE0k4yOcXSuQlR6+6K7TYUL0/moqsXUOnmu5Rf94okb7lyYqfUZfJGpOK7CIPrL74qNZyvXn6JtBKckh0VAKcEv7SQXDWpqxFi0E0VXcK78nQrUQNMBtlboo12sWVwZVZXXCvx5FhBbwVQGVE6PTYWBg/A8MABv3LKKWU6HyfmaqEtEJpxkB13mUAiSjfVYYaBTPJWmQ1FUGU6O0zX1HQyTSMLKMCwbXmhFWRcQRuQV1AEHQx3Xob6NchHjjU0//jff3pSyEcPg8tQw+Ef+AZbhwhJdSvWyYGMJuRoVv7h1j+hURAbbhU0aWvoTYHDCB8UVHoNH+Bdeob4jfCPDnoq+E+EOcYhqIAGIhjE7rPPzp/v/4zghw4jUIn3FCBs6cB3BMRM4j9mcvxdmQZBxRzm1MI5VkJqmdX2jPD1pqGGMwKNQd3vaTBlhA2CmuOT/F3xIJXGB//HFPYtwV/fH/wRwdBFOcC1sEdAnNxsTAoYAAlAVaozjOofZ4igBF8QQQoq4QUULMgLiKCEJJXhBzXgQQGYE4A1FfCElzLOcD6AIQ3dZkJQiCCr/tGqLWzhDFCQFc7+QYC3ofCHboKAaP8wUBQVjsAFkIKCFHDogw4ooHMChN71egIRpnBEIRw5SUPMBcQu2iReDJmXvABARohtZi8O8di6HoIXNXqRWm4MF2eIQsYBMIUmbdTYR+okrjei0IrJCaRG5EhFjQ3kMYcMpEkw08eMVWRkkMTKyPyolTuiKyOkIUgb4XIyoyStkB/BS8coiUI4zfE4lvkV9C7jFaNAIC4lilNRuIhFjLjxkcqRZMgONhhSUgQykAFTabz1FePcagNu8dn24oQQk9ySNC4xikK8BkyCWIYz0FyXKSHATaKhBZEpoQrWqlYAXvqyIWjAzsug95W3IOWdM6PLNfOilLg0jyjBpCPMNAn/Mw88AAMr2FZoMECe4fyPW7PiFNC2NaMVzCg0XnqAeEIilqQYZkRUGxEPz6lH1bzzHx4I2z7Dlq6ddatLPQSNSgPzmFuZJWUKeIDdahOc8eHtpnn7AJTyRjoooa50//tHmKIip6uVs3GNi2RBpkhJmqUEnkh5pVsmNpSUhYQFKXgNcVhQkN285x8OXcE/hgMfh2pADLUxXoZ68IEfufUHA2LQgHL0H77J9R98sJB+tkQrAcIlOoZ5XAlHZL2pOIcB5iQlSdDCHQgwZ4QFsZtrRjC60elHB8H7R2VHQALaACc/egotgP4z1xwVKFCBGpCTfueHf0AoShcKQuoUt4Ba/5UTa9CZHqUCcL3KUUoqCeAoTsR6kJuuh3Su08HhcPcfCinIdoQ6kHMN4icKLagM8Ase8YTH3T9oaDd0WIABxhQAM0UPejjjLQ9LWNjECrcmQAPNA57oFQwoYFuvcd3voLTT7RqPQgMqQ4EE9Y8y4Gi1V7iC8HSg1ir5hgcPNY+VSBDQBzh2KJXqDqXey6Ls0KxECDmZW1ImxKcJbWnJhIACxpqfHxUIVD3a7w9657v9BW5BCwLVjSY1xQFyGGGZeWX1mokWFHT2A0Dy06KS1AUoxFAKQpBCF0QlhRl0AYNuOAMFuxDlJulARgQIc5nc++MTsiFXyQyLeUZQqFOdiv8IcHYVquBsBCP8wwiownOcpwwlFAwtzFEsM4dzZUzzzK5HpwVVoR4o53/kIhdnKEgZRiBRaPWQqYLOdHmEBhqC1k0HBnY0Q7bQhR7AAL2+0rSqDdKhDhlHphooVAw3IWcoXMG+xlkTBDpkwlWv2sJEaRtvCjLjFGBgA+IhylB9zWyGTOZLBlQYubrClzMurNnnBONe6LlFnV3RjPTSdnK4iG1q3bGQbJwjFrXIkEv2K4znLjem4ljIl9ZsIueO97vTJRh5/0TcgeS2xOYSkXj3hV0+SThQIhIUf+O7ium+d7d3snBRAuwug9GkIaPp8Gj3m+IbD+NFbIbGmBwELNz/prhdKELmji9E4NfeIk14EsuegFMvgTkjWFiOFZdbhNv3atgXE8kXmfUSIUghW8kfUpWeN/3pjcNtLnte5nfva18Py3q7MFMU0siMYymRJ1usznE+7vHoH6P6LX0pNq1vRi9J32O/XrnzzIirXEZpZjRJLne024SXUmf2IpNjR52pho4U9eRZ1nJ2edol6LVsZBrHPhJBOkSccyls3g/SckpaUywpI8qvNsCppYXJLSsWpFxkJspvT/sggTn7WRaGGXI3RDojhOzqGS6dqXPUNN80TeKr6sqUPQaWmZlaSU5ySbmUCOQlT2ZoTrYTr6TmkJfJflsOsAAYOC2Kyiy5/3KmjmmOssEsRvPKWxTwFo9SbHvZWf67jz+nyMAFXfeHWYktDOxXP02+D0BRT/M0EeA0CwAaQnV6dNQUhzEUz8NbHwE57/UWrAQZyKQaUxN/LaETKsEWuzYUKmMaSTFNAzCABjUcdhMcUyAGrjEr2mI3MUICsEEj2cItQlUamUEiRRU5SXE9a/dDILEpU0VNHtZwIBEXYhIm8rVsAdhJolcaJShTeAIcnSUb4uNd4iM+45MfvwEDzdJKkoQVhsFDaMJDzNE8zNFrlGQZYHExYRN3WcdI1gSA/PcAKGAQr3YWYTIACdQtDEVTJZAf+iEhDdI3/RE8GfIjenI4eXUjrv/BLck2HWYSIobFW2NWFNaSaRrXEvmyGV/jNg9AI2EVAVvyVaRIiqHYNmdDHDRVPHkzO/vBPrJoEIUYOATCBz+Ai8HjG3eYe0f1StPBPFMRGCKihhzWMHYXgdsjesh2bDN1HvWhggaxVawog5OlVv3xO9bFPrszIA3SILOzJzWQV3uzNyPwB69RHMdnOVZjWAxhQkx1OWxHNr+yJkela5NSHqCjARnyOjxQEKMTKS0IH5xFOrBjiLGTIz0QKDMWKAeRID1gO984AgomIQ7yAamjIRTmNGc4OSY0WNZThpbyD4hVfr6EZqlGKZ2zAFPIG6NTAzgAk6iDWSOwXTggg+3/UQKuUyG/8w8J4pM+ojtxYFoE1iNGCY5RAiUKtlP6wQMUxiGWOIyHUTmHwTxlaDUIsGHNxgaOIUTdsADfQDoGkToVolw1eVnIBY4GMV1D+Q9t2SRQsJAF8WI58j6Hxh/74Qc4pR8kwAMcsgDfYSbN9Hg8UzXOUU7P0nnl5hpUsgR401kBeZczBpEMQigLwiQPUV0F8j7ZqJdTclOK4wArAAPetFh18VjNMRVmEozt6HNoFAEpMCMd8D/HRor8uD8ywAeKqB994yQvdiBIQl1QgF3YxSDwQ5ELJjwloD67QQKi6X0PgFb/0zJocSaZaIyuGUYt1RbWtwExFQEoMB///8ADU4BkeEMlt6E++nFoL7Y7qBUEg9MD8qOXDLZd3xUcJEAjxnM/UzCdJdI8ZZidFbFyMcMxj3EArzYjsDGK0/lswfIAPtBZP2IQ7sONM9Yg+/EPGBk8/BUgcDWOI0BcCNEdiimgb4JubGFNgYRyk5EzBSBAawIDvJE6NRCUCWJdREkgigYqcEUog5IoBqEhD0A12GmiBmRK9TQXv7JrKzAb43ggRDKcf+KTflIkizIDVXalVCZlBNIDtZGPByAiRsoiQdYZjoWHDxAjAqIoUMZlETQqU2YqV3YGbkBBc4ZBkXYkUIAhJNA8YapeY5opZzomAKAALEA4OTAqROBmcf8GZ0SwQY06Z68SaVH2IyJEFAJUooFqHSWiYit2qGUAqXCGQcpSEIiQKogABrkAQTkwAv/THTC6qe6CiW6DAerzYgWSKLrKaHhmBLkwQ0jipb+iYVopq+/SJWNlH3j1I7q5HwtyJI62qjb0KgYmNwLkhMaKOSvglDM4m7URBFJABL+6BclCQ0RQasxSAAvwFoGWrVvjFqLBTaQ3ABoQIZFGBOVaELR2Bbn2omfqrphDTNbCGkgQKrNmrpsQBH6QQGHip94EsJjzGV1yKw+gAaCWJP+wCQ50BT5wbEbhLOAEsQkjGhaWbAbhpLCTKD1gAuSBgJsnstjzRF8SJqkHH/QRERwSJVEw+0Yq1rNx40MZERAAIfkEBQcA/wAsBAC/AMEAUwBACP8A/wkUCOBfAIID/xUcuBBhwocQI0qcSLGixYsYM2rcyJGhwIMPQX5MeBBAgIINQZY8OfEkS4UJTS6USbJhzY44c+rcuXFhyZE2gQ58SVEkQZcmCxQk+q9AgABOTRpECdQoT4kCAgi4yrWrV4kHCwwQK3DsgIIDIBhE6nKtzwEHAwyACXNp04NzIxb4B4EAhAKA9+aFCfcjAKcCARMAvGBB4MBNWw7N+rWy5aEKXT7V7DZu08OB/z4YCOHB6H8b/o0duFcghNIPWERgoYGEhhEj/iHB/Q/3CD8jevgOjrtGjxo1PvAWuGL2AoNrW7cm8G8r5QAEVP7LXv2y94wu587/3fvXr+MFpmNHiLDiNgkcI3BMIUHiHwoN91ewWDFwCu4POoygg0DC1UDgP0H0EEQQMvQARYIK9iDcCLshoYEfU/Sm3BQrdOhYAX9BtRV1rhlEmVoCELCVQAf80yIBCXwno3dsPKBAAQpskF5sJHzwgUB8CNfbPz1ciFuAOkj4g4JQyFDGP09CKKGEviEBn263TaElCR2iwMI/LJCg5R9T4JfYQCoesNVeLa4445twPuQUYmd6BhVf/5i2gpg+1iCDDDmUEagUhBb6pKCEliHFGVJ00agbjf7j6D8uuBAgCYBBIICm3MXp6aeVsQHiAA9g8I8GBpahqgwj3NZDGVCU/3HGGQ8Z8Q8YRPwDhXArPLDAASACC+qwxH53QGrPoUakDIsSsckWW/wTyT+bQOFHBAUkC+ymxXbrLVc6qvZAAaYKFAEGHZymrEV2eQSdT3T9pBAANtF01FBByfSSvUF966937dYb08BWSbWUvghbldhJShEV1b2GqdQuU/2G5Oa/GFdk18ZsSXURW3RFh5h2IX+kVEMzeUXZiipllRWJGcdsUMP0avaUSZvFdfNe8q4FkXSAQSUXSyDmuQFsGMzWZXqlQXB0eizAwMJ++62HwmwowIDaWKPxHFkBWWkl9sUXy/wVSp4ppNRAc3kAYgEPwObrA+vx1+uXc0u0Hm20kf9QYYASGvcDkVP2gKDhhv8T5EAj8DGCjzxwuMAGG3h9pwBgg+2iQFth95CbAsRo9ldsCPRc3vzNN8WVI9QHwj+vr06fmDjUNySR/3wQBO68E5hDEHEEsSvhiPsGXKtl7rkCClmn59ecJAbtM0hgC6BmX5u3OPq/Ot8JGdykoWcauQW4nZaOcO/nH27HybB7Dv/I8I+BAyFuv3HCKSl8ED/wUQMPo1FLAPoigNJt74BX2UumAEM3EjROCi84wwty9YKB5OqCRMggESL4jzMQ4QxKoBWtZJCcXwELWCpCoAo9tZcHHA0wGyBVb4KQg00QIRcQyWAXghABBUAgWSsMIqj/xqWjykFAAf/wwT8IJRAPdqEHSPgHBt6mlqNBBF4hIYkW3SURgylMiGDciFECNjAuliwmbTlKUJDiEIFl5mArqVgYidUuh8jrjgShCnRGosaOpfEh9ipZxXwilS/O0V9GSSQg0SjGRbJmJDYjSFS0sxJDHnJ0CmOJHxOmrzMSZTwze8pU4oKynqFMZd3J4tguuZNNigQlaxvLUuDiAdU8ZWSRWcok6wIStPGsNZH5WURSdhFgfgRznhNbdQ5SNlZmZDVmGdXQ4JIzuOBMlKKcikMGBkzqcXOB4xoNsJhGFlkq8C9ym5v41PlD6FhFYQJwGcycqbG2FDKSpDxTUkAT/5m8gBJPSlEKXMZSmgNAjW9bmtrUNMDQMolJTLXRwPpG4J8yrSdPCVEgRDAXEZdthzL0DAnaDgNLSRpsgQU4GuWeg54FqAWjgmmKWXQEtdmIaThCGhDxCke4GvBhfj4VCG8+EDmXVk56ItnKiwKgvYE0lXMhBSQbYQkVsoDoaTvSk0RPtZ/meJU9/9BPWCWKg9rhZjfBOY6E+KegH0DhBwlC0PzyN5wRJMdxPOBBr8YVtLioBUUpimd1mqlU60RVLwPczktbugCwbjU3QpVP7uijUBKwwKET/YcO6Jc4CQnkfYk7nJSEcwUkVKihYqDPFPTaKxiMj2dNpQ7oqkMi6/9tZ3MIOOxVHqC8FaSgPVyiD2Q1KzgEGQd3nZXBW4H3jzi4Lwfu26lxcAOc2VGNS0tz6Q9NAwPXnmYzEBARmziqpqfq9ipPGUtVnUa3CIBJTFrCgURlE4H2YoAFJmAohXrAB/gRiUH8W9LgRnCFVvlBB38IDuPoc6qJBo6iKAhXYg6QnQNY8rxegUpe4uKU8KolLx4YwEBFfBAdrUBLPPBNDRgkvxbT0MV/ggJ0nQvdMrggUINqkv+Ss4LnNcW2GB5d6cjDF7iZBgX++cAPAAXBWUWwC7Oa1KwkKEE3vOAFbqDVlSUohTI0SAP1rTB2gBzkMP6lyKYRan8lJYQuVPD/DG5IQge7IJAMGiFXd25iBzXLAl8tBlgvLfNhmRrMKbBAAQNQAN1YgIQrKDdXYPgHDokQLYFIoQdiGNcCzCPoTrsGWEB0FRQ8+I9KW5AIMmCBEX3saUE/gAAPaJERT1WDMrygC5v4B6VzUS0fdGAAqWnKAQLd6iCTCm5OW9c/pvAju+oAzEhsCgQGYMBiW1sgpvJhuXQyRqG8y9vxupfHrn3JbveyjNvETM0ygy+GJHLceiT3t7C4RT7ysZcTOxhEVsJuhKW73ReW907qGG54GTxlcsRXwTSJ7lJKddwCRy/B0i0wm7BEjxyDGE0o5m60GabeZwR5xClCb8yYPIvx/z45u/vtyJq5PF4eMxi6R84Tg3u7ZxFhCsk9gvFtHqYkDVu5Gh05EY/SnOiC3LdI9wiWkKV8j2HZF7tf8kpT/vvojVQ5zInCSTYuUo9Q0aXaeLk2d6ZERiT7XLETPpGuo8Ugc5GL2rL5c5NQky6FNJh5v+IZkHYHcy7TCtbLArKhWDPkDGO5vhUO8csociCAL4CKBP8ywafS2nEvTImmvTaehZ2Xdskmw9sCkrno25sNAUxTjFkXwkiEPAUAlkYxk/buBJyesPQAXqb9D93H3d8u794o7a3NjZNkL4dpSjhXH7THZFSSC3zND3/olyL3c+yQr85eWIbh1YxxoNP0N/8bsYmzpMz+jau/k0gCU7ljOS01o6nva5wv0x3Vl26+WkCHlufCspgsItSBHXEhWEHGBgGge7pHUptBTWjDgC6hUZAxGAaBPTxTGK0hGtuFfwo1NREAA3tDNfphWRqgH+2hAWFiWSlwNf2XfkK3JtkUEmBjebqFBjbzgHbHMGFxJkXzNr/EIq5hFiQVUB5AOaYxGwvFUAxVH2WSG7gxURTihI/zAfMBJu6VGPQSd07hJt6UTEZ3eYNWSZvhM4dBUNLmNOikUuwlEP03Fm6jGi+VHkboQAIyIbwxIUPChLmDHMgRJAbyI/9AJmHlQmUHOpa3SgdhYYGnIvPESjRBFU//txoMFDfIdmQDMRrogRopBRlyszdJiFZ0VTi6Mz+7Uz/GwYePE4WQs1cgIhICaHRaEXmd0yJqEVu4Fxb+pkZiQVA6sk50wx+2wR9esh71lSdXox9HyFBoxT5TgjvykyC7EwcEsjsjEARM2AO68wF/QFS94hghQieDJYDVEV4WBhEwQx2LyIje03uksRrpJBseyFBCZRthhQL64SXBFVFy6Bv/sASEMxBwlQMRkiCDsyRChSVIsD7KwQPaiAKx9jZPsSJK1R3miCZosiIM8A+5pVt0cmbo9BpQAyb22Bu5gQP/gAMfYFle8ltf8g+2AVl2dVyh1QNwtWQ98FzP+A+D/0MlwAEcSChRWjIfHeJdflFhEukynMIiTGU9KTIQuUVmugUVb0hTprEfAlEfrXOSP8IDIjk7XHkquVEhy1g/u/M+C/I7Nck/UjKNFPKErcIlXdUhcxNrKuJ3hygQ1FFeSilb/3CRAnCR14YGBVBteQIDJ8aV9MEDqiUfH8A6iYMcRLJiV/APkbkrNflfuuI+TWI/EgIcu2EblrU8+2ca5SF5stgYm0MdapEdYIMimzMigwcR7YV/nMiSj3McMLliuXEcSbJWv+M+DgIlMtYgyEWHFGIbI+iT8uEhLbV/7cGQqhcW3MIdbZJCr7lvYjGGwIYBvpICPGCSvaEDyoEbYP8WJuuzG8KRIMoFK2VgOGjpWUy4liIpkvPBNye2PsahJRH2Un6RIkx1jtWZc7d0EGcoRamxPOwBl0yjaKVxX7SRIb6xVlBwOFMyILl5HMHxAYbznmm1IP3zI1/CJqtJAP75n8W0EHsRPWfGg3DBeWrRIfCljD0AXQnhjIbzIPXDByyWo7HiZQPBAzCwAdZxQiTKEVEXTB+RNnC3Xgegf1MAAsrIYoICKzkQKLoypTmwo6riAolSKFwaP/+zAmMheVtBbEPKFd6YEHPBXeqTHH4SKGfQBW0Gp1zaZnT6pld2pxGUp3S2nq1SOSJaHcJSpjICGgp0PqXBJ04yQVP2pk3/9EETREFw5kEVFEJEoARLBF06MAUo8Bwws3eCinaZAn8RwFBOIgVuwGZ0JkEbpGcRYSuW+gJSkAMjEAEb8GdD+andMkBiUSqjWgNd4AZW5gaO0gWKAmV1JmlfsAVFsAV5tkTP9g+cKqKsh6vEMqCjMQJLQgI9hAGusju5cgY4lAtEgCs41AVQ0Doo4DTmSKbUWiyiUkX19UKLpgE6kAPNsmeSJhBbQARCMKumAiJ+4ant+i1X9RfksgJIkCBS8EGREC25pmtb0CRioIYAy64DizEtJBAKwAKvQisP+7C6hiArKWwQcACCebH/oj3kkRoaIAOzArLTQgQP4gOmckKpUlE0KBsz6HRVGIABJeACLyAE/3ADunYGD9IBGBBseCKwOdstTcMXpSJF7mUgMikFAgFmP1g+adG0ozNtpTGEQ8gctYFtOZJsXBtEMjQQtZQTAQEAIfkEBQcA/wAsBAC+AMEAVABACP8A/wkcSDAAwYMIEypcyLChw4cQI0qcSLEigIICLw68aPCfRoEdD4YECSBASY//DHIsWXJASJMwP8Lc2PFjxZs4c+qU2HEkSIIfWQI1ObCAwAEDYbpECqDAxacpaW4EGjWp1aoYfe7cyrXrVgBM/zm96DSmwZgpA7gMgNZmVY4iUxL4J8Co0aZqxQqEsEGv3bMpCwgeTBjCgX8L/j3wy1igAIICtHqdTPlg0LIeTeIN4BSC0X8QDD5Y8ACC2AIDXJ4swLalUQgPHkRYQYLECBwjcuve3ePDiH81Rnzo0QN48eO+/30QGHuDYLZs5waI/Jiu2McFHhMwSOBx5Mrgbw7/aKm26QCjG/guZrGCPYkVK2ZHkB0bxYIVKNqT0PD79u1/SPyjg4AjDPjPFQIdF8Rx//SgGxJTaBAfCxGwMFpsozlHAARzUWeUdNZ12B0Bcx1GUIn/mBjeiuBxJhhs/8BXW27L6eDbCCmwoEFtGkyBm3A61PCDDMUJ2AORxBGo2z9TRDjFCE/SKNw/PLJAwpN/BOfbCosJtl0BB0R2QAAEHFCmiiymqaZAz32GEFEXwbaAe1N8UMMFMuRQhhR8diEEn4AGKmigAkkBRRcE5dAbCbFtCGKZa0YqKXhsCPZAX1ZaiIECEVQYAX89BJGDFF2cIRARRhABBhFEmCrEPz/o/0CCfYNNauutkRZg2gabAiiFqf8QkQsRWxAx0BkyaPCPo32Bieuz0E72QAEPeJDeAxgoRuGOEXTQ1waLMQRXVDb19CZVKbmV2boZhXTST9HGK+lI5aI0FbkZYWUZUSrV9NK75LpLVFzpomSSXXrJq3CaQrX71ExAldXUZS0ZPHDBQg38EkNzJeTURJ8ZZNR0ZJZc3cLxNiXxWSz1+65ZQfULEmtRnQXYUaepN1p+s9k32z8VssAzChEQzYKVtSX9ngadNk3QyMs65lh3y9ZlHcppxuTU1hOPpyto4D6AAgz2kYaCYhs455xn1CqGYdNW9lhCgSMQtxyD/8SxYKg9XP+hgx86IEHjBx80SQJ7MExLWHQkU0cya98x7th0I6Z4MtZcaTTAYnN2KjQLQMcHH3sVPkAh3Mr+s2RuSATeeuu/NZjgD1D8sODeDup2pYQUjr0ADAsEH/wBg22YIgEFkJg8XSRD8N2IAhwWpvSYK0zW1gKB6/a0bLOdmqV9yQb6Cqr3wEcQMqCfA/pFJni7DFCkL8OQRNo+ZBll5EDkB1yyth2HJAoAmqpHwJy4SWcRuFJwZPCPLkhhBnxyw6/+8QKBvKBViDLVGX51hg7+w4MuAA4JIkAiscyFQwVM4aTsQhhLZcsHOihDB4VVrFSl6oMb/IcGFGCaAiTGTSoM4qT/5kKADRBPMR0YQRkg+I9NGOuD/2DCP3iYnr107F7wssm44NUTgAnxi1lD10+0OMZ8SaZgEFvXSbyYLnpdTF1gRNm4VIIRfcErXwyB2LvW6BO1+GQlaWRjQuAYxzXVhCqHvMoZM9OyRiqFM2LJi1gqxhKN+EsjW4TKIn+yyUJSxpL2ckvLDEZINuEMKQlzWBszebGC2YshUIsKzRJmLjtysma29CROGpYUoWjOI2VRzWdU0xp+sYmXuNRLdU42l88A8WkNyU4PsZNK5PllY7rcyXj8SExfsuybbWFTaF5ZFc4ABmEfO496FBMB0izAiMsrEQRgc4ALxaZTKCAafEiT/7aosUlkHXlMQKX2zGw2BCqgRMldYGZKg73mNII5z7r6NQDTqAc+GE3ajja6nys1qUm7kVJunqRDoplyZLE0mWOgVhcBdIdMBj2ozCZ5EaSgJgAecNOFSBObokQUNegEDbVks4Id2SY3A3JQkZJEnKY6dQRBEAgfakC4wr1nNKyBDuQM4tLpRK1jPYHp5MIUU5GQZyl5OY86ryU2+MwmPijAkFxHg5ijzYZH++lPgVonu4FE9R9/bdAVRrAEwUHIqKMDXuLY5iWuelUg2wkRW65jTrp05zBUu1xZ/4GU8xTAA2K5EAxiFAEq0YYEMZrQfOZDn9lsdHUCEpwO6Ka6Bv/xDbA9gEJTQ3q4+LA2Nu5854YWkLziUm1yHtLOYwlCPbJuliJsqBQb6unODN3nc6i1jXJ6QzfD6kYHSR3Ikfj2g6bOVnUjqFJ7Mko+HiDmH2FrK3zyswAIEJc12VneHc1kpudO5iSmeYAC7qm0WXVqrhiIzdF0tCMcaGBuPajBgnDboBEEx0ECid2C+MCHCHO3bkGogQxGPFXENDZF2akaEf2bpq2FLJIwjuS47gkD+DypBnwYsZ52/A8o5CAH/+Cxnv5RBijkTwb4C0KR9eTjIARhBBqw0IscVaZOsvhZLtmaB+4pIwvzYQYQ7MILpPCqf/zqBWI+wwvUrMFS+cn/gTkElhT0l976WjN5KLyyJyuVPdgkcAokOBKJHSRi/DnQTz1uoAaN8I9cAGsGZWAg+TZgzSPqmcW6UhvbpgWuCiGhB3vS4LBG3SpTzVkG6X3AYUzDhku7miCVMooCFACgUXlwWMHC9Qel0AMWDBhM6UnMq4e9LA494IojcMELhHCGTRRrC5Fo4g2QUFormobYw0YP2npKpRE36MdB0AHoFGMUiWL73AJhw5apZa1e4cRc9colutFNL4yQ8V6inMka81XKeVcv3mRM5B0dNlNGrvLgU2mlvyU1R3LWso54NDi6BDkUUiq0l2ik+MLfLUZ83YuOBpu4K/vdrn2xaygx/xv4xi1Sx4BHHCsaR4kjG5kZVJa8KRjTTMLJufKKwLuOWqk3Hr3oTUxGPOAlSaPBAQOwm6kcIbPsuVXuDXKSP4Q1o0zLSdyFsau85d00A4zY5f3qccXbmFmX6SiRcjHV4HLrvVR4RGZZy7rf0spX/pdCYHYw8tAcIY60F8j1jka9YPOOQDQ6VM41EqNUB0TzLvhBhGlHZGZm8IOP++Iny8WDfAyIBYV6ORP2oajVpSNXfLXC8YuXv5Sc73DhCMuSebB/5jeVnr+mYFLZk2ciTKgsvHPUYLpcqaEbod/cOjIhKfPW8L7wnDkZzVgIVLe9851damFhqAUbOZEGeOQjDf8Kibj7gZysOqH370pojtC485tdkzUXNSH5e7GoFT1vWwxw92LEsPEUQ9d1NBjVTtnjTr/nJtIXGZGlWc8FAEWnFVjHbyGzMZ+BPINhEGyXEqjkWboCXD2zXuwBOuyxXihwOO/hUSOVG7WRAqV1YKdheDaTHcU3EFeEdzEFd/jGWf0ySxWIYsFUHk4hUboyYG11goaTXgEiOFCyG75xI8NxIwcxAvDRJchTMjWzTI/lHSRjfmKlfuayUKGEMKDVgfZURaexFEFVABgQNm9lG1GSGxnWPgLxZMVRAzXQG8BBVcrBB8rBA/GBVXQHWctCOY2zhZdTOSzWd6yRZTjnTC//AlxzdSmewVhqBV98EV8hyB+8YVtQ5VQK8RsfEAShSDgftQLBw1hncUXYUYjb0YqP91V69hdoNYufdS2+IzRc8n89pT3h0oJHowHAqInfZVtLJTsIcowAsgQjgASC8ySGM4X11UJnYTWFqICUkxItNYgm4lJXE1Pn4Uf1B1rbZjooYCXtUY5EA4lxRTZkQxuA9iSo9RuC8w/K2AMGslRQ0GNXEARX0DeAw4xQFmVCAwMRADxYBU/JwxYyKEuG50/YKIjcIRAJkHoxVXufx3/3VCFFZSX/8DnluACsZSHrhYJRkmEF4gcNAjhFElUyEAcMQhx6tR9CE4nu1H8l5B3M/9MdCdmKjXMdHRMm0EORm+Vi8/Q27cGRGlCOHfkeQtNOIVlaKNAjPxI7JjmPS4AgDVIDDRJVnrgbVVI0csVTwaM8ZIk8zQQaVpMiNMiNQOlSbimULAYwo0E6ipE4wdNOcQWSFBKCOrQbfaU6hhU4tQUct0Mc5YUc6EUCOMCU6NgeMfIPo/VOL+JD9JQYh+F4dtFSmOWTLpUAUicSleIZcgUfyjIFyiEcdZMbOLCaSIAbShgkIhYEQ+JhTvVhNpJeGyUQU8ADu8mbqHU67LEjIIUfxNUdzuM/rWh+3fiZb6JObVMhV+IbPHAlh0M0cPMp/HGadDMCfmCY4/UDJkmVcP+oOsvRYXbyjsJxh+fTYX64AIchABzSUqXHgMzpMSkRYD0VV5GYNpPIKwqwhgm2YBogOOYzXuKVlbVJHHz4Azhmj4SWY/GTPoSzAp6xTAJhJvFZnxGBc3tRFJ7lGebEGhBQUaVBNnRih/QTP/koP38lm/CTPvoTP6ICozRaBiGWas7hPyjmXBoqEVGHXyd1Gn40iQ9QY7TBAyI2YvgDKPjTpEZmZoMSpXwCBXyiPz0QIYAYWY7So5OBX70HGu3UZR+QYy6wJ27wJ4AiEH5yBn6CZswGRWT2D68iBG8mBQJBJDjAJcsCJgLUhVwaHs60PZ1iGyOmpG5gZg0kBGt2QWv/FiwCYSpwxqY4pEFBxgd15iV6YWl/eitEmEAjIAMzIAOH6if44wKkQqmSyqab8EFEoARPdAZu4AIucAEjpCuO4iybGi2fATodMAXBAYw6YmF1g2Sh1kEetCpG4EF/4gJXqhgYCim5ujB9MR8FwFax0QEs0DoMBCy58A+rMixgAKc5EByotQDW1GrRKi+tpisWpStqqIY6hAQyIAWt0q3CIiyNNhBl8AMjEAHNgjwDlK4LwwaekRoDsCkdIK8zxGiNlguj1kFSoJXZQzwlJLAFxAaXooYKoAE94AJCwCpn4LDd2mjGIgVBEAG0Fi5lkn4WKy+LQQCLAS4acAEvoASnbpIL0bYFwdIFQaAsi8EhedaymJMezXIAfdGRPzBmb9pETxQE2SIWRot7Qos1PkQ8pbEY3RJDBGFqRbI2QTW11cMXfGEtAiYQbogDDpICHcAcYsFqYKtClzItU3QpApEtGDAftKYYb2tQ4HK0OBEQACH5BAUHAP8ALAQAvgDBAFQAQAj/AP8JHPgvgEAABBMqXMiwocOHECNKnEixosWKBgcaRKiRIMKMAzkeHLkxAACTJgsSTHny5ACULVGGLNny38mLOHPq3InR5kiVP4Gq/NgwI8ejCDmC/Ll0odGmEAsILCBA6j+rAhJm5cm1q1eJMg2KFTh25dWCUq3ClCoSgNWzW98WCFCAwIMFG/AW2DDVatp/BAoILgBhwYMHEWCgiBABBQsUMAATCCAgI2WQICtv/cq5c1GOBdy6JTv3AGGpECBMNRkzAMqXoa8OKHB4AYoVJKaM2D3CzwiBPYDrqBGkRo0ex3t80LGbxAgS0FegMGx6ruvrKwkU1CywcvfLVMkC//ZMnmdaCHdrw1gAIz2EDe8hEIb/b0GEFf9y6x6oW8MI//v900NwIwTxQRD//NYbEiVo4CALjx122HuDyTfYVa4BBgEBk1VV1Vnj/XMAQdqVZ+KJDaG3AH4krMCYhPAR9sAGD7CAGwkORuCDg0ggF9yPvwEn4EAjDFicDMghmGCCIxxInHF8fEDCAgtoN5lAEAhAgABZ/iPAASWiKOaYAqGhkkFSbTSXfCuS8EENfMggZw45lCHFP2X804UUUrzwzwtndBGoEIL+c0ZCUAi0p6Jl5CDnbyssUJd8pplG5qWYcpZmAbMNJph8GHQwggx2AkqEEgKB8Y+qhp4hhBQ5IP83xQoPjMglVJnmqitn6An0wD8s1NCFEkT8kwsRx+byjxH/EJHoQHVhueu01HZF27UY/POrQBqwMJACFB1llrhLKeURWTXJdFBTMMFU7btiEtWRT/MGZRREN91k07015ZuSuyHRC+/ABNerULv3hlVTQQszbJlPJ0H1FrSeYphWVpt5qXFap10o2FSVzVUwtTEx9O9cCL01gFBqJdXQXFbZJeFiLq7grQbAksACjlP0zFuTQDuH8z/4gUD0XYLRdV2GGmtm0IcYWzmyiTFFDNRpMxb2q2EPdNzpACvPd5i2/0QALAsO+idgkQMmGNw/xAlU5AhI0O2gztJRJ1hgdQn/lpVYaW5H1ZaAfRiilpQNruWXGU/t1QOp/SPf5Hgh3XV8G9D26wq4TaGB591q0AHaETjIW3BPAteDgjX8oxt00NmIH+ct8gACD5z7OmNej+VNJQEjEr5leIxvecCXCRzveLUgqTVbAC+VDP1V8/0DAwtTfNAkHz3IEIScUMgQfhlQkE8+FOiT/08O/8jwTxDsN0pqGXLy8RytG0o12QGqgbn8/zmRysqu8p4N8IAPfPgHD2bFAgUMAAMkqAGpZuCGGezpTlJ4FaH8NBBWvSp8UsqciMgyIgCaEEVskJwKJacAcOlGBkkg1hnAQAQaKusfqAJObeqjvxP68FKSKgxt//6BARME505nONQZiBCHDnRAAXz5i0M2YpaAWfEjLtOISH7Ixa7ISzwCE4pPyhUwltDkX/oqyAAJMsAtigdXXRyYuDpCrnOB0WDrSuNQ7GiTLUYMi2g0YxwHRkWDiQQkblyXQqrWLgA4UiyM1GO78giUkk3kL1LU2CA9c8iG6HFfkUxYQTI0lqWY8SZwhONKUJMWulQlANrB2EAyNjHQaHKTPJFJKCvpMHq5BjZncVfEdAkxn7xyUyS8ipU8dpWs+AVa9bGLpBYAAf4tQDLKK8iVbukdXF6EX72U2FnSVDURWcZlUpEliDREo8NEYANm85XufjWhw+zsRlOAjoPySf+C6VzzU6+szMO8RJmElKhx3vyMuubykoaiBGYBkA/1rBK9UY7SJB9DTV5sw7kb4cBzPfvcCHSjvRqMoAYfUE6QGpSb50RnOg+YzNJIqZVmgrFDKkFoQle5mtBkqADWJMCGqpmawUTPNbEZ5z9Wli0aRQBtLS2SgJSDINQhqHVwYxJvPjqrSFHpABs4wHW6+cYzeQdjiZvldwoXpp1Gz6eOnKiEDBOZ9kBOPjH6VF4EsgAWwIAE+flcg1zXICT8QwcDkipBCEQ3JKSNdIm5i3wCI1TKhgctgIFliLx0sXQKZHgCCd5OXzaa91ATS9ekpmEkBbkYtXaANsqn60aKBND/7fMfOOjRB4aUwB4YSG5Myk2LpLMeKhk3tQY4gKQ+Blb/tfKZsaSKKkdbkWGu5VMEoM9AcIOfs2HgAR1ADAuempvdfmC3uxnSb1YXhJ8laAolAGlteaM9PvRMZ4xZQc+0N1LAikisWRHr/iojNS8hgLqcoQuVYPoPBRiVLoJxy2xY6Kt4uk45bUOSkn5QVe/9AwrfC8IPBvSDHxgHQT/wnvs4jFIQoCCm+ePSlrRTQgSj6CQis4l1WmI1TknuLiv4QAz4YBzwia8MeeKTkqVwQT4h+R8YlIL6+ARlJ7evB7O6C2CAKtRK2ZhgKaOLfB6AG6Clt31PRvKc3CeoF5yK/wiAajKVDVWofwjBVUIoQw90MKUNBGZElvoyLiHcsa4NAD6HWcFJodyqVimRhmA4lBByAIUBkeBXgYuooBEM4YiuCT0YiEAKRuWCMyghh0ZQYqqLlecfjCACML5KjTdNa7EJpHQ1eIEMlZCLGzLLWGeQgQYmFVag0vrYBJQUWGkTgRpIQQlLRNYWjPXhHoS3ANcUKlAnhmwbd21C0vqHBpZjWDxdwYkJkYoHus1uLK1sAxho507mKJ46tvveZaziFqGSyqTgarr4Jpgpw0hGMcoLkYhUJElEAz2MMkyMAb8Uvfc4RjsOVF2enEmPxVgWj9Ak4l75Ii8NecdERoSRDv8r2U3gmnLMBAXkFhn4vvmYcHSRxJONhOQkUQnIP2L8ISaHuR1nPseaQ3yPunxKQjAjvXQlMiVeaSvI70XyO85E41ZcOs81jhJ3Jd3mIg+6QlBDl4Wos90FF8oc0xhJp9DR5WdqCxlVnnWHUIXbEaHlVLpt8kA2LJQot/pKOvmThZVkuncfz4gyWsrG4b3i2ry3yqFOL6X4O40Kcznh5X4mMToeltteZlWkfstxeopjHLq7h7QJcAQ7XecN6wjc3V55i15Nk9oJD2X9LMVJeVY8HOOa8GtFJQ0Bjyof6tDTmIbvhEnv4a1snnhSaO+MaXZSMZ1RbaLoqdSyETFPJS//hGw03PWAyToCxQ4ekW14nuv8IDDT8ZnYAv+9l2Up+tsdPFcbAcMwpmwo4CuOoV+6sRvaAx1T8FHd5QDXxHuII1B3BBId8iG/R13TZUYoIzJItU4BY10SM0R54U81gzMaQAIlkBslKFJAg2FzgwPiVoJTwAMCgR9VojQztXRwkThbkRWxRGuotFRXMRoDJBimMTmSgzJddx0+FRppsQEDcBe3ATvzhQN0U4VMIhDJcRxzg1t3c1+c8zvStTRHR1B7RyIExR02VnZM6BYYBWFd9m08dBrX0XOC8W7/0E4rEgE4whtD8iMD4iOpwz0KQoX5lE+PQSVDZYM0NUvh0YgE/1ZQZDhLATBr3uQSJlFRUxEfErItXWNUYMMpPqZCfEFE38UYKZheWLU6b4Mc/3AgTFI3AFKCw6U3kwVRTQNLkNhMf6F8f8NWGGMrFsgwANBQnAI51KFlhkEh8gE2AxAfZDMQEBI6n4Nb4nZYqkMkWfUbdeNYdwMhD/BiFlIpRKiBIfNK0aUlIKMZJWIZ6PhlPLZUGPUexlgfCzZXY3YtksM7+oWC3PIPjkU3/lUCOqADCYJVBbk6I1AC3NgtLtJ/tVIrqZFXqoEdsJQ/M0YVXSJLA9UdI/QPDKBTg+QSR+gB9LRa2sI16PGQtIE5qmEzKOg5/1ACMTkFSEACDFI3zP9xHKl4IIzVHDjCOf6EiEElItUEM5NyfFkyF06zlAYhdQlAEAzwZWwgI1pWH/BBI4imideCOQPBMy/4WBpgAg6CWwOpHFmlXu3FJDgAOzYjHW65AjDgAEB5TdqyF+9xALUSaIFBhm+xOMbjl4vTbQ/1KUBFKafRXO1EO1OQHzpDAowxXk+VAtBhgMbROuYlN8hxUryBI6EDOz7zBx/ghS/2AKHGOT3zhQsAJoHhSpoFS4yTGaQHczBDIf8QgLmRHzYzmtr3ADDgkksSWBpQAmzTXialIGeWXr7xB7vBPecFNIFFX8qBUlMwHULFehyyfCoUm0I3dnexIrRyGDQyOYL/4QEpWSNmEwGhNjqm0wPcIyStk4p/+APcgyRIYhyoo4o+4j4oFZqpGS3ndyWIs50VcSFfMxgQ5hYeIEDaIiHkxRtBkGHwAz/rE6EqFgQWGmIclgMpZqHiU6FYFimmUZ2T+FkjKqAUEWE+BkkYwjBMKFFAlj3nxQchZj7lkydIZidKRj53oj500ig0aj6OUgOzMh1HOThbkkImahETxqLm8i+zURsxiFISBAV1Uj53gid6wmR88ip3IgQCYaMNsaMu4GqOOR6UFUuUmKQXcRRKIzJuoRoP4BxvIid0imRXWgYzoCd6kkRulkTQ1gWE4qVZKihJhGdeWgY/oAOLOYrX/0k4anoiUkEjCsAYEaAAM9KKBCGIdNM9TNYFgOInGAQFfNIFAnEGHDQQriIDrrYCvFcXTfmou1IbsPZA7XQYT6iHU2AcdspkemoozZJEqyIQsOJqZPMWGwKr08IGKYRRb3oaY+YYU0AqfQJnzSIQRLBES+SlOSAFiWU2yxWiyAovSCWeERUYK9MBGrAEMtAnL+BmxHIsNJRqh+ICSDIC1DmOjxeuukIY1KNUpClubzIDMaQEzHIoqGKwfyIFI3AYgWGY+vo/Q6QAHqAAo6MDZZAEOFRDyxKvRNCx73OH2gZWdPmwy2Mp7xEqOKNrq3Kty2IEW1Cw/+ADeyGOx0qyy3fjZxvSNa6TA0nQsWegLNP2D9MmBUiQLYShbPlqs/ACVDhLGxhQAu5zZ8aSCy9LtD5Ql6yltD5UPaOYIOITHKRaBkzQAWazF+GmtcvDBoj2hDMSbzmDM63TAXeIAayUoGhrQqPoAVf5r2Qjt9qXtHd7QifbtRcREAAh+QQFBwD/ACwJAL4AvABUAEAI/wD//QMgsKDBgwgTKlzIsKHDhxAjSpxIMSLBggEGCswo8CLHjQkJBgAwsuRBkyUBXLy4USRJlgZHVpxJs6ZNhx5B5izI0iNBkg5NNpQ5kGNKmTA1EixQkOk/pk5jGhUYFeTNq1izUpRZgOCAgz8DDAhA9B/ZnyIDVIWqtgBTAv8WCITwAILcBw8OPFjwIEJfFisAayAxmAWJfygeJN67oQCBAmoFCrCqtbJli2c5MoXgFkJjCCSPlvxIlSTUf3gxsIigYYWGf0j+4Yg9IvY/Pzr+jdi9G8kIElNIrFiMty5nzmTJNpwsQLPZ5tAlk558ufrDsU+pDnALAMLxApzBu//14NQDatR7WSwAvGLF4cGER/zL3aPGP/s98u/WIf/3YRar4TUXaom1t8ACEID0GAHhFSCAgw4SMFlGAkg4GVwCHZDAAf/AhaF1IGqVoHjfHbcdZE8dh1cEEfxDwggfjFBDDx/Ud18Q//Twwz8y/BPED/XlJ5B8PexWZH75BRFkDbsF988KMCzgoQAHVFjhdB+GqCWIQMXkFFN4ARcjfjXUwIcMfAQhA5prypCDFP908Q+cUnQhBZxlQPGPnlDA+Y8QfwokRJ47ojYigwQckOiWjDZqGRtqBZCgQA/8g4ECCvyjQW5SnPEPEZ/+cwYRnooq0BmD6qbBAws6lqWjsMb/ehkbG/yzwQMYPPCaFC8oEeo/W3xKRBlBsIBBYxxCgKiszDab1QaeefYAtP+0SAJh51H1EEdJFYVQt0p1pFFLI3VVlrPoNpsRuOCOuxBKLpnlLmkGdUluUj6ZldG+XzY1WVRVpSswQ/QC5dK5DJE0Vk/yInVUvANBZm9T8mbnlqT7moUiWW495dgGBDCGV2MnNSzZwM4+fJS3EnMHWVf/sDHQS/9gdy5UUDEmF2AABubaFK9NsRsOMfJWEA6EkSDGkygcmBeCiCpH7z/QBQDdqxJSjXJ1YkVW82mc/RNeg5wBALN5YkNbHGIwsOhaYYeRgARtuuXY3xW1IQH0tQAS/7cAVJOCJzZVkUIowIMdZkTAvhVS7aHVHVJdpeNbZxUpeV1BIFZXL5sFwQDSesZXcdMWd+tfhh1mUJF261Zj0f01OYIGGowg9B+2C4cYXu4FN4WTcj321OIckiUABFQmX9DhlQu8sFlLtWXxXAXAsMIUPMB4JJI1uCmDnnt2Ab5BZfiYQ54CgQ9FEFDouaaSNXzwAWJ/Cw9XAIrK3Pz+NUVKFYMLsB4M6lK6CKAgR/YpQ51eYKoznKELDizVqYQgBWLNji+OiYqi+MdBRpHIKQ8wDwt6wCslkEpUYACVEYJFBCMQgQgykI9jlJWdDtrQUeCBFrU01T2BwGlUUPCBBf+OVQBobaYAlRIXRsZFmm7hy103jKJ11hUTJeokYTxZl1CK8hItviQpJmmXFPfHrW8lpCxaPEkXzzixehXsjQZTyNTGaB2YULGKGmmiuBwGkTki5CMZ6xJSMHKR09TQkCgCCSDpOEWWfCSO8FJZSHhSr4qZ8SdczCNLoCK8l00lOSbLiFtG2TE8ms2PjIQIzbLYxVaWSyDY+YrZQuOTMMoLKBljSxUfpJmwjchiOeRLBFYQgb6tADV8weCkksMR6lgSlal8lysZBj2MjGVhEgMkJrcoSov9bS+KidIDVvAAFqCAPfABDgl4cC0nEUYwgVkAOTegqItRTWoPWZwlo9n/kFZWs1yd6ZjmPJASgzlFlBn5yleQyTvDGEYDQKsdEl7km9jQrQe6+U1wAkMcvEQLPM2RSNWas7gJ3Y+fCjGNtkb5y5aRhKBkieVTvFaQ4hRzBSlgQdCQgAPd8MdIsasN0PwTmAgMcHTeAQ/HvGbI5d2zahgiqUDgQp3JcMiZKB2JQjsGOpaK56vaEhte+NK2cZYTBa3RgENpVzfWYXR+ddvNP4A2hScFCC9F5EytSDe4RMKFQw2TkGMSNyXIAfZDWEVpxLYqlrCJZ6ZMkR6lBIQao961L73TTWxYZx+B2GgENOrPXDWlVrUWkzC+E84KoCa2ZCZmAYqioYQCoE8K/1ntQ4qykoQAq9iKaIZDd/kbgowongcUcUWZHYEOXnef5t4HowfhzQhwJ58/zDWiuhGadG3XHnHWL0LMoUpICzK53malq57MYzY7dysUAAdGuwkCjPjwjxz8IAg5+N73ePSjfwApP0AqSA+CgCMZEPgH/23SFECQzAxOBnlVSlBizauVrpkMspEBj2Lea6YB3xejPTAwj8aXPjsZBE5QyFMZVMwnOeVJxP/4wBQSM7wCxPZVFE7ZXG5VzLv6JQLr/B1wBjOF/JwPThC00538hCoIAkqCZ5BCin8wBRYY9zGKynKO6TgVgm7HIA9QAAumUCYXKPAFZ3gBqAyihAj6UP8KRdJABErJyS2blw1OcWwBMPAVEtTgfGomladGNapc+OofSqhgDV5jEBzb2c7GVQAGNiWDLpjQV2dI4RZWSIQsEEFOqHHLASb16FIXhJ6G2oAHOoCEMjxQgqKCAhL8UkTBzYW3prazZ55SqSR+oEzQjaGlbpXnAegv18gONQZQs1CblFGOlEm2tG9pSjVSZpFVTOO0x2hHJlZynx3Z4hLntUSaaXvb6Hq2RaD3MDlCTCRcfGQW0b2lO1rFkZTECVjGRbNVWtteExskUcRI735WEd4VkwlpELaSb9dSjA47GL7D0vBwQbPg1Z6Kt6HNsHjZ+9vuoma84wUxhfSrhoT/wzi7UnrtsDxE5CkNpMJZOcgr9gtDbEkkxe7ZuVx3y9704iPDzkVxbz2xmmckJLsteZqmW6VfUbnQ9Jw+02T35OPhpkgbvfVHReLx2No6HoNWqvNDztDGOCPlNQ0yYfMaxeUG29c0uxZZsHx8atg+pEpAAqEMcRJgbQEcgkhHeMpSZWOg1Fqpcbl1NWbMitr6uMfNFrElaoZBTS9l5DzWGHC2hz2fP2dN/8aZA1iNmZBzZnSQPUd/bvLxUVlJSnZ+0FEeAFoLuFUy0SNMFAyzPe1ppzqv1RoW7A4vB0A78iKTeqeWTGttT6XKit6l0DTl6ntE2Feajnu5LMAviVmN/2t+pk6hvQgHI0A/8XWHAmIOUC+tktp4CVbVC2/Zn03xn1eor8kyRq9jeYEY4gdRtEOAmrVd8hFXODAFSMNR4HQgDbIx2/IcDvIckGNqS3FKOEMeGjMSGugSTuEVMaUWdLEiAIJatVMCsFEbuZEbRDIkTbKAqvUA4qQXDRIpF/cl1HF6JKU4JxN9dKQwuUQikNUd+9I1XPFK29Ed6MEiAPJQU2BRFsUfPxVUtiNk7fFayGdcGeQ/0OQgtNVMYTheqXcljaNYIogiggMzpPQycUd5UHE6JnhTOgU0c0UbuTEkGTU7u/EaqsUixQF/GdQqVRcpcGE4hGVbFENb/4BrEv/iaHT0FaIkOOEhKQHlMl9WXHTxD21TLcPkIseELYMRG1fQOiMgX3uoG0mzGupRF/Q0WK3iIVMVOQSwOLbIg840hn/1HFmDa9EkiZA1KV01Npe4UDljF8lkTsD3JCRgGC6SUXYjX/kxP6AlV4TxGoARAaNTAANQK8nkNH+jLcnXMM3Bg2SBc1IlGYf1DwgwGQgQTbMUKZ8ziV/1VWbDjU+hNkiEHua0GtbTHkOFA7XjBzniIzEWBPihXAn4jGrle4rhhOOnWn9jSDYoJW4xIZABVYyoPI5DJRsChFKEBiiCXo9lT+OBj0iUkknUF6NjU6yhKbNRN/hRkBhVjfwxJL//oyl0RYC2gwM8UBCegUTtNwVZeCCboRwnM1uS0YuNyI7Iho9SwxRjATgbIBcMVRzSIod9MU7/wAMfQDRCIiNlEmNxBV3bFYV8aH4804zXIzQ5SU54MXYOZiEdInWPaCUYlxAkUoLT8h3cqCKYdS2HoVw1ch8dliMgxj1CUpMwKDt7mJC7cS3tERfBg5eHUyXltXl5+Ude9TkvAxnXxI2CUym9I12/xgc64l8EBgUGBmM4spj+hZg/MCMBliNKEiNYyCodQlUVWFK7uJnvYnlqgUkaYxZfMU7YA19ylR/0lQP49Q8vlmLrM51qkiMygFFqwpr4ZWAEVh/WuFockii1/0hb4OWLwClHUpMThbMZKPA7RZMfNaAkO4JRP5AD9bUncwIF4sMneCIQecInKpaf+SViMnZMU5VBVFOB5xkR69JUTkcXYyY/9ZEmPcJf+YVf9lkQP1QnPlQ+BZFi4RMnB5EDfFADwOMhf7egzrZQKuUZMGAY8+OWGlUmJSpdIaZAcdIFFLRkd9InPlQqoBZlcIKQSIACILN5b6GiIeIWA/AAoHMct+IzHPVe/qlAMzAndUInOvpAp6KhKdYDOkBMUnKgtRgwSgoikiI2X0WCbrFXETACa7JiM9ApbuBAJuQpJyQqSpYDI1ACRjpYTWGeZ7olyHExLYUXHTBmITYnpf/SQqMCBgbhQP/wAvY5UX2JKKQ2qM7yFsrSGAWgAAOgAKxxo6OiBEYgKhFEKqACKmdAorNWAMGjLGCnqZUzLS5SAy7wAmqWaSd0BrnwQi70Ql1AZSyAdstCq5UzIkyhAB1QAjLQKawaKr/qQluwBYjgK1dQrOFpY8jKP2ygVxjwIpVmQqayqsGyBWdQBkuwbLL1FILarekyjtkxaT9Qp6OyCWtGKj2ABB0ALSHzr2EDr8n6ijmkABrwJlKwCVDwQkQgBVfQAUSkLFxIQwJbq/t4Hg/QASQgA2XgnAUhAz4wbOGxcxW7NU3KFB5ALbzzInIlEJciIAXgAbNass0TLcYTtWy9Vkx9wa61QrOMhFfZMhMBAQAh+QQFBwD/ACwEAL4AwQBUAEAI/wD/CRxIMADBgwgTKlzIsKHDhxAjSpxIcSKAfwYRXmQIIGOAjRgPXhyZsKPJgR9Dbuz4j2VBlykrypxJsybFlRlbLsyZU2BMgQMwDvjYU2FKgyOJhvTY0iBSgTAHFuhZ4F+Bq1UJYK0qkKvNr2DD7jT5s+lQnwAKgFwKMiXLpw4h/DvwYGDdBQ9QsECxYkWEFf9YAB64N+8DvAcgFFA81SmBAAQGCvg3meDkomIzaza61unUoWozviUYumqBoR4EQqj770EEFiwi/NMwZfYIJP9GCBwxosQUDcAFv8YLQWvjxwGSV34YQIBBAY8jExBQAHrz5pOXb95OMUBVp947fv/27jYA6ORWr1qdu+AfDBT/SPybggTJiCv/gvToMSLIP/65/YMbDhqQANwKLAjkF4IILjAYXq1JF9kB/8iFEXKUXZddSAJBJ8ABHwqQAIUUcmeiiY01tpR5nlW4wF8oGChfgSNMMYIONdQQxA85yPCDDEHUINB+//0jpI49fEBkbh+MwEcPRerG5AckDDbQhDktp92JXHa53nqmeUeAhYGtQIKMU5CQZpoa8FZDDmVI0YUQXZzxjxsCSSFQnHr2KVAXd+apZw+/HVYAAVpld0BkXjbq6GaHFrdYVwMo8A8GTpYxwxkvECGQEn8KQcQZoHp6Rhcu9EACC+11VeKjsMb/yuVVCkCggAI+9NCFEp7+k4unW2zxnwYYVAXBBpEtMKmszDYb1gMPFBDtAxscG5h8gV1abWsNYXZQUWsZBRFZF/3kkrPoNhquTwl5i5loTa1bkkr0DkSuvTyt5RVGXKHHU7oAW8Thv23JixJLBZfFEFLJnYtvVwIxylh6VR0G7QMwuIbXAtUaqx54TlGGkXNbBizrSSVxVS5RLEf1kVcGqVVxaxtDGwEMrwE2hZlrCnSmmgamuYIGKKCgMbRjagXZ0o8JsOG3I18XcUYlm8wdWU+V60HIaSU3VEYyS2XsP3jV9cBeCdJWAm8jQCmQH//4odsIBQZn9MWLqbfaYWVr/yVZxIdG11x1zWVIWXXUfThXh4y+arVmHbGMUVpdeyez5VcppvnYBMW4Qm3/6HBjDUka+R+UUpKAxIwGCqSBQLXxMMUUPPws3+19sfAeDCvwjsIC7U0ncoj/TFcio48DfNFUzOe02AK8Iwh0gLz9c8UIcvcQhAxwxvmPFOCDX8b3cObwD5A/BJHD9kFAIcNA7gfxpG7BdzhydcnnL9ZRS21VwAb/+MvsePODf2zqH2fAE57+MacFBspOLhBSBDYAwMBZhQCO058GuxQyjGxALyyogRS+4Klc/MNU/zACIoywhSwIqwyEIsECDlAAGm7whszanFUeYKkfzGBU/4ACEf+6ACVLHSRaioGaRmTiLRw68Wrt0glKFsYukUDlJ+aa3ME4hDC4PDF/TZziwjYCF5CY0YoEQRi93DI5c/mrIQb7oqM6AxV20ZFDeEQLTchYR7Kg5V1V7EpPvMOvlpjmS3Lkjhel2DD0aIQoKNvXU+ClsIIsBY9MqaLzrMKYrUDgkxuYloXI5K4wJrI7XVxIUMS4Ep94pDPlWqJVWhSzGtYwaZzcQM1ehLGb6QVjF4MWDWmYxOQ8ByFPOyXkIOkWSZpELVqsJCG7csgKPYBMrjmbXvoCGDFUaTYyeh2CimYY4mgFAkvLDtUok8w8Dk+ZFflJaAzpr0aeiycGCcpp1vP/SWpxiwV1SdB8AkSbgs6uQKszEAtI8BdoKYaGS2vMdQrnkH1JJ3HSMch0TAlPyfnrLJTDCHpWuZ4BcGVsq7FQBFwDG9kYqHpFitttdFO3VfllY3lLUVaugrwOxSxx6SRc05Cp0eKJDAHwREh4ljoU0KiRYU0VZHqOBSGL9SU+amIblILgpIHMrQe4AU5gVnqxgUAPWi8Knmkic6idRsdpVXFO1OQaMacRJAE9Teq3Kkc5p3QNJp9hXicrJK28nAk4Nqpe24rkNoF8YDe6YRNwbicYwfClL9+Ez+82K5tW8fRQNGxPVo5JPJGRSGR6rQl5mEexWpKHk4s5DF98Vhvd/9RgBEIq0g+gpIOFSKlJTeID25j0jz8MdD4j+EOafrcARHkIRNWhkJbymlqwNIxfr51lbBdQWTW1KasCahuUzKe+MsAJCuaFwvriB6TGQklI6fsP+oz0JNmtoLmRSdx3MCLd6nbpkKsdSGL4xgIb7YY//JHbTHvAPe/NiYFCYOA/ykDhCZ/3fX8C3/conAM+zOe+gQvAAQYnADb4V3+Zk1YnMwfM1bwmdDUo4J9mEKg5AaqBdIKwjv+RA1WxYANeiUxRT3zKqVBTPRXkIQbOpps4veCESrDTk1/QBSJMuYETlkENSEAt5JGJyNVlw9imYqECsOADMphBEjqFkDMQwf8IRBDWm4lA4yopayBfBrOeB7KBYnXABzKQApvdzKsWCgsRuejCD5AgUKtQKM971jMS04MBBbBAV2zeBBFM6CliAdBFh3rAmCJN6vVESyAA3AALLiDjH9XgdTy0kD5LTWuEeCCUA6jLkrfTk1ZWstakltciX6nHrAGbyLGU5VjqJcW9vlJhSkHjsWHF0V7Py17xUkoHr6jUcsWR236cNuSiSEeHRTFkmXwJR6t4LoSFO93ilkiypa3GpjRbJx3ctrfCvZM0+nWSlxyYFu8db5mEK9lrCde6LRnIfDEzjx7ZF7YzGTPtFjyK7izKIq3IP39fkVzMVONoHqaU70BzkAP/Y+0sUWKauC480m3B98RlPm+HgBxlDEsIV1apMjHy6zIQM3LQc3qolf/LnaUGF7Y58rJ7ieTlDoGLkVnrN64c61jBDOYFK8SuN0o82HWso1KcnkYjJ5xh3ya4SowJMYwk8eoVqlbZgvmijL1IIMqiYU4vmSX7QR3mGm9luzHJcJSAR16KGVN79naxjcFgY2hDQQQkH4G6XwzIPL1Q35VKsmMCG2UH6ddFQNqvj0+x18wzKddnZrb37EV6ZgLMjD4sGA345fEWUxZjNFS4qm1+Mo8BfLh2rkWQGj4pZxSkSfOmuaxnq7Kyr2nrBIKDNB22Qbk3VKIIRzKfo3ZLdLUM/+AREpSYbERmTk/JrD0GSmi5J4CAWejrQFeb+sdnPgT6zTgtds2rjJj3joRa4qcQl6FOVaNnoZFPXuNIZDQSJ1dSFaJ6sfVpAvEaQZNYczM38/EbBVJZDdV/mmNMEoV0CeEc3IdMAkhdqXUe0IRvQ4FO8SJFafEllKMe0UKBsTE08peBuaGB/+AbMgIbd9N/VxEA6CRXU4GEpLGEndd9AugcPWVXGaRM5NKCMVNPfmQePpE5diFx3LVNs0Ef2LMbBJE6vyEcjec/cqF4EHBnhyMZGpUc+TUd1FE81REdwrMheTiFHbUyS3EWjcR3GOEBY6MsaHUXEWCBtME2bdOIAP/iNvTxG6tyM8HEYnixAhbzZYqhX8URVJORFYwSfAJIIQmgKNUVE0whHm/hh68VFG+3Q8CDNmZCI7zxXm7TWIq1OsGBILKRF4n4O/dlMQIxTKt3JYckOIziHdCBWnJRGdmRAP5FFOPhSivzNdgVMod0dbrkIDzTJtWzH6QDJUSSJKKjgeFUJtAHGAvCF8BDd3wDPEk0JothHNv3IZABfMNoVALAAMhmSJFjSC74RimBUljhTwGkFyigASmQVTeSJD2QW73lWLtRfa3zOjIiez9jfVXCF1WijiiQMXj3jjOUKM4BIsWzjB6yOLTmbae3IrD1SXmDOVuhS/8gebfTgzr/gCNbJRAyRoYEURtqEiBKUiO8ITugc3208TMO8HjFMx1ZMRkmSRB8eHFNIVh99TVnMVWHIRhB6VU5+QE78j4YRhAf4GEfkFsOqST/0CRrKRC31Za70SQ7QxBvFTLoNB0YRJVwhHbRNoNXsZV9USDyMQI4gAQ4EDr/8CPqIwPuw2MYJgMywGCJOZlueTpGEiSV2QNP8gc8kAIcAzFSUx13qJcPwVc6wYI1lBdcKX/UMxBI0FuSeV4TNj6zaV7cIxBAwmMPqT2K+Zg7kiQ8EDFWkR0QIAAwqIKkuRAksTyWQ0gOsk2DKSU9eCMjsATn4x/fEz7ZKT4cxmPspT4TFkTj/0Nh8QM6AiYyIvZ3yfktrPVakeIiZpIbGMiIWgWZchJhdtIFfjJhfRInZYBeGkYQgPIfOxMBNvQdMKie64lxJmeHnIQxwpExGfMA3AQYStJgetIFm+IGDxZh3yOgdBKigFIGPzACDCVqXDdiFKKgC8pEVrF8RiiT/7MBL4YjP+ICZeAGQuAGdnIGp0InL3AqEgZhUiADS6AB1FIViyJi9tiij2JijYFOFSctrREbLNAmfJADXRCkQeopTyYQnDIQVOaWVCJqkXJLX+ekjwIZ1JRql1IAGBABGvADcbKlpmIqPjqkViYEMxBBU/A7/veeamo1XPgPQdEBI5BmdsorduZyEJ4CKkrwAkVqoniBQbY0qCZjYgcBASsgOzVQBp1iBGDaqG8mqgLxBV/gBjVQOxwDaZiaP6CEARrQA27WKwiEQCyUBaL6BWcgAzWyAMVxQa76qlYzABhQKa/zPU/mZmeQC8GSBf/wAmVwBSxgKR4jHcSqQXnzACSVA2F6QsKSJ0vQAR2TSzTEGtmaPFixGnBqATogBT7KrALhoQpQF3onF1SarvlTLQB0TZeCKZoSRDkAPlfQAZWGavhqLfqqP9bShvlKO16VApXGrXi2sIlULQ+AAf9Ao7GxUhugAOphsUnFQzUREAAh+QQFBwD/ACwEAL8AwQBTAEAI/wD/CRQY4B+AgQgLIlzIsKHDhxAjSpxIsaLFixgnKjwIkWNDhQUPigwAICTDkhxLGhyIkqRLgwoHvvSYsabNmzhtxhR40CRBmP9eLiQp0WXLlUFTNizwMyhPpAKcEhA44N8AkVazMhXIdGeArv+i5hxLtixEo2g9ciQKU2VBtjALfP0K4e3ArQMjsPjHggWJfxoEsljBAgWMCAseKIZAoACBAI8LCAgQQGzCpgKjWk4YdafZz6AJAhgZlLLbngtVXt4KYYPiwhpQaNAwBcmUEX8ZkiChoS8KxYoLQCgg1y7Yyk6dbhWrGe9dgpOZN9wcurpFrCkpAw06AGTPqgojrP8gsWIKiSmBNfgZOCII+38j4uNA31vvbxYLIvxLcX7Kh/O7/YUCfvahsMA/DyB4AAQPwLCCAxA6AIMBBxwggIVhZSYQAv8wIEACB1gn4ohBFSeXcpTN9U9iDQ7Ggl4a7FZDDT3I0EMOMsgAhY5l9NhjDjkE8UMQPfzQwz81IPSDjTIE0eSSS/JRg3n/4CXAVpXVZeFUJHbp5VJfccUUUx4QN5xwxKW5gQIRkKBDDUvimEOPUtTZxQxdCNGFQHv+o6cUXdQpRRkuyPDBFChwRQBjBIX45aOQhlbQVpQ+QMIH/5QxAxH/cErEGQIRwakR/2zR6RdIkrBXAQc45lyksMb/ChobdykwQAdIlCHqp7lwKlAOSChAXJUCLcDUBrImq2xZDzD1wAYQCPTAXgj+g8EGAyQYkU+YIYQaSx8l1ZBSPbVkrrjJLavuiNxeNhRN6dql2lBtsZQWXPR6xNa39CLFVbxPrSuwRj8Zhe7BotmLUlIbraSWT/o65Ng/B2zAVLSKIRvtQA8cKC2a/zxWmnZvdRYdQtQNrLK9ML2lHcMhTRrwvw9s/ABhvPH2zxQl6AyYqitEcNhvHbOa5lwphuUZVzFJ9m9njwkgcmchp7tydSqhNlNbdn110Ikyr3jzeP3FN8IH7h35j3sjIIFEzi5GEFwBA6T5DwQeI3bXmMQy/zXVY4BDJrjTSos8ldSaVc3l1aDFZBK/I6soF9gLPWDYCiuAsDMOH4wAXw0j9OB5fA0d2UPnngtEeuqrwzfFbR98wMfZKyQaYlSHQ3YlxRkyPrDMb504EAQwKHYYYX3xtkJve40gQ6Z1npHn9ANJIVAZmRIqA45Q5HB9pv/gKDoJMGzAZQCOCgDBZL63jxOtxIX573PV/rMCki5I4cY/+7+w5xn72xMRuqCEM7zgDIOaQQ1AgKwqLSpl7osgieDngX8oYC9lcIMS/tGrgWwhCx8UCKpIEJy7SfCEsIKAAlrTmmcJZAaECgIUypCDwCigWc0STpU25i54neSH/RrXzP9QSESM0KRdMmHI0n7iQ4exjGHl8tYSuVbE3/nLauCKScQUNjMk1gte5kKLFIGilCt2q4qxAuNOIJewKY5xIud62Fqa8jIsEusr3ZGLSArwNZehsXFDTI5XFBazMC7sjU9Ri7fm96qf8E2HCBmWcKLFNy45pjIFoU4m3fjHjJyLJDQ5JCGB6K75OW5yW0lMYhaCggi0spUdQ0zHFNMqVyEtRZlkiMk22cmbCCWJVVJk1oJYmpaBzTnOuZl+NLC8wOyMN1MgTNAINMsDEKBVBJgMLu0SHUxmSDObTFzUwCKyXlbEYCtpGBTtIhq5VGVMF0OWa/TyF96M4Dapw0FgzAP/tAjILTiMiV9xtEO1sDRSIIvbXbwms7iQVSab5nSIUJJWTNUYTCVVyWNQhvMAR2FuNujxHBJYpzb4lGA2/WRRDonjlioZzZRyOR8BABeUbsqESwLIKUIRGpUEQDSiPJHXRE1iGu7EbCVmQhYKxvM6s4Vubf84nXsEgoQljKAE6OmLXoADnPwIZDz2qx2CGAUtv7lKIAs6wAIWAIMFVMia4+QpQhjwDwR8yFFALZhMkvYWAFCuOH7NygCixcMX0fMfJOABkt7kOR041Wzm6Y1AdjOfs8lnCjjAQeoQuxvE/gMFv1nAYMaTORDcz61TsRD7EoeQhuZVJ4Lsmim5kphE/310ef/o3IyiurYf/GNJvS0SnHybJNCJrgc0+gBye9ADPix3RsiN3WcHgjguResrF4oKXl87lpfxLXgFwVuDDDOgvrAgRudBUg2aNCcoQC9QgrJeplzwjyfZaElOmqpAmtSkQ5Fwu9elzGO2y112EWRyk0LTawaEOfE8QG5tQpIMyiCFM1iYTxj+B55eIBD5eq8hZbARopqVWvRVjcAFVtlajDOQBgqETeOJD5yeN4Mz1Nh/0pOeEDQMQCHsD4YziqaxUnulC6X4j8O6S2OqtIEITKEGLnDDC17AqTN86h8C/IcSRGWETx1QgS5sTKs4eWQ0hpe29+PDDAQCKl+Jqv9TWzBCFkIlA0TB4G4vLbOeBaJCgXQgfF0YVacWQgQZsEBYfF4UWvd8ZG0JpIEs+AGVBQKFT50hCEjgygOmMpwQeYzRKWYDtFw8kNxMAbH62QAGhKOAHYL61Qi5FgYegIGcHFGIS/RME2H9x1s3cWlT3PU6WRZFfPFaVup8iLD3ZUeGncSN6Dy2l9q1RDZGMYvhCmp2yvVLdGUN2tK+ia+zfRlFljKd9fIMUbyyFmHfWtnhLkogcZ0aXdc7YEdEzbwSNmzROO4yj4u3Raqdri36UJT1DiNF8m3sEjmcKFpzZFZGAp5mgxokVyRzvcYFcZkY0mAbcdyuKSUudeuRJ+7/5Cte/i1tY68RlHAZphRVM5Jto6uv4IaIWJo2kAFU5R8Wg8BgV15Hh0DwtW7c97wW9m2ugdEp7BRXV8CiRK5sTIeONiHQXVitxaCJMgO1ODAZvbCZ4Etf51rkdqboHeFNjiAQiLsJGcSigRTvQFw9kLHih0ltFn0o3ZROuO91yJBnx2ovedmk5oLg8Iq3fq50EV8IYxi5qbQ1wrkSJimaSzJrXM9pkcnPC/btXWsUM4Q9kD/3spfdxChGp7ZfYYo3y5oZjfF8LWbVFWKZpR09r8ZmOlE3/kXtjD45k9yAKs27vJyh5x/6VF5h8IMf4KSp8bkvmca1X9OfuDbFodeO/8ydgnCOMMWvFzuWtu7HG9qUAPqeFUhgXGQY4FjMYnpUvNiLjDLqelNq4RQWrFVgJdEd5JdOJRFsGHdgxKIYn+UXKKUB84EDIwUfk7UbvvFPz3ImuZccmpcZB+VaflMZOZVJ2QRODlU1SJcw2PEy+nJ+mDEpzYIg4oFSJNAz8NE2AuEHqUMfszEYXLUoZsJ5nNZQnbEVjzEpuKM7OoVTkEEsJxMyv1dFXtFxLuFdTHOArKF8D6YffsEz+OQ5pxM6IoUEsxEjg6GBZxJgi3YgbQUtCYE0hFNTfXc4kuE334RWYsEhESV+RJWACfgW4MFHG0EpraF6TKVZZnMkSeJcyv8lUoBBH4TxT6sWdw2EiEulSn7DQxdzN7rjGEZ2AHNhOJG0ITk1hUV0hbF1GjjnFO/kXXizAGTTVE5lVcyVW6JjgbjBGy/yIlyFGOLBWQGCOYlyN4qhSrb3L2qVAREyIRXyNypoIdKYU1vCXYrXMGdnEMXRFHGnGKvHTPIXGJnmWLoIH52jWefxg5GHOeeBAyAwBSCwGzyQG7txP0uViV23VjDgAHRABxCSAQciNYtGZLeDISjWh80WiCRhImGiEEyRUf9QJo/2VSnAA7EjXaPjWI9lHhPoOZ0TO/GBKSI5OjtzarHHWVPAA7fBA4p1IDNlGbezaAKJirDWNWH3d1X/YiyftlR8kRuhw1xJghC3CJRGQiNJIjqdk1sDgSn/8AdkeDqnMzs8cD9GJ4B8piECl20Y15BZiCBrJR6yYVuaRSNx0iRrgyNlsCMyJCREElWiU1xI4lzAlQNDYiQ1ciQgkCjG0loGNRDfl5UPQTIochcY8w/i8SJBMxsfMCP85V7Y8w/WIyg+sl9t6Vv7VSNBwD31JSTAhVirFBbZJBkW8lAqCJjbAnVvlxx4w2DT5Bd90Rsh1VwzZCeQ6QZ4smZ70iP/4AK8mSNRxV+/8g87IhA98DqJkU1bgknXZZoYwXgl0jSO0iLj0RfI04u38QMuQGF70gU6VmGQCZl1ApnY/5Od2KObCBEkuIEfEwOApVFOzJkRXtF4ixJ33XiMENAqw3FBOFAjjxlfdoInL9QQgfIC+pMpOZAkUxlJU4E+NPmeOrFNfBU8xLEBFBoB/BEfyMWbGWQ90lNhdSIE1vMCQtChgLJmMoAbKEBqoumgX9KQuPcqBXBDsucXOpCdfSIQHPYPOTYQHMadMGQoI7ACjrKiDcqiocE36jM/CLIV6+WdRDBpWKajB2RlVDplNuYCI2AxdwM4B2mksKJDeNEaTjZhbtAFVLZBVsZmbfZmT/oCbvADLNAsG1OkXtolcjEcfLYVA7ACI1ADUiZogyYQRrAFRTAqROAGMqAqCCJmB7lVp8rCBmMyHAyiLS5gprsyEIO6BYgwEF9QZ/ixpZDkqO3zkIDRA2VAQJ1yBrmAECCECEIwAnIjHEUoqu7zkCpUa/WVpqtKBKbyD1kAKhEAhyFjJq1Cq4wTphtQQSWQA6JiZUSwCZwiBVfgA4iGrF1qrOqCJpLqGiMwA1JWPWVwBfpxldh6QgxSANriHEEJJyPQAQ+gAB4ALcNRQRVUrr5jia1xADhkmAjxLGWyavaKRgWwas8iazUREAAh+QQFBwD/ACwEAL4AwQBUAEAI/wD/CRz4L4BAAAQTKlzIsKHDhxAjSpxIsaLFiggNFvyHcGPCjhodAtBIsmNCgyY5BhiZ0eTKgikPXpxJs6ZNmh0zEoy50WXLnShfflxJlKVQlgNHJk2KkqPHAv8I/CsAteAApACqZg3ANeTNr2DDTjQ6sKhZk0hfglxqsmqBAAUgxN0A4cGDBSxgCIzwz26ECCgeRHgAYwEEAlS5vu1aUIBXgiEDOJ78T0Dly5TFat78kOfHsgO1CiwwoMCDvhsEs2BBAgcSHFNwjCDxr8Q/Ehpyk2ARYcEGqokHwNVIdapxqFwhj7ZcwLHUym8JwN3ouODzy5I9ct5esSlQhUpBl/+uixfvChJTNAxMP6XElH9IRsgf8U/D7hUr/KpevYJF/93oKbRCYAsIdNc/BQqUGmErOAACHTxkkAFBBxAggIVSWTaQAAcgwN2HIMrklFMFIMURVXedht8/I3xQww8yBJGDDAKVAUUXNv5jowxQBPHDQCP00EMNQ/YgQ4z/0EjjQB98wMMKBR524ZRVFXSAZdeFqOWWJYqY1VRdcQXBcMOlhgEJI+hQQxBHzpgDFGWUIUUZbgjUxQw6ujCjnF1I8c8MZcx4gQwXPPnAb8sJdMCWjDbKHQTGBfBcgSyMUIOO/3TRxRkvEHHGP0T8Y4RAo/7zBRFfvFDDVRsFUKGjsMb/uqUH/2CwQX09SEGEEUaEmkuooZZRwmlxLVDAARsccKyszDarmQIQ0CXtQCv8swJfDxTggQJ9OeQVTzlpN+JJIjmVVngCCeXsuo2mpJFO4sI7VrkqOaUuU6Clu5OIBz3G7r9gpYRuvf3ma6JRCDcFAEgtrdTlcQTJteg/EFT8zwEWCzTAP8KFOdxib6WroUOZAWzyQiaSq5BBL73VUWkDLCjYPywIVC1tt9mX8z8osGBXAdJ5nBzLozFEtL8CaTgZ0RsifbKWRYkLk73CQWXXXf6RgFts89EHJH0j4IBbBw90QFdcaP8js10LpJggsfompPRhxy5AwAGLVmhQyRsO/5TA04x6pdhnG29s0HimCbZABCu8x8M/PODwgeReC/SefDoUSeTml4YN9kA8fMDiCDy0aHoNLsaAIN7N6QtpVJddCbjJOUG11UglwrWVcDDHrADjadYgQxn/+NnnpgK90EXxUviZA/EyuCAQFP/kkGQZMsz4Qw0jaPCzdLJPbNzs5IPF3HQLXWVaBGi+KJAUbkjRxQtnuHGGEGcsL1Cdn7rRZxmF2oBUnjOy8hkQanJJYIkKcKYRyAB5AgnVFhDxjyxEsE4PKE1VXHXADjYrLgM4zRRkMIMZSOEGz4OCDzrQl2hV5TALIcmI/LWWiTjNgzi8ibtkIsOl3PBebDEXy/8aphK0+OuGOVzXt8DDw32pLChxa4hagvITmBAlX1Pj14jIksTAzZCJUkPZt66oFBO95CxRAwoRq7gWdD1sfF/cyMa6+CF5idFeRGyIZxD2GSCGKyGQgoog5QKVARTuICMhitAiQxClRZGONTkjT9BYRSkiJCfvSkqV4Cgx8hQGBoTpS4LqEkiqIAZoi0nOQ6rDSsm4soCQjGR4yMIStJTFJfEa38dOc6sFLA4G1aKWBlizGppB6QHKIhNXHJMdpq2sLKxM2t4wM00kxlKMCZskVq4ow5cZSGY9Ow8ONEAf3NQnN/VZzWCOlZjEhAmOMUROVShTQAE0JyQaktRCYHn/TUs6E4szdAvFUvMPwLBmCp6TjXxcg55xTgE317LAAxQAHODIZaDKqlCFBMlMfbUOMxCgkj2tk50CSgd2SeunJXsCRVsmMl1x6csDUICCFdgHofIhCNjSNJ9xDjNFczlNX/LSM5qigHGMI9ADLLZJqVAlb75cQAYMAAMEvMqeksEQhwSgoedkSaVLqdcZPUKm8VktNYyjWQRW04Fi2kcD74krmrSmNZvShjX2mSvlPiCfD0xBdAj9x0PpCgL0nOehU+CBYhVLB0XlbW8WwkxULMMAfoJVh+F62MZiKpCa0gZNLOIeH/4RBDbRKAhJ6oGPgtCDHOjgBz1gEYtwIFuB/9TgtkNa023/gTrRFehue2vOATgokMheljPe3KLLWEYVCBirbWtlAQ9qMCgo8IhH/7hR8QbiJ4H4KLYC+ZGMYjQj6363SSOYApSAFlILDVd2rzuuljL7kwBU7WMfI80DWKAB4eXAePITwvL81N2BlAFQ/9CTnpYUpzi5QAazsVZUoGLcpLFBvv/648rkqZANxIx9XiMenu4kECG87x/5e8FASCyFGRDqAyDwDWIIiOF+FodjLCPAaUjwgRzMoE6g6hSo/mE/JQBrC6cK8gxqwC2q2FMA8a1xP9mwSY4NAAIDiIAGhjc/YJ2BCGAWyBYqiOTbGDIxGb2wlNcsEA8UQP8BqvmBriJIhF9tIQsTJIIbppCtBCJGWWwONMey9QAMRIA+KvYUFIAFBSZYYI5TyRvQBB1oSNeqVqL7hw6ChBoMhJA0A40ypdlsq2hhAFJ2+Qq4mhjWUY96h/Z6pB2dOK7wWNPVtCNrHJ14w0uqUddqVNcVcS2rJX4m1q2GjEvHBcYYNixhYSS2WGANryUibdWeEREUJXkWpuCS1tmWNkOqveuwIjEmvh630bJJReWkhWDhFndnwGjHVYcEXdwuYw+dPeyCXVKSMtFwaDYiGsPJO5P7Rva6rahvWj6Gkisr42dsmWzQLJAlXXqnvHkNESACMeJp3NcU4T1DgSNHIGP/gimthmgWRRbEK5aJeWMEHe985zuL/S5i1PD9b1y+hcOCpNjFYIcslF9ZOE4RTiIXucpbY9jjldQ5eEKuE3+dHGIQg0q0nJuiqxlGgRX9uTu7YhmNWLZVwGazWYqI84H1i4vjUpiXEhIyrdOF621DwUAK1PW7oI2QzQlZdfzVynz1MOFsZvcehTJWub+LuR9D9QHsopeCrrWgBb0WC1IwoMFULPBdSWVjVHk0tMeNaTJk5tn7mXNvr92HKMvizwfCdYEUhi/quU0xb3OtFYAyWyAj+zKP+PIwurIypceqcyRTZflSMuf4ZnvKCK425w61Z2+tD23euhuaCQb4i2TM/8P1pTR8NuYtI72MdNKvr6/KF+5GmxrDFDMd09TFLizAC1zh6h4S9B836uEf+fcbwDE0paccCAhP5ddKI/NRlcFVFiIpTodDbhdDzFYQIRMap3E1jMNfSIBQCiU2/Ld/9nEthwJ8qTQ0fiZIBRh0ZfcQ98RV2XEd+UR97ndZ6TZLKgMmcyRAguFZ5NQ1o1Nb27cbg7EBFBV2dnd/pIRMvpQsMGUQWgcmBQEpA5RSL1cdfaN+q8d6mJRHQ1ElBeBLNXVYQZhTAoE5fUUf9jEYPyNAt5I433c1ladUkDEmLEN2FYM3BwADeLMAeHNSy5ElDLAhN0hH6HZvTZFJVTMVZP+IHyhgH/OBBEAyOgtFH+O0Gz5zNX6hVgI4IFpzGwPRG0tVFwgyFYgxFZDiSw4AAw7gABmQIFeiVQmBAAKQAAeQAFylUkrBSGYkRJdUd6axAW1zHueETgKhG++BBGiiAcyoAeeBH7xBMzTDGlpjHzggGyzSGoJFAjYVjZCIH743ICsAAosFAv/gAP9gAFFhEO6Xi7lYYcc1bF8ofVORFSOxMa+zgRggU3vRM7fBYyCAAzwQIJ+VG+lxG3+FU2v4AZumUOgFWJDzDyCAWFNwkXy1WBdTIRzCQQW0KFjShU+XLlhhLkkXMkonFBtzKAugd6IYILz1D+A1ELFFJEICW9v/w1sz+Q+wIVgCITrpRR8f0AMfwAeXUgPvYSy7aFy7OCWKwiEbx0TxBlMbsSgt2TO4QR9EwlpHEgQ7UlrmNSOs9V2ylV7/4CKakyQ+8iNGaTmnKDcx5ypYgoVR+RDEQX1lUTEpIo7o8SJtgl1wAifM0zzEIxCxBV5DMlo/opZK0gN84JhEyTOwcyEoNRmUKT512RAbpB0/RyY/JxcnKBgIJTw8kiN8smI1oiPmlRAy0FqY0phCkl6HoizCpU8jBWXymJkdJ0X41ZnA8QA2FSTDIyeZYmKfQhBxMhB4MhCnVT3SIz0x0gMl6Et0CSnDJZK6qZloNxwYiDu9CRwYsAKW/5I9BNY8UkA9xFOY8NNiOpKe2SViDSYDnVOQyBQVMARl+pSdNyE4BvhO2UEQt8I+6BEkfEAjz5Oe8dM8mdJdCjonyxknL+Z7M3YxT6afIDI0HoU+bkEVMcMawuMCchI/9SMEbiAE8iMFnKI89LOgJvRgH7BeyLEoamahIWIQF7ahVmctfiUQw1Ngm6IpnPJlZ2BknaIE9fMCZfABQqV+h0ijW6IRz4E+xvE4eJJkRvYPiUZnozJmv6IELyADCmA4BBBSzeeksgIp/lIg4ykDKEoQoSIq/7AFRUAEZcYihiRDATCjZsouF4UchjQAGOBAZXCc//Arn2IEcjpmiFAEbqywKluxKK4ygXvKLH+qAB2ABFKgYqUCp4MwEEmQBDRTHBoCaJNKPqCZEKHSK7kQpwLRqZ9CNsXFTphZqk/zd4b0AA6kP6BCp6t6Bj3QAVXyOnMharT6L3RBMdqCKDLgBirmJ4vWBU/gA9wSaVPRZ8VKPoS2damhACQwWq3JJj/CLVu3pNfaQfZ3rAU1oAZCEB6wAbRSrjm0VP/QrnshmX2hABhQpvCKQ/RaEwEBACH5BAUHAP8ALA4AvwC3AFMAQAj/AAP8G/hPIACCBQcKRMiwocOHECNKnEixosWLGDMSPPiPo8KOCA8uTJhwoUmSAgOIBHASocqRL1mClJlQpMabOHPq/EhwoUeQDWluHKnwZ8ihQhmq7PgSZIAC/yD8K0AVAtWpVLNiLQCgQEqUPB8GEEByp9mzZmMS/VqQ49KeLAEc7DoVIdQHD/5FgBFhBYsVKFjsXfBgAQEIBAg8DbA4Jdl/j3s+JEsZsmXLlSsPFEAUreedbEO+ZdpzwEC6EBZs6BvhrwYSSEbgGEFiCg4SfvvipbrYawEIpiE82ACB+APhhfEeJ14XqleCnB8fGLs5ZYADCsl+JYD58ufvEEcb/ywJVCVU084PbNigV2+E9/D/tkaxQjfeCAves/j32vaI/wD+pwMSSJSgARIaaPAPbjwMNAVuJPwDwgq18TCFhRdOMcUKC0DAmADRlQUdiCCCZ6KJnT2lkG//HLDAAvSRwEMNNNYQRA//BFEGFGVI4WMXUnSxYw5l5CBDDzIgZGMPONL4D5JB1PCfBu8V9huJBwiAHXeQSSVAYieGKeZDvqlI0ABccTUQVAQdV9gKA31Qgww99tjFP25I8c+dZZThggt93tnFGW6cMYMUh7ogwwckLPAPe9wdkMCYlFYKHptsoTnAfnwwKYOe/xBB0BZbZEHEIASV8cGaB0TKpaWwxv964ga/KcACH2X8c8auAxGxRS5SXIHQAgUcUKysyCb7nVQY/IMXQa05igF7FNkkGVCnlWXSSgbBFBZKNHWm7LhhroUtWEF1G1e6osWllrsrtVXSut0+p21YBkE1Hrn8OqRuW6PBJSK8I831kUf7vsXiVVJBkBoMhcGAgsT/wBBVAQNYZR1jBXEcnkOZddevpe7OG1pYHNk0kprBbXAfC4GtoMEKFLJgMwoR4KVaVgMw5vNmda0J8poCPMeZXWQV8FjR0Y1FwNEujfyZtyXX9JRzWKVGGAooyEjCCFP8t+CDtZEAMwuEvfgAAQ9A5ahyEejFQoIJ2tyafhO3CMEBe7f/CBUEAiBW2AIwGOBABoc7YADQA7269GWRSW2WaRyxaVrQjXXcXFQu/kMYnCRoMMIH/606Zw9BpE4kFDKk/mQcPegwoGwJhh0nH1LW0IOcH+w++ug8OHBAlgRAFTlBUm2WpeTjsjlVb2YK/c8AA6wXQQpy/kBkDv8UKUWfdYLPvQzkB9H6Dzf+QL4MRpL/w+41kM4DCohN9eWH/7DB/P46PWed89QyDQniJzr17ekfL9jTCwh1BiIkkAhGEJUE/yGFGuDnHwRYnrj4x0Hw6I8gHiiAAvizhFD9IxdnGMgWEEIEKWhAAWzKoPM6SMNKCacAbQvhAPCigSQ96R8y2A8G/zAWNPbMMFvn2le2UkQamSSlhlBMS9R+0pLTeAssofFYUa4IsI0cLIr8sxZPfiLGk7DFjB/ZYFPalZKUcSVg8TLYBsEInpRN8SiiYYgT1WJFL1rxiUoBmLvYhLWCHPEqjJGJz5hIRymiC2Hr2mK8lqKSSCKxKPLi42kW9huoHKZYUnkA36ySl04m72dzVMrxqHO8RlarKXv8oyD/NROffMuKvrlKVZLzgP3AbAUPsFiHsuIVDy3ymGVpJXUYFzJX5kQoTWkjTGjili5e5WJsewB8/EIzv/zjL2hLDmKyckztPKaKDHlcdEJUnZAtk0Tecaa/CFZLjyBsKiwxDZoKs/8awfxlQRqYgoJmZjbl4IV6LFlkQazSSedUJStFa84yRbQZpfXkOV7hDHUWYrwSybOP8wqk0IgZFZdpM0Yk+BoOHPQBspkNMMMxFjFJ6SzkEGY+Z+NazpylmsMoBjLXEUjRjHWY4Q0vg8XDoEIUwx3HWQYBdFQkT8RTOajkk4iFoQ8PyvYPgc6tNR1oTS/TlhyyTiwCgXmN6ABUO7ppYD/0cVTahJMaXkJsAd2k2T/osJnAkQU7kaOMRz8qL4riM03TE4hWLgccq3juRTrFGXz6Ajoe/K53TOqB7n7wPiaR7h8lEChuBjK6f3zgA3woHelOe9o4ReVD62xlZFpJWI3/mGSGihXIAbKaUgDprgfoAyKPoOAjKHQBCv9Abmaf1AOxkXYEzR3BP2pgWj7IqXQbWkCrnta4xr2KqbSt7U02WCYWDUQ9L3rPCnBQA/Vxb0dlAFIXhEDB7vXJSEYKQo6ONBDq/uAf2htIc1+T16V+KXAJeRp2xHuphBDSkL2ZnnMCoE8MPCAF0OXDFaA7gvW1T0dEAhSgcqCo9dEJUCr4h6L8tL4aTAEFbetki8LL4GQd5HJYCcBPrUOQAkQABz8owwxe4AY3IDCBDHnBnVJ4hheI6gVKfsEMLkCCDSSGuy2qMRjZ8ODnCYR6IiTBB2TghgWKqlcIieAWirAFIihB/1Q1aBYGAZdBLdfWQx+5CgAGgIEp9MAFBDHCqLJQqkFkAREz0MBVfBoVOzvaLs1SgA5ypatKEyQLZ5CBCRQgleK1yljGerSdZSwVBdhqBC6QAnIH9Y8SPspZv/GcqGc9kOMoAC/syQsIFtQeuxyR1sC2dV5wIkaSkPFe6AS2eM1FxW9JFYtfXKMmlc08O0rm2FskD7oYia4uApLaYiq2Lb3oLVimMmrgSmQbhxI1JYLbkV+8VsG83S3SKMVa08yiPTMpMEye7N0VsXa8L3nGNELb4B1L6FTjVROXiJEl+nqIUQAu7ks65d4ON7dTbEKwqmG8IfU6CIt4fDCrrtGwdv9mNrq3JUmHN5yS0OyiRE5OkoVthTc961glc6u5ngO84X4UWL3pBckswuVdIl1TbnXp2E46yrGflHHPz40Q7QBVZISduLwUqXWmcF1cMXE4w3XOJqlQhW+7JWvaIDYcoY1b2+I6Ho2VPZqS1fvePlk3u3nyt6gkNTlt+gcK2sPQjnnlmFpU5WQmCvK5OzOV0VQ4eYSCMLaY12HOwsvE6ANMDuWFWONUmujH4jFzzTGwpD8nef5d44Q+22RFP03KPFaA4hXnYfThfNwAA0y8WOWT08noV1SP8nhCR6gt+Qrpu/34pGiRlsXGVpoeep/WpJQFuHkrCeCjs/WQ8/CdmXD/0r0zW7Fkx37Q4c6XahxNkCJb5IdVrEm5xhfsC1Sg37xZ93kDfo5J5Wpm5yH8V1HEF1EgpxD4UxZKo1jFB0asty1EQRcFkXMF4DK71xrYF1A4MFC1UyW70X+JFBUZ02gBuAF84zxHtEw/dS3+A1QaFVH3kxBkgWUfZUm0NGE94xz8BCMZCBvS9Q/SFSEp5Rcwdhy8wRhZ0VgOgxyDAwMv8oSitDYMtRB4ZoBaUizDc2DnBFuQoRmv4kz7FnbW1htZsQGQRSFiFjYj0CBT4CBqNTG78Xu19xs6cx9yMzPglHv0QRC00lRdAhnDszdpRziEk2Wtwhh15ofYAVXGV0Nz/xEwe+dgWFNX+UEhOGAbChI6b2Uz8mFQgwN4A7F5MhM6lzgCATUzRIgzMEYYRrU3h3FeawcDDjCLDkAHinNUBtgZULWLjic5cYRJxYY1WbE1NbOJnIgBYsV94fQAKJA27TGKX/MfscFWbRghCrIfAyEx2ugoFoM2f9FN/5BXxaIYWjIWy1N+vAiGQVFYEiWM65FrzmJSzjJZgbGKzMgaejUbHAYgywUg/7CBCWI2A1EhGcIDPEA6o4NarAU2K6AxR7N8AsCI0LEZEvlRlGQXmxNhkpFLDpNejuI59JECaFgb0pVZ7YU6NqJf3PNfzaUDphg6bdiGCVldpoUjvUMQp/+1AjtGNMRDfj8XESNnSELTdjGyVjTSA3wQBOqjI30yXDnAOsz1D8LiXDKJk9b1D3xQk59FOo1iGAn4NASQAOsnVAv2kz3WEZiSRvwnOMxYNnJSA0mJPqwzXMd1XKDCPjcSB0kiJZ81AjrQX3zwAzUSP6ZIJVaGGEzTHeXoHWVplnbBc89TXi0CI3iVUqc1J+xDJN1zQHpiXPDFOj70X501XUfSKVj5JKZoNyzwLBYlWBE1Eo3pmI/5PxrJUVNBK+zRNe2VA7w5EMYVJD4SnN8DPnMpA3HwPnNiPvqVJEnikhoyhPYjVIaoY7I5ERwTYfayGA1hGi4jOnMCBTcCnk//CQVEMiR0wpsmppStwz7MCWjl8wOBeQE8AEzOkzRZVp0XgXxApWO2lCYqsmf5Rx99MQITMCcDUSTd8z3dMwN+0j5GEj51kidCZl0k0HZKpSW9iJ8zN3D3lJ21l14PoAGolWpdsEC64iMvoCd9QkFRFmUlWqKIIgM1wCEYFJsaCh7XOVVKhRV6MUB+QmkzcGRBkkBGRgRd8GZu9mQL5AYz8AFt0zhQYaM3iqPcMRJGtCYbgDMKgAEkIAMzMANGZmR3EipOFmgS9GYDsR4YhFRSOqVjciwMOBU7FKIGGihn0AVuFipntkIOYRqu0qZuaikC4VgH4QHOggEK0EN3ogQm0XQGuUAEWfAPpoIq/1gXAYAYVBeosWIvFYYEQdBAKaQrRJALpbIFqHIGVIImr+V3mso8XBYVW9oBMtBkAxGqK4QqRAAFJVCBU6ExoNaqzGMVUjEAqMZkRJBCm7BCW3AGQdAB1NKrxFEsvwasyZIXpMQeLDAnQQIkDFECHYBDXGJ2fkOtI1McHjAcxYGoEdADRdIDyMUfbcKr5xVr5DoyG+ABxOEyEHBrEYCQzTUFEaAAITQthho09So1y4FDtwYBcvZPaQoccnawUIRDOhixGREQACH5BAUHAP8ALA4AvgC3AFQAQAj/AAP8G0iwoMGDCBMqXMiwocOHECNKnOgQQEGL/wQyBBAA40CLHQVy/Dfyo0mSFzUS5GixJcWXMGPKVAjSpEqUFwd2JKiyZMaELEnubLizZYECEAgUWFBgA4R/TqEeHUC1AEeBAW7O3Mq168OgGocKRSny50eRHQsQtPrv6IG2D/4tePBggdx/DzY8aHo0QIEABLIKCDDYr9+CAiQWSDy4sVavkCMDxclwQIABatVCyBshggYSn0mAXqEhAgq6f7Omzir2n4fND1iskM0Cxmm6cxGrTdyWgM6BiQ8IICDggO/FgAUK+DsQOe9/zyVLP1gSa0usVP9hbg4Vgt6BegfQ/33gvfxeuHbjyo2wQrSOHiPiw6/R48OIf1M0lO7Mgj17FCz8EyALorXHg2hTkJAgDyD8AwMMR0EnHHGMGfRWAm8xMN2GWwnEXEFq/VRAXSuUyMMHNaQogww5sJhDGWVIIUUZUHQBRRlByBBEDkH8E0QPA/VAX376paDBB/9cMNAHoHUGQ10LMLUYT//4JgBvvnGo5YbMZfUbcxH+ZZlVzAFwlGkk1DBDGTO4UYYM/5RBkBQDxQjjnVJ0MUMXXZzhxhlndCHEP1LkMEIECrQ1kHBvbenoo1x5mdo/ECw1ol4sjNDFPy8Q8Q8RZxjxzxZZ/JPFqV/IMAIG5ykK6auwSv/HBlJIKfAACT3IIMUZ/2ziqaf/AOnqcbQ2GuuxyFJUqXpqbbABXv+QQBBd2kGQKE1m1bTSQj4JNdJIIYHkUbfJlrvlTTdpW1BZOonLULgYxduRvOp+S2VmrhrkkVnm9gsRuGB9u1NIlHk7VFBnFbzWAUvVtcFcUeJV3gaYsWaxSo8dNBi/iBHmcXT+ajkwS0P1dBNbIfp1VAEDSOwUxCygsMI/K6Bw2lwFKNXXxRn9FSKIirKl3dAEZZlRhQhFJ5jHR7cFcsgwlYXxupaZ2dGydi2gFwoktKfBzLMBuEAEEB8lJQFKEfTwAwAiKBoJBIZd80AwZD1tXePFBfEKC/D/vQIMch3wFFKMLWalcND9k0CVjEP90nUuWf2Th5JL+s8BgtslOAFxjQcDezjI10MQP+S444r/tNjDD0LGdx8S0WogoA/6sfDZfR8gOUWCLIy3wcoDZTlcYlMb6zishhnkV8ttGZYZZs+ugOIP/6yoI5wy3AgFFNnraPqPPcCHBO1IhF/DQDu68I8LLpThggoyfIDC7z7z+/Tx+H81VnNPUUzVAAoYQARQBKcu5ClPm/ITr9wAqoEAiwhKIEIRvvCPCLRlQsTJnwanE6FKjQgALUNCGXj1KRKO6h+DMNUZdGCB362FN0/ZoAw5hIERjYggGBjBDGTwgyv0IAc16IAF/zzgFKeMiGGV0ldOOEYdnABgXzOMYmTQlZPHsGslaBmLTw6GMIRtC4pSPJ621KUwfaULLeIamROx+MSRWeeL3ipYvMLoqH1hJGNm3J/BqLRFknkRISZz1VE8GDS1RE4tFmMiHbtCRupksV2PXOJJ4pgRgY0LRAzT2gH0dhfyPEs7q0kkRBgztaPhcZEUSaO8KkmwoNgLK+1a2FIghrcoxcWGmAkla37DEOL5EjiolEwkS0IuXmrRZ2aaVVMGB7EF1O1J46GVzgrjMdUchiAb29ZJ7rgbkGWTN0hzGnTCGcx1WRInB2sXyrgjnhGRiD3tKRHNbqMUwyTyim3ZzFzGA/8Bu6iFeVZbToV84yHHFCchgVmORgIDnVOG0SWwbEsa2dIypHznAaaJAIGmELsCoaBulfKgPRFJq/Gw4KRToM1JV8Ae9QxkARB4i3FcpRG1YO4tUTLAAg6wU+NAQGlFA2YwScYvkDCvZZWKilPq8h8BoSACeYsmBJKCFAIwzKJsQ8Ht4vMH130gQV/rDFT3uQAUjI1mn4Nm30pUIgfI8287TQoEnMeYDBpEQ+WcXL0uoxOhIbJ523kKU2BKqSLuhTw0WwEIRCekHwXrB/SJjwaIFAETnFSspZFdaEaQO/vgRz8JStAKHqCU4QAmceA0iNEWl9eIjAuWHoJtP7n2thH/mO9HQeDejXJAJ+0F4besI0gQ6BNcJNTOSDhAUmd5MJvRwpRWuyFMRoRjUMDwxnitpUjywNSza/JUaxswzT+QVAM4QSFO6K2TjXDkIzgFK1hAkqx+RkCf84XvPTrInZBqwAO7BCY5f1Vkdqf4oZ6txS9mclUEpmAf0eBgCiOQQftkIKf1Vdi9rKuv6dALozjFSAozkIILZFCDFPzOMIOx64CR9c+EMQ8CNZktCHIXn/JKmFCC+hOfXsAnBbrBgYAKMqC6kIN/aOA891tx/ib1E+IxJ5d6iYCCRsAHCnfhBWcAlRL+ISojeEpUX3iBDEhwHuwqOZj4QkpbPDCVB2hA/wZZ/tQ/eEUEI2yBIFkwQg40gJmnHIcAMT2zoP95LQ38IEZ9IointkAEFyxBAb/zJ6WqKuhKP2upEAAgBnoQo/MO5AxBCIECFDDIy1EKL2au9IAPWx6aDUQH94HWQQYAATao+tYDUc93MLABDFhwImPkGBhxTWwqGdsmTQxkLFtTbDra0ZgKcaMlmX2WOU6y2bEKdroWEslw8WSVZmyjuFm5LmxLh4rbekwjv41GVqqSjdWu5Lcnpzxzz+TZAlYeFKXtbnen05xFCQu9Bw7bYds72cjWZkLU+Js/Vjtc1M4ju1OWGeC17OJDY56XoI1rdCd84a9NCRirc87J/MZ5V/8lD1POw7KWDyDB+W42vq2obyxSUouPPCO9tAJLn2UOLw/YpCe9Q5CWXWWXEYFlYxKXXYObzF1EPefUyPXHVjbP1DDVyz7xxjmkVOxiEXWIcrDJ9LC3No1xbCXBHi7vk5yx3uqsUj83s8l9otqIXwd7zMud2rLTG7Zn9vaxY4kSa+O73JOzKbSCHvRTH8CIqdGllxzKy8dsDCuA10hqkxzMNxqTXY/kSIjwZc2gMYVSdnlpNFd2ANVQ02PI4fu2C7aY2Mv+7xprrbcH5kSNQLEkFSWJmmdZl3/I7PijzYtb/pLQpQ3mZxvLpkS5g5MQLf3k0sfK9YPnob3nT/CA7L3/vFuMVBseli5PZWmJ+oPRvFQqAHMFu+8NubKpJhEzRr/6f7NUU+Ilh/8bgxxLI2jgIm+Ug2CsFHxtgVUVBDYz42oxA1VzJXlW8xRP0TLjsQAssHXUohM0hxjB44FGwxsqAU5aYTQPxUfCB3xpcU3NkhdlxR6gMYNfw1KosRcWYxVpkWBqQRcaBRq0wVIWxCx78TNrESYhYhxKiDkxxTCAthwgeBB4RUe+lzDNYSYw1xQPszZoQiCTJTuy4Vyk5UErU2qFxRkEAjeiETcD8VRQknrNlE9VVSl1VzfOFCV1w1M5U3sCNSXBwTi+wVozJBaQg2Bp1hy/008y+DazoVH9/9E7dPF4c/c7j/d4d9EZX7g7migtLNUft4EbubF1tPRMD1KKf5OHlVJaKpY4jZJqMtQTlJFmlNMWtIYXG/BUQwhVdNFrqDEXm6SHp9aGMuhVnFWMA/EZNINRnmh8NSMbMhOGbOUAB5IgIOAAqudBw8E4iIMQb4GCKRhsisQyuVaG5sc5ngRTTNFPnGMXMiMaNRY+QrJfQmJk+lEaHdAfJOAZMaOGM8NRPPBgSAIaHCUtIDBaR/EcjYIAA6GQi6I4jYNKYPRXCCYQljEm2OEXSbQBj6c15TEiECMzNJYrIskiOvIPwTUCsCZZolE7GmA7teOOSPIP8REtcMNWeTFOyv+BR0bjG96YXQE2i9wlSM3zM3ZRMzCZIjXwI9fzIjRSZKYTXDJJX7YVLFNQAvphAh0wX7lzPl8FNzdDVVOyGMYjUw/JKAc3eAXGHUvRHiQAAjWgA/RxPRSGJ4TyD9rjPeiTOj0iA+FDj45IAh9wAUrCJDVDNqixM1dyJcBEHD91UD15luH3M/1UVlwjO0iiJCuyIzFSl3FyIzSSW9njI7nyDzUgX/pBEEh5H2/zGe3BFN0Xex+yjZA5EYdRcVoYLSCgAz/gXjRSPXepWzviWKsTWSNglT4Al3wQPj+wnFXWA3xQA3xwAV+Fg6thhKY2mwoRlN3FE3+1MmzDAhBGmuH/Q2XO2SIDYZ46AgU98iPxgQTlA19Fdid3sicz4ALSCQIu5BdQiJ0QgTEsc0388iFTMSJuqBftQWXu42FvYp5y8iY9kgMQ+iIyMqEyYkA8tiaqEgHPwoetx59ekTxmRxCbgQIfIAM7IGEwMmLotScDcUAy8mFB1ilYBipXJgU9cGSkZWqP6aEzkTwe2HI8yDIK0BlGNgW76QKJ9ikvsKQ8JgR9QgSdEkFedgYRpARJIANTUIQ8CillYSYFQJb/xDLicVL/oANVNpd0EihZlmWLJiqf8gVf8GM3KSHZuKWv4n8GtoC2OBeewQe7AihzBiyjkgVbgAiIQARdUAMsYIF09Wqn5eKCgLYUEIABA2A7MkAEDeSmubBog5AFg0AEPdA7rlIcAcAwjoosbMAGMbSq2oEBLABngpoLWXZnA9GpiBCqn/QUpXoUO3qqr8KoA0EVHdADNUJnckYQg2AEZzACkEZ2D+mrUGNr1kIVOaQreSKonyIFSABpapYUSmhV0Ao1pHVYAYQBPtADUrAJXbAJDvQPS4ABiZKj/fSl1hmu5RIXRaRmFsBpckKscYIEFjAQREcrGlmv9posRTQxG9ABSEI951MDsoMQamZrBws1z5KjjdIeB+EBCrCqFFuxjrMXGFAek0oQn7MCetGxLgWyUXRDMhEQACH5BAUHAP8ALA4AvgC3AFQAQAj/AAH8G0iwoMGDCBMqXMiwocOHECNKnOgwwECLFwFY3EgQ478AAj1+FGgQZEeNJzFa1MhyY0uWFGPKnEnz4MqCJC8uNDkQ5UuTIIH+HHqwQIEDRh/8e0BA6YYBBTz8KxAgANWPVavW3Mq1q9eeBnOK/ScWZAEABaAOQKPgwYMNcDf8g1Bgw9ECEKxmBTpy6r8BU9Gi9Vvgr8PCCi0iHlhAwD8CXyN/hUnWpOCzhQcAgLpUwQYMEWAsheH2AYQNpz2kHVBVIACBA06XXoECxQoWK1ZEWICi9IG5eH9fDODYo1W6eAksWABj+VzUeAtTtegYsgACCf4x+JddsneEInWC/xWYOe1ftFDRW2VNlyOEBbRJ4BhBv4f9HjXw/+vx78OIfyNoICALGrBAAgu4Nddcacsxt4ID/ziwQgYKNnjAhVcJQNwBjgmHAHcFIeDYh9+VGBlJEPg10Aa1kYACCSRM8UEPfEAhg4025iBDGVCUEUQOQfzQg5D00VeCgClEoGQEBpKwXw377YefDHzIcMEFPChl1UCOXffYQMKZKOZ3GBWmYWNbfvQRVZhtuUEEJHzwAR//1PBBDTL8+A8UXfD5TxlS/CmFFHwK0cUZRJyBqBIvJHpGF13M8MMUckE25qWYRoZRXikSNMAAHijQQxlElErEP7n8U6oR/xiRxalfdP9RAwsPFMYhAQJAYGmmvPbqVXR0YaCABjJ0IcQ/XQyUyxb/BGqYXIURQBddvlZr7UyofaYUBgNF8ACCSk2FwWKJkYWTmiqhpGZGfPUUHkEaBcXTtfRimpO5Gxkn3ron9cVuSC2tq29Q5645lVEIE5ZmQe/W6/BOJZUFb8PrAhyxSsNNhVStSpmGGlRsIqyXVjVR90+XJxOnsoYaPpwpS5SNF9RYPWEGAWADhPuAkiss4BYEtUaXVmuVwUZWiiku94DPBzDV6UWFccQYRo5lrOJUASBFQAEE/EZAALsS5/JX+nZE1lkW0eXBmyh4+9bbBZgW213TGrXAPxssoGQKGpD/0PcUU8To5D8sEO6220vDJe3dD/y2wAHNOcfcQKLdfeEBEGioMq6cewnZdpDhevLYMol02WCAkaSVSmbphdRSKZBQn3189JBnDj/IMFDu9j3Zg5z+fTDQBwfq5lZbbkWwAoyAw7jCP4IHTscD1Hl5cnYfej066dZada94eukkHW8wlk+fDC7oLsOOQdq3/kD6jaBDkTSuv6OgUkQqRRll/KMDCxGAzsFy1TLuGZAiG9mVANhkFYRt4AG2idEI8DQQRf3jDKrC4KlQpSolEEEJSSiDBp6ytZMdYFcHTKF3pnUwujzAbxroQRCEgEGCMGsQXRgBBkB1kdddTYVA/E7c/05DRKXIrk78kUEPFCAsxhSGLloryb7MFRazSS2IWCzRvUKyL44QbGYjuQnB7vVFdRGsMmbLogpvAi+soIuLxiGjTyhWNoz1hSdeNMrBwocYO6pRTH6k4k7mSEgwhmVmZ3SXuqSDsKaU8Gr5Qpcb/2gijH0vYv6a2MQCNpR03ZEgRjkAat7StKUUQAEIw8vIIjkTjqCsS2KjZEMMmZE0IsQ1OEHka0wCmFAmxWO1ekoq67Y6ksWEYhCJpSwb4hqQjIUkMIlmZQDDmKmwwS0P9NndpgLF6HivKqwhGmb88huhJSxqfRQPVQrIsKphLJZfiycylynINlLmLH+xCM4g0P8WuURgIKX5mTkFA0byeABobmGOQiv3GLvoUSt5WeWZWsYm4GDuhCfU1dbc+REBeHQgKFym6hCSmQB8KiqFeYuSdkYan8WtABjg57TaA9G4JU95uMnp80iQm9AE1DTIocsj54K5xRXgcQp1zj+Ec8KTmalqVUuAALqzHVlecTiqQ4tqduY2qGTrNFCpW3Qwd5SdGWgKRRqBjOgzo4HEqG8r9dY/tDnXgSStrstpzlwj16Dl6GqB1GkMAUJnKVz95gAiSkBIreouxlzGpPiiCnn0gk+rHGA5K+AB/eyDp9zh7h9C+kGd8vOfKfzhH4BrXm5+urPc8OC1IABBbiSUm5b/LrV6VRsIiQrCAMdkJ7f0TOYlzfWauShnBZutQe5ylyfbgTZPPwhCc0Hbg/n5gT5IGAEJUgBAxClveZqlD1pHMKM7fYAH07uaAEgkAA5lznrB5QpGRspAJ3KNfP/5j5DytL4c6Kh/6pMhfuwj3hLAcCD/CcI/goAn6fJvRzuQgSf+B7J4fuQAJvtSfL0yXMTUdyCsWQp04vaiOtnvHzpacA30xCP++WjBuQNU/vKnqEe9wA0EKcMOsLQAuzxmQxt2GBu/OVmu/QN5KNDbWvkDKBd3oX80xqAGEbWoDWbQBToIIEFuFWQsgk0nWQGOXzYzAAWwYARSQJSpiACGVRFh/wtEYBURviAFGYygVn/FcFO7TE82zEXMsSmzmZEg3UO9oCCp2iARclCg6Dg1AJnzM58nTZCguYVAPQjUsTbBrH/AWQYaUIoqdUVqSpu6IAsg8QXK4F8p3CBZ/7iCCfD2mCciRVfkOnWQOyUsfr5Jgm4dCLdUU01dG3suMX1ATJfC7ImwESzhGe6xdb1Ffp3xqgCbV7umTUk/tmsl8xWKti+ZyGuri9vVeja+zMbFXG5yjPBGI/jAZzFpo7sr1W6YvnIyL06Ce44p+Ze4d5kTDzv23q2cYrsbVkiLJeTciczkvkKWSj3is5kIr0g9ybgQi437X2H8iU34vRijUCto1P90oxclmfGCQVsn5K5nLfuly3+X+9yg1NhLiYiav9QFa1jZizFbnkbTMTOOd3Q4zBH5yVoaxbJIWUARzfn06VxlLzSBJcvjG2134xyMERd5Qyoet+fgDTnerAoDp5P1lElynkGGOL/tLW+Yf5IkjESYaRo34hE3MHxDj0kBA4lwnM9dYF20opqkc7DS9FysSGHT19jOr8MYBKpcgkhxpjjplxTtmZaxjGG4CQCOIfTsR0E7A1e3S5M80b6p/OH2qha1r3FpZeqUYjrp+T2YbbJo8MIMWoAWVrf0hjZFFet0bD4SqrAQAhcVa8aucpWcX4RlxVYM0IkTtS0tELh/jKb/NMsCG5M28KCn39m3BuIzoCJMNay5uCB/6ZYV/HTngWH81MRTtcljTVqDhWsA+GcgRRDwxXsbl085wRpQIRVQgQHJQzjq5xaqoRrjkhep41hoEVA51TaV5hZkhRxtZDaO8USpdDkXAn0AaHEgZSkok3ndBk23dBabAQApgko39S3tVxr8hFJG0W6BsRRcpVO5gRu3wQK9kVB0IUDkIjWiBgHvkVdKNRVbE1i2l1vgB35AJBJ2pE+Q9Rc58w8R0BsoIIR7FzdfRXYrAhdm5Tc85TxOklOIg01suDWOJEpL9TNLtRRSeDlLdUJW4VFZcx2EGDpf8oJqNDBqwoBkNgAP/6QkLPIAbQEqMCU0pLY1DsRVcNI34lUkf6BdAiIgTOIWZrgiQvU4cyU5qRg5GZABFgKAYPNlFyE6oAODGvZHK0dcIGZS0CIdIDM3NwNpAaAa0ZKKKGAgJVAfaTVBv5NfMNRdtIGEDLI0TLM0FQIDonGNzEFWVGFYxcEhCtFe3ZGILBcSGQgVA9N9WBF/kHYUyoECDgAj8vM7tZMfQxIk8AMgI4AEU9A35QMjGrACU2CGEegADkAHDiBbubGQtOFX0yE6budbU1WAhbhM73KOxiFZDJNPa9KOp7E8I9ADSNADIxAEMhRdogUF0WUfOTBgNZBfdIJaIDAFuWGGSPYgIP9AByBQPgupJEiYajCYW7s1Ood1atTkYVrhcSOFFpC2ATAAAvQxP/ZhktIVBzKQA/9glbajREokJPMDIP3xHzigAUqCARiwAW2hPDy1k9GzjGqFiYH3Sl/WXlo4bWzElNUEfW+BAikwH/RRJ9TFHz/CX+rDXyZJYCGZmKJIKxEAgS8ykBOUVodJjzwwBWlRfdvDEeBIdAeBd6CUInlnNxvwPPolA0LyD7fzXzfCX5xVXUYyIEyiJPBzJ/cRBHwgXevDB55QA5TydF+CK4oBZJzZmQWRa9unJnqzTbIjPyFZAxSEmj7ClUhUJzowP1OAA+MVkjJ0OzviYvwzA+vjJHb/gYm2d1sQOZzgAWKgFJy5JhBL8zYPsDyygz5XqT4muWAuoCO6Az/VtZ09wj+DAimPIgUzQKC6wwMoAC1YE4joCRFVNzV6BDVz0UuQVn8jUCX2sz5BojtQQCjNMhAu1iNdQGNd8AJnYKJn4AYpGigz4AIXAAIgxSFc1qATsXbz1RMQYI4e8SaZtQIzOUHrkz+Ggix/AmXI8igWdCqOQhAm2gUygANadjK4MpQ0yhXFRR7i0xFpIRdKoQEThCfdOaJImkGJkgtnkGgZVEEXkAKVQpebWaXeUXUb8WF59ymgMZBlYCyHoiqnkiqtYmWNAp7/FEqD9aZwKiYRBWkFsSuU//gtxeJBcaakYEAQb0YEr+IGMkArc7NUg3Wo3VNRB6MWA8ACV1AGNWRluWBlWbAFiMBoPkdqGEUAkuapvaJ/HhYqaREBXsoHgEJlpcIsRIAIUoAEHQAYnaIrS2WctFots4oXykYgU5BpXbAJNgRnRJCpHsAeX6M1T7OsDtMpUXFkLCBayUKtqToQRNADxUoQJaSs3lovizEAETAFM4Bj0zqtAwEFRwYcG7AxjxEu7/qt2dI0ccMDH6A7QXAFORAoGvAP3GJXS9WvphGwB0SKD6ABH6ADSKADduIk2foWUkFrFHtAD4Qa3MIkMVJp1AQtITuypJMt/eQU6tcbAxEqLgqbRcoWN7NKEQEBACH5BAUHAP8ALA4AvwC3AFMAQAj/AAH8G0gwwD+B/wwSXMiwocOHECNKnEixosWLGDMWHGgQYceGAhUeFBkAYUIAHUueHGgSJcoCBf7BlCkzQMyNKAckFKmxp8+fPxGafDh05UKVJXmqlFjy5oAAEATqLAAhIdUBBZ4eHJmQZdeiQAcK+Dc2rNmzYV0SRBlRJ0eYVXey+ccGLsyYBUJ6pFmT6gYIf7FmdRvAoGGGChOTDSCAsePGBAlAEFCgLNmuaDNrXts1ZuGbNgsjlQm4KtW7APKiRFpgw4MIK1jIXqGBhAYWC2EseMD7QWm7Mm/+O0CQeAHiVQn8k0zgAAQCVAkQMDi2sYCxhnkSZLC5u0a2KQt8/7TJNuFUCIBhr+BBYsSHHjr+9ZDf40eQfz/q1/g3or+G/7exEBsKMPTm210DLbDACiuQMMU/JPAwxRTuuccDDyscEBNkYhFUXYdkEWCZdySeZZB4Cwnn2gYLRPAPCgO9V0MNPcggQxA5BHHjfDTy0QMf/I3wIAlE4qCBkCP0oKQMP+SYQxlQRrmDDDWMwMIDXTG22FhVHTAWcSWGKWZIKKYYwFM21RSXTLyt8MEFM8KXJB84lvGPFF3guRAR//DZpxJ8EgFonzP8o8EDG4ropZiMNrrZXDUlFJdOvGnQQxB4nqGppgttgcgZblS5AmnKFTCdo6imWiJVCkCggAIPaP/wQxldCHHGJnzmIsUVHdCk4T8LQLCAqaoWa6xmD7g2EAYDwQDDQhtM9NFWXlErFEdsuSRSeUYtdC21x4bbKFjaeaVdSgWZtO1GE4n3VEw6DRCSW2hmuRVY4ub701LpppsUSP+CJ1BeKE41QFUnQnXamaKFxFW5Z32o78Rb8SuReATDleZpVCGKKFVQkZddasG5hsHJvRGEHnowTYdxdlZhV9aIxxWwwAELNBfTZOJBoKVllMlMsZh5+XwSVh9DAFNqqzGMNGwsOOjgBzj0Z/VAI/yDxBT/4RYBCxHwRtAC/2wwk6lVYUkQjAT5BiyWxykn0swiDiQiAQkot5AAeg//HRS2B3lWMUeA0wTBAQ8wSAJBPWR96Q/y5fgDk//QiMTWAEatwQpff53sq22uQCGFSo7go45B/FDDBzwgGpliB8w9lqJ+GwtamZGyi1faDfLwgXs0As8HHzb+Y2MQdqIuAxRQ5lgGnlL808ULZ3RRvRv/2MnHBxFkxdGXENcuPkUIQ0ZZyKCZp5MCLNTYhRuAYv/PGfMTYURDbsggJFXLHZcQmOMLYKMe4IENYCACGlhCDqzHKT8RpAsawMBdNOQ/AArwgiXymF9c9Y8VVGkJxrvACDDQKgV47zRKQwzhPCIQvYDrK/9iSfgwSMOekItaFkOMutSCLaTo5VstXIti/6ZVQ79NCyzXKooPA0YSdckQiRi7C15gghStqKUw2iqioxSDr3WFb4mc+Y7TaLI7rDBsJy7ElxZT5bCj6IWJ3JpIHOV1E+G8RSYegIlWzviwOGZGYmvc1xsj4kdsEUwmA6MJeTI2EBS9MS88MQ5fWsIXzIiFOokRWkQUMrMZBjKM4EqKtkZJsNQoTWmhuUtpPiae0BSmWjDxmG+idUrBzEQ0KrSkdRxSmeb4UiaUYRdkHPNJiIiykYYRDwCm8o+oZGVnGwwMBJ7ylJx8pjW8iUDYtIkCbYaNN7s5nNmU5pnCYGcnzSxLaIz2HLst5zmVuUx1HqOYYnqLkHmRlGHy+P8XwDxTmYV5V0xeQxvbEKk2Bq2NoW7TzW+KLVqmkmJEkTOsZgrLOc5hDjxrRhbIKKdvBElAZEI6InsSLil01AnTdtLKgBaAN1Gj0Ad+9zsdJIlx8wnSCBIaGxcNhHOztEu0FvCsn6KAQR2cQmwYhILdJCSYMxMAmEDqIQSYtHCQzKdnqokiImIFAg+AgeIoFJ8e0OhHNWKcDMwaJCRowEhTEFBsdANOch7sRSsAwRR+Z7XGBeEDfFgdDwjHrsswZHZX9Uk9BzKZZi4ABSSomg7gI5/T/QNHPciBDHIgH9WVzmoAqo02H2ABbTooSf251KVupFkoEK8GUyDBA7CyGI7/9G1DxLFgYjVyIsS4i4xkTFZeZzqjGsjgtfIZQZX2s5+B1OAK/QnSkmokAyhJ4brSi16hXFC5D6zANJIqi950u9uwpI9dLrOJ96j5D6ygAEZTU+5AZiAMF5SBeVDK3p0GwrzrdkF6ZwgUQaj3AuzJwLsbCUDsyjuxKN7uMG95aQEw8AAWHCl7XahVngJMPyJwmAi5+scLiPCCF8gAB8wK0XKkyuAi2lFNMhnAAfnDhydlSlMeNgIRtmCELCBCCmXw7s04askWB7IqcUGyAjaggA5owMacuhVDtkAEGbAAA8zkn5GNzAalFbDJSCjDGag3kE1sYSEaUMBU/KKhX225/7x2QY8CYNCef0ABCvPrAq8UIEG7DKuib97tADzG5KpgIFodVCjnSDjN2Qb60QxRG1COSBEiQrrFN2zhR7IlxKFwS408vLQRV3hPtWh6h310CL5GGcNqiTpMlPZKEIPo6hzKcCSfPmanFVlJw2Tx1WbJNCVByWl+qSSLoXYJQqqJmTQRxDMhOcy3XghsppA6iZvutMX49WlrgYtktDUNbY+CS1+jk9rVdkisIeIwUBMRPOjmZXBWuhPDaMVeQJR1uhlyQ5AUmSsuPGYcPdmQf7kLRaaBSuBSg8XBxXvf/Fa3qnmCbB9SRFtTbO/OmjlFuzC8YV8JeWYOQ8zEtrtfFv8LtbrfOBSb1JJ/KOz4x6OdRoLz9t+YnjhnbA1Hi3U8xko7mETbyzAs4lLlhs2I+TL5VHpaR0uE3S0P/Wjro1DzTLtbZioRpJPDQBuR0ITnvPtyrovZiyF6O9XrgnZVpfTrYljvmLkCUJeWpTBhKtEKxgZdwNIgOiunDIDaF2umpxueVAjaUkGe/slWV50gbkFmHrHyEgCc8i+SucseXYKX9j7g0Ml6AKywhKhToq2rM+SkQm5yOJxFRzwyo86WSm5SUba6vVrPJ9PW+cwD2XVkDYulgbYJgwg8qzeHYxkqz93ImlSnMp9ppnKIUypfNsYxshP8iThkz03LS15nInr/pIIuYefA5V2cV+9LX1N82VhYNt0s0ANQ4Bvlq7KVCIundjpvkwMw51fQIVWvhFjLYRDTwTcEqEXZplLtRRowx3ESRhqBp0yQ5HkEVRsCogFcg1CLswJH5VC8wTEpxD/jBR0fhWh28xwqyBy+JHvhIzF8U0Szdi/UMik2gRWDtgEbkEdKwzQEg3XZVFBHQiRTUDVV0x+LUwIkADajFTYLsCIy8Rc200zL8Q9YoiBFFSyHEx3UJx27VDfhoxx5E4M1NIO05hbXkhWIQnkiAwAvYROuETVEYjX9YVOTlVxZgwQjgAO2YShgY4XA4lTDoiFKIxn/AANHhYhWaCDP4lMi/1IddyMdCiYiDICAdYMABIAA10FVJgV+nvGJSSFw6wcbE0JTqKUkOTUQ8zEfWbOBGOginCN/9VczwhIt89dBHUQkJCA6QjIFF5Ih4qEoLDaMmoh2DJYSRvdGHXETy2aFEHBUIOA7H7AfSlI5QVCN9bGK/PEPU4A5S7iLslFhu3EgPOgaMAIC7dEfM/U7PfAeF0IHVBR1l2FVdiMA3CEAIlVMLReKycgSbkiDfTEcLPI1dUYQPrJWCDk5SvIDI7A1I/Afu7iEA7ICD7AbO9gaL0ICevUBMnWNxtUDF0AlfMADKaQcjUF9Sdcl+9YSS8EW4lGRR7U48uEHlXUfOPID+f+RA6pVOpcjJCUQWiTgTaKXTTHVH8uVOjpyPKWzAjCQQgOBkmJxKouSdNXGcEPRM2wSAZDVHjhQhNN4VpdlH5MDBQuZHzTCHw8CkbeRArKRAnrYH9eoI1DAWs1zXBw5KuOWW/+DHXpTUitZWC/zMidyAC4CAu5hVvdxI/KxVjQSPMr1Hr/zD3xlU3NyKf/wJFESPfolA5WTNemDIvE0HBBHSDZndZVEIcq1Hz7yAUHQmDNCJ6ooH5NlXKiDmXayYf8wA0BGEKuzAuO2E7Hjl6OZS7kkNzEBHeGnRxW5Ag7AA4bJjjMyEJtVXXiGI5cJJcyDZwMhBfQjPf+APaBSYLn/CSRmwxE+o3bDeRGhIY988Uy8tgFHtVf/wAdRUjzZk1/QIwV4Rj+c8gIEcQZKIGIi5gZloAMkoADA5BmcmJ4+AZrNtJ7JMUViBSMMojkjsDwAdifW81//5Z8LcT+BMigagGiStCYMSiKdF5i5MwBYoQAIdAW04gbWQ2L/tRBnkAt9cmYkJgX6A1GLUhnkdaLdkXhkBB04AQAkYFy0Qj0M1EA65in3Y2JW0kgCwDNCGi5UREGp9I+WIpfcWSvd+Q+eUgRfkCcj2ZS+omBBeqWMUhfAFRwD5WQjUAYjVj3z0yc4+g+D8J37IWkK9k5s2mB8MWixUgN1sqGb0CcE4SlSpDAFWOYB0tdmgSo+g4EBHcAEQSAEfNIFuIIrC+EDatZIv/Jik0oxO4igHdADZQCeA0FlfSIDJjAQpZd5pVo7SuMxlDIFNfA8dxYoOYAEFjAAf4FomScstToxI0gQrhErxnMF2ZMDGtArCIol02R6x9pgjuYqBGRAhsKbIxABjNYqWoaC1zoxfTcQrZIsP/UPPvUPHoCgpFqufkNAn6etFNauFxEQACH5BAUHAP8ALAkAvgC8AFQAQAj/AP/9AyCwoMGDCBMqXMiwocOHECNKnEgxIsGCBAMg1PhPI0eNADxe7JjxYoCRAwQWIHkyQMqDBQKs7DhQYEaaFXPq3MmzIceEP38KbCkx5EWjLlsiNXoQQMyYAT7KjAqSaEGhDAX809qzq9evDrEOVDp27FKOBZw6vVrzQEeqam0OLLCyLgS6/wpAuLpSLNeEWrVqjAlUZcECAgIQiEoArOPHBo9SfRsVgFrCHdNS3SxT778HoGE8gBEBBYsIK1iw+LdCAwsNKCKAvnt3KueoQ/PK/AeBQAHf/xoLIDC8boDegREjFrA88eG/WyFLz1lysM2TLOvqJQBhQXfUGkiM/yio44NAHVdG6KihQwcSHSU0hD8dG/SCB9710r0IYcP9FSuQoMEUBI5g4Agf9PDBCDxMQQIKyjEn4WIFuSWQVgdo1dh0HDqGG3a75ZVSAQ/8g8I/JKQ43ng6/FNDDzXEyEcPBi6IoIEoIoEDEgca2EMPQcgQxA//BJFDGf+UoaQUSRZk3gAFDCDTX8QdEIAA0HWo5ZbGzYTRQHEVtJdeJUZAwhT/fCCDDDD+s6ZATLpxRhdIKgnFP110cYYbRLzwj5xu/FmGDB/IttUBxO215aKMQgZBYr1pxF2UA2ygwQc1yJCDFHPOKRAR/xCxBSJ9uiHDFCcG91tvijbq6qvTsf+x0gNeIvHPC6CCWtALP7CggAf6rbTBAZ7BauyxXkFAa4kPYPDZP6ut8MAG/ygg0AAPsOFTbgoFdRCINxUWEmYFvYTsua6CFNlGN4E4VEllmUUSSyHRpBm9MUnpVFIujfVUXoR59C26BOsksLtygYsVWSbV62VLKUk5VV5D3fZWXymtRZNYBuN0lXMFh3zdSAph7BJdHhClb0uV1YTWXSspC9pnzH6GwQYejDhVYoJRrFFgGw21YczcEWBlXsyxRdyV0Yn82MEbz5sWBBwhRZR+D8gcAQumCTjFCDgg+IGN49lagoAkRKA2aMyO+Zt2ebnl2wL/wIDCCg4ACKCDBDr/SMIKKCCKEHQCZEhccIERkIDTPSG8rmEV27sSlJ8twEKAJOAgUA8CZdrDDz3M+OI/BpKQwmlsTwsBlDOXdrkGByoYYxA9yPBPDkKuWcPY0nqEm0GNLebWcAJZyPixaKkU4mFiLrDA3Q6gSODYY4/wI4xC/mC7QFCsGQQUQZQhBRRl3CmFFF0IEWgXfrrhgu0fTLEAtQYJ0Nvx+Ouk3XEyAWdQX5h5gPVc8I8ZFHBOQjgIEc5ghH8o4VYzkAESDEWADVEofxjUkkf20ipn6YAPnDrDPzpVECIYgQhl0ADkVsWdDLqQUfq5C63+gQESgDAI/4DCnCQokBnyhm50+9KX/zi2kJswhYgvTGLjaiJEg7gLYQqrF0wIkpLBhGRlSFnZdTymxPx9ZCHecmK9pIgR7NArKFfkFhUppptr4UQsH3JZFztEsnA5MTdfJGNkqjKvIZIMctdKCltUMi6BbYyPUjTkHBv1xHoJxYwPIYpalHISzUgpLcrDi8UmI5eEDbIhXAnlhUbJtDsusiJ6JAsiIRnISUYGkyHyXWU24zFI9qUgPavIF7nCtCv5ki2KPCVFmLLFbr1FSv+A0l72BQGrnWUtwYqZQOhXAGBFbC5RQUzTBhcdQ8aEZ1eimuEUw5bA+DJLwoxIULJ5ssyQBCqUqQxdyKSsBYhGNP+IALQiQP+a1CVzdZuhmiE5Yr+OJIYwyjnOSjAEwKQpJzijJA6WyJnOsPgMmwNoZkeQua++ZLM/oGGB5VZwuvBMQXMpEpBAYLO1+0CANvP0WWMGI5QHHAA/znPeP/IGILZRawG/cQtucpkVJLqQKAcjiMY+hBR3ytA/skFNgMCGow+0qCA1Gg8O5OMatUV1ZvcpXpe6swGppohvmftajRq0AqBuaCuIOdxWDle4BBSOeOhMJ8mwsxScSKwzWNvAA8xEAoGMp03/+NE/QJemA01hPg+QVuqiSdbRsEBAI1Cr9RIkOhjhaAowOIhzfvKXAzCgcAgoXEV38pMoAYyDdAvQP9CUWBf/sWlNtQMS53qUIq59tQODFQhmY4e93HbPTkpa7GyfRZNHGe4fbkEM04y3Wq/8xFzMq8tFnic90pHuRT2ykQ6sxznO1eAHL6oB7YIUvu4lyXx4Op8BDaJPnGCIMUatrmO89JTlwU0lQdTbmcb7Dz78gIBlwF2dzne+9Alke3l6gZ9w1QU3zEAIBuTDB6RlELccgLr6RRYAmonJtXggmZ0xSE7vA1RlTaEGdeoCk6DQYCHoqQsGOcOE99SFH8imAIJbzFtD/MLkPYVqVFNJlDagg+3JycGhKuEWRKWrMrRoA40B8tCIvNpbCiTJBcGAtXSQAz0tEMcipHIDicAHNG2n/zd0ATGXuaytu1TrHz7owRnOcOZ/bGHK/5BCD1bDG7tMas6IFoisYFoADAygAz1A3yYEkostvEAGLMBAXQhg0wc0pkSJnjMHhXWzVo2gBAKJXwewha280CbUsA7zXh6ALRJhANS65FYRY83rgdWRXVwUWFNHxhHs9tqFv4Yjt76oyj+aMl4syYsej22sLxrzk1WBVzHxaEfrIHXYcvEStT3ExE6KkYsbGwkrz0jGSk77YUPpr72UGrVxU2ddyn5j1MAtRrJYkpJXRGrAMiMwZAIQJwFztr2vjcRHlqXZlDQLUmuSRYBP5ZLqDhgnJxZthS/8cea+ih33HUVJRpwsxv92Y7mYd0jObOyW/J4I0BKdb2sLZdoPcba4/1eupLzE5bR8dn5FO8ptGrTeNLcjzvdITIDfqykgce0AlApPWioyjEskoii5LBKRrxvqY9y5u61tTYx+aDJw5NhM8rotXApFOAvFJaKJyfSPKHVhLEfIGilzsaBUUWKQ88hM8hVvsUhX10dnmla0GZ2ZIz7UCoNIJbnoFCtZrSpVdApd7AxTWnlgA67tSMp2PhFfxgxLDyWt4ktZ3YU90yrxJiMmoZuRWTIFABHbvH4OMOsespqNSR56QTZUysNl2WjaVMyV1n4h1q8W9hZP5B9h2fKzv9Y3MksdaPg5s2kmky5oR/r/VZhG/JlSDch12ZhznDPkuLMR8jbBZExM0t/bsBNrWossaUgToNWgbjbzZBu+E0q/03gLRTXAURtb4RGjpXzntHoLOGeQdHcb8xLI5DtQERUjkn1qczn9d1aFdVmukU/4kTWgF1PgZxuPEgBW4hnE8lJAlFPEAjDp91AXslA8gxDCsVr0Rm+DlBYeBXCFJlgPwAKDdVkiqFZfQwI6Eh8kcBpeNS0ZFU3pB1HQFRzd8Q85BSA8RQIO8DcP0lZ08xvBcSV59RdakQBytUhHQXFiBIScMUkpUYIAQhoREB5nciM28g/ucVX/wFVeJRts8w8bAFP+ExN3YSF6swIgcFYD/yIemTUFDrAAiDIcE0J0LMgVigNdi3NKPXhH67QZBsdBJfgAXaNWmHIj40UjPXBVI4AEaNNVW1OKJQhU4OcUWRggK1AgOPA1U7AgZDMFK6A8wQNRa1g8/4AA/5AAB8CMnciGbkgvwORG40KDvMcsW3Mm3tWKMOKHbXIgSACIqLMAsnEfKRgTROg64YEDYbMgL4IpOIRDf1BYreJhWCcQypiMbAeNQ/QW+EZI0jZPoHE3KbKNNZBY6mVe18NbGrA1gmiOdEErMzFYrXEm7Qgj1/MDfBAEnmMeUxBd5JQh+eV4RFY1ilQvL1FiLnF++MGIBNIi5VUQn5NY6FUDjvWEgv+oAKAhWBtAPxWpWQlyPUKSA0ayPYbVVmCWfIIBMq1idAvXhvOGE6CGauORIDECOulVYD9iIwtyUmiTT/kUHj2CkT8QBHHwPTJAPmqpJBxJOiugKFGBhr/EgtL0cXpHeuRSaDSDVQcyXqvYI7/YI5llWDRCXp/TA0TZPeCjJOITaEziJnxwAeahKKrFbHYZERylEX+nLoZ0N7PFA2nyiz2AilV5kJtjO7QjJHGwJlBwJEaSA4EmEOkTKDNQBsKwPaiCa7ohkvt4mTBhRgQxe/tySUAGXSx2IgECAg2CINjzA7AJmzlUJ+QjPucTnXCyJxP2AlKgnV1AQDUwBbR2cFj/4puodB2zFyUTsz8Ucx8ocDcqtB58sCa2sz0MhmMMppaB1il9gmMj5AZdMAMucAH5lGUCIVHk2THjMhL9pSgX4SV2tgDKGT8mZSBrIgVl4AYJVD7lI2MjNEKeMkIvgJ0uok+gJzzEc6DS8RQZMSYcl2L2MgAKQGhH4ph4Mid6UhAi1KEdmgM1EAHUIjzFiaKLoi0Uk5fttxsRMAUy0JjqY2NdsAldACpgEGW6IkJpU6DohyikJ6SMshctihfV8gAkcF5LwqECwWclVARZIGMyQAJZU6B7MWRcei7HATB2mk+rIQNQ9g+TJhBrlgVEkASE8qZF42FbOqeuwgbaMjQyvgGj/2ABLMA5aGoQufAPWRAqfvIZDjopcoqoIkMXOtkBJXAFn3KmnzIIeIJpoMYqviE4noo/+uEsAlFmSrBAaSab/9ABevlhb9Wpr0owq7MszRIB4xGiUkYEOJRMvLEXL/irGQRqCiBmI7ApTMJnRCAFSNAB1qKXk9KUzlow4pY1t2YmiYUEPaAkg6ZpJDI535o/bEA/n4EtOlkQmTMChUWImnYXHkCk7Yo/8CqrPeSQw+hqh9qvGFRqt7YTAQEAIfkEBQcA/wAsBAC/AMEAUwBACP8A//0LIJAgAIEHBSpcyLChw4cQI0qcSLGixYsYM0okqDDhQo4YA3hkCECkSIcBBggs0DChyZL/XCpkqbGmzZs4MY6kaJLkyZM+SwpN+dLkgJMAABQwOBBkQ5oHd+acSrWq1YtIJ4L8OVDoQZMFwg4YUMBDgQ1nV/6DUGDsv7FLj8KkOVDAP7sN8TIMIIBmAAIEAwQOXFCA06uIE3fsWZIjTZVAY878h+GB5QcsHqxgwULDCg0kNEz5p6G0mBX/VkS4/CDs0qVNYw8syBHCgQcLUKCAsaI3id/AWURYvQCCQsCGZxNE7lSv4ucakb6UvPhfgZEQIDz49yACaYEj/n3/0DFCh44e48uPwFF69YMN79mGlX92gWUWoadoGMG/xwj/PdTwQw9B1CBDgCP8wYICZAlEgAAH4EWQXSAdkECECUCnIXSCFYRQZA2ytIBCJPBAwhQobhYBC7ytQIJA4/0TYA80QvGDDEHIAEWOUMggUBBQCARFF/+UsdAOfEzwlnXWBXDASgIYJ1CEG1ZpJUpLCQaVWrMtOdCTxhXnGgri1VBkGVJIQWQOQOZgZBdSCNTFC2d0AacUM7jAxwcrEQABXnRdKeigV9HEEkhKeafBP1IQcYZAjhJpBBFG/GPEFy/8Q8IAGxxQAAFcEirqqNCRJaVALOgAqUJbCJQDCxgc/8fWAiydSuqtuOYEwQYYwBfrQiyM+KtFI3HEVEYw+bTQVwOpFOphuUb7nLHUSUUsotMVJVRX2nY7lIddPeQUV9KW+1yyLRkElFPOchtVTIIdRdhGMQX6Ebg5cSSAYRTe1aW5uQ4lcLbcCtbYV7C5tqt2rAXLgkC8wfDPw9sJtAF9COOrkL57PTkQAQR8+g+oWSqXnHV2gervxgCfGxm+MmW1JFva5YaapqCRsF54OHyw3j84lEACEqAJ9wAGChTwgAdohSXY04L5uat9vYk2xQgfXO3zCHzwB94fJMBA68fOMemgACoLgMA/CJTdclVRcbStsdcZdF1Yli3g4ov8qf/6T3gy/lMDf/yd2BsMu60wYncRrJBCZ/v1V0MQA/aQgwyX91iGkQoNvuhKBEEw4ZdrjezkXSq/Le1XSlErr9nLjWjfAgtsQDsKK+BQAx9BXP5PDlC46UKaUqCpUBk75lDkP12c4cY/z78wwwxG1qDBewVIGVjqqndfFVsL1eqU0ihM8YGBOUjhhpqPnvGoEkQoIZD8L7xQhqrwLRSyx973fyUbDXnAABTggyWU4VGrykIWiFAkJHTgVwXwlMfs5b8KVolpEFDArt4DHoEsIQhpCoIGFBCrs4BPIADUmFSgpRNsbcuCMLQJs2aTEGthBSbo6shTGtKudkkGhy+L4er/7kVDGUZmJzBR18CUUhK5MMZds0kYQfzCMhsKsUosrEgQcwivuAmlbkukznW4RUEicvGKLevJhxbjkZ8gsVssieOyehKvDv3LIVZMzPZOhkabuFFdXQwiD99CGJN0yGBEDMBrrMNEQ4WqMU5kGUrygi9+dYiPfaRKDj0SRhfKBl5RnM8AIDBKhrFmO7ixTltW2aBDLgUvbhOIXihkGO4Zhi9Qq4sdHRLLTEJEW13q0FeykhDXZE9pl8nMijqzmSlshgXPdM/SykLFrexlZf940pNox03ErQAF9rFM0wAjS5rway9o82VEkriXYcYtXIQ0y2UQB03IhWYEQ8MBPjUV/5rQCMc92SPLMZtETqgR5Db2gUHjXDSFE5HgAzzwmc9QNDHL3GUp5GRJcg75oGyiTp06FNe7EELSuASAZrbrjkBOpJCfhSc8qvpAiX5jNHFiwDWKxOh8wlnPhk4BB1d76X8+gJ4g8OkP/4iAra45pYUcoG1tS0AvfalEmc2NOishC6cUIJAIvEg8YO2BQGgEnhEITQM13QBaQhaWfyygntDcj876MyM+/MNHOPLRP34wuBV0YAM+xCZDngQq7oF0KnZTiyIVqZDu/EZTWIvs1viDIhLQwQF0AAFwfnq1yOmgBj3gA4FyYDke4ShzyItTkMSate04iyNPYskB/sKXP/+V8bCInWEcTxJHttxGIb0JbgT0drMAyeC0OuqdDMrgJuC5KXg9ChLn1KQ+I81AISxokEL6Yhf+4dZKU2xK3Ta2yPBNqT4POJE+P6ABfRqoIcUrkvJy4CaFCMENRFgfnIrkggvItDULidJ3Kyi6gryGsYG5ZYG7M4IfFIl6y4OCFKBQp3+cgQiZqhOd1vcDHHQnLBGa7cgGDNLFLtVLixrehV/AwH+0eCFbmJT9uPQp75IYt3QJDGxUEismiFUhm3gUA1t1hjKYaUl+YuuJb8zktbSFhH+TQaMuTAQibAERlSrDFLK7Fj91eclN/i6AUeoBEvbADWcIkkAmdQWF0Cz/yScMc5g1uCReVYxEYIUP0zxgHTDL+c8W1WQisXotUObxzxac4bEOHZE/sq6d0GI0ogXllBVGx4tVTaJMCB3SNU5aUMXykKTTFUhQkmvTy2rIdLoIz0/DLZjVMuLGZliQJXrrJYd6NA616Gped1qSIaE1twytRg/Zi47TaeOBGXLbXmNF1JeuIqJoKLduyaVucvFQSmJjzXY6+yajxiNX0JXDVYf0MQ8BIrDH9cJvu0zXgIyMo9cVlKIopzFB7La23f1uKEYakHNcoqFEgm3JGHKSszmKxp5jl34d58/VZiMgd02SZjH2MdWuIxEr/q/DZDE6DUcwcmYz1TB/S1nz/97WwYQ5GC6eVJSlK51xXiuvQ5JrXgj312Ho4vCTSWjS6Eq53LRtSJvPhg2cMot8HpCd4jBdICoZJTUVjm/T4RwlzhHMOUVHIb4I1pLnJLG1bh2ulhOmJCxpYliYlj345I01/5CYm9lillYudt2yTDAlC5wlXJ7zabYEtrOPmCXI0CUhZGkNaxawIt1spjcsQqV9IHDTVT5t46r2+qd8u5YDcDM72RvZoRQJGJLVki/kfJDXb/zEYw1mXo4hy8XcznjVPD6un3m8aqTJ9LIcfHTbdeqIZ6c3mwX3cNKEQGFpWxeVjVxfhsXtrtVlsFwGRiVnucxqHOaiFYjhnv9o6P9XmTkc9wi0LQjOZXKQEybNrMAB73fATHmANf2QgAUosEzI0tmvjTrI5Hi0MXZkR2JBSnkzHMHlGaUBOJH1N6GhAUQzHJdhKiDGFod0S8uBSpqBH78BAjK1NaBFOCPQULRTALDkGJSETftSYumCb9QCLrWSSg+AO1WjMz7TUi6lKTjjGdKkNMe0WFBjHASQTHuzH+YTWegxAqDFJx/AJ/+wVulkWCLmIGujFzZ2WMliLIGxckfRFrMiOyjwMC8SVHOlA1vzNyMYGqpxNLySPWx1SxGETN3xGTqzH0hAOP5hVAVyZKSRGZChSNwFKlOVTleIhR43bGlXLyRFEE/nWKL/4TWC00Ei6E9pdUwKUxzGJxrscYd0RSOTcyMEwlcCoQEw0EoL4WcQIlVPVXJ95HKmRkhMtBdtN4cuQn//sRB+4B8iiE/3Rxy4UQC0Yh+4gx+gQTjnAVpiRSN4lTkK4R9TsBob4GZ30XD+Qo0fxYqfpmhrETqdshBDox498FkBIh5Z8xvHd3wk8Bn21B//QSM/kCME8ju9EwQCgTx6JRCjkWPVeBe4NCXdxW9asTEKB3WW4XgoQAIg8DdXI37p6BsOYD440Iz/AVrv2AMHAiQ4siP/EF2cwxC7EwNTwFUaJUs6NxvRB5AQEUehFhi+tR0k4ACasje9UZArMBo04o7//0A5OaJcyrUjPoKRUDBdcbI8wvAPfDAFGKASD2IXBVYXKJkRh5KSamEfqaEb3EQ7K0B/P2AjmHM5bsJcZQAnm1MkQWmPaqYmmeIGQkA9EDYCEaBdAmEcJviUN7FYB3Y3ZhNzTmYbuKEZuiNWFFmP1hUnXWAkm9Mj9cUoAsFizTMDaVIGMiBTLJAWKEMldEkVdkkbRDGQzgI+I4IaPBABG6AAHQA4AhEnaFI8bAIkyGNhzcNip+mYkPkBIJBKD/IpEHKZVqE9sBFzjeQQJkgf3EECBnJdjilfralmAnFhZ7Bh/zA9NcAn0bh8BFCIupkYKSSXAyEysLEV2RMB5+Mjm/9TPGlSYcz5D7kgP81JBEKgEBFAMiBzACd5nYJiKzkVlf+AAl51ZGgpZESCnpYSoC4mBQ6WNCMWh9ZJn4LCBrs1QTQRjRGJOfDjKArxKJXiYoiAYa+CFh7lKR6loNHCBookJYEyQLHyA2hCoVDwYpCSBF1QA1xmKITlZyA6KqG3EvJBmibQA5zzYpWCZUQgBSOQlKG3eUlWo/7DEneWmC5WKVkwKYJzPUp3XgmKpOayMNsRAT+2nC62BVUmAxrQKzQzMr7VbFaKK8c0ZgN0V+6jZl5KBGUwQjMhJiNSpWdaLsYRKx8wA10QJI1iP0tQQtHIEp2yAfN5p9ESjdGoQQo08ABc9VX/cAEyEB4M0hozBwEphKiqsx0XQxm70hARgDRIMwACRKOa2jLacVOOSnl3hhEBAQAh+QQFBwD/ACwEAL4AwQBUAEAI/wD/CRz4L4BAgwQTKlzIsKHDhxAjSpxIsaJFiwgNAhC4MaFGjv8AfAyJUGGAjgVFolR5cqDKkAdTpmx5sabNmzhxZoTJk2dHkSZRtqT5ECFKgkADtDwKEubJkjmjSp1KdaLGq0BZspR51WUBgWz+FYCwocCDDf8emC2A9muBAV8DDJALciNUiAIGIiRQUIBSg37/5Q0cwO/gqogTBx3qVG/HsXAhwP234cGDCBE0sFihgQQLDf9YeF6xWaBlyx4GsDT4dWAB1oILECiw4MGCBTBW6CYBYgqIDzxGfBhBfIoGDR0iPBB7WK/AAoH/8RWsuHrNjXYTYif5HEBrsXArY/8+LnBE+X/D/02ZQmJF7QcKJBcQqbTAgX+3WSyI8Pm4BuIj9PBPgH4I2MMINfSgYIAjGKfcZGIFcJ9AeTF0nwAICDChdRx2+M8A4G0EF4gLuLcCCifq9l6J/5DAwwcwJvhDD0EEkYONMtgYxD9B0PjDPwrSaKNAUEhRhkBByFDDBx+CGBME0kk40H0E3OXhldUZFEBcr0HA2msFhGmQl7OV+ZpScH1Wg0A5/FNGDjfe+A8UR3YhxT9CCEREF3zOUEYZSirH1mzSCQBBhVgmqihV3j135nMgstABElC88M8ZXQgBxT9dDETEP0QoMUMNGCRkqKGLpqqqdWNtQBYGGGj/8EOnZwy0xUBdjMACBmONtRwBECyw6rDERkVWWmlZ9k8EKBCkAAYKFMDrcg2NxFRBMf3kUlNbbXXQSif9VJKVxZab2LU7acvRR0x1+xRJWZUEgFbYrlTtS+9CRa65/NqU1brx2iUwVhA91ZFR9crbk1sRxsQhooARhGi/5r57LUhQvRShB2JBwNZZlkUAQwQrkIwCC82a9g8Eqb3lMbaF9SXzQmHKBgGwBNxm2221eexxmNJRR1iFhRU9HcWKvbQdvdyK9Y8HlV12MmkCtUeCQBrgcBwSJPinn2W9ijmXYH8F7fFpJXPW9RQACseggEGYdxwLaoXJF3T/HCAAAXvv/01dQtMdjfRU825bl8EtzScWBpUJFAFvU3ygA4IAcr2ZcnWPJeyyuolGAtsHBhikgkD+48eafCT5jwxurv4PH/8gV1ZreWl50H1UUhj04Pzq+5pQAt1nn2xh3myfQDooKIMMR7p5pxTQGwkFjQrmwLqNzUcP/UAy8FECtQRJuC/v5FekZUlgoo/QVw/gUIMLfuLaBaa1DpRL/S+c4UYXP+BAmUB829uhykfAREnoKz5zkg+WcCci1OoMRNgCIozwqTZ14ENjWRnOoFTADirKZ2ZxlQI6UIMuHCkIeaoVEi4IPvzQ5jsOs5ZJFnIXi43Pgzi8Cbqy1RTubAcp7/JIu//CBbAgLs1wOSSfDD3Cw56oCyhFhBdWiFJEcB1sYPBK4uCWGD6f+DCK7roiwRZysKYgjIpHSeMNtaiqfw2RKxojIxWFiDiVZAcpZPxWD9lYwKRcbI/72soZz7gt7PzsZ1iC2O4mZhih8TEnUwyYwfS4R7CwoQBsUAsETmMb2+CHbtTioFvmkpSv8CU6ujOVQarkmuKJBTqvGYyWGumwWj4SIloxIrYOMhQEvmVlbDELZvijGc+MhmQsIEhqRgQi79xFAN+JZpkWECzcoGABKECRA1bQnpJxsi2PkmUjYwaYNd6SK84hyCiL97EHdOAznzFO10JTTA2wRzMsiEAHwAb/FzEVRCn/HAg0pUMby5CGmyQgAQ6C4zbirCl07FnBK+9WoQOgL5WmOiceYXIxdT1HIB7bHH4ecLLYdYZrAinB1RKqGxjULTLOLMxrCACs94jsZAlFwhQmRxz0vO0DAhqBH6aQzwXYrWgMEcDEFIIAjWpnl3XpyYe2RJcRHYtk3GRbjJgEoA/gwDPZrBtVgVYbkZEsocTBAYNkMDoBvc51bdpRkP4hhuWA6DtFq11CDsA3vR0gAU6F5Loi9LJgCWQFKejP3PiTtk7WRqTsYVuAkje6Hf2IIAbiQw9uVIYd0SkIcRjICqC0EQ4ihEpbotCGAosYqupFcW7hGTavyTOz/wRLNzBaHhRksFs60akMdPqH9abXoyH9IAjAnZMJm7e6C6zJSQcsCJSgEwCaNpW1V3LtmCRUpem85jk3u9lyMOO5z7n1HzNww51uFITpKSgOvC3D86TgBiHo707NG4GyWlNdCS0Vu73jb9l2CVCAUuYBLPjAD1zQvE5p71ICqZUDP2UnNwDqAiQoy4WoY04A885LXQoABwmyAYkOoAM6YJ2E5/SpM6w4FwKxVA0igJbb/dfDGrXdyj7kgcv0QL4upvAmPkXBGMtAAwoAqUUtOkAcOxm8H1KABUzQgy68gAhXVoKtQJUr0BAEAgc43pOdrBZXAVMgPsiBpf6xCYHcb/9TadkAXw7wgOmO+clrAVllKkMC8whEBi4QELTWAswR3/nOD+jxch5QKpx4NJ0jseWhx7zDevXwX06UiUvmOOkkpquSlpYqR6foFCtydGC57LSquAhpLxYSiPga4ryWkhGEfYvTklZ1TirNRUwLLItoHCOsxZXqN976j7o2XxN3+OjtDCVemo72HHPZ0UmO+teG67CqHx1DV3ML1w3xlhSpXcdI41Fb4hJ1souy7E17G9tgnCRjuliwrtjr3u5et2C5jR1wP9s5UETiRs/XUY5SUt8c+mG8GWJDOZLbMaI+4rU9hJC8wNDJ/QZ2GDssRqZZ+jGv/MlXJqNtm5REr7v/gyqlhQ0zZL86i2WkGTtBuk5IuWYnJWei7i4aHdtFDOHZKre0ofiUr4SlZsnipNItE63JjC1fccGWYchVcerqJbX6wqjKO92ViBhYJP3E5J4vw0mSmT2faaHmh0BakPlgncMoV2VeZtOrAxygZ3aTDXMgPfV0shbcTOx3zPt55k4Ok7xX00DJkjkQuz5gRI8qsEPcQoAw0/k2BnCp5lH0ng14oGZV+u7UCYOti2M31Rt97ZY+/5UNLEA8+XxcMVuUT6otyzKMY336DCxQCm1JQze7vDW3iVAQvKhBx/EmBn7GX1TCsEo3zjG+Mt0ahhVWPPyRvdo6IwbPGCeZLIi9/2Xg8hcvjYtsrjkAmG2jHxTphgcgAAEJhvOBGjCIOF1rVpl8P/rCNPJognNLS6EdtBZw81EAUBMyipcC3KR4LdIZn2NP/qEZmBM2b/EUVEVOIEVNlgEDU7MeDTIc9wcgAyIQdNNPfBFAgzEdA/VRhfI3AkhtPJEvLwEB3gEiO8N+MBAaXdMZGoAEOIAEJXAcREUaZ1EzrEcfSPVKm2RQovEZfdY2oZMeB1I1miFnsjF3Wsg3rGRRwYNj11I4t6ZpYAI0z1Fnl5FMWeU/AsEk/xAcIIACyuEqNVMfttOECHZWPogEI7AEbxMgpRME9scHxEGBdeMoTuM3fLETMCgYAf/IRkkxbj4HE2PzWgDwMmihG50ROeihA0xCfwmFMvzkAfUBYqchMsakUMTRVm4FNzziOj/wUOyBAQOgAHcVHSP2TBkCQGCIOAT2EqQ0VQNRKpeRVZGzJuUBIN+3AkdogZvkUgf1OTASIEhgIHMViD8yJDyyPAIxBY8XE19hUajEf7qmJfwFRWX0GnMxAGQxYhL1AVPQIg3SNaJBMpbxWLbhfhL1OVE4HD1QID1QA3JFOkASBJc1J6wjXLDTA0SlFqwBFUoldRUVfQgXcA85NtQiHu6HItlEW530fsYngjWgWQHpIzlyXHNijQHZI63jJsDVPFXogrWjV3mBWnkDdOH/5jRSBCKqYRrCwpEnck2VQQAPoBtT8CIBmSNJ0ltSAAXWoyOsc1wzwpLxdSS+xTqwwwM7CHdTVx/jiJM5eRJf0RF3NSYHsAHCpxZqYVS1IRA8UAO69SdyuT1HAlwGyVs50gPT0ybNcyR34ibCUIJTBVBWVxB6A5YSoTh0wRMw5Es1MzzAclifIzo9kDoMJl9/aZVSyZLwtSlSkCl8Ej35lQLREi06qSEUiZgOoS0FZnGEohB8NTzMd5aWMX/M4wID8SY5opTtJV+cQj9u8AJC4Ab/IAUzoCTMCEO5o5pRASbhsxOiBCXn8xetgWAIIgPWI1zFOZdN+UARdgb5Y5xl/6AC9ocCQDM8GsKcHTJWiMQwO+acrbEBU/A+ZUCc9PWZQpApevKdlzIDxvkPFzAFG4AWG+Q36okl0xU4IlYhdyMQIEIC9qcBKWZlEAQqvylhZ6AEDoReOeBn4YieB0osbLA+ZugatagA/9EDUuBitbIJtEIEuUAERcYpMhABlDEdYbZjIVos6yNdAwEiCqAAPqAD+8kpmxBkRrAFFHQGQVACxGgzAGRoOyqi0gWfBfAsEZA8m1I/9fMPRsA9SECLZEE8d2N6U1oshgYiHjBCPAJBFeql/7AFX3ApPZBMkiEdlidmZ1o+G/AsHSArZWApn/IPuTBBW5AFRMAHGrAc9oaRgsazp+QDJdRSKhrABxXaKQLxpS5QAgqAFupHPGcGqR/WKxBgix3wA2dwJzcwqF2wBCagMmIBLBkkqoOzSWsBAZv0DynwDz9yBVX2AptiAWjhMRzjGrQ6OAOwHKVqZwKBAlfDiSvwLPHhMmFxrAS0aHsGNQNho//AK59XrdbKRwqgrTYREAAh+QQFBwD/ACwEAL4AwQBUAEAI/wD/CRz4D4BAgwQTKlzIsKHDhxAjSpxIsaJFigEKHvyXcWDHhBlDGuwYAOFGACUJohyJsmDKhR8bdjR5sabNmzglZqQpMObDlyp3fqTpk2BJkTFDKhTqUqNGnjx7DhSQs6rVqzeJevx41KPBliULFICw4MGKCA8eoC37YMGGAv/GDoQLQOxKji2n/qMKMSPcAgEKCAjAlyPVkHy5Yl3MuCHYr0N7joWQVm3aDQ82/HvwL0IEFitAsxAY4WwEFGkHqAbA+ihknhAEHliwAMUKEh94fCAxZQSOEUhGCO9BkASLB2IJBFAucDBHjoSj71XauHrNlSm/usxbEMCAjRj+Yf9Qe3sEDxy6P6j/sGJFWwgEIAReHhjlAAgDMC8gAWLEhxE99HCFgAReQdAIAvERxA8y1CBDD8Bp8A8LEWCAH1x7/UOAhnsd0OFUByRQmHUkWoehQAWgBBhgcWkIHwHJzSfWbCt8wIcMOcgARRllQLGjjz1KAcU/UAQInHAIfiADkT0KNGSOPdTwgUAenJgQXx4GcABhJXbp5UIrchQmSVwBJl8AaP6jWgEkOCgDj1IIBGcXM0hhZxf/nJGnQF3YKUUZ/zwo4ZqCHSAAAQds+OWijDZm5nxxQUCVALFFgIQMShChRJ5QbEIEEf8QsYVAZ+SggQIbfAffAYZC4GGjsMb/umgBnP0zQhluhBrqGaAa8U8ZSHSwAQRjFUvsq7Imq+xVHvxDlqKblaaQBwpU6ZBWHjll1LbP4eWUdpA1BRJLy5YLa0wIRdXTSM91ld1J8AK1k0ZAqeQVSROpa+6+XmY3b1fdBmwUdtl6ZKZYLX5XwHffoRgVuDdldNh0/FYMUk9cETwQu4EJxFZlbbXlMUER0PbPsAt7d5S73frVcYt/aUibAe2tAAIIPICwGwkaUIgBBgrExRW0yjknncXWucayaynWF8AABl1Ia1qe/UOC1RIKlHUEHXSggGorA0aS2GKJRTULJASHhA4Atv0PEm+PwLattmrg2QALk0TAYIbu/+03VR4GriFVDIyIdE5AsSvVUQM8raaalYWHwmaWhTwbAZgnVwCiZcFgGwn+AUhgD3H8EwdxRP5TQ4Q++KABgKr/E4TsswcoEAxBuxxbhoQJ0LfvPSF7ONIsphmS8X9ldIBmEGC2ggYa1ODkkkTKEESAAupAnAxvBvHjQEOWkUMZLiw5QgSNtyuAYHAJP/z7NbERc7sreph843hjwMIIQUihJ69nwNOeQPWCLpxhBmWogQYwgDfBwEdi7oOfBEkUmPhE6jsYsAASbgBAgogqC6M6w+yAJpDYFGWCKJwVZQbCGRbogHo9gAKvuvADDWxgWM4ay1vcly6BnVApKSFJXv8AlsIiMgZdG4EJx8ZFL5O0xCRBZIlrCraueRlxeNiSSlSS0i5v9ZBcG4tiU7QTFK+EcWPXuiKsFCeVh+jLWxeDIk+ASDA64ouKd3HiTL6Fxj6qsTFF2eNSwlUvJZ5wcSjxiUgSwiI90uSR2sqWcyYpsUr+sTHc8ZcWX0IdvChGkzExG8hCxpmyWYmPT4lkRSTWMqMMxmiXzMkTkfJJhFixWzqkGuUW8A9e/gM1vISBL8smxUzyji+HWV+LnDUQ+MyIALShDXLiAqPlUEwqyowl4lS5Eb8Qiy0f0wxmOkMh0aCABSiAQeRUg5e6oKkoYcLQWKLpgHriRjf9QdJwkAD/vRWgIFGv9Ags02QYgmpTJtshSIpQlEMIUGaFtVKLZ0BDgtA873kT9czXVIO3RBpPoXH5C1k+hyS16RNuCBLIFKbQM+SI7Z1ig44yj4YvaB30IPLy5GtUkj52YmADGPhMeXAAut+k1G4uhek7l8MiYiFnAe0Bndz8oL0B9cAPKf0H9mInvX+s1GseaFgBAOo7a+7tH4JDK1UIgAABtPWmQXGiJ1mEU/s8DS5UW8EU0hMDr1Z0BdHc3IoCI09nlQUFuPkAhLDHWK0Sp6TDsVGgFoQ6BC0wPN2SlKQKShC3/gMBezEcXFdZELgoLIfBI0tZoAkjzMkHRsX6BwxWoJsa//SAQT0Igvd0pFsozO56b+MnP5FUgyAsSUfW+8cPIORVyQTSULLRy2gBGabF7WWw2M2IbYZj3CAAClBx6tOQdnsFJFw1Sg+yXg6g0IXvVe8HfODDB0YDmFdKCi7WDJFNp2uiNkqleNAJcEjExtEBdGAKNeBDDv6RA+/+CEdw4tH3APUPPyFwBtyb78IIsiVDRZC/sWKDR+Qz2NjART4B/svCBhCBKUhVOA4ClAEN+D+BEEFPXegTj34whQhUyZl+O8ApQVzEAJh4QzGdj2o8gAEN9EAKL7ixnpwEqjwBsAxL8BrCOOKhsxIZrgUQMUMxhJkOjEAGcdoVjQmyhQAKpP9WcTnAZgkg5i/beSBB64APynCGGn/KVwLZwhf4IJ4SokjId75zsYo1gPAsoQxC6MIm9JSLLUihByZAUWyIFSlfJprIzQs1Lw+glg9MoQRwCxSCgkYsE0Ogzp/+9E9jo5m0BHWb2drixWIdayRyc12t1GI3xaUxXk/QimwUWLYU6a13JRHYCsGOtI0tqyw+R9fb8gkZewjsQt7rLgx5IrUBaa9fN3uTSWRXD911F4CdcI6zZCO3x40RPnJxKd3KJLnEXUyhcMe/bfR2tv9dsDfSe9fCxrcx1R2Rehm0ijp1d64Zgq9/Q/LZ4553tLfF8CA6JIpIWXbAiFjxhCxRKVD/4aO+DvllX5tc2dsZSsbM+MkuQtzmTZyilSIDLzTOkWKUvGas4Q1tnX5bjP4FIhWt65T5uSR9PE/ly2syMed8+l/xPnq82a30xXHxxG9pKKd/fEqNT70iVWdlcw4esHDdy5MFW5kixfKxtpSlLDjkdPFcZnCFKGfIa+fSskc0KcOwnekAB/e1Gdq8tICzMwTxJfNwmDeDNE2groRLYQq7ORdhTsgWLNtae4LMDAHcziuDexuL7c5cVmYBEYhWQvxZGQ1t4GlLXdkkg92i9a0PRguAZjQXUE8QOOA4lUFYYApfGK5Ynb+BLDgRLe9QzFRuMwLRzGbaUzWQpSpFKVKZ/8fBxEy9t8U2xr+ZztSDJBywQAMdQAvpTQ/E5x+NyIqp6yLHSpbKgaxkp9EZpmEanQEyqwE1TVEU7uRqvWQbiIUzJKAbvYEkPfAffCAcV7MAghVQ9RcdJAFLIEZEW1Fa8BEyd3cZJ4MW53ROEzIhKGA35fQABZZIS1cXj3MsbRFVuiEcRqVPAGJbdXMcbyEWaDIY9eV8+DIxLHdFYKFsYfEc+OM4tKYAmYEWoDEQU6A1MMg1QAM2qWc8hSEfP2YWaPM6PohSKYUg/AQ9dnNDeSN3x3NdQVd602VHxqRQuMcwU3NrLEBUWTgCEsJS0NMBDESEubdUxCIWsXF+GiBV2v/DNpAoEH5AN1olECPAUsehAAtTLEXzcNbUO4L3VqKlRu8Ed2lSWAbRMAKhh0GjGRR1iaEjJeoRGi7lTmjyUggzFmlxGxOoPaOzVQaSILclAz8gO9LzByxAiM7yHQSlKL7XHIbiO2+1IW8FV6/hF+VGV2pSEvfheLexHurxDzxAAn+VFsRihEu1iZVxGzwwHLbFWAYSj1mFIDciED+QYFc1An7QUh01OJ0UUGg1jZ7FX6nIEemTRMwIGKnoHY1HHrwxBTXTHiiwAK0mZISxJQ5FanmFG4sVINdTJLJTibayhhpgXgnGPVr1ILYjEBbSe6Z3McIDWp/mdnVheas4Fwv/k4jMZHdtsTwLwCqCFRictgAwAAKgo1iMlVu65T26JTs9oAMa0Dps6B+EJjtQgFzXA4hopBjuwyX7dXjZZhQlVjaXA2SKOBko4AA2wj1LeZU/0iNNYonCYVIjwAe5xVup4z3EMSXMpIqCtzh7cyijCJY32RH4VTxwAVvrw1Qy8g+0VQM5Mj5vKSRC0l5SoFtG0pEL0mDINSQC0WDF+AMXsC1BFzyHQpgQ0TDpk12HOVin+Gal0YgIQhyzkzrs1SPX0wNIEBxK2ZlNwl4Pxj18EAMaUCWaJwCUsheScigfhpowcUcu0yKH+Jrro4j3oT8jYFs4QiRLuSDdxT2SqSP//9BeRPInPOICgcIHJaCJjyMmp+ecE/GaRjGd0DEfKIYmHDUhbfImv5JmFVYGf6JjACoQdlJhXSAEUoAn4lMDU/BTDbN80AWfVQEp8dQxJKYUJ7ZMKehkybUgSwJeBzpjM8Yn45lmMjBfGFAAmgFBe9OcEooVMhISGClkCKMZKXOLtOJCC2ZAbtBneDJlU/YPM9AFZdAgJPAX8TEiLvqii8EGTmpkRkaEYzUW/3IfBWApNcBnn8IrpLIr/1NALtADaPEWseE7vgN4TMooGXpCtAYBKdADQvApTqIncXoGvkKnfGACKap3Laqhabos90mErvYAb9oFoIJjQgAFRJAL/9ywBZ/yApjWAZxhYpojALD2p8pyYlFqZCcDNCWwBP2jK6JqBHJKBBjWAT+WWhaEqYcDHwKhAOHhA08gBVXWpaGSBaECLB0QKY+CaKz6Pk6FAbv6Ql2wKQO0BbgKKqhTQsUiZEv6q/uifZZCYWfgKTZ2Bj3ABJhFK86yAb4KrYejfQShAD4gnqkTKkIgpv8QNHExTV8JrvyyAR4wLLV2QxoAX/+wBBXmBrrailWiivAKP7RCK7PBS7bxD7LJA7F3MutaAM0SsCiEQ5QTG+EBGjCAGbEFsbHUPJhVEwEBACH5BAUHAP8ALAQAvgDBAFQAQAj/AP8JHEgwAMGDCBMqXMiwocOHECNKnEhxIoB/Bgde1Ehwo8CLG0MaBGCw5MWMH1EKDOARIcl/IEeqhDmzos2bOHM6PPkRI8yUK4OSHIqSZVGPMjeWHKhyYwEABQoMKADhX4GeTIP69Dmz5j8BWb+K1Um2rFmGRpF2ZPnz51WoVgdYLbAhqkA2USFQLfBgAYp/B+wKLFAygGGSSwlb5Xi1cWACCwgcONB3QeUFmDE/jtpYK1ivZ0OLLpiy89y4caXmHVB1wYZ/Dx6weBABRoTYeiFMpWq4t2GML0tSpR2BhAbjU0iAmPIvuYZ/JFaQSD5FwwoWK27jLimAAFiwXwWI/+/+NQBYAgIFgB7N3uFRo1sXDwiQd8EBzJcxo0BhmX/lDQTo1RsEARCwAXERaIDECAzq0MODDv4zwoJIaKCBDz5YqAFzI/zzwQh81PDBiB9OkRwLlhVAQIEBirWeeAckgF57NLZH32C/LSVcVMIJRNtxI/RwRRBEBtFDEFAIFMc/RhoZx4P/xPFDk1DkUEaSZQTxDxRaaqmDDiOsAENgKH3HlU8QiFfjmmwihEZWit14I2F00tfYUwPAtcEK103xQw5dSNFFklAUWuiWWw4qxaE5yNDDCLepuCJ66B3gXZuYZtoeZ/RVFYBcA0QwggwzdCHQC0T848YZ/5zhqqtduP/gQg2QbqCXigKkqemuvGL6QAEKDNTDP0QQwSqxW/yTLBHDTvUrBLbu1eu01J71AAQPCLTAVQKxYCEJJNw2AAZUNdTUVjz9NFJPL4kU1lINDVXtvL0qRVpYbYH0U0xa6bjSSWollO696qbbEr70JkzWwQW9RDBwKLUUXLtWdZpXtL/+KlBV/0zl71W/HeRvRUUxBZ7CCSdFU0wX3TlVx5wJtltUbEDAcQQrPLCCZZbdGtVJOa7E7WJXVYUtCg+ggLPSEexHQgr77ScdnyzcliKPGZk3Vnham4kyjUQBt69Rv5FE2ACxxYazdSxM58AUfOaMW8w8+qTYxgs03TYJI+D/MAKYDI5QHRImbmjiCCB0+AFBz3Uwm2sERH6pmv94591V3QlwQHcJfN0eYks51Rh9Bo3O2VS5cRZYYDD+AwEBSUv34d8PPghFD4Qy+cM/w+qAxO8klDDhCCPyEUQNMuz+w/I98NHcPzkbRODJGIH32eboUe45yk8FNfT3pA8G8wAeyDbdFUfm8E8ZUqxfxvtlWAmFDFVemTsUV65vZA+0goB0VASoUwAOAK/tGTAnPOLYXDrDsU9dRC6jel8XXqCqfwSqfRNslQUX9SgS/KpoBTjP0A5IwkwRhkBVoYoCFNCBJyTpIKwiwhZS9Q8ZaCBbesEIgQJTwh72KjeuG8gI/8qQBCks6gypykEJOiCQaEGrNSLriBQ5wpGQiM2KPsxijeyFsIhNkWI+cRhpwuaw9STEjFqc17kyYrAwsmtfNAlK6GTSMDS+sYtgRIgd0/i5KWJFJV6RF3wINjG2aARe+pIXAPK0mJ4U8JFbKRnC+CgaLLZlPV0RI1NaoqN2tSyFzsoL3VZ2pgLG50wH+UxQ1FOeViKEepS8SVrgAx8xsjGOYmMLVD4VAL3UhVyxcR1VbEaVAFauN1GMJCobAsAABvAAVmFd5MSjNVTCMpY2GaRHrHinuNhpN3IpAF5odpW+9OUfmNnAAaIVJ7YkhjQnnMsG9OMAFKzAnilwQD7t6f+A6NxTWynUkSrLo55rYlMiRynXrXpZrsYMgDVUec0/IgAb6KXtWnrxAI/m086I2eV12KINdsBFUnBRLW7XmVrVYBAbTtGnoGMxU+YIMqODSqRlGPGYXX5mFQ+85jWy8RELWGCbtPEFogIs20C4ha0IeIs6fRNch/6Ag+qYiDlTQNyJtHObjs1FcpfyjkxDaBBWpsemeuSKvuS4VKhAQAEPUADOsBM3EgjEATu76NUII8moJM2pxqHQEpbgO8AtaAoVGuqG/uE34vXgA84bCNxQ1JdpUip7ykzlTNGazIK5kWhfFYxeDgABnuEHM7ALoIoKVADXKA1cWa2BDmrwoB//9OBJTPqHDv7xuxJYyAcJslBzRlCDfxS3Bs5j0EDE8IDfXAU9KoElNAfCAM6eJXw9OiHpeESn1j6Abwy6goOahCQkCSQIOahdDwAHpgfRlkj0kwGRcsu7R/3DOht7aTW/E7Kv1NS6YAMZRupEYKIdKALVYdCjmoQ79MqghvL9ARSmlAP5XYl+TBoUk3IQhB/oIDoL0Iv1egMWAnaHAQYFsGjmc5AQCuS/oIUJI30KA+NooAcykMGVrOQCI/p4UVsqlIahMKgdO5hWU+gqdAl0qcqpeHtDIx2B6ORkUMURbQ/QgB96IKgzdKELXv7xPzAoBCP+g8MfRkFdjjldzD0Z/62l625GroIBDdRABW6gIKqkIIRVuapVRsyBC3qgAYpuzCorylWK3xxLpsrkoRuw8/sEogRiDQSJZzDCP5TQBRs+YADR6uWhGU3qu/zDA3L5hwlKcCqBHOsfiPiHEYjQhSmwYADBIsjrSs1r2JRrIAPogAxeRYRNKItYSvyHRCWqbMD0utR88QBsKJMtDchg0OjLQQ1YoGy5vAaiCnz2syGAgWz9AwPnrmhO2njLdbVF3PC+5MO86EeemISOhoy3Dwf27n5LDCv86pdQaklwTep7Wmt0pMItCUd4ZS2MBO/3QwZ58D6eEpBUPCQuQ7fMgwDMXFohpR7btceKS/FcGf/3N8SBsslIEuXjO8mavAR2yjOa/CHsVrhnWV5IUuZbjABg2BV1yZKgw3EoIBN6zTEe8pszneY696PIxaauqbOMMZzcZL47y9aOE2TRjBZ6TZTub6IfUimJxMpVUh2VmY2S7WbrSlYwPhPqlfXuW+P1w3nubs/OPCUGf7fZiHY6n0aFh6MLTlq7/rCJFAXsAOaJxPr+8j+6hCAg1Mu10BZRH6FTfBW727sWYsbnphBHz3WRyQ6uyIjpsuZu5OVepAIBn0rbdfPEC2ywJa3CiN6UDuFW5KKyLbpEBUD2mYxqb1RTrZVcxf8+OVxUQ/2pbMDtbKiZZT6/sdRxF5mkm4n/U1BPl75EbT/1jNo992MZ0r4Y86CBPDa3zi53DgYqp+OMV59SAA8EIPsPAFT/YE8wQEyBISAm0UgyZzdf1RdNswL7hALR4U/2NDV8EgELEE0YURgmYx7W4zWRN0uth1O34jM7pRpIFUTBtAKwkTZ64TGgYxh3k2+N8Tr48VrYwTYpNVd84k8sgDQB+FAzSBjfUYThcYS81hLhZBUm2F25sRvQ4hoXxVIuqACqAQG71Bt8dTBFc2BtwwLVAVskUFUkgB1faBxDdR210VIEVlBq8obhgTnV9GYA0z15whIg4xtYOGXlF0w4IxsX5TM+E37uBhdLJVLGwTfgNTuFYyLQ/zEFHzAd0TEbRjU04mE5RkhNblg66gFjB2VIawV4BfMzmgdXEUBR2QE9/4AdSBMYqONSGzcYfEEbK3AcSOA3fgM4GvAHYagBgrM4wAgdq1g1HRAsdaEikqImYVVQiZaEQXcwaQcVF6FRakNXfEIdPAAC/wADC0BZ16JOfLV1nKE2xeGLjfU3HXJfiKUhi5WOvANZw9Ihx5EdsZGBMpIA4zEQ3rE5Z/V+AoEAaPWM2+RZvAQVrAEb83R+cYNXYrIA3MiNsREYfNVdV+Eap4gCGpCLYPIlDxI4FcKOwoUEuhUkQQKMfCA4xoGBkTEeWkMpZxVu/4AAAoBiKkZLWIFLg//xTJNxH/eBTjyTH9cSIAA0F66xAfYELn7jXurFO1fwD0vgBx+JIRriiMT1ATWAXI+Sjii5LSQ2ECa2EDLpbE+GSG2RaqUTZ3QjStiyLaNVAKtzGv2RAiAwhgpWO1Nyl7yjO78DktPBILTCBxcQIoKpJfIIAzCwgaCXEJsjIwIgk9Old7H3KQP2Eu0UJydUJybobAsgHYGzZeijJXHQJWemXuuFBEvwOw3iXj8gXw/GJETSkRaFmC4CU2mCWV/xmDeHECPESXw1YHZCZUkDXj2wZUcyLFtCJI2CXrdFmvxjJMkpX/mTW0gyLDUAYrJpHhlBQCEUQtAEk7mZVlhkEHL/oSN1shgb0DR8UztFUpzIGV+4g2P/IGESRj/2YypJQp9GIiH0SCZG04lB5DqZg5vfqRDc8nA9Ej4UKTRv9SMLcgUdkj4CET8Vlpwcpj5XciWDomFlUEPu9QFwcy0MmCaYA038OKAV0T0DtlRWIQCm8UAdoza+GATQaWbsU6NS8D6FEgQX+kIRuj7zwz+CowHbskou5mQmWhadkaQV0zGLtEj951cKgAEsQFvExT85JhBgZp8+aij5gyXz02HVORuc8hVVoTlHahZURkVStl1zhhXOIhs3lgNS4GWmckE/dqdm5gI/ECZrpjkr0o9nuiYgU57L5xtn40ADkAJIIANg/7YqrmanYGZBduoocJOBk0NA3emJgWojvkkgvhlnvZEnJIA8ZeAGM0BBZ+AGQtAFq2pBL9AFE+ooYppCglE5mrqpmdJLBdJAwIY2o3KqL/ACSMSqp/KqXxZotJIz4SQZkWMpuKowv1YVDyUXHRBBwRqsRCCsYPYqSuAq8VMDU6AABwkB02VMz5owbNBIJSgVcrFbxMIqm2AqSDQQSkBBPoABqUNA59pDNbMxwcIEFnRpAkEERpAsApEDGoABt6erILWvJVQzwYJuxomqAmEEWbAFiKBpqyhtqfM6POSwBoQX0BJXEMBtUkBBlpYsM5QDIhks3tewIGtAdJFDt9cDflD2D8a2BbnQBVfARM/ChG45QjH7NU90LQFIGzXgBrAKBYJSBjpQjAGYQzk0tFoEVLQxO8KjA+EaRLbChFSrRRpTFdlyYNrxtdaFAa8BVzgREAAh+QQFBwD/ACwJAL4AvABUAEAI/wD//QsgsKDBgwgTKlzIsKHDhxAjSpxIMSJBhhcBDDR4ESGAAB//fdTYcSTIjSdPDtQoMCXLijBjypwpkyDJli9XrlQpEqTPkDsHBABZQKPGAf+QFhVo8uPPAgOLEoSas+HLqh3/CUBJs6vXrx5/QiSIdKdIgQUuQtgA4V8BNlDdLigAdejGuy3LtqxLF0KBBwceCF7wYEGEf4QXFCT87wCEAwcKEHCrMuvGrWAza/a40igAliSV+m0rt+2Dgg8gPCjggbXPoUOrJqUbgYVtEiw0TNGgQczu3SxWBGeBIvhh4bZZREgNYTRdynenDiQQQEBWAdY3a6/I8+xnkAMGFP8YoLHAaLbmHUMmQFdygAMB0kpWjQKFBhK6R+jX3+Nfjx5IjBBgCbrxFsFhLJCgoH4ffFBDDQ72p98UuK2wHATU/UOdAAUIMFljWx2A2QGNaXVAAtulqFlZF8VV0EUwQgXVAhtEsAIJ+/3X3z9BBJFDGf/IkIMMUMgQxA9B9BBHf1AE0WQOQfqn4xJIKAiDedlBgJllkxEQoopghhmVdAWlRZl88aVJWlRQbfDPAynUIGQZUvxTZ0FAlgGFnnw2GccPPXxAQgR+TaalACIKRKKYjDaaGQGRnQlVBCT8I2cZbrzwjxv/dNGppp3aCaQMH/yDQVyRReroqqxuZ94GGCj/UEMZniKUBRH/lEECBkmRFtdprQYrbFcbCCaYQIcpWFCsEsm2EUuWKdTdQT/ZBCNQw2Yr5k2cQRTSt2Kd5VJKBMEGW0sFXZUVtNq2uxmMTE1LLbY9ocXUUiOhBYB5LcYlo3PhmZlVtAcZBdFzCLuVMF7uClutQfky9dm+Bk8FVVl+rbbAWhBs3N5A1r7kYlSqCWYjccOtcOM/laKwHAqnwRBBYoK1R9e5AnGYVYbWbfVhw9s5O17Grx6LGAorPJD0AjAwPZhfaRFkXbnjufXmA7Xdp1uA/9xXJRI4aH2gcv+swDJ+U3At0BQjDIqCQHMp7BakbnnIoc9b5S0Aij8D/+2VUSlxtJRQAkedZlQb9fXXjTkGwaMMPEbueA81UF6DDhA+WDnlPxjpuZH//MBHDUFMSFxqHQYAgdRSH+SlVmv6PWzUVuNFJuJUu/UA0mx3TiTk/+QAhZ12QtFkj44nz6OTSQLatoWFpbV6zpNxKPv1M8Un/chaddhYjSuMEAStZ7hxRhddnC+Fp3UKIcWeOfynwXJxFfoeopJhr7+YLpI3ngY/OAOocPUPXBmhIER4QRlGsAHXrA5DsdufBFVUM2DxqgYveMEZoLAJXJ1hgQrg1a/q96KGZIRhNnkWwSbIQrBwq2DdShe6sAUuGobsLBzhFr1auD9npRCF6IJYd//A1ZN8BU6FOZThSYzoLB4yaoUlrJe1UEiSpuQwAHqRisGUUp50VYtiZMHLCxliMBk68V1R9IkQI4YQNYZEi4MrihwHQjih2Kt2Ktyht9rIx+hwBopnXEhT5EWwkQwuXVLBYgA8MBW/uKUtf5GRwsoVEYP5qz3NcUzHVMMWGjXnMW2JTHYKkrecATKQCWliH7XIEsKVRyNtUYrVCLCByGBpdbS7Vu1O0pcNGAYG9ZlZfcq2GJgl5pjNIQDU7CK47hHkQ31DpSAh1hPyUOwffmGJr6Dil7itBjHmoUtrsJivuhyENX+pTW5WIAYSUKidwlGZyw70trcdaGaCaWBfcAb/rxdZZzId8VIAMiTNgi2xIOJBHMew+Q+2wI0FVzuNapxjuKi9cTZ/EYxyeJO2Summa/i5kXDGhgIFUeg++OlabYDlJrTEp2fZ6UjPBjLTgppxJx+5GATE44F/eGAAbClWsQpDVMIUxn6re6l0CjDUrLlzPyPwg4D+UQIklAA/BlJObc5WpREIRD+j82rZzMa0xmjJIJjx3qEQ8rpFFZReSwzXXpIiEKUM9GbU6VBaSBQYpd0IBwIaQQ/48J8kCaQHOkjsCAAL2CkAdgQNgqzl+MCHH9RgdJQTKwmS9oDXaWUgbsWMQU6kFQR81qYUiYu8zvmS+GTMMJX6hw4o16N//xBWck2K0g92q6Me/CBIPRhS8CAngx4kqQcT2qxgpqaV6lCyZ2v1kltR2xVzmglaaEKTz9xSrATFViCOy1OfhpukJSWJecrr7Qh4w4LVTO89z2yudeCjlWhSFyxx0QszJfkz0hzOPA+wDcv6Myc7zcAgeyqS40CXqyAdqQZtOx17QIudDsHHs/e9nougdjP50OUBJPiADOjEvuGZ+B/G6wIU3lekIgEoaQSYjCjrewBlZtiJ8hFAWwz14Q2wQMSYEoL5hpy+9UnBfblygaUqBSyDYKjGN7bpXVXbHgU8QAPA0yCo/nEGIpzBCERQggb/8YEItEZ6oGVDlNcMSQ88YP8AHZDBC8JckDP8YwtZ+EcR7IQEET4ynNNdc5SBZWUW1KALWzaIFK6gAbp+88+CFnRQSeSiDugAcsEtgwsajc1wtinSoDbIsUrmpiZXxIc4PGWoBT3Gm7r6JoOs4Q9XzcJTnnBgqYSirIvIFFq7C9XsoglcQQOacPGEiL7WTKt7DUNmV1GNPJGrTn4S64Q8TIhBTDZ3TNjrH/oQ2fPCqbTv8mxpqUvbMQH2DClZQiuOS40cOYleyjIyeMcrJHFlWCXRXcgSwgterYU1u6tVkjtKRSg7LAtoNmJHVafypqLVd6RxPfAkRqtcJhGLSQxuRjvSFSUp7Iiqy1hGf3MkiAf/jTK8oa1HlL9I4140ilToSskzQ/Lkq314TkqeEH9ZrSgs4V6GMY5xnNgu3ie8Cr6weCZH/oqWC0OKXQDJc5FI0mYfs5ncZPSc02b7xkcEGVBec9B8KZ1wKRxaQ90bSahxpZ/UrAomCzCXohZmAYy5+93XIxkzjcmPoQ42GX0idaE0PKFvUtjcOVwuSsYHYlRBy3gyursHyCzAjEGMjfCOGLwTFUM3+/vRnTtK1Lbcikyx4+GxuJR/vaotHJtLh+Uq9S72aqiGKU4EihOcfyDtZUXFO804BtCLU2uUQg/kIM2yRKosReRuGcBaDOVLRaGHw055lrisNhrLH0g4JkWp/9kEjE+7GxV1y+xnfGmaIccLOiNpMfxQPG6vrnuTLZBcy+QNFxsXPV76qlEbK8AbBTIFIPUPtiFPwlEc8aQcguEYWpcmfmc1o/RM1UFTrENdH4Fw/idHWPccsWMsb4J15iJ2j4cWHhCAWTOAHNVoH6UB3jUclJIbXaMyKrMchyEQLeVPzuVHG7Ih3uM9qFRseoQUziEYE/UmMBBRxnJUftF4zMRQWJSCGPAAHZA1HPUPU0AgW4hVMDg/ZKMguoEDbANY+FEpywEYjdF3/1Rf04EWMzVQAmFfPFR0kNd9D8AWViYQlWcYCwAzxgQYypRdHSEea2EyEaAB64UEvIEEVv+1hQR4H8oxiSlwhmf4D/oBYf/wBxVSVo4hXwQRO54lY1EWa1pHF/6zU4cIGMGnTIMIX2jCXcZiIxqAAwEiVfpxBSNwBf9AJYy4G/PzDxHQASlwNmzzAZDFB5gIWSPAA5tFHIoxYRdBh2eVKP+QAASAjW+1QmyELqrjWh+oV7hkMWtBGEijiFClI+D1D1egAwFSiyUAiQlyjJl4WZVzWZmlhZulATCjId1TIloRcQaBIieCYdIkG8fmfPGSEmjHHtWRS35BIkqDIyMwWyNAWI5jYjoCYQyiA8joIBAWKPi4W0bSOYfVIMBBGBgiEG0hWlshUyJCItm4aikERiEzFdD/VziqUxAHYCM4kliVMzlJAgVKAiiAUhC/ZZS+ZVzB9TsK5h8Qoh+6sTSkIVoksmM69pIfgijoFkO7RC1RVBaGYTalIlaRY1xxQCTB4yQ7Ajl/siNDKRA5kCTF9R8BEhwo8BhS4zPvgU2HgyiA2ZWD93X1Jj2WUSyJyDaCVRBz+SPwEzxzOTxMGQRxkCSNqSNJogPrRQKEQR1eMjVmcnMmYjeCiRELMYHZZheTdxolNQWzBTlDMjx4MjxD4jhx8A+V2SRl4CRGkiQQtlkwlhZ3I1p9CZiBVpoPsV/Qdxc6g2Z9iQIGGCEFpmjFAyQoRiTJo2C7CWEUkjSO5EyNcRHH/4mcEvFvoveGhikjFrM7U/ABfCADI1YGdCIQXfA+KmYQffI7/0Eh7fUcMVYifUme2SM4zYmT3GdyiBMXJHABfLAnnbIJKBahKWY8fFKS/0ECKLABXTKKAimgKZKe0PFzl/QAbCMk6YM+XSAE9VknJvY+fJIDP9A2M5M/HdEh0uWhYrImV6ljtaNMAfgAItYFM1A+50ME7CMFSIqkelJcMboCfnZOXImjrYJ1H1KOBbACNSAMM+AGUmA+mqJB6XM+diIEBvEBEMVNUHE34ymlqwKOaJZRijgrB+ZlAvGlByEFZSADu9JAjqRja8qmq4Il5rRTSKEAETArmuJBBGQQuLaSpyQgfX4JH38KqNmykwOANSMgBYp6EIhwQJtSAyyAAQ1EqS3kF8WiABrQBW6gBHZWQEawBQU0CEQgBRrQAVVDqi3kJuYxAIZWBnPWZXcmEHkmAz6gANIXF+gxqbg6OwfBAjlgpFzWqrNaVwowGouxrNgjI6vxAArgH/JZZ13QAxoQK+41WtgqO2pWEGvRUGVTKSNQAzHaAbASSdjEBul6rtcTVHmYhxiAgxC1hCOIrwXFrzIREAAh+QQFBwD/ACwEAL4AwQBUAEAI/wD/CRz4D4BAgwQTKlzIsKHDhxAjSpxIsaJFigEKHlSY8V9GhAk/dgQgsmAAgyc9kkQJMiVJkyFhrvx4sabNmzhr0tTI8GRKnywJzhQ4QGCBlgQL/FNqNGMBn0WJdhzgUqXEjh4XdsSas6vXrxCBcg35MuVRsUezDizAVCmbok8DbFW7FgDbAhAIPNj7YMHeBf8AC3ww+B+EDXkTLyhAIACEAI3lehw7UABTsJgzOywZgKpSu0sfLx1tlO0BpXifTs44EoBd0BAO740AI8I/EiymDGSxgkWEFbT5Cvf7m++C4wMPQFiLVYBHAv8sR5/unIBz55qzX0SIVXL3s6rlPv8dLz5AXI94N/RdgYIFiSkj4vcY0eNf/X8j/CBB8q+EwPgAjqADfQT20EMNQQhUw3wjTEFCBH0dJ4B12P0DHXQVLiQAAv8wkKF2IGoGnYUCYffhU8sJBJ156qGggQYDIfgPFDlAIVAOMkARRBA9QFHffPgZ6MeA8yExRQnuPbABAY9hdwBr01kXwAETOkdliFhmqZVSrBUggHkhhTeeUf9sEMEUBgaRgxRSzDCQFFDI8E8QZcQZ5449/DDfByNAyJhH0lF5gIWQaWnooSAylpEAeQ22wj8/5PBPFwKdMdAZZyjxT6ZnSFGGC3yMsJdhBJT6IaKopgriYQqwUEMZLxD/IRAYRBixRRZbfHFGDywokBQEBSwAgWCqFmusZin+M9s/uv0TwQaFOQTSQHMhNG1C18Y01EzZCrTTseAaWu1GMVmUUk8kUUUuTzJ52y1d4caL5UsvKcTtQazVe5ZKqqlW1EnjfVbQAAZ5JtdKFXGH3mjLsUUatU/9O5mK08Err7Hc/kQSVy+p5m5CbTGMl3mqfemtU4YptRcLKKzwwAq9wSxQBBH45pvLhI1KAF6lnrZzeE8m9KUA2Em54oinXqwZtymK5lhqyv7jwQYeFPCAcqkd8GRccolXWnrCscDbi//ASMKLvnXQQQRrrx2BBu5pQEJ88I2AX7MCafCosKWO/4ihl41ZB3h0gw5knXWFK/1VVVkdDCV63oFMbWOGQdDXb4/avSAfPfCYUBz/6DCQgQaOwCeQ/9TAuUA/8PEPn6ZPwd4DO5/2JARED5r0oBgiMKLi8na3luHmgbnwP0VVDRgJPciQg6RlzCjFjFBUX0aCP/KoZxB6LtggCX0V8GRjQwdg8lKMJg38+jddltRkD8CwAgmvuvGCG2d0YalAQtQ5Y501kkEQavCBKQgmMRWDTuLYx0AtOaZ4wFIACT4ggy4QgQiW2t8ZclErgsiABBhI2cMaSEJVbWADxHoABkbgAjblYH8XlAELQmM1aPUFWkJZF7W8xS6CfMteJQwiiP/G1UMe1qReJmGJSIIirSIKUWnZImK3SkKvrCAxLFXkicJUQhkjdvGJqooiD1GSRKvQyydlvOJAUHIWqnTMWxEb4Q7RdRV4fRGMi4OJxqgVlDPei4+T4RZ5jtLGjuzLiiJRF0W2mDCOqA+PGLnWuQ7SFoA1ZSmWBJhdnJIWgpEJeV3rmscegpq7oIZJqAzMXYAFrNOwZWfDshiU7gjJitxReGT82CbnMqiOQGAAqfFOeN5nF5UtAEIPYMECgMMe4PAFQn6JJu2AxRgUmS+UX3SO+aJjolqaayydcUo4K6mUETkMNQ2bpXfyhbwCeEA4e4nZ/M6mG97wpjh7aaV6pHn/mrxcyJUlIlqJ0AeZa1rHQgIl2iO96a4ubYyaKXOYhagZm6tRs3hyMdlnzAMalVkumTW7Td40IIaapQ2eEVjAzWBGgvlNwUEkwA17bEM8k51vm9Xp5kK92RaDLIc1FEVeO4FJzbs8kDxQustpVmbPswXIbgL5AxJeRFWyjbQEAIIdfQRSn/jITZkL0JrWKIc70hSKRJUpHAP+gYCdghFh63oceeDIGkNihylPexlv5jaCBRkIQZ2zz3+uYDfNzeew9qmBYmsgwB/I4LE/qAF+/tBSFCxgZ4erDkJ9KLQDJMA6HGJoV1BGmTEZcSlUAdZsXCSf1P1DgHXKEfXm9KOB/2z1QAN8HYMaNIKYRuhJT6rQdf4xKN4JoHBuFW1OTDQXTNIFOmOyywCSySzB2mggUPBfgjyXvc6RbgRIAO+LlPRK8x0UO+bLC1M0q1wt9YsreO3X8DiiANs4NVIC8dT0ysDf185JgAJRkwAVW0AUPMCoXzoolRyTu/bisWHvO+bcGJuDMkjBUtOb0f+yO6MdBSEOkcUPCVAALFJNiXi/czAePUay6JS4TM4ageuk8IJYnYEIQpCCEGYkBCicwcJukkENYIQYpSzQfSpWLhswWeLkFcU2a6LUpmC4wVoRQQlEmEEZPvCAAcTmdkkO80O6HAES/MANmsKgrHJBkC904f8HGohKQvQi5jorZDkHxoCvelAGIkg5F1v4h5970IEQqtZqgemLnRctNcQoKUVmMsEIfhAEOZVBdBgocsogsGRGezohvopWHq2oQ2x9+tRS5EhDaAIUhqjx1AzciRhJrep6bQuNr95MGWGNqlnLuiHv8iHCNLZHNAK7O8Hm9WjHWGqLSSTXxza2qfF1xh4mW9m6tpaqad1sV9OSi2UJ90icPW2NTBLbNkn1Zm6tRIYg+XFL2RiZVrLRdrXaiWFB9xqbvUSsXHGS0k7ivZO6FYkV5TWWRHK3JyI8L/J6XOeWCbE50hKEgQdl8cZkZzK+yXjLWiQKXwgS72WQkj+kLIv/ztgaxSJsI0aFSzuEt3heo5GCnQzcCcsXalCGGjK5r3gBc+63kzwUrUyLkWg09nhozjBMFkBijsNIarwEYaUk6yomw+lAGe3Hnzix4VyMd1oM4k61iG8AbOjoxO54GVMCyy9/+QtxLQd3wwTGMJc9DfrGY5kJVaybqE520kcjSOky5TRLzkjyGrei04KJlWX6qHBsM0NlEcYvlu8LYfDypGtidJYEGW6FDvpweD2l5ISULrybXNTP87BLS8GLcHrTMt7AbIYwiLvmR7WBatoumFzriN9cLB1HipnlkpyJZ4RKkBLjxSjqfeDnpxL72KgnmTBoGeb0Jobe6K03LBNO/+8t9ADLMcmooYyO+aiePkC5f6DDrfO5odIZiV5mOU1bTFHjEnyhsuVpkvdMKwAjuuEg9hQzyKQeiBFNwRFNKYJK6kUxlbEoFChQJAJ4SSYWngEsikRcdjcQi0FDTFJXkrFDS/d0D6AAK9MejyI3LyVTYgMhGCAcKPAPNRgz/1B5MAMztkE7JXI01zR6CXUdGKJihpQU/8eBIJgarAR3rMR/GHU8IXN9D2BScEOAZTMFYmMzVUgzzuIscvMPOBBTMVVdzDJDgMEYTFI+RZNgBjUd67d1ooVEjuERL+ZlXnZoFIVK5PEY5IFeePZMYnM2Z6MB/DEFfqAbJAU3JuAbef9DiC8SHwMCIIJlNwZIYsRVO+dzIeXCOwKRAJUhWpEDEkwHTAURMRxlVIO0foYUiMnkHvBRNwSCHwNRVTAiEFiFVU91WB9wIL6oG2eTUsfBGMsxXJmVEAskEFRyXO1FGdOiSVsxV2u3do+nMjsoN/KhAwuSWK9TNvkxAktgH5L4VAuiOnniWD/gWAziIM7EN4ejdR7IGh9CIcnYjDUXcc1Vgk8hHeLkdHgRTb3xHgLiPdwjA94lWFzli4rVV5LVAx8gWHIiJ+ooWfHBAyTgF6XyJycTNPJYIp71iQoFa5J0GY8jHc7hJcazFB5gGEryAC6iG3ZjkHxQadtFk/fxD6D/U4n/wB/1wTmccyC9WEA8ADN9oV7o9X7aFB0Y4ncVo2/bdlqnlRbyZXnL9B4B5l80Qif+YyPcA2L2cVi5VTpBACAwxQJ7cQDkU1bmc1xDQzhqoUBO+RBYETJgIk5e4j4OU4UkIBBXYCA54j//ICkE0SN9aR9+8CMBAonlV03DRSUo0pZWkmJxCREhg1aGBHRwtBZFoR74MQICxmHTw2HXI0CkQzo84osAElNmiZZBuDXm0U1XMpkWIVww95bFgz6XlJd7yQc4kiBykl2ewl86AmAe5l8GuZAOQl6AwyiEU4IpKZuzyRAV8l5fo5kAMAAtogOW9g9sMimeYic5EpGP/4Uj4thbK6BpbLmWXsKW9QidjRQSt8kcD0OSVoMC8MEHMsBfXZBhcNIFdhI914MjcWCQBnIbLDB+LpYVzBmb7jkvo0Qx8OUeipWfXfAC3MmdGbZhADQnOZBb/wAD0LIcZNUYntighsIG0thiRjEiKzAFryIFblCh/4A/FzojZwAF+1kGOCJk4AMtcPmjJmosbJB4TUFNyoECFFRBbiAEFropXbBj/IMplFIGPEpTxNgYjRKkwAN5J6Qb9XFhGbQpYopBSlBj03MBICQQsSGinaal8cIGT5MaNjQF+YkpVCZo/2AEAqGnFjoFCpCEjBJybiov1PROGvABZZBBGCQQtalyK7nyYyPQAcDkZVkjqIMqL2wwKiPQZxekpwmxBUbQBbwyAJSaLIzRnpcaLxKFASxgN1K2ZrLyD1sgBTXAAnJ2GIcmmal6MRswKDj0Dx1QAxfGqLlgBEZABDKEAaZYGFm6q8BTfmqKGBuAAWgiW5LyAmWABH5yYJB3dc6qNMDErb0XTRsgNzrwkEOmZ4iRMr/6rQzErYhmeVHzhWWyku7qTXtRAJl2EwEBACH5BAUHAP8ALBMAvwCyAFMAQAj/AP/9CyAQgMCDCBMqXMiwocOHECNKnEixokWBBA0eJLhxIQCOBw1+/GcwgEaEH08iBInxZEqOLC/KnEmTpsuMJHHmDGkSJciXH3WK5GiwgMEBJnsi7biS5L8CDwkiBWoSqsQAAmpq3coVYsmBCgMUICg2AAEAQQeMJCsQKlQIBQpA2PCg7oIHK1awQPGPxb8Hfx8UGCC3cFwIBOKWfUpwLEKrWQUSGCjAKoGYXTNf7InS8dOWY5FmhBqgtGmwCge7fQCh7l8WEWBEmD0bxd7a//hGYKGXt28N/0gEJ0H8IAoY/yAkxyigcmTmzxFmnay5esOeKlcmFYka5r8B3wN4/5BbFy+LKSNGfBjxr0aNHkHeB+nRPr0fHTp60Ne//x99HSP0UEN87n1QwwcfTJFCXXBddkBlTwlQ2kFQZRVdQhdapyFXYg1E2mdMofbAbiToIJ8MQcQhAxQ55HDQfHHQ996A/7CXngYawFZeXAVMZlZkWbHlXAAHFCAAAUduqOSSYI1FmlUhjcXdUwU8cF4NP8hQRhlSdHGQG/9sGeY/OZSRw4pZBpGlQFP8BRdlBEl4AJIHMGnnnV3BpVydUI1Yg5ZnnPEPEQdtQigRYBBBhBJKuDHDDB/UVUCddYKI56WYcjWXBxHgSB8RX/yTyz9bCGREF/QpMF5CG0CwQKawxv860wb/tPqZVbutINAD4HnVVHYabTfQSyGtlF1OI40k67J4ElWQU1MOOyxnGwHVUEoJJbUURjtVy+y3Ww3FkLAtYcbtTh+Bl1JoZE14mncRydUqARvUiVhCRkLwbrsDmfbchRKCm2lSzyqElFEeujusk1h1l5pAc7nmV14RrCCbrnc9MB5cPOrplmKKTSbAnnKBSKlZIFGH8kHUCTxTshBjVBbDpQVlmsJkGcbaiL2RgOMUwP2jARIjAJcee0ILPTR6RC9BdA8BzvgPHwIhDVsEG2zQY3McARlTkv9Y+A8CkbXsskzKUmhuwAGX5lhobmlNFworkPBBD3z84B9CKEL/EYRAP+j3D9ElAIeeeiP8MQUJee0FwwILzPnjZco1JRDbB1Va6dl2QtlRhZ9V1iFYSKn11wYdACfDmGFCUYbrUPwDxerz+ccfHwIeiKBwK1hFGpAxL8f58BbN3FCPwf05QxddSPFPF0R0IYRAUJwhhaDTS+HCPzJ8EMEDtlJ3AJGeE2++hnN10IMULxA66qCiEroFIkRI0UMH4Gl9/v54zpVcq3JLnQ4SIoURdACAlSvMryw3EYLx74EactbLCkItCp5kO+ayFgSHpxKWmIuCCeEOVbAlLRJyhirGYgtqNjgwp7jwhU4hmAa5hUGNBAtb0VqhClGTtmOhDYYspIgI/4HIk24NBYfSKtazpqKtqnzkQzJsII+s0hgVZgckZJEQVuIUtiBGJW1JjEhGcBKTAPRqLDer2YT+0TKoICkuI6uSXR5wlzoq546MAYCTpniZxWBFQhba4hbDFqcPetEjzhojWMzIyIOVpV0mYeIKb2UpCLRmAXnR1T80+Y/Y3GUwHOtYq0ijLy22DSHKgQwbQfIvIx3SIdlRDGEYmTA0EmaRa4wJVAwCF8AcZDfI2c1x8PK48tDRl68qT8bo+I8FFBNyVPIMlC6TFVdiBUrRMdv+cMiWyvXLKIphpB7TmEvSxSU5xrRSJv1ykBwt7h9AOwgLckQcDZBgCkiYQgnSs/+eKSSIB8TRy/f05xx8dUdk0uniBtFCMAfmzGZrudkiB0KYXtZlLyzw2eE+8A+OVk0g7qka0UawhAD5gT+221t7goC0AAENNlojgEwBSZDJICls2hRAnQRAtsxl6Hw+5BYSm1IzF/ISnXTLKAnU0x6BzGc+7xnB3xLyN/5ADQlDGwHREKQ7BIFgCnp53JwoE7DLEamL0eFp2BDwSq34jkIrGYu+mtSaEZEACQeZHfdiNzu/5UA/PwBQenrwAT4cDUcs2ItdEHMZkQ2SOQ3L5j8O8KC20gReGfIMSnZlJd4AZ4Arkh3rchCE2c2Hak21UXqARjGtIU9CImtOWcv3U8v/aqZ8DQEPeDxAFxYMVkuxc55AxIQigaDIRcZ1T4HY8z3qABIjLdOmbWHVmKLosS3YFcgGNPABGdDnH2B6Xpf+IVwpwO51ovXugabAK+aMj40D2dx0+QcladZlqTUoQ/vOQARBBWoT/wjUC15whi7MwAU/SND3sIvQ+b5ST595gAKmwIcuKEEg/Q0woc6QCyIYQSCh6iQGkjMpjzn4xP+LwHcFUqpRbSELL95CDpAw4n94oC0QRrGDAeMaBWBAAT4IghSm9z4iIEIKGgBMKv3XTB07GIB/OV1dIlCjERzoHwqQcGFS6eQuC2TEdOnVDzsS1Gx52csSDEsMsYUdnCRL/5HBOvPwdHKuOocQLGw+lgPDmMJJyplJHQTiDae1ZjdjkVg+QVdYSgKzP1dHgjYcVwdhVsM9wyuoa4l0mR1dETpP8tAlVKQSy2VCMhMFzpvNIafHrOg7U6snMdFzuWiI59BYEFkvjPOqZyKUZzG6W7MuFgaBzZZ2jVMjCCvILk/9lV1fJNLCFhcYK23mrySl2FWBFkmM0maXCHEgXL5zVBJq2RPyuYI8hDVM2AyvXk0FnL+uIEveepDKdMwwFKLi254yTkvR2pBtJeG0btjQPJdLXbTkjkQDbdBUHoYADNLuZCBwAIpzrNgMS5gfd6hQzJV70y2hdbUa2ZGesEGNIP96672K1Ms6+nJXkDumJeOiR8RM0UhoLHYDFYpiSg8bI7plZbkY9iSO0LvlV2Mcb1BwnGFCwAOE4VGRDkNFnP2L3GwbJITKDWwdxhA8VMSlu/bVL+yecy53mU1eNpkbTT4ABqyhOmLgMnXSPFKu0/kjy7TOyj8SJAHS3d9PHAaT0lWFLBE1DRonmprB8Ap8u5nNxf4BgxUQ8y6tsWSRnhL3UB6gVceEXJ2c2/eyco1rPA/8NicKFbA3SWYJE/u7FnKwz9BlygipPAwqP5uMLXMBEThObCh/HN7kRfeQc1XYLZd3lkmmtg+USk9KJvaMP3L2GHnSLedS19l0Ei+bTGz/YknAzt34xvgaWNw97zmF9vOAB189PjOp+FxXdtG5zg8iZkY31zTa7O7YFxcDEDF1IRuexTgaUDfCIRwlkDTwhCM/owGFMwIlcDgtRR9IA1CMUxeu1RxwAl1HciQ/ghA2dXXmI302FiWlIRrtIhplN1FiAR6X9HYVswLtNwI4cDQCgVcrxh76hAQ5iASCdTQyIiBNVQMfhSOzEVNGwjU+MhD4JxCU8nxjIwCAlwAQ1GwgdG0TtRbdAUq3p051czQBklIDRB93U2U2YjtpiIH7ESBWVliIMwIkMBsPIFMzRUiX40ZG8iA6FTaVwlYHgQDydYJ+tlkK44XwQhB3dFF5/3FPOWggRqgm8PEDf5Me/3Af+jEj38Ue93E0yuUeMXAgI7ACKAA+M9UcbhQZ42OCDVGI27RnMaRmajZvVsFjiTUcHIVaAtEf/1Baq7M6v7iDSFA4WcVPiIMeARUBC4AYf2R/I8NzCTFWB8EA0DdfmmVmtUQWUVcUBZA1KSAcAbIfK/I6QUBaKdKLg4MEeDUCFpggOaJ2KAA5PTIWSPIcyjEZsKgQ14hi0BgV1vcUAwAYEbBUeBMEK+IiZUAmfxME6ahSBhKRNzIFwrQAG5AYY1FQCoUkl8GPO+VscOVvaqM2DLMUU+ZPIzBAeiMQLvI3pMU9tSMQfFADfBAEHFU0Of+yAt/DI6ukU1lhLyCSIfsIkilXZzMjFnqEbBCgAAPJTj2gVzngPAvJPTC5UgJCWFSjO+7IOMzIJ89FOREChQBHlFVkKR/USCZRc1jWKVamH7GDXqP1In6zklmCNx31DwC1ApXzk2ADXdJIlBDhQT7iJEfhRB0SMTaoAz9QJlJQXgfRIo8pA2eiJjLwA8olEH5BKwQxPmbjk4DpVouBMK4nGQIxABVzTz+wJY35Dy/wD9PTPALhJWHiImdiWv5Rig8QAHT3XkiCGP34mZuRbOXDErTCF3wwA/8wA9aDEI0pXLLTPFJQBjIgA3zwAZb3GZsHFjIFnEtiPPlWORDAAlz/JZldcAatWZ5eAgVEUD3o2ZguIAMjwAKCMVne9IfciSmpRCREAkCdIgPX418CcQYA9g+JogRnYKCNKQM10CaCUXHJoXr3qSSe0xjfgQEk0AM/8J+CMigAligediisWSO3spneFKGx8hafIZ5l4AaEgmEH4WFb4GEBVgYawJQmuj+EoQAaUGFfEGKHIqP/kAXriQQdoBB0Rys3KjBVAh7CGCpG4D4v6jz4g0olg1tJCitV4jkKgAQusKGk8qI54Bcbg0AieaWywhq0wmOpY4kHYQRb8AU0Chjy8nJWaqaYkqWctycj8g+KqTcu8F0KQCElaqcuEzGu8mUpADTA0QGBDcpkhGo+I1YANVYTAQEAIfkEBQcA/wAsBAC+AMEAVABACP8A/wkcSDAAwYMIEypcyLChw4cQI0qcSHEiAIgGBQa4aHDjv47/AGQM+TGkx4YiTQpMyXGhyIsVY8qcSbMmzJElV+YceFLlyo09U+rUGQCoRqAiQWp8SREmyX8FBEatSbWqVZlOeV5kunVjAactAwz4GLUogIsFDE4tUOBA238LFjyYuyLCigcDC0BIWzQA36R9AwjouzNhAQEEBURFLBjq1ceQGY79N/alWaMho2ZNLBCxVKhsQ28QOPdfBBb/UEdIPfcBCoEsVshewYKEbRIrNJCorVu37RX/UMw9EPgj4sEE/g1e7tizZ4HJI0uniHNo9cw8pV4csBdCa9q5p0z/+fBPx78aAkeoHzGwx78fMnr8CFKjB3r1SDTo36+fxBQeDjiwwAFu+SXAgcold9g/BygnmEHOddZgAgckIAACAiQw3YYbFlXWUJsRJFIBc7Ggm3o61CCDQEGU8Q8UQQQBxYo/9ODeCDV8wMd5//Dh3hQk/FNaXBAQkFx00CkWQIMERPgPAQhwKOWUCkVlpVRqieUXAGxNFpV3KJCgogxlSCGQi2V0MVAZZcwokJsyBPGPDHTS2cNuD7ClnIPKHdBkg1QGKqh0BLDlFlvePRDBFD2UccYLRJzxDxFgRDqppJi+cMYMUsjAnl6LMTjoqKROyQZlCgygABJlEPFFLv/k/7LFP1sMssUZQbCggGP/bLDXARsAWuqwxFrlgUC7zjXaabihhhdUzzaE02YZYQaSUkt5hFlCmHFV7LeBGhQiQmEVZO5SJQl1kFGWHRQiWNoKNdJ14NZ71bji9vTRVu7um91QJiEF1LUa7YtTWlAZlNxg/0CwQWu+NlyZwEQVVbC9GDPULVgmwTuAVylhi5ZHCx52ZVpfDvAwXq3NJddeoRUwwJcFIHkABBA8CdrOhRbZlpGO4STYcg8291zGkX1lcL4dqyXQxwM5tSWoej0gl6J2magfkFOAQIIG/4CNxHo6oLheDyPYOIIf6iHEHpArLFBoWhB05DSWDjL33HHKaf+I9JTvokWuVFNxOdYAM4/18GoamOdefANd8Y979gXhXn3rfZ2abCjEDYNccQ1YN2GBeTZSzgcJQKBnUf6N8VhikQWdcggfNJZei0egQdsyyskmFDmsGOfk9Ml5nn3r/aMeCTyQ4ADhTwbQZJOLCev69TOdqtdHqJOlFokoRMCeFDOcIUUXQnRxhppqmmnm+v9I4aIMfEwRwa5QNQgBYt1j7/+UepnbPzBAghFIgQi0+gIRtkCEBsKKVkX4RxdWhIHRPOtXU/mfBgUVFV89YDIW+EcJegAFKJyBCEY4ww86MBohdbB/DxnXuKI2EnVt8IZWEddChHaxwjBNK/0ymGX/4KUSqc0QhxmjV0JaUpJqFeSIQrEhwKImIn8hpYjYQqLrppUTJgLRXQMTYsd2EqKOqMuJGVGX4HhFkML164hapAkXqfjEfL3rinSs4lHa9RGjXGtEXMrgQBQUtIbp6Sk9VMjRcqLEOEaEI5DsIr10eDGPhGyIFrMYFc/ylLUYqWYEyJnLVhOxPPUxMFoKWRONUxiEOLGVjpTIZvj1k668pHBOs1sbuaSlDGYwZ94h0T/uMhu4POBmMQtjXwaDys6cayDHCZVy9ieYxTQmlo8sIlS2AzKSWBKWKHPML0Ejs15BZQAe2AAGWvYADCggna0BXTyD0zmrRcBqMLCakBZA/5oFrKWPxjnMg5BEkIURFJuDWwknowK1bfHSShkJFc1qlqdEReCisYmNBliAAhZo9Gv6EaEGcICDEZRUPR9Yj0rXwwOB4OaYAewIY44CoVDh5DkJOChCbzLF2PkFOzmZmMxAlagHcHSjGpjCeshDHhzoBgclKI+N6mMjG9XIRpP7BxKUpzz1KLVrsvFnoTxUFMVAhTHOeZBzLORMDDEgQ9ZDKCIHl8a5VvF2UPFOMZVa0pIeb3I9sJzxLGejILAHP1PYz2n6I5sAZSAuBGoLyjpSFuLsCUEMwdCFMiTXx4CEYw0TJwH8wh3X5IY96HkP8WoE2MD+QCBlG4F4/sGDD/98AG4RkMuhanagoY0WObmM3oEWKarORuYyJClLdNICAC9VLUxiukCdZACFHuQgCDn4RxnkJJ8a0IcPQfgBH+KTo3+IB2weFQ4/RauzI0lPegLI2c10atzHcOkpCuNVODt5X5nZs4DYZZMUBqym+JXBBXPK7j8sFx/4LDhOP7hADWJAggo2pzE8rC/StpSzmVlpMrxSwAoKeJ4VuWgg55MCFCQIBff9bsBQKMN1acuCAihgL6ozq1viquENXim00bmZkEbAhwNrFwpdKPA/1neGTWQKfmW4wJ0iUEEruYW+PY4lGwKwv+0N4AFiKoMbGkjmJZ9QUrlA4UDOIAOwdWf/L1mOs2EQhwQXjBkRW4jgrGj1D1ttQQo9QA1l8lIkORuaNF9qjfjKBAVLwWpWZQAbQfL0AAIc89ByhsCNH4aBqDxgNAVEjws89Q8FtNCQmE71pBXw6V5ZeCb08qJdVa1qSmbnlQX7YR0hqS9a4xBfZlRKdbSFLjXi0dY+ESKyfS2o66DxXM8Wo8BUuUNeY9KK12Z2DmdN10TqsIaN9Ka4pSjFal8RJnDU9hIx4kpoz7DcTTvjJb3NFFuDVt0SCbceMwxGl9SyOkb047yM/a9EOoSW+FaIrLMySzuKkVoFk5rBlK2VYU/xIP+kI8JzzUZac7GuAMc2uNeVnUuOfNqT/wyJrAVpO7b81FxZhKYz9a3hVxIRXauENsCCPXGe+rBpGNfvzkaTM4YKTVzMXQhzYp5lO27rJzRkycW6ohJrkeTdK9HMySZK0dbAmS+o7DUj93TrVdJcrrNclxrJyEinOz2PTotZWghAoAVA4ABxGaZdGES1voB9J6icKWMI5sSlE1fO8GZKLa/uULNbTCR4tdKXGmZpYy5gBSiAQeYzTzVQ2c1DjGGL6SpJ9tCqTjnxFcBvl8MwTEcxj5URNx538rERiTMvjhnLp017Uas9AAaISqbL28iW5MAsNKgzWc2WNFzrJQdC8D07EvUFE6V1uyiw0wxP/HK32/8Ydx/cFf+rvV7RoW6vYQ8oqt3TPxyX4eUA6SeqRviCMMQ0qTONWZihFY/yhI27jdFnf9DxYwaBOhswM8ciJOxUGoq2AHZxGuAhGxkFHiwAA+DxGnORM9y3SqbDGL+VEPdXc5ZRFh8DcoLzd6p3WXmVP6DCTkJyUQ/IAqeRGhWoUbnhH/5xUgU0BUhgG1wjHuMhEHKxAS4HdqPVRM/HMO/FK/qHZVpUFuD2dCfhc7gHGjjjHVcDA6fxUVyzUV9jGyS1UiOgA0q1UmXDNumhPP+BeXERGpokUwJFNH/CICnIAO2lM36DUCfBcxSXGeimHXlVNb8HgVrjHyo1Bf9AAiXwNSMQVZT/U1VT1QMf4B5XkDZ+EFtoyANTEDf+tBfcxzDuRT0No3rwNT1PklM6IxA8pkWXcUZ8uBBrEXwu41HhUUAogjZcRRBLYFU2Eh+VkzaHNTb50R//0TwCMl9zl2MnEzTEcQCpdyQ681YNkmNO+GsGRxTJtk1cghZfQVRz0TmdY4v1wSPs8VcrQliBpTaGtTYloB8mYiK4oQEj5gCcSCCjQ3+OMVpFYYqmaIcEkIfPsYp6eG1ptBGww0nbuE2fdTtzsRoYVRtTYB7gFSeUMzkjEASSIxA1cIiJJYMeiXkwYACQJTr3uCQmWYANY5LRAY3/gCH/II2piGkFCW+5hm7c+BlO//Ms/lE29lGRhRUHPUAj7tFVYZMaOMg5+eQye0E9qqc6gmFQT6J6Rzh3BxGCCbdDF6dc3BcVHvAAtGGIaUMQchIEcZIDVfVa/zCJTJVa6GEbHDUXBLAB0XEgC5IzipF6UTFaltUknoGKV+kQZfEhhiEWDkMXhkgnOVBC1zUjMJKYP/Ba9kEQMlAfOqI8QYICC4CZx+QWeyI90QNRJiOAfykTI1E7bOQUOYMCZZg27oFd7pGYwUNd9FEDtLkjPYKLLoUDQPKW/FQzUwGNeQmKqjia7DYvBYMk1QI1kOcXG+CAK4AEPTBeMtImaPIPoyY8AjGUP+BdWVUftPkBJPBBUv8RX6HVZQZhWcRJHSxHSBtofapUAIujVHEiPwNmJmUwAyemXWUwPHOCXf8Qm3SynVOAGnJpIPIVXxkhkOlJEaapExPDEVATFXaBBDUQPNnlPmYSP/GDZDHmIismY2xCJnEiW8BBeYdxoAq6oFexFkyEMiTYnCnAI9Y5A10gBeujYkp2Ykk2YG1CJzlSY/kzipR3eCq6IQizlTmRKOEzBTIwA27gBhKkPuhTYEymPuYjEAhWA0FiSoBSJIVWpKWylEtiLgMQASQAnUGpPktGEJIiEGegBEs2YC6wkRgoKl4KpuDCBi4XSqHUKywwAjLQBZCiBJGCQGZGKZayZC/gBi7ZEgEQIDeEdCp4Wi9MohfcoQAdUAOCSmZphkBnUCkLZKgvIAUjgD+EJkyTej2mFKhJYAS0YgQoxECumgVZsKa64gFEFUAwlKpIowAYsDsyIARfwEBbYATFugVYsAVZsF2o4QHccX4MUo28+i2sxmoYwCqTsqYCkQUNtCMYwB2f4SvBMq1/4yst6AGYqgE9cAUKhkDcWmCCBJ/kij3c8WUkUq0RkAI0cj5z4gPQYiW7Oq+9ujJf9jAIkVKr0Wnl9w+SKrDXszICYbDPEhurIRUg5rBa9DAGKxMBAQAh+QQFBwD/ACwJAL4AvABUAEAI/wD//QsgEIDAgwgTKlzIsKHDhxAjSpxIsaJFiAQPEjT4j2NHhB4/BgAwcqBGgxkFjkyJsORAjyhjnlx5sabNmzgfhlRZkWTMjCRnajwYdGfGoyb/FRiqVODSp04F/CNwcGnSpEhzat3KFWdQgjTBZiWKdCnYASqXQjiw4cCCBwIXuC0AoYDdAEsHsMwI1SrLf1IbZgwcQEBhk1S7Kl7c0uDOl2ABFOBYYGXQgWbtLl0A4YHnBTA8PwAdYcU/EiRKjECCZIRr1z1GfIj94YPsKStQTyHxD0WEtwsWEKhc+K9TwFZbJl4ukEBgxtAl+qS4VHIADwVGP0DRewEKGP9WiP8nMQXHPx0Cr/zr8W+Eah06esCPPeIPkika8LNgEUG06ANr0VUcZgHgpVQABCCI4FQMJpZAQgckIAADUh0Q3YWMSeaYcQnhVQAKU4ygQw0kkvgBHz0EAQV7QfwjQ4s9yAfbiTX8w8c/NXzQ3gghaqABCSygYGFizSEoAATODfaPhYEhgOGTUJoEFk9O4WXgQAEMAMADG5ymI4oy5CCQFGXMIIVAZbiQQxllQAGFiv8E8aKY69W4m0kHBGDhkgIJsGeUgAa6GF3/QDAABhogUcYZLxBxhhJEOCrpP7kIpIRAQpjpQg0r0EUAkqAKKuqoFz4QAQYdjNDFC1KcgVAWWfz/g0gXI2CAUF0QLFDAAqT26itOhnpma5dwnXaaaRjYWmiX0hVUUEklwSTSdJZtNCVkl0H267aAotQST445y1G4C1ULkksvOQaAuusqRFO2ED3H7bw3WVtUZDQ9lJK33kp5FUJWVfZRwE9RRQABByRY4MIMF/jVhg/JKy+9vz587b8fXeXRWWGZVSAEAtV1nGYQ4ErXySB7lutoEcCAAgswsCCey8HVjILKuhYgQGVSEdTzQD0TaRiRFC9WYEcbNWavSRtX6cE/nsks9Qr78RceCT5q4Fp8I/Sgo441eO21QLtpQDV/pXl2wAO5QrBwz1LF/VRgOuu84JANNqe3VEQX/71VvipdrJRkTVlZ2WR2/cPZdtyR5xqJP/zwzw89SM5ejDq6dlCI/0zhOW8r3FyXZjsXQNVSw+1s2HPP7elcAhZS6Pe2hDd1+O0eWlmgwAUcgIJuNcgAxT9ttvlPDjKUgRDlAsV2YxA/QN8Diq6twHafS/GN5eogz+49TnylpdQGG0SAA4l8/LBmq1J00f77/0DRxRnwC+TCPxeMcPMAAjoHcu/fCyCUCPUPBTxAAy6Swhf+MYhYZSEXsSJCrIzwjxeUYQr/8AD//oekYgnwg1Hq3gbgsgEFnE8KKBQIEaQwggjs6lMbyE7vmPUvDn1LJDORCQh3mCGMgURcGQuXZf+0BS2swAspRwEKUXj4wXG5C2kfKcq0rCUUjqDrhkwZIrSOSC4mjmovQazXvdQVFilKq1/+Epz40jKWPpVlKDb0Yk0eoxMqdsgnRUSKTKyIFYZAhSTh84sA+sYwHzrkMHL8GxRVwkfBZOsncFwIVKjkoUKZrntuQZjCDtcwZ+Ewjn8JjMQOMrFEQuQnX+FJSsBIlqoopDJ6IdBBRAaBDRjqlvzDjqHuYpK64MVCCeud6YY5HAYNU2/J6ePRqGRKiVwrX1bUIlEqI8Q0WhI7hdqgXQZQss50TyAR8A0KcvOj/JBnCn8YAQ9AQALxuBMF3GmOXRR2MSsNDZEMImUzBeP/rKNIsSCTidbRvJURuDwABgtomUIRugLwYA0HWxtB2GrQNYmKbTYjEAh5gEQ1630mQLvrJGAOE7eRmtQ5VIndVBLgnH2+hCxWJNzDzjW4ZZnKnVJjQXhkhrVExSdGQF2PiNhTox2N4EdiyE1HX/YWAL3tAAJYHXI0MsgFLchPfmKQvBAgFSfl06V0pOmUxpU4gYHFLmtLKDm7NhvbIEED6NHBD+AjEIq25x/p7FznTNNR8CS0ZCKNSpVSKpA/HYRIEVoSVl1ak79oKEtYMtwsd7WAFUzBNin6wZzitJ7LtahOO+pcRg/CAx5M4WUR+Ed/uPQA0yVFbntzToX6lBio/zL2b4QjiFmPo5HElQ+eilsAeWqkIuEJr00yWA+OelDUH6SPDyiqUxC8xgeK4kZXCprKghLE3TwdIHu3hU5IW2IYVR7uQGYRSPlIEDwoKO9MAplBmZRHPORBIbmcXdF0gRobDUSAf9o9LNAA883wbsttt0MLSgQmEAOq9nxlyEH7/tGFGbiKTcqDApmIN7wzsem+MuDDBVaggBgmRk8pTaaBd5jdgLGtAxqogYbPML9/0NhVNt4Ejg8CX4pqQAEAngqSVLziRPqlKf9IwQdkcAYiCOQMFCRCLhwVZSMQ4VJuKEMLlSIypxS4yCuGgAIUYIEeKJAIW9jCP7ZAwX9gIf+CZfCBB54WAFyFDMx4LlRrxfwPC2igBOpxVaX+kYUu9KAD3ORTLXNFAA/mOby2HGFnmJVaiUpuBgeBCwAj/ehOZxpqI/SMam0SkpC0MY6eNvAeX7pEJ/YTYs9CGqxTDUKgTIdc1dwJvHTItKs4rFp4pHXFOhKuUidtibLGlqyLyMxnWuyHjRH2YtDYRye6eolDjDWWNLKSbLP6XNSiYxulPREwXjtjnoz1P2M9JX9GK9m3BrdAG2lIckfk3MzsCavFoi0+IrFDUMxWcjyCFoWU1JVq9DQrj81PSI6x3b0GOFP8dRnjVMcyAdNeebOI5I7nu8j4jsgW89g0ILbSX4z/ZKW7DMJgZE41ssQpHEbgJmw+PvKK7PZk0+j97/AlJJnJAeYxxbJM3SL71/o6OMi//Sx+rZKRMLWjEVH+85EsuC9LAvrOAnv0iTeEdX0CDJ4FCvWLXWbW1fxWSpbCBjYcYF1XmgpbLFQszpxsk4BDtyqxJxWd6dPgAN84uc11SA5Vh6ySrTOAsgM1kNVFS4YCcCyLHjDbWRJJhfJ4cjwWWUQexu9gzrvGGNLtgxS8JJxMTkocPwAttf71mvlHLBlkULaNpi3aeUtnRK2UYQ6yZ/ymm9gLkz1UM7GMgAN2tFMeRSgWnEAAgMC6ADAADRYglydLHNRM9TKqcRQ17Wxn/2jGCc/QKe4fG3AOcQgT9vI+Z0CDLDLy8UhtVS74aGdVynfrwjZvFmr3oAFPLEACEdBTGgBRIfIarmEbpnU1JJACK1AaKFAz9LRb7Vcc7jcggAdW/bYS1cFgYyUSk9cRdLE4nhEaAmEaMCMzK+AjrSEiFVVRsREEFMVWnpMfpzE1wHEACdMwU/IzC9FSUSUVDyJ2YWdKLFF/ezdTiBMy2eEZ3Tc13KGCuTEFLwhUYYOFzEUfNzgFOSUaucIZCmMYh1GGiVEZCRJ/SlFSbCh2DzIhpfRBI6cQ3vKBI2EVaHE4u1ca4IcaQcIfLOAjJIAE7REfSzAisSEf8kFRtvEaPv/SUX/YVLiCVcTnJwqiOmg4NE3RhiwFdlSRVc3kTwpRcMnEEWixaNvBgnw1TuOxGyKyHlfwU1wTV+ehgEeFNQMYOvzxACwgF6aTOniBVZi4capjJMMHGCgFh//AAAjhVXKELsandiRRGaECTIVSMy5DAlvjB+jBHrZIV/BBV0eVNTr1D4AIGsDxAN91F09hVXazIMMXVQJmhFgVIQLgjPtEeLFWVvuGGZphJXphF7nSJb9zWa/xHgmhiEaVEIRYTu0UHm/RWryERGnYJ6pzJPHHJGEHVbKDj4/mbQAje3gBSN7SPb3zFuIRIh9QA5olOXHCHusBI3WyGv/gI6ehASD/8A88AE68IhC3VwBdQk+GAVXqV1UHAVWguFj2JkldVFP+1jujQQJtxQdyIgPJ1QMygJUCEQcycAViIiOvcRAm0h4YRDURcJb94XsDMSRbl4k6A1XWKI9LuRDFFlAjsxd0MU5SWRt7GTzTJTw9ICaAGSNFVVTNM1FfIxuvwQMkAAMW4jNAIzAQEBipM5fS0YSVRyC68xStJ3t2kVAI5CLxAwVrcl/DIycpIhAogiIfQIPBEzxAVT0I1Rzvd5SbOBVxaJmvJHvlghV9cYe7YiosIFHJUwYpBF8J8VkuKRBZ2SL6pQMjQAIoEENhl151ZiAtpZsTAXTHsTO+lhm1AxdT/9Be76U89AVf94M8QUAnzfMmYgI9FMUbXAYY3lVVkwl62nkRptghVmISaBGQNqWNtiGaFDYDQuAGxMMm8UNfx3M8EUY8LSIDOTIFD3B6cJkR2ZmfF2Igm8cXCaWNybM+xklhQjAm8iMQXTAmB/GgMpBRHnQwevKWGgooRjccBAEyjfYbOiVRbJKiUiA/QtAFQfoPm/BkQpqi9PUBKRBDaFFn+seDM0oqbCBkTlgACoAoVyADXUAE85OiC0EEL2BjFUQ8P/ABGsAlQKl/mBelvqInlkQXracAI1AGXeAGTgZlTnYQefoPV+ZkbjADfKAB/ANAoEJkbDoqdWEhdMEsZdQQKbJiBFmwBYgwZWrGZmqmBGcgA0gAAwqAK59yMofqN2xQS2PmA4ryBQ60BU5mBGq2ZqpaBn6gQU/zc6H6PbaiAAjUBUUgEFMmEINQqSukAbNaFV1Wq7OzqA+gAB3gIjeQA012EGn2D/ejaXXRJUCZK8bqN1wCNehnKxZwPK6CY1sgBHzgQvOJfouWrdo6QtkxQuWTAnKVA3HgrHGSAhjgQcxyPepaNGzgrmm6ramFQStpHujXWnvGBoa6rxTjrnARAeWjWjqVWmmqsHLkGeWjADcREAAh+QQFBwD/ACwTAL8AsgBTAEAI/wAD/APwr6DBgQcTKlzIsKHDhxAjSpxIsaLFggQZCsT4TyCAAB8NguyYkaTJiCELjgQpsOXFlzBjytTYMONGlio/jvzIEyFPlyczCr15sEDDjR2Ttgxg9J9Rpg0F0Ew6s6rViyMXsiSIdGvWjwVKGmTjNMCAAgI9MF3bsQCEARAKPNhA98GDBXYjPNAboe+CCCgWoIiAd8EGAkYLEKCqUqTUx/+kNp58tXLMrAMxUy0JAG3KAgsgPIAQ+sE/0wv+LVhBYoTrJSN6uHat45+OESVGTPm3e4oG3xpYrNBrdwEMvAQeFEDLHKnCAJIXQ++6uCABAQkMLq5uufvBlAhb9v/s6RIpQbQC0cJdHvfuivckSEyZ4vrDvx73Z+uPX5AEEvnxxbcCCv8c8I9oBzqV4HIFSSZAAVItJpWBj13HnVQIYGegdxzO1FRZXRlUwFkKsuceDrHV8E8QMkCRQ4tB5BBEEAX9INsIH+CoX2z3rdibBncppiB0BGyEVpEqWSjAdR022WR6UBVk1HmdDRQWWgX99U8NMpThpRQGvSBFF2CSmRAUZUih5j8quJCDjDqQgFyBARzw4D9MOqnnnpWxodgBi025hBQvELHFP1sYQUQuuRChaC7/LBqpEi/MUAOQEBSYKZ+cdupkewPkNYIbRPxzhqT/ICJEDxhsIOSBG5z/9qGntNYqk2lzifaAAv8IZ9eBDEbkXEJchQfeczk5h1OytjbbqUcLFSsSsyzt5NNKPn1nkFBUEWVkQQMghKyyCjpr7kPk5nQSRz0xFpS4wyqEWFJYBrAUekt9pa518TLUFFICSAXhdOfq+RNB4IV0MLTFYjvkchC7xV4BB2ww114sRBCcBqzFN0Jr/rk2n3wFCUfcAwcoVzEEhynH1IP2UjbZv0U1iGfBM7XbbbYk2QvXBiynbJrFdh2wAF59eTxCDa4h4dsUJUyBYmsaRI2DBvFpoEEEGdulK8txPdVRSwLEPF3ZASBZtoWR1dlghEvafDPOLyGcWWP9AnVQlHet/9ZabCPw0QOLNNIoQxA/yHCfDjogUQISV5fgMX05Ln3jbPS9t4CETEIYWXVpQ2en3HPT3Wm95YpY4kLhPsBabDIo/g8Us89OOxSx/1DDbSMgMUJCP/yAeA/2gXAar04hqZ1Bkpnu/EVshPQhc265vrTiXRR6xvbcn7HJ9gWtWYYLMowApAIkVgcBAZs+7z6fAwygQAcjyPDCF4MgmsWh/2BhkAxiGIAH4hcXg5jmfQh0klHAtgEM7IUEXAqCC9zgAiR0IFZucZVpCrito3TQI8vam7gSSMLKQEsh0kKheEJIkRNyZFv9KiHdYggv8IToYHc71k8SghmvhCRmHcyW3f/sJkMOiYWHMGQMUZJCRM6g8IVERFdCBnCT8virLUX0jrSqlRKcWKuD5EmJGEc4lRKly172QpsLbTitNj6nbG3L4kSqqLAXaiUoLklhQtADgAMAUSRogQDMmjM2ECaGKRFz1friErbEVIdiZXNQZN4WybY1T45zFGO/OqNHqlCRij/clJAQ0x67mPIBKFgBC1gQnBVoDUDCUSUKWICCu9yFAARwVQAgsBY0ovGScTQbngiGSYccESdVygrNzhMXoAENNHMpzCxJUAIc+G5HrkGRNeWzm99gbZXFwUvKQrOBlUHsj/EiZkeKdLaNVIc7WdyIzpASrn+EyyxSolhxTpP/mn9YrDALIEHlkICEy/3uHyjSjW5I8MpXCmcwhbkLaSIGFTiOLSl3wmhC4madhBioOsB0X7tSiMPxLOcsIxoRI93CQFvO8h9ZM59CXfOP2VxNa1rjGmAisIJ/9BRXygkYEH0JnWHGMZJ1io7NBGAnCuFJABlCQBEbxrPMLCUnYemZWZjSmXDJBTCulI8OPlADwQ2uICrKz0FwQIJ/YA1rvwOBXHkwBRJkrC8d2IvFRhmwp1JoMU7tKPMSsKQMFfMl9trh2AIpMYtFIGSzIWsNZvSPw+WgIEHoAX6u8A/fbekfHyBrju5T1h4wjWnmY4GU5qW26xCSqRHa6GFjQkV7/2EJi1iMkkfkkhf6xGZGZfhHGXCH2cv2wEa9Y6jUYoOfyuloCilYwKteNckiSUggeZqtCXcmIkSWhTkEgYtq/sE1+cSuS1K4nXBbxF7asZdw562sDC5Qgw9MIQJ0QQtkBNmgDWnXWWSxElc+aU9/KsC3ny2DG7bXhTOYykxqgsIZJDym8FVWNiRQzgKlsj5cru+/MgyWQASQqQKgYAo1IFWkiMDiSBUEUkQ4gxIMIgUXuKAG93XKItnHPhAflg1kUc8AACC/HGTPxUTYHyIehSgjNKoLbvWABwAAgQOstH0+zvJbPICBCOigDF9A1BZysYUtZOEfZ4ayPcXSlFll+f+/z1zp/H6gJikIwcFEKIMOTMNjsMnlzYAWr1xahQGDsIA/JNDLPzzwzFj9I8CAjvRBCq2ABxRaJjQ8oqQ3jURNh8eYyPzKVjgtQ0/LDNRkVJh5dgKShh2L1J7KtDG1wpVa96xYW7R1qN0F66u4UFvDqiNGWOgQzdxt2JwJkbF7DRNT81osOutiskpCQ5GIJZ0eZLZFZH3rm3RRsV1xdXm4ZepZpeuO5aq2pH/9wb3p5NXr4i7CQPguU3/Lnt7qlt6qDRlt87qN3l61UrR1bHVF8dRs8aoVVaK3h4QUiZOM+MOz+OoQgnCHRNG0Dsn4LahA5UO+jExzzANFyjT8io//KerES1gtiM+7Z090N7G4uxEBBBkqvOyIH9EDIfRw5IQ0Q1Jihp46EQn1OirviGTUTUKbwNuOmHFilJCFJbfssi1rOUAgbVuWBBVEAQVwlQbxUpzRoExiy3mnQiw6cKCwXY4+HLUKF8bEroNQILyMSz23np7lEO2Ue0FlX/oCH+HQckCEKczynnJbKy5RKqGD49sTuLAxyjPuSaGilMC1lsQ4BaUUU8z6yrmXwfN0lYfGaWvokzUBpaCWtpQujyVm25Azb8RHraSE/kvtJ4qtMzcZUYkkFjatV3kDZB+MXQFU1/ngQGrQ711df2PXFdilloXJYCN9/kdkNUhsSnfz/8rfp+4BO2c5TFGkBvmJK66hgKHYpI38D+rN+mcMBn07pVwQAzGYnTpJViQdEmcz2VVEOEFg98RwzTEx5fRPfaMapnRoU3Abt1FQtPEPJVBTIvMxOMUxqzRLZTcaYcNL+vV/3Zc23LUkFQJbAQNP77NFQYQ304J2KGNKBSEacrEAwiEfIwAbsCEbbvUfNTUfu6Fcb2VXqXQyI0hRe8N2RYWCA2dJo6OCu/c5T4VA4XZC+yYibqEALDMXjKYco1ExtoRKbUUfN2U+TqMb3YQEr1QCGpACw9EXhncyGsYgSNVOKrF0d2JRu2cg/hUZDBAZGTJ+prNskzFUH+FVZ/EWjv8oMV5zNK70VhrwOwdliX4wGwyVNaq1gySgShFgEHHxIHeyHVSBNkUSSY/hR1Z4IQcQVXDDcry2hRAXMz9xJSoRKgTiiTiyJbLxi5qlH1LDVg3VfPExBSiQAQ5gfac0AHRxFi7xGH0VN5LhX0iBABcCdz/0f1qBT0OmHt9FGnbRMfRRAzXQAzJwXJrVI6b1WbNBiRrgVgIVWqGlUN+EhIfRX9NIJ8vTIAJxAAkAKIYlVf4GcyPRFOujda7TGkigAz2gA+ZojsNzHzmQOAVxBVfQOxpAUEgAWqG1JfUVOL+4NLrBAysQNlWYJ9znVwURiAVZSCZxW13nFHTxWAPyOh//IDjtxV4GoVlpBZKAA5FoFQQfQJRDGI/KkRqXBHl+VB0u+ZLPESIfMm+c1HcE4DetoQOZZVldUllBgDs08gMa+DHv6BpEeSP2RQIGsDkSYhQq6BSPkSnSQQBPCZVZYUXjAS7lMiIPBDtoIlxgIiM5UAYsYiOotZH18Q+GaVohWVep0WYW0hQwQ2I2B5UOIZNNUSVVQkVXUpXOuAKUo1mHI1x/GVxgmVmalZqxU1mJc14/cAEfYJJzAZduI0iRBCGQZpkVMSUYgSUIMyVmEXY8pQMwkibBJT6miTtgGTtegjteIl8yUF8s8JgQIiFNpZtWERZDRBIyaRet8QNvMpj//0AopgImswMm6UU7BaFmBeECwaUDOIAC+fhUgmRldImd3YEemucuiLQBBFIGM9AFbtAFULZgZHKgDbae5vkm6ZhoGrZ5BgEo+OkkLQExjCGcv1MG2hNjpnIQDmYQZwAm5NMD9yUXRhN6BeKCE6onf2IdF1NZLHYoivIPjeJiNfqhpuIGW8ICdyElWqd1K0orbPBxRDYAGBAbZUAEX3AoW1Aq/2AEiOIoTVYqXSADf4ABEMBBPBak52IgmRIukyUDpOKkg1BmUopmpiIDPmBPHqASm4JlXGoucrEBChABSCADZ5AFUkqm/PMPYoABBMFIcfo8ciEXCoABLIAESVoEkXYCKWWmKDLAAlfmFoNqOokRK6nRZSNQBh/6oaVSA8ohJaFaqaazUqPRQBFQP7YjBWfwAj2gAZVWqAwkXaR6LhDghRYTKv6EAR3wN1wyAhGAAWAXFx5QALhaq3STQU5haRsQiu/RNQ9QT66CrCXkQA1UEAdUEQEBACH5BAUHAP8ALBMAvwCyAFMAQAj/AAH8C/Dvn8CCCBMqXMiwocOHECNKnEixosWLAxcSdBjgIEQAHTWC9DiSIEiDJkNiXMmypcuPBU0y9IjyIE2EGzMqFBgyJ0qDQHEiBFCgIUmgPX/qLErgX9GXUKNKFdmx6s2fJU8O1FqAJEEIBAcUEPtgw4MFDx5EUBuBBQsNblewQMFiRUG1aR8c0AthQQECEP4WCBBAQAEBChEjzkiw8UDFBAX4nErZotaEYQsOcFrw6T8Imp0WgPDg34MVGkhomFKCxBQcGv5pKKFhhAYNSFiToK2hLYu2EVDkfVCA+OjDgQMcIDyQAMGmhxU6d6gYYfWCAggsrsx9Z8aDVbfK/9Ro0LNn0gvakiAxov2IGv969Pj3oeCH+R9Up0ARPMIKEvSN8IGA7o2AwwcfgDAFCHSsUNpjOhWGnXWY/XMAQhd2p6FUAQy2VUKeBZXQBv9N8d4/QfwjQ4orBpHDfPO1hwRtOCAxgg4f1AAfHz3U0J5sa/nV1D+SLbZYZAIcYFh22f0z5IZQVsZGQR4N5mGHWHJWHAkfBCFDGWV00YUUXfwjxRliSmEmFGWo+A8U/7RZUBkzuDCDDDLoMEIEGxS1HAHOIQbBk1EWauhLBBSg6D8DdDCCDP98gYgRkxLxj6X/bPGPEQVxymmce2IwGgEXAkbooaimKtUBBSxg2gofyP8ARRebbHJpLmcE4QMGGwRG3IMEPKjqsMRitME/x6ZVEAYLjabAROCJOJROSn3o0EnYqlTstofyROVHHWWFVElCGTVeTAIdxVlGXXWWkE0iesvtvNcONdK74YmnFU1a5QRvugp5WGGEQgFAlFhmpQXDWWmhhVYBrC6qUE6SDeQYvcRqq+3EIBK1rrvJppUCaqpNoZptqsU2xT9TxKaBXHWRIJdcKCycFgQbRNyTc1hGJuGERFL4M5EdUhs0xhhl5ZNHOTlmJUEFeDBWYIqOhrNparGw3sq1uXzbbSmwkMLI+/3Dn3ALHFuc2h9XvWiIjTUVAM8VbyTAdo8p6eTeeCP/XZFj5zZU1GYBbGYlzgv8toKJ/yzxjx/wyVeDfPG9+IOPI/zzY3s46BZb5gOurJpr/zgAwwIQ3E20knYbydCQiGXod6EdFWVlREQVjexpONSQw5tzqhhEGS4G8YPxP/SQ/A+QyjCf85fDVxAMfRakHXaFfTX79ix1KPFTAxT+wGpfzvACEZj+80JCZ1y6fhcvkPmPCz5qQFzOEEM8KGjc969hYJtBVgRq4IYkICILk9qCpQYRhUFgigUe2Exg+Ncq/1nwf+4qzdUiMAL5yEAKkPrHs9x1tQ1MKSbk4chNNHbBFk5FXlcRib429pCUAIUmG7HKZFw4u2jFUFz4qgm6/z6Ur28NxV9Ni6FQdsjDDe2QifeKl0GuUsRp2ZBc05KWU0bSlaVNS105lFffmviSkZhxY0wsmErWmMUbIsQzAJuJG9OVE9vZ0W2cQUyIhFIxo5GxXkIUT70ugxl+BUV3UxLIlTz0Ns6UZTh5WdgK/COctZRlAdCJCeCIdBifZI85j0njH2uiQzqCJ4aFC4nHbOcULCmKanlpywpgIJfVTMFEt7xlav5hl9/4Mi9o2ctfBnW9I2WkOojJYUyuUyR3NWmUR/RjvwJou6KB5ikFSBhdXFMgE5XAQEgoyGrGObr19HKSK0BLw16Zu8HMDUuSGdrRniI3uSUTMfZMzCjpqP8TmuzxKVA7Dmj6dCzTYC1mt9FcQXKTmtu4BTgRiCgLzmLJtFGNahZrzO3WdU+BDSl7RAPaMq93KhcGDicnAdxgxIKuokitOAXAwANQ8B9bloBxmWMZDnazHhLsJwXBQcs/XFW6FdAFODWLwAJOt4CHZbSjCUnm0Ua6GL39USbyEmRDmDMY/n3GamlZj4BqkKPJySdzOlLoj2ZDAhwISHPt0cE/aqADHZFVQPmZglxKE527NYaZU90h7KAJFZmYJzAGTUFtCjK5EQQBRm86nnzmEx8kIOFrDTVR5gg0oPqMQK8TbUqisvOzewYtOkqy6t4Iu5KiHcRwUBtIUbC0mQH/bGAB/xFQD/jgpTeVAQoteuxj49PBHvXgPvBxXlrr84F0biBRyxkjZK63HNmxNiqGawhscXLNu6yguCkqgxTUZCaElCEH581B8Vb0Oxn8LiF8uMA/AEQcQBEJNEtaznXnVYApdfUrijLL6OrzD7f+w3wvOF+ZxtsmMElBCGM6wwzm5AKEpMCi61KOhUi1Xx7eTlEr4MEFyuAGIniqILkwsaXQd6mCrE8IUiiDDOxXEFZZt8Oj3COjGKWBHnzwBVkoCBGyoKlPbYFTbviHGJ4lQcD8BcdQ/oxTNrCBAUTgg2dCXy4y1eI2YQADASwIaDgc5Q7vhQCuSlsENFADWUEB/wrtO8MPWKAAnOHsKdUrM46pzCuZ3iUCLAMQQhDbK1bq+dAGfQAGRtgSH5KHaUpENGthiDuZaAyVhJT09p74kMvwJNM7YSMKjxhpTUPJ0RyD9HcsnS2spJBK2mq1qbtD6ZcUcTJZtdYMQe2dUs+aI69OdWM+fcWNoVKa/tKiHJXo61mjupCkNFhPlHYUKI762jgcpBGHIrBfv6ufMLmhDhcCrwqB2toZNmK7DJnFSP/V1KKUohu/3cYhRnPY9H6jSWYbxx8qe2A6ZkjFxnhVZocLJk+MoyiVqRmrHJI5JklX1Q6wl70Ec4KJWpR0Q8kxaJox3yDvOKmh3SzCfDom6//udkAhMADSkOYsNVtqzFGHSScJ7ImEiSdjpEpwMpZyq9GMdkiomeHcSZvft3O5q2IJHLa05ahpUVs2qTaanQP0aFKdKkOis89SVhGlP0e57sJ3Q7BwBj2xrItbUuOa26CmLrEBJiRJMypFKWa216aQQwIVHXkSdjxer1JnoLYRgfCvVxuQ6HpuY7LbtKdl45wCC/6htbjMhQXpWadfqtYzkPqR4fCcznR63sR9OSSAICG82MWczbP8p62cs42BDMT4hDYUszSby2kekHG3MZIwPFvmukIEGZxsZ2779Te+29W0ovAvLTTVrHtwk5vLTqH6nkuZYif5GxhEwGbZfBr/xBpDmE/uEG9Fyp7cjvYk2JXUgg53F0LCN9uNMmqCacPtQ0kgNpLddLO4QQKXBTYP9UsM4zB35nuA4xzY9EYNsRgNqB1NoSQSiB3v5zdehC4n9VoEITVigVi2IzVmoX8kYxvVp2Qv0xu+9HQocDancxbHUXUhYjsMiBN4F1hNklpNIoFJElVaZ0H3gm/tdkNjUYRF+FWjUWWtJxspUxCsYSKLFxvr8Q8jwx9LlzAL0IIFYRaAYSEQ4xcHACgdUlKF4SdO0oM6OCQXkgAFwQAFdy7q4moptS5igTBq8XpwRWAKAYXrETZHpVQowEu31FOEaE4rMEubxxnIl0zOUSo7/8gksjMkCXCB3AMwQihFcbRtjPI0d5GFi9MePsIjBKInx0VW0nMb/Pd6ujUgPfAeY+UjCcIDIJBOyxEZzfFOF5JaFoIQTdFHU0WJ/ZNsQQEwMdQVjIRyr3JL74EjlIU5PVIQP1AQragnCBFXsZdTvZM5IGBODmMcTTJmz7GDGCJS7MeG3iZ/T0N/+5OFLIMQlBMfu4Uix5MDPxCNNnKPXkMynfMBK8M4U4AgeoUWvZgQSpI6FAgh1jWBpHdotuMx6sYuCPEgKMAexbUiKAJcwDVcPaAnAwgXTdgeA8IHciUjbvEAxHQ9fIMcsSN/5+gQxjh8kxFmTrEZrsceOZIicf/wJrLiIvDYWD+CA3OFH0HwATyiULfkIDVHJL14GM4xgXMjAIOCTws5a/Z3df/UGS8HA5MXG3HCJmyiIhjpPMpzOcbVA8aDJ9DIWK8RiM91bfpFZgHXkuRhlVzlSoUjFK3yAACCJ5CSA3DiW8DVJjmAJymSInAymG7yD8mTViAQGnujHJKhHYWROnJ5EYoEOGBRTeL3DxEwBTyCXjFGJuRVEOMVJwjBk//QXjImAzswV5pDAspyi0kCmShZmbZ2TQGQmQF1GmyGJ+0VQkmGJl0AY6aJXr8zXvJTJ1LwIiOQAsYxgdbjJGFom/+jmTaxGQqgAIDmAmWQYP+AJuA5nF3/0D7f+Q9C4AZCYCYuAELNiSxfZSHIR52GYmiqZxqx4gZucD4tZilKoBBg0J8F0T5lQD8fQGeDwnuDEpfyWShVxxkd8AHdiQgKtAVbkEAotin/kGIrpj4yMAKKZjuBYWMLSizHkRAKwJXi1T5E0J9GQAQKlKFCRppBAEEBNEEHAAEnNKL89QDayQJTMB9F8AWdUhBbQGRElhAeACKdcWM6Oi8J8wCZo59a9g9HGmS6EkH3pyVM2qTbEiyjkRYYoAHulWUwSgS5ggQRYFsgYpIFxaXcoheIN2UPwALKI17j6aKpSWfIAhiIFxhE5abz8it2JmA3kjxxIF4usCd92qeAL4o0G8Asg2oaEbUQHfAsBRVTxZGjjRqooBF1u4MQ/jF5CSEsm+o/zDJCitamFhEQACH5BAUHAP8ALAkAvgC8AFQAQAj/AP/9AyCwoMGDCBMqXMiwocOHECNKnEgxIsGCBAMI1IhRYcaBAQBoFAnyX0iBIgEQFMmxJcmNLyvKnEmz5syWME1u3HkxZACfLjmm1MgRY9GiHVMWEFig5VKEGpcWINiU4AAIAwpA0Fqgq9aBBgMI+Dd2rM2zaNNCNclSZ8KYAgdYRbkzgNQCbNhs2PBgwYMHKCJEYDF4heDDEf49SKwY8N+/CyBsJfCvawACP4ma/Em2oACxnUEnNKu2tGmDGVOCVZ2xqd1/HrhC4LsBwwbFKFaQ0EBiSokpGoCT+MeiOOEIix90+Lv3AdcCBDZI1cwZKdKDrwVSvixWNNnuJs2K/6V8ujzN6zyNqq484AFfwCt0T8Exor7AEQL/CBw+Yr5AFimwgAIKLOj2DwkjgDACfQWt8I+D/8CwAAwFidXUZ5QJoCFZBQhwwGVjkUdWhgeMaN6JJ/rkFlP/QCCQAgKh8I8G/+gwAh9B9CBQHP8E8YOONfwzgg4CIfHPFEiMYOR9f3wwxZMrsPCXV98JNJZYEJA2VomdHUAaimCGWdmYLN71WnsPrDBFDR/0EGQOQfxThpx0zilnGVBAIQMUQeQgZw5zlpGDC//IIFCQGkRwGwEEeDiioyKKKemkaTU1wD8DYDCCDFK8QMQL/2SRxRZFGLTFP0YIRIQSRNCJ3FYQHP8gGaW01nqiXhBQtgEECgyQQpBEnNEqEadKEQQGXf1zgHMLFHDAU7ZGK+1Ms/2jwFYtNhZBlCh0YC2mGDyE00EX7aTTSzGNpO5HbIGl3rTwSjoSanSRWy9CK9F10Usn9VThddcNxVC5ROUblrvxJuzQSUeluxZdJyFcrr7oGTSdV7JJp7Fzjz0GwQOKZSsrdJU1BQF42Jm705cKU6oivqj1C5K/K3HlVwQDChjlCrwFd6BvAgE3RYFEIwfDY7tKx9VPHbpWXVmgbViWQt2x/A9mV7dMK0dSVUYSSQzLNUAAWTUGMgsF7eagBjwXh1xiyHUcgV8L/CMjCn2tAJiAkPX/HdkGzy4VtZWgifVZZ0sJkGXTyjau9WkAs1WxXQAsNfZWkBn0QX0j5PjBPzoWZKONSWqAwxRHTrGgBvgJKeQHOPC2wtEtEvDhTx9eqbiHn5XIu0EbOs7l47XuG1VndVX22lIfR9DbCG7GCQWecTL0A+j49aCjjz8KtPnnSrvVaJZZBk/8+TSxkWxTd/3DVwQj1CBDGW542sUZ/+Cv/xmgClHQGV34RwANQoIIdC1XXnoW+hYYJjaQKTbSiYAGZNCEThGBCEYY1j+2MCoiGIsFHrgWV64GLQaakFILqJu1JKijHhjKUB1QwK684hwXdaQj47qXvYoClxP6sDTzuiG7/9RVknOhJ2Io8YlKIsbDdf3wiRVS2Q3fshCGTWw9KmEJ2AQmuSJOMSGagSKYrugWnPArPT85I3YE9hGDueReBGMRzLwIRjnSa2JiTMu+wtJDoERuJTnESUimginr2OsplStZyQCQlYzNZivN2gq0oDU1s1gyjBXLI0MCCRMlasZ4q0GivsaUSIS0jwBa8ctj6Ca3xYRMICDriywf8KwSNS2ThOsM1KKoSYlUp4d4nFko41gySC5mAbkhUG5IwAIS7IZGw6FRcDRQnMDAIAK0cxbGMOO06pikUboMp0MsaaVI9fItQlHXpRhJMYtBYAHv+YtgCMOztc2IBEiYj3CMM/+Y5HTMPc7RCirtQpTMFFSKJmmK8shEHktmqEMCENx2sHbOKfJQYIQcZHbGRsirFECe2ExMPYnDzCgV5x+DeRtAmVMAjXkFlaYsmVfs0hTyWEg7FYLa4T5zpYKUaHgV3aRR6jKUomqkPRj4S3yaOc0jFUQDUIVqCnQz1RTkbAW5kQ8JeHA6EpgUb317QK6wFZ6C2FQjZflQoz6k1vFsaUtBfdiKAibMMQXARe9Mk25Y9482bQ56+AFsDVp4IIGkwG5oQ5DqauS6EWwOBKiLjx3tstMNBeBDY+Kpla72VmWZM64yGSRYuvLTvqDAAQdSkpAGG7oa5Eh7P1KtQGgEtBH/9OZ0n5tRcWCQ1QUcAKaavWxP0Rq8qXmpM58FbWjZdxD2HaUyECAQggb7Ayj8YE8yiFN2e/CD7oXOD/jZnPf40IMPBOlBWC2IswyXwJuSRQDgtBIDlGuaqRxPJ4JzrmWw8oBmDqkHfIACoKZXBikIpAvY1RNCepADGfhJUIWSgaFsW7eWEqB8vfuMDYFKX0o5MKEy00redIOg+PFBfnTqwgvO4Ab/SQEKL86BFKRQ4C4IwX8z+IcUXGAoJBSQhIHD2lhK2OEFamYpGxhABKbgwjm9wA35AxWrLphBVf1jVf+4sUAuUIMU7OVZsTqZDYucxwPKRSAYKLELyvCCF9wP/1Sp2gIGN5iqLpTBDw9AFqwufGEyF9lFTyHBB+ZnYFQZ4VQbvLIMxCAQspLQz0UuQLMeQACxuk8DRPpHnq6MPx+4J1nK4hiRIV3R2XhgV9dKGgact9oaaMBbMILRpW5DalIjy32KQRaMboJQhJWx1sAOYr2G6K5glsSodQX2CcmYQ197xImdXE+y02VsZcur19V29tc8OTNPsibZ6aGitYHo6z2akYhG3DbBJsZELv76XSmz17hlwmxzobvZvJwruqxYITVChd11TBl15k01bC+kJ/4OY8zqxUM+dnSQVmHYUzQzNkVOHL8rIjgZnV1sPr4sit4+dg7ZXbmISzsh9v8tYb+mchcqVQhauKy1sRuWxqAUtYhVkVjEbo4aInNbvSG5VCO1sqsaPmfMHVIIOf1sxk4CRYuiTGJCjQdIg2HkKeu02H2ZIklYYY45fxmrs3IFchA3JOag/TjN7UUSQl5RZmMreb9HbRJYtTSe/6zNP/sikLrxfUzQEdzZPTNwpgsMiflyuzD32MZoK68pJWKDi8IqoGv+hXYYCFeEChJLvdVtA/DUpk6yc7DnukWzhLMamSPH724nsuRku+vV8vIXvM2tOFGiZklPijaDoOBoYC2ZdAjaTYP+q5JVewiGVC9GFXH74wWJOyHtW3Hmtaj218TqtjSAArb1jDezdSb/jQoUUlVijKbEZ5pBf4J8nuLyQpip5GbPeURgKtHXZWPeO98XGMN4Ffw+Bn67MRzGISVS8hdJ5R7vdH6ukXNPU1b5llMr0yHg4X69FldUJzOAdCnP4R60ATIGQSNPhSAlsBsFiE3+hBysBDgz5BpbJEi/Jh49dTi6hBRfAh4Kp0nqFBcDQUgl4RplYjkfUxDbgjYCOBwmdYLHgRwdUBt7wRdc0Wc25Fx2hF/c4SKkETVo9RQn0zglQhki4h159G0IBxYa9XjsEXuVExuKJBCCcSDNtE/URBhSshwJuEqypEILCGiT90iSVjvroxOfsYVDZhAJJBAlglaiwXwm9HNJ/5QvMQFKmaFIBDEbkBEfPgNNM1IQaIMYOIMzhmE3doNVXuVVS5UbfkNLJZR0SXc4iSMWQGWD5cSI58RGMjN6m8EZl1IZl9gzCwI0BYE6wBFVu0Ecd7Mf8sEDPDAFztSMaFMgKBUyXbN0aIWIyDN6cKUsITI1yoVH+NYwyZIVtRcfvbFYBQFYgbVa+IEDB6IBU7UfaIM67DiP/9BVzhQfDhAZK8JTloRZbuE7h2hW2lhkAOdrYcRybPh1C7AtrsMm5FVerQM9r9M6hgVVu1EC+ZQkQrIgOoADw9Eb8eEX2MIZj2KNl2WNa+Uo2ghf10hmVadDBsFRlcOFkgYfw3EfQv9SPa5lEG7SA/gBVajTOvg0lOfoVXGzACyQQtBBFGwFNSXiImBIFiUyXwIwXwKRAAT3ED5ojbiGUs5Uj/VxXtYFJKHDOfWBJMJoWxT5DzzQjKbIApJUHZjhj7aULV3COwjwD3lJi1mZX0wBVLuIKZjCGDqwPQKRI6CTA9oDOgdhH0FZXm3iWPhhlNIhIhiyWRGlIVjYKORBlVnJEAqlX1EUmsfjIroRP0GAI36iJ31iENXzD4MVWIAFYNz1DycmJMz4F9qROF1ijQr0W3z5mUCHciDGUTR1fc7DOtpjKBBmEAp2mNrDXZlWKIWiXdzlk7n5ALu4S7yTJcI5E6OWfur/JVNxGJZ8oGnzMz0FAQVdAAUCIWASpier6WAC0Zz/wGUzsiiCxx2+Yz7fWRFE4YD0MnnxoTproj180GDqWWgBRGN0ImDuKRAzVhAGNic6UgJ91xVz6SGMwmH/WV9UMRXYAoLNpBvm9QMFZj9ngD9Z1gU0NmMDZGM2pmN+UiM/9hR1yVkfOikOhFd2uRhrMj9u8CmtAir/oAQsahBIeqRCcAYT+gO55Rw41aHJtaNiEqAD0R6ClqBzokGocmVV9qWctqQ4GS51szu/ZaXwIntYIY4IwgdloGJEgAhG8AWchkGnkkEZtCpdoANocxtaQYMfpqbxMgBZAWjWogAdsCkuxyAF9QOmdBYqqEIEZcAHvVcZXKJAhPo4ktcVNrQpZTADnnJlp7IFg8BBW9AFQXCp7vMs+rip58MGXGKJa8IHhTZnX9oFNdABsRGFV0N2sEo8svGHtaEBPSAFK0oEuZBBOcAEjNEsYMZnwUo8s3EAzbIBlVYbJPADDaZj//ACMmACU0JLXjit6FN0zEMbM0Ik8pMDriYQtIZXI2SuWsMGovYXu6YYzfQfyFEbsvEPg0qvxAMyNnQbtwEy2QdLoCawUFQtfEETAQEAIfkEBQcA/wAsRwDFAH4ATQBACP8A/wkc+C8AgAAEEypcyLChw4cQI0qc2NCgwX8FBiIc8O/ggAIfIQyAkBECRoUZMSJMKICiy5cwFQIYyJHkgg0Pcm5YgSICCxQoeLJYsWLoPxYDI+T8B+FBAZIkCwSQKnVqgKsECmptibBrzK8ULc6UqOABzn8RlOaMsMKnTxQsYOR8ENXD1INXIQQ4AIHAVasatU4VmPVfy5QJAwjIOFgAwqyHHbcsKFmxYokHMwvUTDCzxY6gAaRMOTdCUBI4RnzA8WHElBEkRmj4h2QgiYFt00aw/fo1iSn/NBRNuxTChgJPVyr261jgSoIHFE4mPB3sy4PQJy8Q+ADpbx3/evT/kCH+R5AeBNELHDECCft/I/59EIgDONEV/1A82M40Y4HJXAkkwAHPGXbAgAIlEJ11MFFVoFQCSUUSUzn99kENfEDBRxBByJCDDGVIUUaII+bwDxQyQDGQiTmU0WIZKhJUwz9T6HccAf/tNRlCCzLo448oJcRCbCP0UEYXZ7ghEBFG/EPEP2fkwiQRZwz0QhdSyDACCxv0BcGAewEp5pgRETAhdxGMUMYXAkX5Ty5O/vAPBkyZGSGOZOap50BdbuBBn079s8BuAs1G558eCLSBRBeN1dmekEb60FVUTYgcBCTN1dRcnC612wMC8fVUAXwV5JVzqEZUnaQSFeDRRf0Z/4cBTjgNukIKJOSKa3ADsTCUWw+o5VRUVl1FmVRZnfrcjs2lKuBCl7HqqGczDWCQqx0xJto/NQ2Q0wJDrUDCkBrc5qt+nf4DKqj8LbCfQDD8swIMPbn7gH5o5dQUVP8UJt1/0Paro0bN9gjkczNVm+1YJi06KAoCTdEae+z1cOF66M2GxBRIkDBbcGL8Vu4U5eba1lzIHWDmX4EVqNGBhg3U0oHRIciqVhDK7F9CfQW7ggYaFNlDhin+E8SHQQhkokByDhQffOjVQJ6cP8zoGsQa+atYzQWpPCABq94MVgAjTfUUdxuwNYXULnTxwhlVVokk3GcIUffbcAsERRcryv9Qw3wEmUkAAQccgJjYiCfEBhpQIRfhA/jJhkQNUrxgBBFbEAHnFlks2QUSdPbrpZ2Jl/6QUwuQljpaGtTgQg5JV5mDBqF3aabhBpuu++kRkond7sDniZCjBSE202CUBixT8LpvZDZyHw0gvUjGUa+AB2evW72//UHIMoDMi+nqU6kfV8BcC9irH8S7EcodqAOJ6mVVf9V/qkMBhq+RZxwl2rNZwQJXT3JFghSIy2P4GQoLiBMsAA5rVMXKmVYYIpVVWUZmkxJA2HwkFotYa0ImMY670NK+BY4rV0MhwVvaIpecIOeFAdALXijVFWVNkGCUueHhIAQwHVamOc2CCfH/EsIZ4n0Ee9Xbj2l4ksDhoAwkGLjUjQqAI8epa19MwdSocDcqK/JwK85JyWK4sqCWmCSHCNkgQ4a4PM+sZCY5g0D6ghUBAsLmA1PAwbgEgpTg+Ao/7ILBoCCXwlzBZgq5kldRuDPCRZ0kZ5IpTFeqAxk0Uod7iTneZjrIxoE4iiMnGcl+FkCUXL2GPsBZzx8SIhug8epnGmAB0MqlAZKRYDgr0NcL6eesG34JIWJ81swCALaYJOwz+1PISqxVE+Q84ABnOWAti/Q0goBnBDpoD8doQ7Jtxic+wPnNT0DVFJUtyHuOIVDMMAg+AiSgmAJhgKQAg504RuiMGQEVx9AT/4QZxUEG4YEd09LztPekhmIEmQIiTyag/0znVJMxGAIEgMnmqURC/zjAfoYCNCT04Ggg+kfRQvSPMpQUReX5R9XQw08TAVSkPaganxCTRuU0J3f6C2PyAIMR+JFgPuxpTQ9mtDSCSAFLApGCUpcqECGYVEQu+gcfaKSBmwgMbDQjTE4ZhJiUbCBoFyiDktzgtiot6R9KUIJAwAClJ1FpIGWQwQ9ggxQqkspwW4WUq47IlAEoQAEdaN0MZvCCF/zjBW+dUpO24KQXlCEIU2ABqVKC07yyiiPRMc4DMEACGbyATf9Y7D8YS4Qy1IYwD7DT4SzLKjZswExnoxVBkIS5E/8tgQUKeAoBFtCz1bJWUh4I1JkEooA0FakGcSXBrBTArXsWgA2/NZ1ThDsQDMCPUI50Cayiy92K/I4gw9uMeLvLvO8mBjQtUx55IQXHG4p3eOMDyS4x8h+SuEww6/3RQXYWIdGQ7YXqUldJQnK+6vFHq6v1yn3z2xD/IMd2x3lghP9xlku5S6MPkIuA8XqSCV4liAx2yLZ2eZPU4qRTKF7Ku9yHYOTYz1j3c0gauWuVqBQgfRs4sX5+8pOe6GZdBFlXlxxMvxfXL4OsBWbvpLiBQQ0SKG0p5ZCO8rP3rWtWf7JxBLvil14ShCs/jFYOlbngMXmFKv1xoLuWiIJx8eT/Y7cUTvvUYt1ZRcW+9vWecs5rUzE/tMFi7pcaY3Lm503oxKAyjbyCIhwSnOaWBjQgW1DmFBdby8V6Vo6xvuznGU+KIABbTqAJrRLPzFddSxEIodrXk6LARTfjpEsBsMfMGILEbDWEsXuf1bt14mzPkskImFHVZZaEZdPnTckZj+in7G6ULWz5ib30FT3ofWSXi+JhVwHsuF3y19c3bElzLBMgYV+GR6OuCLT2jKq7gLK57qKXApuIFH3l2CyLImeo5Pit/fjbXbyli6AyCl6BfWmClVEmggAENqxSdNCBUaZglHPMj3DrKU2+Vyx/w3E+KrCEKIgX/LYTAXCRMij3/xFXynucn3eJyr2hBrHNqkMgf0HcOeYteGeUPJgXempIv8nja0agx0Ldxj6z+Ula/kEvedEIBDxYDQ/qc8tx8SdeqbOvdC5z8GU9pl8Ehyd1GAKr+y74fhmZCQAV+RvVEGRjwflDKxU6m6SjRV5A76YtEThOgHcxhpJ0jNidkywEYZXgM0u8dRz1ma5YCyPeEtS9Inab9RRUqvCBD3u2eRuPVZ6WUygB0HzFqUvBsDA5ErufM0pRrVLSZtodLwWdw5FRyZE7pQz6P7I5VIH0AJtICBrcg+MxoHGMBCWw5UIXKBfkDK4vMlv41nTUeoJb30ADujlXO7ISZZupxCf/B/+RwjOQ8zStBtkMjvFlo82BfOA2ekSKUgCustGAHYcdLkyPJlPJPVmFI4MBagFIYTiRFiTgHughA0HwTz0ABT8QNeiRTRSDUNWER9V0SwxEX8kSP4tRJ4EjINGRAKwCTAPYYdnySE0hS0HzUUZTNAnBgumReTK4HjUwI3/jGiSwHY7UgdnXI9CXEO4kNhGEMygxIRpFLis4HjnQIicCI1DwWDCigEYjHjMiEDWYNDKQhUEgJ1XIAvyRFQ4FNl8SHclSbKaDFxgxGYyBGCShUQsQFAqlAx/1A0vzhCryhCf1WFJ4HhryDx9iUlBQVEkDHgEWPx/4JcyRU1JBPHlWIB7/IC6qwQcydR4ekjQDgVQmpTSZWFItkgNScCImsoW/ly/8UTNhImiVtVUFIhrtBT8CgR+QiCEtQlZX8g9YIgT/gItC8Iln8IkEsQmfuITwgQMDBypmKGghlhAlcX8EFyyxEVZiZVho5SQEoQRUQiVq1SZm9YkuMCMsAEqjg4rJKGMO0jsd8A8zAiImJY1n8FbU6CRRAjdKADdKJVfvJ3ACUzjjCBMWJxADsAGxMR5B0I5EwCRnJRCMBSdEoFYvQB4sIGtnVGb7+BDMBD3WowAsIDUj4gJScAaIlTmZ0yRfkDkNqQEw0ExnlIoTCREg8Q/+E2D3Jks/4AaIdTmZkwVbnTAImWNaGEBgILSSPsIGZ5M6D1AWGuBZTqI5T/IPnVMGPkAnozIQZwSUP0IqPQU5JRU3miMlhcJc1UMQU0mVMfEU7HJj+RQBONAiUrAJVVJaSPApjwNbriiWX9ElqzMQoGICBDEiOlBvZ4NadMlVD+At57MuAFQumVdNFHYSYRmY1lFgXbKYkikvEWBd15NdjkkmEKAATcEdkQcTAQEAIfkEBQcA/wAsCQC+ALwAVABACP8A//0LILCgwYMIEypcyLChw4cQI0qcSDEiwYIEAQjUiFFhxoEcQYIMEJIkwYscU24kKZKlyYowY8qcKVHlPwAfb24cuNLmTZIaTYbkSdQnwQH/BhQo8G8phKYQmDJ9ihTphg3/HizY8KDAgqz/okYNQLYsUYMC/qWlybatW4UAcMbVaZAjy6AFNCKFgPRB1gURAqOIsCJFYRIaSKDQEHjFg8cFlCotS9nsxZM8L6Zd23GggACfP188a7AA57eoUwu8jLOn0M4DAjANwPep338RUPxbwYI3jAd8IweYzBRAAQgXnxKAsGGB8wWPgYclUIDAvwPXISxnipG7d4HcrQf/IEAw9D8Ca60LEIBdtXuJdx2OllrwcVbCuneTADGFxD8SOPwzxQhTCDgCCSsQFgELAvXG4D8s9KZBgglCdtxxy41HkGnnCWAafRt6GNZB7KVlXQIEICAAAu+1mFoBG65W0HFQYfjYgjiMcEUP/wQhUA85yABkjzz+wyMSGiBZAoBIFDTCCB9E+WR/LETQAVYHgVYeaKelhR17LoYp5mpPyWZmU7Ld1JduHxD45Ac91JBDGVJ0IcU/Qtz5jxR38sknnXzuCcWcUPwjgwz/fEDlPwscQJ1Ap1k35qSUoobZUwUosEEEGviggQ4ySEGEQUZsQUQuoxpBhKpElFGDBjCA/xdAe5XWaqtqGEZF6wMR1CDFJl1sQsQm/0ABBRJXCrQcVtzd6uyzMrHRFQYFdCWdX73pdltEPnW2k04sibQSQ62FKxe06FIalEGXIdRuQu2+W1BrZ2k0V0hDnQXUd0tJxR1HzaYrcEVB4fttvjqtO69QQknlwVJYaSVxBH7lVuWCGOMmEAYbYCrWhZWRhRBnpzEUGmgDQysXSpiNdBBSYXHFlQL/yMzVY5tSzGt0ksGIk8iUZYZZmvSBxy5RlwHdULxpcShpym/ZW1d8CM+Y1IwFcIUCgiR0PcI/OPiXWAS48YZCb4TtRnaVK7TNIG8C/mf2bzhHBeOZ5cG4VppNKf973t/WHZD33wxALSa9ozW1lGyTFcRVzQI9gELb/rVZA5x8/PP1CBq4eSASTz6JgwYDdr0CCnRr9Q8MjsHgnKMicngAexAI8NQB7a2VFov/sFg474bfmjia9NUOwXNtj6CDDiMsMYKP/5RREBTSCySDjzz+8E8NPcjwg5BBQm9okf/p9pVpkn45u1pq0Rr8+xSxMVxTOCnVIA41ICpDDl248cL/ZyCCEkZFhDOAQSCj2oSw/nGGM3RBCDNwAfemMIUEFQA76EEP/DYoJqbY7oLV6kpWNqABGczgH0r4x6kIKJAcOA48zOGgDClVrWrFsFka+AEfrgAFPsnABw9QQFf/nhKWgCUuJ0MZXkdKUrUZOrEtCpMRT1TiEiraq4ouy1LBvkWXJ3qxLlz0lrs80hp6rWZlReniuX6yxXAlZF0wkuIX33NEuljxYFOcV09S8hJ95RFcANuQvxTXr6VIxjhJ2cuIrlPEugRsjnSUIxvduJOC3aVlekQIjB5mNwg8Bjoyi05WouMX+zzuK8e7EIzuFjS0wCstKIOkTOSyxp8c5IpsRIhc8iKbqHCsOVoBjOQIQ4L+kCACJKhSrB6wgQEoYCnPPI6ZQjYySMVEibKsiRoZlq+XVKVv1QJMYAJzn8BcjGLohEwzhWOSoIksjquZjSuzhDTRYJOeZylZNuEF/64zsoZxzapKZCITFeDcjFECIcxjnhmX2JAEnrQRZIz6tZztROVR+lqfWp7yGaM15TPk6dB4CkKy89wTkpjhIxiPZi+mSIaZkpsc1/4DIehg4AEDuApTuEJE6HwFOqhr2+lWwDqiouArKCjlV9h1EnmRFDPwxI77/jbVfZ5Rl/y8Gn2aAxje+IemUepaMbtWoNKhLUECgUEEYMAgrq0AQQoCZdbGoh2ookwqn5Gdl0qEHtPMLoOQ0qBVR6MSm7TsInlZpQfC4pzmAHMF/ylQoiZbkA/8QwMaEANmKQi2y7ppCiCQG1G7ciH18CQ8HvLQpcLyGVrpDkUCYRGLEmBVtv+cqSBlqtFxbsYCEiBBBwUJgvbi9CMehW4ESECSBkb3H8yuQAMCGqvpoCMQZj3VdmrRnTVr6yKIrhKc2jnejVgwBST4oQdX6NE/ggSF60EhCO01Ug2c1CSB6IB7I+BD/gz1jx9MMAWMIoBpUbYZzyQEeNx9C2JHujAiXmcBkxtQm4jbgyAcSiB3opP0yhA+/enPhRzeH3978IMeREljfRsplzRU1QTbig0FiY2M41ktrSVKBmWYgRBeQIQXNFAgDQxyA4XAQCEQ+QxQCJaGZcCHHkyBByRwXXWqw1cXP3GVaRpAVZyJgQ6MQAYukIIbuvAPHgNZhQEkAhhGhcIzvID/TzOQAYFgsJTVtNjKXoTxbPzFHA8IMQVfLoOZV2UEFZbqH6rqQg1YQK0ZHQDGeI50eDC1AT+X8AsvYKAK/7GFM1xBAwqgmUDEgqVI49kvX9nAAVRdswf4oAdSMBabPd0BjsWwkY80NXf73DEFPIU5vNLc9mQwXww05Ta31rWyBeLrjtXspjPpliSlvWxdRxFpdsS2u7ZY7cGyNIwnxYgZF4bGSQ5Fpd1+FrVPOryXrMyS7yY3JbvozyamG4qkadcdzTWSNuJSj0CZmsGyGkaP3hsmdbQJt6mdbXJfld4O1+LR+MYd2dT54AQrOGnwSUt+a1yNtkzpQN6JppIobjh7/07sxQtZtGaNe9l13Li2e3JLdr3bjVJ7yUcWHBktR+ZhiovKAOymFObIbAHMOcADJDU0SYox3dgcuNTMrXOpoXF4relXxzbglKtsBaYHJSUplX4e0u6ZmvhsN0nxTMU9elzefxQ3Nx8adK5fhZk+TeqNcEO2gnDMaDUsZERbWc3tarfAHY301CNOz5zUm2FWK4CxJYabwQzGnAu6fCll5svFDXSaZkmIPq2JeCWOvrbnoqUZMSmjlb3EKUoJIXUtb07+LCiZfI8O7FXZuMpkRo7joQ+HEC96jLvmimZEHE4KOeoLaiU3wW7MbtyGsZ0BZ+hYNgkrlTZz9jW+o5c5/f9Trfm0BOdLYSaPEUGe8vUbWf/5g9mZzq4PMp9RM5ZNPW3TsrSZdpEMm81iIn5jfq+RSS6jftjxdULkawMAHF8nMxEAGKnDgHfzM+UCTqOWGZjSL+dBHyLSEQMGUXJUUmgRIwnmRqOhNBsyAC0VGwQ1IqrzD2czg6PEdcZhgbzENxF1IRDgSY+hHVO2FIEzHuRhHRo0GqIBS+zSUSBFEE+jJYy0TyXRdBvSMMuHSErhAVwBVL3xVjTFAsBBLbGHfUTUHMxRUJ60ID4lMdARHW3oU5hiYLF0NJ5BYN63GdrlbSO3h783d2VUZw0YHZMDAmKVGBrAIOPEK2SziOQUORD/liCTQznT5zYIdVTn43lAIxUqVoQdwj54qE95iFL8dBIvtxP0gRTOIVPPdVkF8gFhIzYCAV0C8VWVt3eQ9VZT8DZoM39ch4kRVRp/cxGSkoclE0u78w+0dYKZcXN6kRTGgRRSwUyDIYnFNFk5QgIjcI1fUyC8kTENwhvdmCAWAxl28yF4Qx6aKCKp1Ynb1RkooiJWVUsp+EdJJBCx0TdN4RyOGIldAwJPYhBQEjfJdEy9ASEkIAaI4R/S1Y3AASO1MxDIwRSSMhsfKDj/VxDtoR5g8jfKKCOOxy4VF0e9VGqtJjlvBQI8ECCJcjn0dVmYRTqcNQU4MCAU1DW98ToX/3Q8kSNgGGUaI0UeBeZ9tPIlaqEed8ZdBTguB2F/QlgdSMd1rRYYXaM58wUnRdIDyrM5SOA8mnMgiDEFidE2C/IA4ChUDrACC2CEX2Ia62FNF4EdvDM7DLCRHGl8DIFJHvIhNEIYSTIC5LNewiUQ88Ujf0k6iGGYm3Vcf6Aox/QYxiaRJNNadHkdJVI4dWmXS6lVVagW33Vsbdg5S8AjQZAD7NUj73U9QfCXX/MPTVICwvYBTdYDcVIDUEIgJKCPTyNVAiApRDQ76oMi4oeZzYJlwHgcXbUCJfAk6eUjpMleh9Je8IU92yNsslmd16M9RlJixGZZaLlUG7k+owGEl/+JmRNBNLLCfhEWOuhlKKPpQtRjLNLzXtD5D3HQA4UCJDIwKNITBIGZA/71jwsQHnMIKURUfuQJEWdSNGjSgzTiFyTQJl+TP7JpPdWzJwVRBi7AYRoKYutVBoUiBUFiJEbCA/8AYEvnKLMzK7YTnAcqE2liHMnhSSiQVL3xoDgmBS/gBkTQBWR2ZnjiBkQWpFIgBHZSLBkmmF7ZNiNiPCbCoi06E9o3FfTxACnwATjmBm5QJziaaQIkQCn0pWdQEEJwBsRCpHBGbLbJAihwABekLI7ypJRyEv8CAAOATFNQA3gKZmXgBgzkYwO0abOmaWXmQHziAv5VQfmRHXCaLj7/R0gbQF41wAdzUgZdEEBAVkCmIhCogioF5AauUkGqNjsOtqjQgjcQwKY9F2oKYAJf5gZuJkCokqn/gAiq8gVnwAdARCPIwaakKjDygxzAulMhpAAR8GUq9AVsNipbkAUFwSPFc0EG2qsCYzeO0qYQEGoa4AJ8WkBEwGYM5EJCtFtiEa3SOjC6ompMsWoPMAJ1EqbCsgXF0gNNYl0SOarlmjJT9qYEsGqSVwJBECzEIhCbEAQ+8A/UwqC/lmv3mi4E8AAYFKAByisj4KGFMipdoAMdEK59Yx32urACQy3WAhYJBV08EiplgAMZi1N8AYweCzVD1zEhCzkyKBBUsoC1HFEAkNay8MN1BsVM1XUbYFgzHauzTmRsIhsTAQEAIfkEBQcA/wAsEwC/ALIAUwBACP8AA/wD8K+gwYMIEypcyLChw4cQI0qcSLHiQYIFBRoMQFCgQAAcNR4UCRLkyJInP3o0iBFjgQIFB8B8abGmzZs4N478p7EnyJA9EZrMyJMnSoIFTAYYAAHCggcoIkSIGuFB1QX/Hhjc8K8AhAIBwAYI+3Os2aIURerMybYtToJwWXbtGqBpVoMYvDLdcOABhA1fX76UKbNk0p4wVx6cKeDAPwhziTYU8I+yALWVM1MuuNmt588D5QI4bBIszK4PNjxYsCDCihUoVkRg/SB1AcAbbqdOvaH3hqdZn7J2TaK4VOBdCxDwKtZsgMtFT28WUOAy5eoBCDz/R+BfAu4JE3T/B00eodqjkjET7VgQAgECgQkcePqaxL8P9qfoN4gDyYj/AI5AggZSPSDYgQfA9FVTgYU1k0jjPQfTZQdQ5pgA4/3jmHjffVfehzeFNJRGCv6zgFMraKCBD0vo0MM/QcQhAxQGyRBEDkH0IMM/OvhXUA9A9pBjjlC8uOM/I2jAAgYGKvcSBNlpx1N11XUXQIUwEdAYiFxyWWJiYA3wj5iCbRABCR/UIIMLZczwQhcvnCHnnP/I2UUXZ3Txj55CSCGEQV1IIUUZbZYhwwU11EDCU/A1dmWXkEbqFlhNEcbTV2L+EwGgZ0gh5z9EnEHEP1ts8Y8RRLgwQlWCfSXpq7B+/waZq15BgME/GnQBhZ6bFEQEFEtgoMBf/3DFF1exJqtsTVpp9Y8CWilgkLOuRqSWYooNxNFGHaGkLUuYibjsuJF+hFa2O6WrkEelecttQafN9GSZY2q1QAEnWlnUWHEJBNZa5AZ8blBGqYeRZGPGxFFSMMkEwWoRsJCCayygkBUKzSowgGq5NeccUDyNhZZDAnWm00rq8WSywB/CtW1Co8VF0AAikvVSs7NJlVVtBQww2lIi/jvyTI81HFhwq+W2wXLvjSVdRtapzFllp42s3WVSdrcyyxMdTBK4RIUFb3oamjhcff+QMIV9BamNQ3H/vLbpzjrjqoF9Ka7wD8Yvhf811mXYXm2ZZs9t569Bjk1NGQHfjbc119YmpNK6INFMl9Oztq32i0bq+M8PQfwTZEFJajAFC7LBUFXEBd2twQh89FDDCEF8sLaB7nEXlHbdEa0veAclDjmkB8Mr0KwHfKXVCiTgMMU/NfxQwz98/DOjDGX8U4YU2pfhggw54AiFjTgGETqQNQSZaA8ffLACC1XVdm9i0JV8QMrD5/9QWAJk3vNtG2ABjLAnBfJtL051+ocSfEWEURlBgXVSAhGU8IIXFJAHEXBP7vTHQRCxYVZJgcDMmoKBHtypIJto4K+CoIHUKM8r9+qgDD8Egb08zCua0oAMZHCFHJzhC134QUH/hFUAD+AGMnJBmFH2BbahfMuJM4wiW8wVlGuBC4oXqdm3CoLF0Ejxi+bZSRW11UUnviwkZCzJeUSSGDEhpStkutlvaAJGSXntJOf6yYjQaB6lgAQsSHmjQHwGmd5YRTW18Y2xuoMVJ/lNLD87C/7qiBN0rYWPC8GIejJVtSf9xipSqZgoW9OaghjrKx/jVypFNsmdUIZgKBsZJRsispCR0YtXLNjBxFSbqnQgAr/sQCKfsoEBLCA3TBEM0FjZEefIcn8o84h1UqYWrBUkQ7PM5EXIuJTQ0GwA3wQnw3D4AOGtZjUHIo0kn5mcriToAI4RTDtpchrHEQ4hg6vMdrQ0/7XKYDOb3HSZzEKjFJ/dDCqvSajFavMXwZSmLkSLKD2btYDigIAEKxDOAjKUGI/Usjp0oc7U9lky7AjgpBg6KXdUKsWjmIuLAJvJGxNZLNb8AwaxqQ0MaqM3jP5DlFXZmbOwggH4GXVTKMCY/MrZN49hC2uDmyZ0iiIl4OXzn1Lc1kvDxs6QCA0yq6kYbP4BgrLigHn/4ME/nvc2FpDArW6dQoA+IKDXoPMl1KEOlC5F1cpYZzOG012GtKYZx2ATAf9ALBgP1q/9GU+ZDvoKVtaKgxGQLk3pC9IIeuAHAJVAA7KJX8duRoAHwAAGDnDAFBxAh9dgbDkmtcyW7IdV4P8plgEArQnNYkaXjEDgAIh8gAaQoIMrqAlGOQDdD170uRcBSEV3S9vrNrtZIA1JBrFLEgYwIJOMlOwxc9EOZK4kIQr5VXi57RrQEGIax8znASsAkA5EJyQcFQR82YNCGYJgo881V3ShCzB9OTsCJMj1brI5ETrfw+DsYEiakKkOEtPrGaGBNyzd9QpXWkOcEcwXfIE6w5uEkL0u9ElQUJBCimmUgzKMD7nZsx4fZncB/KxgNe4pQIUg0D/gUXhc8jQevAqAgimkCXuE+lOe5hQqUCXQIGfYxJyWHChBea8GOrjxcgxStR9zMF4wMeIAFKAxcA4AAzr8xwsMMqqCGCH/Fw2Es6lQRYQXzOADuJNPl70MRihB6V918UANAUDoAURgBC7oghLOAKpcmEoKV/DBpgCjIPjw2csfZE5dAuCBovYgB7s6CBGkEIQISKsrC3rPpX9cq+TV6qcaCIIUbrCJXv1qCQdpViFX7eUCpKZYt1LNVOzzug9o4FkGyouzeM3sg2BgA7eqJEwVosk7NvvSVCQbe8zotW5lpNvXlqG1w7gTk3RLq0Nxorlpyc5wd8mKXfW2UNjFRXGhsXhLlFxL8O3uKYYGlinB5by3qEaleBGKmXoZIL35v9vkuN81GXcYXzZwc9s7Zpb89rYIbZgioho1gFlNDAkG8chdcmR8/4T3Nqc9lwcRjUx/Ae5fmmXpQv6FAFzp2x/Lskzvlrwo7DnXt7RIbqEcfMi9pedBa9NLpj8labijtFh2q0qe/1xy63pmyuPtxdOQqCujQXVtqCIVAjWrWFsRDM0Y9pPDOLOV+BQJyXOLsoIDvI8vs7vdmeKUqfg9BaHVymwQWazBLKxyY6HZxyTySohIFe4cHBG30N1KooupKcKWiubjh7QbbwyZQFHj4iFvkKk+5PGP87JHdcKwhLW+hk5BpAUOWSwXpmYBMilmMRuOcas/JF7wAuy/gM+Zwv3VIY2nsLhyWbmXg5MnDvM1vnzN9L/UsIhUd6bWD9IZShW9nytj6f9CMKSZa6ZXoAS94uGDNpphEX4BO60NqnvGEcVbGDP9W1xkcuyUJzENPLxTeo9jMrJlUlKTGYt1S+iXRSXhLjuDAjgFG0o1Pz5DdUIHXg0SYe2hGgsQGxl1TExDfFLiUVEDHYCTV9uhT6+UT+IXRXHBcjDDRQ1ze1DhGgm1MwviUPLCHBEWGBQFFTCwAlPAAySAAiwgHFs2XqukGZahEVZigvpkfv2UGYTlgrckFA0zFwY1GrvxGyYCAzeFAsORSEulKUt1TrkWAarzGgJUIKxxIoHhMSGTV5axZ12xgqVHhQiIOJXhIRyULWr0TGEHcwdiRPIzFXsDXyyAOm2TNsX/gVGgtSlM1yzCVFQRgzoV83RNYRpmUYIIKDLaIRBXMx4ToiHbAVLZoYcJ+FKMNRCtJy8HgURQAV+vQVbP8wFrBQJyNSCghYk/xQLQ5TYjQITPMxtxuGko5YlihIJXwxn3Uxk8piUVsoeKZYVKJBoKwTD+whxMh0izARVsMwLOMwJT4Dp3I1eVRVd0NSDxMz/KkSCPISYy0VQhA2jGV3qPIor+lBkJsDgnNY1gNEYOiIViIxDJAx88SGQrAAKWZVnPs1ZIgiRI4B8AggPHViBNsiAL4nQLAE/zkRXyBGGNJx0pKIAaYiFlc37tZkum0VtAERYZwgMjQFfTIzs9sFzL/5U+m/UPBqYiGBlcqwGB+sEDH0CUH/AHFwUDWPEejpEdJaMlz/FK6LUZB5AAhnV1AsUvdOFrmccC/yEkn7NcBqEjzlUQ5ciLbmU6+jECfyBXsEOWMlADfCAGdzEhWzKN3ZGX0VEQiSM86OVuG5d+QXdODzAgSOAHoHNcOSA65YMjYimRJfAPkQkgsRMEypUj1oUr2zWPxac1WsKJUpI7B9Ado5l64bZ2miQWlwJc8Kc2SLAEfuAi5PMPOTAjQTA+/GU+L6IDOjA9lzk+OoKZBWZgSAA/BgKPgqElpKk7/eM3j6F/VycXXfZIYqNjcTMFlVUQ6UM+oQMFixljBVEGtf8ZOjYCOouZIzgJJJs1O+SIUZPoFAjBY05jFn8ZnQwhNkN2GkwxdmjSkNS1I9sjBVX2D9wzKC0GBd4ZY7lpPjtkmTKwm1OQAlPQjr1jJfejHc9onxDxZ5LTM2PzEqpBArBDQG7wJmfgBowmoE/GPTSyPbTpoi5mEISyQzKwA4qCUR2JHYlRnxo6ESTyM0JzGtCCAmiCPTOwPSUqYgXBaHtyEGewQHPSJ1Q2A1XWJjKAH0GlHNxhhz2aEw7yoWOSexGjATVwQHnCPW4wKqESKqjCaEwKZXISJzMgBTNwpVfxjlzapeQBJjShAB0wXEiwIixgArGWEKJyBnAGKmCgQhL/RARJ4AZlEAObMpobpKewAhng5AH/4AGEcWYRQKYywKSM1kCncipEYARzNmp80EJesRwTZqmvgmGctqlFUUNn9gAsQJSxsz2iUieJ+mg60AHQ1qpfwaOwGils0B05OBAiBAEeoGEsUAPc06tEsAWbAAVMYALCuiBdUVvHqixsMADPyhR1IRMYMAIz0gW9Ymv/cAMj0AGbyhzv9K2QoyC1UgBFpQN4cgNEkEJbECp+YGrtYSAKRq8sw4OBgQEdUAIzUmsFYa1BwATPAhjX9AClZbABg0QbqQC3ogE94GK78itX8A/wihvwMlkYSy6+9kK3UhsdUF06UgYXYAIbGGHLHZayAeMXO/MPLaspqPNWD7BdOCtFzyZ/WgFtNREQACH5BAUHAP8ALBMAvwCyAFMAQAj/AAH8C/CvoMGDCBMqXMiwocOHECNKnEix4kGCBQUaBEBQoMAAHDUeFAkS40eOAwb8U/mvQIACBVoCiNkypsuYATDm3Gmxp8+fQDeO/KexKMiQRRGCJJoxI8wCDwpA2DD1QNSrUhVAUCC1wAAIXmEGGOByIEGMZoM2FKC2rVufZ0OWJErwKdgHD/49WPBvQ0uVMNGwHOjybMGcA+mKLKDx5j8IBCC0nEwAIdt/lwcKMGwwwOaGBDK/HQ038eEBY192Bcu6JdjHCwossGoV9l68uPVuvYsXxQoUKFj8Y4Fi+ArhC8DCNLsZbWe20F8mJqDzH/XNOKFjTiiatHfTTTkj/xTJtPPJnV8foJhCYgSOESNq6Bjxb/4IJPT/jGA/ZcUKvBs8sIFs/yxg4ApTTPEBfPB94CB7C/hVAFuVUWcTZpJNGMABAlxYUGXQcfjdiEDdVNdkkqn0QAQktPdBDTXwEcQ/OcgARQ85GIRjED8E0YMMPfTwj5AjfPDPBz0wqOQUGpCwwj8oRBABXgYWUJmVAoSmZZbWdXkAA1ySKOaIL51FU0hePbZBBBqMIIMMP+RYxgxnuCFEF3dK8U8XBuXZxRmAAirEoHr+I4QUUnQhRRlluOACfChEZSVkY1ZqaVsBQEAWQRnq9YCmGETAQoI61PCDFG6cQQQYRBjhKhFS6P+gAQYxSVYZG5fmqitpXamkQAc96LkJEf9sQewmV7CgwGBQQRDbrtBG6xNNBeWl1z8RwFAQBtVGRJ5HTZHE0UYdzZXRXOCeO6607Fb6UXnpjicvQ+8WJBVVMN0F1b2DFcQsYYipZphOiB3W7sELFZWUYgmZdJBLKY2F2lcwRTXVVAJ+im9YZAHAkXhKAeUZd9tppx1mziHs3bg6ybXuwyyxJpXFj4X1VAED2nQTYzwDkNJKK0nFF19+PaCScjenVXB1CdFE3WEYbSa11FGrLHJCIRmcFGo2SdcapZ8uAAOLK5Dwj4L/jNDeFO8h8R58ODSpQQqRLoBXvgRYaRBZEBz/UMABkAVuWIeEE1QZZWwd4CVlBWUpAANWWyqQSzOZ1dUCLMKnQ5Iz9uBjj54PWYNBo6f9NoMLFrlkkyz8hoLdfmcZAHUVTj0hdZI1XhnkYXYXOYk4lZVimvlCtQAK7dUX5JCe2/gPFFCUAcU/QVRf/T8yzBgEH2/KwH334HcP4/gfrBCglaEdcECmv7ffE04DE6XAimySoMH9GkxRgwwzuPECsUb4BxGU8I8zCPCAuQgUsYiQhBlMwVrui+ClpEIWD0BlCheQgRSE8I9NIFCAQgiCCWglswP4RYIo/M6+otIXDGygA0h4npASEqDHtASCBmsKuZgiroH0cCkpDKJb/96VlG+ZB4gNW9fLFtaZlpTpJoAhjxB/Z8Qi+hCJ5iGXy252M5k9hSw18dBORpaTsqRsimNCy7c6oq6sEcWNStHIS/QVG2c163xRGcAGyDIgsjxlJ2YMmGkKhsYxxWsoDGMIFidjE8lcRS9duaFXNHUxm92MkBdRy8hIZrJCQsRjPPShQsZSuYmFUU1T6UvG/Ia0AQBgjyXhCVrOckaHLMdel8klyqRWsoN8JmAg8+RCnFOScfWMZ4+5m8byMsnihWVg4pGivT70NwMVSDJ8qcxZ2FK1nPzyIp9pnE4yc7jtCFORV5xJKWFCsdbYBCuf4qJBWAMWD5BFJTP5ClUGgP8XvfwHBrgBy8QGJhpuhvMyiCmnZgbyNLRkxndBjIsoCRMej8wxQCe81m0KBCX/jOpsw9GAcES6gvuxYG1qY88/VmA3SQWOdp65CbioNcjNwHSaZdoOhyqjuJ4+rkso5AwbnfMtZM4ELYCZIz/zEoGyKQgHU1CSVKGqgX/MjTgswM3NCBAZA8FgBQ7oj38cwFKxGM4z0pndSwTApZ3+o6e+PEACQvPWKZLkiog8l8OWUjBsPsBFOkAS84K0vIPA52waAA5Wy7YCHkgVPjV4kYN48LrlxNQ6ZaIrBH5JnZ1mKQFvpZAAEHDOioALMS6BzKciEFUdbG4EQbiCj4KQI+z/xeFNOJrh8nqAJMkWaUFpY1KCTLqCCMTmb9bhKlcJkqX0dek6nkWAXM1Z2oqYqYlf4WdL/NLU/MWHDwX5AfZw5LwgTG9GPRpSfNKWtvh8gA9FGl8Pxke+DzgJOBGCCeFANKHNEkBx1VVhGD10l6ba90W0ZRSiFIWoQjHqH2X4h566oOAyLGpROYiwC6SQYUfJwAW43Q9LH/DfugI4wCrTCWMOQoL9RbggjJJe9qLXhRf8T4BKyHGOcfwCA54BT3USwgykIIMPZDUyJUZxCjNFEJX87GdQ8c2LZJCDHPwgSBp0AxEM+A8j5IIICeQwfqoqKYUq2ZNPBLBAuQUVFtUg/8NS4LIBt3wGKfSABbTqit/MfOYAF8CCFlyWApZQhh4LkFgFMQKfOhAzPff50X2hyQMUgAEfXEEKm5jeFgwywr6wxi9UgbSS2YCvg1grAlaNodoO4gGqDEjUsDaICzGAw57IcZjnEkqsH01EHfYaiUss10XuCp5dW02NCpHiSRIjl0QikWnjiUm/jJ0rI5ZnJMKOo2LUWB1uH9WUJyIYtUnTa3hhu15JnGgx68LFduczMWZMzE4+xpNxWwTZyabLKJe97r1JJTKyAQuSkSbQp0ANmCaanb19Yu14udHayQbJvS4moEryRTkUk0pN6sLkwsgyLU1cONaY7WtRumzkDf8TZb6WCRVIPgDAX7RZzi5ZpqUNstgR2WafpRnKc4dr3ydKzx0hkJfkuBomXJmfzbKLTFnWG5M518wmO4licLkMiEzc4VLYyfVJUgWeOJuKHvPIsQ34DH5mEeq9F9q4XoYsmGjEuhbLhe6gLZ2dfNuXp6+C0a1wcSaFuXktJ7JJc0KUoA5t+67rRROMiIU1BHg5C23Y6gF4gA2VC2TaE8MSlqy4KTbJW0zyBp605lDemSwZ1QfvSbnEr5jHrMpeWp5HZhbcRGWRCdAmA7TFJPdvOBM9731ZbGK2na29RCvxqztLecuFa/66l6vxUsHV/NEscrT6z60EfKtEJi+K61v/4wPP3OIbBPlTKxlOUBYahbPefXMRz8AAXyvlZCglXkQaTW6WkpRwTCBg9GonRHR5cRtII3HMVTVK8UsdIk6EA1SXUU6Hw2cSFBfxtzeucS8aaEEXExt44SyUAoKfMoIQoCn9Bxj99ADa4h8FcRwtZVZS53YIFTzHZxAa8hnQESYTiBkUuGTP9xf5koGfpjhDswEGYk3+NDb+8SQswBdSAiVN1ToiZT8n1YK30RUJV3gE400jIxpRU36Gd34yiEKHNFEM8Wd/9g8eUDMG0VJM9Q8tUlUFUVVVRQIl0CYlMAJ5mIcmxQJTMnt7BnAOAxjMVhaZMSEt0SFrpSGYZVCY/4F8ihdEUkR3JjEWP+czTSYVd6EXfLGEyeMeOGA67uE2bjMCdbgCKWCAkEd6BUF0YrMABpABsDgb2uQSEahwGtJ4jngyoFUQcnVi7tNDDmcu8AJNMhEWeYE8LcI2h+VafrAESDAfSKABd2g/waFVSPNWKoggCdKNU/AHJAADOWMQVzJNvJcZ0CYAoDVdpCWJppEuzeZwWlMmgFcQx9MiH/AeBfFarzVD7QWHJCAlAFJ06lE2f7AgNZAkvMUHkcUDLKVNnXEdazUyMfFNCEFaoJUAEEWGDSESpzV/9oIzeNEeRTJfu3VlOpKQRmIkatMiJAACUwAC+zECSRIfSzICIP/ggpBhRjalVltSV2yVOweBAKNFXaIGj+ChM5G3ACsAWTR5BaFDIwUBJDnAIz8AI8uDOr/1IjXwW2qDPyzQOix1AHlDO6PXgBpSfp3VdiLiOCJXFoRYJq9RNpoTJD4yPedVEOYFJOM1I0MSWLwVI7ylOiPgWN2oAccBIBmVXF2Sg+g3IQLAITnYjiI3EFwzOTXRFwGyIijAIPNVPdMjA/8QB1P5A1BQlT0gXlfGW0dSkzQpVe31HlTlkr9hTYezVrLzXxQSiZVpL2hBU7lTlnhRUkOil55TA3f5PNJDPddTEIT1nOp1PaIJJAkJI1fpIA7iADNXYtfhlr2ZME7kRGn/mBh+gxFNNQX/kJBDcpd4qSgwJj3wGT0yEGERJgNdMJ9y4igg9mFvwiN80AM4ICVG+F9guJHf2RBP1HF/QRABEgE84GIZZmFukCgcJGEWticFwScYiigFcSgN9qFSMAONAic1wAMC4hIgAowHOhFCCYQJMT+odhwuhio/hqF7kiiJchAv8A8EpARnQEA+ZkBCUGeI0ig/8AFVtZgrOhrUciJg4TMPkALrhZUjYB/74wb+owS5UARdRkA9pqH/kAsH1GMv4AYzIAP0UWtL+h24knsY6BWU9gC0tlIfoEFCQKZS8AJfQAQ7WkCtUhB0higyUAMkYDF+s6bQ4kpNdnau+PhV7QUfeVgDLlBjBNQqxlJAUDCNGKAAA9KiiAotmZJa0rEca7giCJJBEgYoW+anSlAGQaAsnvcYuPKp0iIVTFYz2TUAK/ABF7BhQ9oFHhSmfNoFV/APJKSJtBo5FMN0LqQBp/IniLZpxdIFr3qsYHGoyaoy3MIVfjcAI+ACqupBW3CpV+AD3GIQJ0RT2VqrrnYXA/ArS5ADwCpA40oEmdoBWiFJskEg69oujyQhm9oBOiA9NzAsBdQD+LpCBmFC/aoyraaGAaIAEWAB6XkQPyAcG7CGMWFBatqw0cIGtLYB5+oX3BKjqDZpGKASs+qx7jNpLRSxPhEQADs=\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdlcy9jaXR5LmdpZj81MWIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhwUVBoQWZmL0FBTURBd01EQ3dNREV3c0RBd3NERXdzREN4TUxHd3NMRXdzTEd3TURHeE1EQXhNTEV3c0RHeHNUSkJzVEd4TUxDd3NNQ3hzTEN4TUxJeXNiSkNNYkl3c0xJeHNEQXpVakl4TU1BeE1UR3lNVUN4TURDeE1USXhzTEF3c01BeXNkR3lNVEd5c0lCQ01USXlzZEV5TVRFeTRUQ3lNTEF6UWpLeHNMRXlNTERFTXJLeHNURXhzVENpTURBMFFySTFNNkt4TVVFQ3NqSmpzc0lVZ3pLeU1jS3pNaEd6WUdCRWNvQnl3VEUwWXFHelViRXpzckt5TWRHemNqRXlNVkF6c2pHMVlvQ1RrdURsWXlIellUQTFsRkoyVkROR1ZCSzBZWkF5c2JDbFk3TkZzN0t6WWJDeXNUQTBnNU5rb0ZBemNiQTBjdUUzbEhKMHN6SVNFYkUzcFlSbWN3Q0dkUVJqZ2pDWE5PTm1oTE5vZGVPV2hPS0g5bFdVZytJWDFTTmxsRE5XWTVINVYxV3hzZUNaQkFCemczTjBNeklIMW5TRmM3SVFZSEJWWkpSNDVvV0ZnM0J3Z0hDSGhkT1VrK0s0ZGFKSkJ0UmtVakUwVWJEcDUvY2hzY0czaFZKelEzSkwxL1JtMUFBM2xERnBKUEg5MkhSREFySUhneEJpc25DQ0VsRTQ5aE1Xa2hCSzZHYzJsWE9OV25rc3RxRW85NWIvbkptbGhST0k1aFJxWjJXbjQvQ2xZWkJLV0hYdkduZFpCUkw2Qm9SMmMrRVo5MlJmZnIyWGx3YjdpNm1YOVBEVWhIUjdtWGI0OVBETk9WYjFnMkU0QjVYTForV2k0dEs5K29lNEIvZUdjSUE3aVBYL241OWJodlFwNWpNTGlrbjBoSE9MMkpjcCtpanNwMExWaFhTSE5mVjlqUnU1OVNDcjdBcy9HZFhkS1lmbWRpU1BlNGYvTzBqN0JnS2RXN3NLQmxPOXVXWFdkRElMSldCV2RhVTdSd0wvYkxyaU1qSTVla2VNK21lNytkZnpzekpNZVFYTmk2bi9uZHRySmRHSytZZjZ0M1JkZUlXWTkvZmRxMmo1dU9kUFRQdnp0QklMK2dqbk5CRzVDSlg4V0FXYStianZPNG5tZHdVbXBuWFZaVlZaOWVJT0dBTEphUGkzRi9XL25peHc4UURCa2FFeU1aRFMwT0I1eWZpekFXQ29WemJFZEJNRDRiRFNRWUJpMHdHMTR1RXpBdUxTd0dCRkl1Rmo0YkJvVkpIem9WRElCOWRDa1pCaklyRnFSNlphdUdhSVpTSmgwY0ltZE9OWFZXT25hQVhGc3lHcE50VlZNM0xISlVOMmcvT3l3c0lRQUFBQ0gvQzA1RlZGTkRRVkJGTWk0d0F3RUFBQUFoL3d0WVRWQWdSR0YwWVZoTlVEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU1DMWpNRFl4SURZMExqRTBNRGswT1N3Z01qQXhNQzh4TWk4d055MHhNRG8xTnpvd01TQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTlROUzR4SUZkcGJtUnZkM01pSUhodGNFMU5Pa2x1YzNSaGJtTmxTVVE5SW5odGNDNXBhV1E2TlRoQk4wUkVPVVF6UkRjMk1URkZNa0pHTWpBNE5qTXdSakF4TlRkQ05rRWlJSGh0Y0UxTk9rUnZZM1Z0Wlc1MFNVUTlJbmh0Y0M1a2FXUTZOVGhCTjBSRU9VVXpSRGMyTVRGRk1rSkdNakE0TmpNd1JqQXhOVGRDTmtFaVBpQThlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMGdjM1JTWldZNmFXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzFPRUUzUkVRNVFqTkVOell4TVVVeVFrWXlNRGcyTXpCR01ERTFOMEkyUVNJZ2MzUlNaV1k2Wkc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMU9FRTNSRVE1UXpORU56WXhNVVV5UWtZeU1EZzJNekJHTURFMU4wSTJRU0l2UGlBOEwzSmtaanBFWlhOamNtbHdkR2x2Ymo0Z1BDOXlaR1k2VWtSR1BpQThMM2c2ZUcxd2JXVjBZVDRnUEQ5NGNHRmphMlYwSUdWdVpEMGljaUkvUGdILy92MzgrL3I1K1BmMjlmVHo4dkh3Nys3dDdPdnE2ZWpuNXVYazQrTGg0Ti9lM2R6YjJ0blkxOWJWMU5QUzBkRFB6czNNeThySnlNZkd4Y1REd3NIQXY3Njl2THU2dWJpM3RyVzBzN0t4c0srdXJheXJxcW1vcDZhbHBLT2lvYUNmbnAyY201cVptSmVXbFpTVGtwR1FqNDZOakl1S2lZaUhob1dFZzRLQmdIOStmWHg3ZW5sNGQzWjFkSE55Y1hCdmJtMXNhMnBwYUdkbVpXUmpZbUZnWDE1ZFhGdGFXVmhYVmxWVVUxSlJVRTlPVFV4TFNrbElSMFpGUkVOQ1FVQS9QajA4T3pvNU9EYzJOVFF6TWpFd0x5NHRMQ3NxS1NnbkppVWtJeUloSUI4ZUhSd2JHaGtZRnhZVkZCTVNFUkFQRGcwTUN3b0pDQWNHQlFRREFnRUFBQ0g1QkFVSEFQOEFMQUFBQUFDbEErRUJRQWovQUFFSUhFaXdvTUdEQ0JNcVhNaXdvY09IRUNOS25FaXhvc1dMR0ROcTNNaXhvOGVQSUVPS0hFbXlwTW1US0ZPcVhNbXlwY2NBQTJFQ2tMbVFwa3liTTNQbXZCbHpwMDZlT244S2hjbVRxRUNqTTRrYVhUcFVhZElBVUtQNmRBcDFhdEtkVktOSzFjcjFhdFdzVDdtSy9lcjE2OWl6WGNsdVpjcVdxbFd6YjczS2JSdFg2VkszUDluNjNGc1ViRldoZ0prR1Bqb1VhMW5EYWdrWEJpb1lLZERGaXZWYVJVelpibGl5aE85cWZZclZiQUdsbjgrR0RnMDF0T0tlaml0bmpneTVzR3U5akZkVEJ0eVRkc0dpazJ1ZXBubGJJVytHajJ2YmJ2amJwWEdEeFZFVExKNWN1ZVhVa3BHK2hUM1lMZlcvT09GYVAzeDNydlh1Mml0TC81Nkt0alBhc1p6UENqalBYaXozOU9EcGF0OCsvNzNhK0lqeE5pWi91SzU4dnJKbHg5cCt1RDJHVzI0RnhqV1pkQUltRmhTQlVaR20xQUJSVWZpWmFteFJLRlFCTXcwdzEwNmtwYWZoZGNqdGRSQk9yVUVINEdBc0JxZGNpcXMxZDZKdk5DWWtJM09uT1NUamNUeEd0S051TnRhbTRwQURGZ21iWDlNcGVKTmYveVYyNUlmZllkamVabXVaTmVXVldKN25YVjFOY2Nla2wxdldoK1I5L0szSUlKZjRrVWptZ3g4QzZGaVVjT1luWEh3SnFoa1hoOWRaU1I1VUZKYm1FNTVZWGlpaG5reGR1QldhWWZtWG5wdXYwVWFkYXlVYXlWcFFrVTRhbTQ2OUxTZWNwcFN5dUNsRUx2WW9LcWlOY2hwcGFwK2FlR21qQjdZYXA1TmJkdjlKb3B4NVpwYmxsZWJkcWl1dWZibDM2SHpQclpVWGxJUldlVldMWUVIRzRKZmh5ZmRrVm5BaE9tUmF4ZTU1bVpiNzdibVVobmg2MWEyVmRtazFXZ0RqZm1adWFRRUlNQzY1VHZacGFMSG9zZ3RBaVBmOWV0bWlhdElucmEzNzJqbmNqSjcrT0dlT0JBdUpLYVVDajZwd1JiOFJHZVREeEVtNnFxdjhqUmxzeGVHaTE5YXVVYTIzSHNjZ2orVXh0V0tOL1BGNUk3T0hiMzUyZlh5eXNDR0hiTitZK0ZJSm5uak81bXJ6ek5kbUhQUFBZa21vN2JyaXhrdmF5NldwR3dBQjdES2RMbWxPbnhVMWVxSDFHZXh6SFliVkozeFFWa3lyZjhiQ2F1ZllpQTZzNlkyWlZscndpNnNDWENOQ0NTOHNkM04wSzJ0cXBkSEZPQjJjYWRML3FyS3ZQV3ZsTWxSSXE1Y3U0WWVualBpdGhXYzUrT05UcGp3NHI5NjFCeWEyd0FhdWE2SytRbHVlejJkWnl2bm9USVlPdE9tbnMvZHhBZXNOK3RrQlMzZDhidXV0czhzVjBVQ1RmcTJnZnI5cVhwbjVpcDJyMTJTU2ZhWkd5Y1g5NDQ2aFp0cTIzTkJuaEdLMmtEcE01TVFHZnkyODJLbUQzRGpISjV1YytQamlsNSt1QUpNai9YMzNxZXVNTFpyc3h4KzQ1dkhyS2lGcGc0NTFMdFBybG91dTArZGkxN2xZRjYrb09JMS9Ta3RneDhoRnV5dmw3M00xNjFkKzhHUW9sdFVNWFBCaW1aT09KQzgrWlF4REVqeGUycDYzTm9tZzZHN1JTMkZJWEtRaUJBVW9leXRpRXdqMVZiL0lMYTQ5NHR0VitNaTNPUFA1TUhIb014OFAvNFZZUXl6RmFJRWlPMXdSbDRpV3lSbU9pYmNLSVArYUJwVXBmcWFCdG1QYUFRWElSZHV4N29xaitkZ1ViWmUwS2lJdWZ6OU1XZjhLdUJWdWdZNXp4bG9qdWVnbnh3QU9rR1I0ckp3SDU5VWhkTUhIWHNiTERVVXVoYlpPRWV5RUtreWsybXJVS2xPMVVEb1FlMlFFbCtVbDBObVFpSWh6SXNxR3lFT3VyQStKQzB6aitBVFh5VkNPTW9lZTVPUVBOMmZKS3lsT2lhU0U0aVpYK1RmU3hjeU9OaVFnQW1Pbk5QL2hjbHdBakJEaHdGaEEvQW1UZ0VGN21qS055VUJnUGhCZHozd215ZWdIdUxYZzdvWmVwQ0l1bHduTm90M09jaDhNbDdZQ1NVNURKc2cyeWx0a3FoUlprcmdGaVpBeGhKdmVERlFkMFVISEtRVnI1RkhFV2Y4dkt2WHNsZUNMSENwSGFiajBtUktUbVlSbHlSTGF1RTh5VHBaWWN1aENremdXcHlWUWx6M0VwaXdKNkwvWW1URjJkL3dNLzc1b1JxVWg4SXUxMng5STE3TkZMazV4aWxqOHB2OU1tazJsWlpPWWE4UW9NdVdZekRGMjFJNE5aSjBXbDZhdW9oTEFxQUlZS2dHa0tNeHVjdEZkWE94bE1aT3BSODFVaVVCSktpYytJd1lrZHlLU25hT2lKMjhFVkwzc0hjK2Q4bHdReHBTa1BVY2RVWWVxak9zT1Z6bFFVUVlSZmVjTFlpbGRDZEcra3BLV1NIeFpVYzJJekZRcWNaZEg1U2hMeWFWVVhwcHJjS0haNWEyVXVsaVVhdEdvUkVWcFNXTVh6S2hBUUpzZUZha3lpNnBZd25KUnRFTVZhbVpYZDdpb01XMnd4SXlhYUUwNldHLy9maE9hVW4wZFNEbDdnS1JDUUYyOU5kZG5QbHNBNGphV2FiQWJhbkozUzl4bWN2R3ppVTBxdXl5VU5LQ1dGSmt0SFJSOEFJVTZPdjBPYTFxVklIRE1obGF3SGtjd2VtdlJiaVlsdzBibVRiMHdPeFk5MzlQZXM1V3VPMDJCYXlvbGVqN3k0Zld1QUViZlVRT2N4QjFtMUtBRkJocEErYXE2dlNydXdmOGQ3QmdaV0V3SlkvYXlxbzN1VVRrYklaWXVWVjNSNWErR2tYclVFcWVMc3FxVkx1d0VzT0xFNVpSZHZUWHhaVjhiM1F4ek5xblNMVEdKY1V5QW84YVlxRXo3TGV1RVRGb2MzM2kwWjdUd0FZNzZXeUwvRm5ZRkdQSndSZHJiQTFoWml6SVdNcm1haTFLU2lyYXdoWHVzYUp1cndPR3lrWmxkN0NJdXJkak5PM1pYLzJNWURHSFpjSlJQOXFMUVIrYmxDSjBoNlVnWWpuVzlDQVAwOVFhRUpIN3h6VzlWOVozbk1PalhqZ1U0d3BpODZ4RDFTa1RKRWU3Uk9NNDBwdEdYQUU1N1dnQ2QzdlJkQjB4cVVHdWEwcXp6MkYxVG5XbGV2cmEvSHJNc2tHZXRZeDJuT3NVMUJyR1NTenppeENaVUsxdVVNWkFQd0xya3hoaTVTeE15N0lqTlloYkhic25GRm9DVGFWZlVDeGQ1eUJqVzRuS0RtMk1DTERtcFBtYXhqNFVhWXBMbW1xTTM5V0pTWTd6a0dEZWIxRXYyY2J2WHZXUWl1N3ZLejhaMkFKSTdaT0RhRHNvTWhFQ1BWNnRGMUFwUTJnSGZyWVFOMk9hb0FQeXpoL3VsYVNYdVVadG1FeTN2NGwxNDMvdXdoTlZ0a2VYdGtjZkoyK2NpbVdtZjl2OGhWcGd1cDZpY2JhOXZOT3NjTlJ0ZFVJVTJjZEtUbHJTcU56MWdBZU00QVFnQWVnS0dMb0NnQjkzVWQwVkEwWmV1ZEFRMG5lbWdIanJRUDkxcEFpVGdxQXpJdE5XUlRuU2ZvNXFscWhhY3g2cWMxS3Z6K01UTi92YTNTNngydG9PYngrdm1zZFc5L2ZZZTE1M1dSdlV4bGhPd2RtUVhvTWZlQm55OHBZM2NMaFArM2VKV2V3SG0zZTdBczNqSmZBLzNBUmpRZHh4RFlNbjdEcnlWbmIxaTJJazl3NHZWc2R5TFRnQUVDUDcwUFRiOTVBK2dlczBUZ1BLQmYvMlNzejc0MnR1ZDhYUlhPK2R6bit6RHQzdmZKQlc0bFBkTlZIY1RXYmxMQzY1TXFYaGNOVGZjbHhmSEpkSk1FMDdBZFEyUSt6TGtjQm8yUXJkcFg0VmZQV2YvM2xDRlZldTljRWtxYnhaNHk5STlUVWFVa3d0ZHNINFBDdithMnpXd3NDd2ZwSDNlNmY2YnV0Tks1MzhCQ0hWOHh3Q2RsblVJdUhSU3AzUnpCMm9EVm5VQmRnQlZkM1g5NTM4S09IY1UySE1FaG1tdzVtNTI5NEc1QjNYbzgyMnFOM252Wm9LbEp3QlpaM3FSZDNnNjVvR0lCMjY4Vm5vOUZtK3R4Mkt3cDNUM3BuZmlobmlTTjRKbUYyK3hGM3V6MTNoTFpub0lZQUFNOEhvMDZHMUxTSHAxQjNjYjFuczh1SU0wZUlTdUYyOUdtSVZjdUlWYXlJVkVXSVBpcG5kYUdIZmhobHhuaUdOVnhtUzZ4bXlTVjJ4QXRudk9SbmUyaGxuTXRtd2MxbHg2YUViTDFWaEF4Vk1WNGlzVUJCUGN0UlRmSW1ka28xYXQ4WDB5bEVKMC84YUk2UlViZzNaeVlyVld6Qkk4Tk1jNE9TUkVvcFIvY2RWZzlZY3lPMGRwZWRWZk50ZEVsUFpvcFhoWG9kYUtubmFBcDlaL1dTZDFVV2QzbThhQVNaV0FmRWVCS2dpQVZoZDBFaWlCQ0VCN0tkaHNBRlpyV25kNmRhZGpUY2VFU0hoVXByZUUwYmlFREpDREsxaURTemg3VGtpTlRKaU5Ua2lEU3loNDBnaDRCZ0I0cnhkNU5OaDZxd2VHV01oNlRuaGw3VVo1OHJpTzdYWUFDeENPU01nQTl6aDVTY2lFa3plRWdaZU40WWlGclllRVI3aU9DRkNQcFNlUFYraHQ5TmlRV1lpRlEvaUY2WmlPQjZsM1llaU5XeWh3bXBkNGxrZDRTNU5ZZUVoM0FoZVNsamQzVlZocldGWmt5RmlIYkdoNC9XWXVuZlZBR1hkVlVvRWEyUC9IY2ZQRUplamtOVzlqWnlsUlNOeDNTRHZKTmpzcFNWa0ZjMUxTU2t0RVMySFhZTit6aVFTbEhqc25Wd3lsYy85bGxhTklpdm9IUkQ1VWxRQ1dWNkkybGdIbWY2NklkS3pvZ0VySEFHdFpkQUZvZEh4bmVrWEhsbXlaZ2tiSGRDbklsa1czaXhMNGVyVDNoSUxIZ0VONGd0UzRldEpvbUloSkFBdFFldnhZbDlWNGtKVEhqNlZYamtxWWhJOHBqL3RZanRsWWpnbnBiVWk0QUFnQW1veHBtQXV3ZXUwNGp3NnBlYXBua0p3Sm1nZlFtcFNubWEvWlkrWDRqK2tvajUxcGVnWndaVXJvbXBSM2o0dHBaYkRYZUozcGhWYTJlcXRwa2NNWmVFbVlrSkg1bk82WW1FV29tWXZKamhOWmcwdmxlaGhwWmNrM2h1SjJmQ3JXYjNiLzEyVElSZ0JDVm5qSXRtSy9WWEVRWjFwY1JscW5sVzQvZFZ1a3dTMUpBU2p3OHhTamNYM1pGMGxjdFU3cTlCSW1CQ1BUczAvdjQzSTNzMzZaYUZpRlkybEsxS0FUdFYrZktJcVM1a2xodVlINkoycGlPWlplR1dyN3gzV1BCb0d2R0VRV3FIUm82YUZacDRGcCtYUUQ2SFNnRm5SQ2Q1ZHdPYU14Q25Sc0NYUk9sd0FWWUtOT040dzkycU1WZ0FCQnlnQVZRSmV2aDRRc0ZwZFc1blNNaVpzbHlKRFNxWHFVVjVCWHlIb0tHWnFLV1k3QUNad0dBSnk2Q1p2QnVadk8rWnF6R1pxeHFaajZxSmc5QnBxWm1Yb0VVSm1zdDQvSHlhUUpxYVh6eUpsbFdwdWdtWkN1YVFBR2tJUi82cWVCcW9SK21vU3YyWndMRUtpSnVxZUovMHFtdS9tb1pUcW5TM3FjcWRsdXNIbVJZL3FPVlNwNzQraUZtaWVRWHhpcXFIZUdaTmQ0SXFtR1p3Z0JROFp2d09kSjZ3bGxIOFpzcWtwR1JmT2V6WFZaVHdOYlJ1TjhFaklpU1ZrbmlGZzJQNGxua0hnd3ppRWJySEpFS2Rjc3k3cHl6N0pvTVRPRmhtVi9FTnFKQnFaUkZwcWhXTW1WcWtSMXFuaC9IMHFXZVhXV0hCcDJGMXFXYVdscVdhZUNhRW1pVzVlQUtab0FCaml2VW1lQThzcXVLemlYd0NpTmJsbU44cnFqUlRxa1FzcVdUa2V3UkNxa0NCdWtDdXQwZitwMEN4dWtPcHFqUmplTWtnbU1sc2w2ZEptYlRjcVB6NWlQY1RxTURVdXdrM2VQdmNrQWZtcXlKa3VvaEZwNlhKcUUrOWlQQ2RtUFZ2cW9uRXFRTC8vTG1IZzZqMVBLbUhYS3NEN2JwWU1xcUs5Wm1sMjZxSWthdElCcW1ZVWFxTTNwcDMwYXA1RGFwVW43cDFaYXB6UUltN0pIbVN3Ym1seExwNXdwZTNLYW10NjJtdzZacHZib2JjRlpuWjVxbkdtbmU0M1hnMjNubmJwWGtwK2xxb2lYWENPNGIzTm9VeXJWdHdIQVpjODFWYjFrVTUzbFU3WFRPZVduTGZ5WmlEMVpLbmNHUTVCTFBIS2hLb1JXUEl0TEh3bXFvSEFGV0U4RU9RMDZpZ2ttV0FRbVYyUlp1Z0JHcnFhYnVpQktkS3o3YVNBNm9oYUlycTlidXJFYnV5UnFsaFhZZ0NxWWx6QUtvMzNwb1NPSVBnTklyL09xZ2tGM295dm9vMEVxcEJYUXZCVWdBVUVxQVFnZ3ZYKzZ2QWpyc3c3YnNEMnF2YzNab3hMQXZXei9TYWhLKzZjb1c1bUVtckxvMjdDVjZZVGptN0pMVzZpZ0thamZLd0h6YXdEZjI3USt5M3I0MjcxTVc2Zy9HcjdWV0w0cUs2ajIrNmZmVzhBWklLZ0piQUFMbkFGVFM4QUVES2hMbTdSc0NyUUVuS2dTM0w4UFBLaU5LclZNaTc5dkdzSmFPNmFMU2FjNlM0L3cySVVxYktxQkozekVacW9VcWNKaGlIcW1HbTA4NkczUFJwSkx4V0cxdG5oaVJIeEFCVjN4eWF1N0tuRkhtWDNoZFNvU1UwTC93aWxraFNycmRXZ1dnMmdKdXF5aFMxSGdxcFZhVEZjNFI2SVY2b2xiU1phb1c3cXd0cUhwS21vZWVwYkFhNWFtdG5Wcy9ILy81OFp3VEl0MExIVnl6TWJBQzhjNGhvQkNOM1RYaUhYbmFJSXJ5SmYzcW9OQUdJejArblQ1LzVxQ1F3ZXdBZHU4dy9pOFFtb0FDaHVvelN1OUdWQUJEc3dCUXVyQUNKREowK3QwMGxzQjFWdW84enUxcEd5eS9MdTloeHEvL0N2QTVTdkFBeHpCRS96Qjc0dS9Hc3kwMUR1MTB3dkJFQ3dCRGdETXd1ekw4bXNBSENDb24reW45WHZNRE95bkMwek1CSHpBcDV6QXVBeW9NQUMvVG92TnIvbW5HTXpOWEV1MSt5aWF6eGljYW9xWXl4bW41YnlZNUR5eWtWbk9hL3VwUm5qQ0tleXB3ZmwzTDF4czJKbDd0eWRsSUFrNzU5bDdUelpGcy9wd2dXdG1CdjIzOGZsaWJMUXpqMElkZU9Lcmh3Z3U1Z1FrYWJNcEIwTEZmNFlaa25TSk04U1VQNVBGcnpSUTlIZC9CNlc2cWV1Vkttb3lZN211bkZacVh2ekdjeHpUZUR6SFcvL25nSy9JdXEyYjA3MFlkYXRMdk1XcjA2ZHJyL09LZ0FsWWV2SjZ2UExheHdab3ZQZHFnTkNZMUVabjFENTZ2RE5halZNZHlaQjhzSkRjc05JcnZRemcxYVJNeXFHY3NKUXMxcU5NeVVsbzFnd2JwQVlzeWtsSXZaUWNxTko3ektSc3dQYWJ3ZStMekgvNnpINjZ6UXg4d01YY3pJSXRBUmt3djN3TnpSQ2N3QTBncUE3Z3pBUzh3SUQ5MTRXdHdINTZ6STFOekl1TjJBVWMyWS85dmMvY3dJN053RENRcU5lY3pacXQxM1U2dEtFWnRSYmN6Vk5McHFWcFpXSmFtakY3bkxGdFphV3BtQ2xjbTJocnFTemJrTzhjM0tqM2JtRm9nN3dHdDI3M2dlZ2pmRkZtbmpTMWJWM0Vaa1hzVk5BWFFOdWlvSHpVS2Y3aVhsMEZNYzcvbzFZWFRUSE1Lc1dWeEdoUU9aVWZUYnJjYWxmZnVzWCsxYTZQbHRKbE42SThOMm9pS3RQb09vdHpUTWZzV3E4SFdJRkpMWFZKN2EveGluWC9WNEU4SGVDNk9PQUMzdUFBTzNRdzZzZnpDcU5FS25RQlc2TnVpYU1hSHNsc1dhU1dTYVFTUUtSMFdhUWpUcVFCSytLcERNbkxtOHBwSGRkdjNkYjBpd0NjSEtTY0RMMWRQY25US3dISGZMOWxEYjBWd0FIUHl3R2VUZG1IYlFDWERjRkh2dGtGdk9TRXplTUd2TW5Obk1CU0h1VlJQdVFObk9SU1R0ak16TXdKM05pTEhjeGdiZ0JmenNDWGZka1pjT1prL3IyTkRjeEdYc0NOblFHTi9lWnJQdG5TWE5oeUh1Vm1UdVdRYmN6Tm5PUytmTFFFZk5tQWZzRkFpOEV4VzlxTC84cTBlNXJOamJvQWpsNmFzZTNvZ09xYnVRM2M3bnpPbWllRW1xNm01cmpwK1h5ZDdZWnRMUFpGeXRWdmZjaDg3TkpjMDUxdTAwMFpFZjFkZHhLc3piTThrYVFmSm1jd21zRlcvYlNnRHpYUy9yV0szU3BxS2lyZm8xYmZtUlpxNjdxdWVYelRYV2QyL1kzZ3JOamdyMHVCU1IxMUFON2dBcjZFOHJyVWNMbVhON3FBQk42N2Zkekl4TXZnOXJxalIxMmo2WDZqY0RuZ0FheWpGUjd2LzlySTh3NlhKSDd2V0QyTUlmNjlsenk5bkV6WDlHdmovTzZua2d5OWNTM0puUHlubkp3Qk95N2pkeTNrRUsvakVoL3hFYS9qRFREeDlNc0JGMy94UXM3WjMzdk1uOTNNRXIvWVFwN1o5cnZBRGNBQndhempZZzdNRjIrL0tpL01oUDl0NUhCTzVtMmUyU0R2NXdsOHdKT2Q1UmxBOHNIODgwSlA4Z0VmeldKKzhRNncyR011NW1JTzV5cmZBQTZROUVsdnYvUkw5UnR2NVZHdThuNGF6REd2OUNldjlGTnY1RXR2NU4rYjJYRU96WW0rcUVQN3FLc05taGxRd1JEczZCWnNqMnNQMjFMTHBxdmR0SGd2MjdpdGtPWEluSUZYbllLWHRtaTdwcDhldy9HbVpTQko2c1JYbnJ0MVVnaE5jU0hsVkp3eEl0V1NIYjY2Y1drRk1Idm14T3dsRXhBd0FBVXdBS0pQK2g1aW45MUNMNGpMNnlHVFJodTRpcS9sZFFJR2l4TjRqRjdYY3c5cTRONUszNmRMZFVkbGRzbyszN3pJeC9ZcTdmNVg3aGhvZGRpdXJqZ05hclA0L0ZkWHZHMDVkWGNKZ0FLTzdoZis0T3dlbzl2L1QrRUVYcU0wR25RN2l1TC9hdUxzanVKWDNlRWo3cndISzcyaHJNbGlEZi9ObWNrT3JNbWgvTy93bjhseEhmRWNEeEFTSkhBWVdMQUJRWUVJRXhia1FKRGd3WWNTR2tpVWVOQ2lSQTRXTlRZODZDRER4QVlHSkJndzBDRERSd01PVXE1MDBLQ2x4UXd0WThiazBMSm1ScEFOUWpxUTRNREJ6Wk1mVDVwMFdiVGxTNTBOS0NSTlN1SGp5Nk5GRzRqUUNVS25nNlV2UlVUbGVyV3JUNWNjaE43ODZWTWxUNTg5ZlJwNDJwTmx6WklzVjg0OUczTUJTUlFrOVdZZ3laZnYzUXgzRnd5K2EwQ3c0Y09KQ3hzNEVCaUJZY2dMRGh5UUxIa3k1Y3VXTFI5QVFOa0FBUUlMQ0h6K1BQb0FBUVFFSmhPQW9ObzFhTml4WFF1QUlPQkEvd0hhQWxnTEtFQWdnRy9RdG4wWHFBMmhRSURqeVFOQVFONzh1UFBtQWFBSEdCQUFRQUVBMXJGanQ5NDkrM2Z2NEw5ejkxNWV2UG53QU5SYlY5K2VQZnYyOGVISGQ3Lyt2UGdDK1FjTUtNQi9BSVRyL3N2UE9PUElLNjg3Nlk2N0xydnRwSFB3UVFnamxCQkNBU2FNc0VJTUF4QUF3d3c3MUZDNkNqL2NjRU1DU0J5UmdBUUVTSEZGRlZ0a2tjVVJZOVN0UlJwVHBKR0JGUlBRVWNVY1hkelFSaFVaNERFQkJoQmdVVWdFV2hTU1JTT1RUQkpHSkYzRWNjY1hCWGhTUlNjVFFDMkJKSXUwa2tzZGk4U3hBZ1lxMExGSk1CRlFrOGdFeURTVHpTbWZiQktCSXNGODAwd2M4MFNUVGpySnBMTk1RQ3VvUUlJeUNTMlR6RUFaSVArMEFnUXFNSUJSUWQxc0ZBRkNKYUNVVWtZdGxXRFFTeVhJd0ZGTkh5VW9nNEVHcmNDaGhFUWFhU0FER3Nwb0lKQTRrbFVubkJxZ29WYW1jS1dWcWFReXFqV2puMmkxU1NhTG9KSXFxWmFXYW9BT3FaQmFTbGxlZWFWcUttcW5ncFlxYkpWOVZpbWRsaEtCQnhFbytGYUVjQnNBQVZxbW9GM0tLbk9Mb2tNRU9yRENLaWFYS0RpS3EzdU5hbFpmcUw1eXlTeWZua0lycnAzcThndXdERkFJekFIQVlEQmdCUU5nQ0N5bXM4NWFJREM5Qk1zTFlvWlRTZ3lCd2g2N3l6UEtRSzZzNU1vME8yM2xsVmtqampYWFdqNU5zcGg3YXkyL0FHNERFVUxta09PTkFPS09ZMDQ1b1pzYkdqcmxvbXV1dWdZVmhMQSs4QkxNcmpyazd2UC9qcnZxemh2Z08vcTQ3aHJxcitGN0QrencwSXNhUWUwQ1hEQy9BS3VtenJxc0UzUXV1ZVA0Yy9DNTZ3WU1tc0M2MFo3UVE4QjM5bERERTJVc2NVWVpFMWQ4eGhJYjl4RkdHMU5FRWNVZkJWaXk4aGF2dEZGSUlYMThjc1U2cmZSUmRDZS81SEZQSFZFMEVzY0RvalN5ZGRSalB6UE5OTVZrOUZCRS9aVDBVRFVwdGQyQTNvTVBIbEVHeWh5K2QwZ256VFJTU0JudDg5R1JJRFYrMGNjWWZWUk5SenY5OUZGVE9UajFlNGRBb3VoVm5XQ0ZkVmVJYnRXSkJsdWI0cFo5K05lUHY5djFwNkloZnZiYkYySCsvUE9QbHR2L0FmQlo1Vm9LK3dxb0ZCcUVTMXdVQU5jQ0NVZ0RDbENBQTdlQ1lBVERSUzRLSkZCY0VGU2dCWjhWLzhFSVZqQ0RGN3dmQnNtVlFCSmVVRndYVk9IK3dzWEJGaTZRQXVmaUFiY2FPSzUyT1lCY1U5RmhWMER3TG1hZDYxLy9BcGhaS0daRWo1aWxKMjZ4V01kVXNoSVkrQVFGUGxrQUZUc21HQmhjYkRBT3Uwc1dJWU9aa1EzbUFJWUJJMlZVSXhvenlndzBvZ2tOek16WVJ0Q3NyRFZBTzAwQlR0T2FtOTBHYUh2c1RXLzA2RWVjK2Vab1JGdE9JUW41SEVSZTUyMExjaHQ0NGhZM3EwRnlrZHdaRDM2bTFyWDUwR2RzbXJTUDF6WXBuMDZhVFRwUnk4NG9SN2tkQVBCbmJWVWpHZ1Eyc0lBSHdES1dFWWpBQ2xiQUFoSm9RSmNzMEtVR2tGQUNKSXdnbUNQQWdTNVhFSUVIUE1BNFc2T2tkUGhUZ0ZqQ0FBVXdXRUV5RjRBekMvOTl5RGNhd2cxdktuUzR4WVZ6Y1ZyYUhPbEV0NkVESk9BQTV5eFJPbTJqSmVFRUJ6YW5zVkxwc3BUT3lUR0FBRWdDVStoS0Z5VXJpVWxOUmVLVFFCblFPZ09JQ1hoaUlxandDSHBRUG1FdlU0cHlWRVV2aGIzckNRcWpsbm9VU1VieUdFdGxiMU9xRXNpbDJQSVlsRjRQZTQwYWFhYUE5MUtSa0FSVU1WMlZRQVJDcWxXMXFnS2sybW1uVGxVUWhuaHFKQW9CU2F0WUZSS0tIQ1NwNG1OS1JYcGxMUGR4YTF2cW9oOVYyRmV1K0ZuVlZ2dExZRmMzeUVJVXJqQ3NMZ1RoQlNjUXJyTk9JSU1Ub0lGYTc4ZFd1TGFWQWhPZ2ExM1ordFlJcWhXRWM5MHJYLzJxVnIyeTFhOTlGZXhmODJwV3RDYVdnVHlZNFFKNUFJTEh6bEQvQk9jNjE3akFWVmtRa091eURhaWh2SGdnTHhESWF5dEZKTzI5ekRMRnRRUXNpU3R3b3NkVWtoZUdTWEdLQzRBWUNnYVRzTVJFaGpDNzVTMWhLSE95Tm9xR01BV29UR2dtZzhiVFBNQTFyVG1OYWpiUTNEbmFqSTU5QkUwZjlXWmRvT0dNT0VvenBEUGRwaHhGVmdlUzlrbWJLSzFtU2ZPYURXeFEyK1I4UGtuZTgyYlRsT0paejlQOFpqWHVQT2UreUVsT0tnZUFnUTJ3WUFRRDdrRVBhaUNESGdTaHdBV3VRWUVKUE9BUjZES1hHc2psRkRTQWcxOUtXQU8wcEdVc2xZdXpFTWtOTnlMNlRlQkVGQ0oweW1oTnI3TlJra2lrVHNTdGM1MVJrckZ1dEpTYTA5eFlOMTBhYUdwOGJEbmIyR1l5YXJLTmsxQURVZFE0YWNVRi94MG9aeHFLdlNJbEZLVlQ1a3huSHRxWjNnRnZ5bXJLZ0pxMHJPV1ZVdXBSbjhxeWw5WEVnZXAxdWN0Z0RqUHdPSXJtajJadnB6bTFxVUJpZWlybzhVVWtwQ0xWbmtQQ0ZqNDM1S2dTS1VuNHdpY1JsTVJxSWp4cFZVaE00cXRkbGFVbVlYa3FwRDhpd1ZsOVJLcFJQYUFCWGNqQnJwYndmbk9sUVF6a09sZGZUQ0RWcFNhMVdtTlFWMUxUd0JlK2FIV3AyeXBYdmNaZ3JyQitOV0JkWGRkZVQwRFh3NTRyRHlid0Fic20rOWpDdHV1cmRhMXF2Z0kyMWJzR0xGK2ZuZW9KOE9EWkRGU3JzZk9hYlhCRDFySVR5T3k1UG5EQnlvNExCT3N1OTdvbis2MGZRdFlCb2FXM1QwSmJSTmFXVm9wcmdWZ1Y4ekxiMkZaeEFmOFdPUDlzQmE0U0xTSzh0N3RGek1sQU5zYkJFRUNab29IQUFTcHU4UVhnTVk1MnBMaHErcWpIUDJiM1p0YTlqUjN6RTdTVFk3ZS8yRG1haUYyT1NPNmlqYjdwMVZwNW1qbGY2bmlOYTJJTEpYd3hHVi8wVHEwN0JxcHZLV2wrODFLQ1I3OFBTaHJTZ3ZiTUFteUF1QnQ0d0JSRzhJRUZKempCVU5CNjFuc3c0QkpvWUFvNkdJR0JhOENISHZ3QXdUSlF1OXFEZ0dDdUt4akJEdGJBQXphUTNUNk82RGVFcTAyTlZTT2sxcFVvTlVWTzhXU0UzTTZZeFl3elZrSk5QVTIzc3M2Z0JqV2M0VXlTSnkvNXlPUFl4NVZQS1FPa3pKalRnTG5LbEtmOFM0WFh1OGtjZEFGbS92SmpYaG9xTjFmUDlHc0dIbDhRMEdWUE5jcWpNZVdBUjIvL3p4WlBmWW92bm1yVlNrNkNscHZhdE5FcEVlcEhoaXJwWUNIVkpEMTVGVnB3TXVtUDFDUlkyYjhKcjZCNmxLa3VxMXJjSXVDbUhZaENEWGIxMHlDRVlBVkhmV29JdXZwK3R5WTIvV1B3NmhNSU8vL092cit3bmMxc3V2cS9YdnUvL0p1QS9NdS9DekJBQTd5QUV6akFCTncvQ0p5QUJGeEFCVXpBQ1R6QXVtcEFCVVJBQlFUQUFVeTIvd3RBQUpUQVpKdkFDVlEyRkZ3MlpZczJDa0EyWXpNMkJVb3NCYUtzeDdLS3pKbzNlMkUzZXFPRGV5dXRmSnUzMDNJQTFBS1lLWnF0aHpsQ3dlQVkyaUtKZmlPTWhsczRLT1N0dTdzbTRTSXVpWk00ekhnQU8xSXU1Y0tqalB1ajJ5aTVQd3FhUFpvdWw4RzdsRXZEUllvT1Fwb08vNmRwSmthU0pLRHpwRlRLcExEcHBLL0p3L3BRcjZzUk9rWmlwTGZCR2xaNkcwSVV4UENTR2dVaEdrSnF1ZWRnRGtjc3BFYzhPZjQ2T1FoNEFCVFlqeFQ0Z0FIN2dMUDd1Z2d6QVJQUWdCRndBVGQ0Z1Jmb0Fpbm9BaUU0Z3hkZ3hWTVVnaTQ0QTFuY0JDTFloRE5ZUlNtUUFoZW9BUlJRQUk5cnJ0NmdvOWRRb3p1Q0dlWmlyc1JqR2RVSXZUUktJeXdycm9kN3hqR2FSc1lBbVllYlJzNkFBV3RjUFc1RUFHMmtSbXRrREhGOE9IRWNJOGpvakF5WVJtMHNESGJVQzdsZ0M1SndQWGpVTTc1d21MMEFEQzJhR01QSWdDaXFvb1RoQzQvWUNiK0lpYm1JaVNVS1NKV1l0SkpJaTdMd2xJbm92cWpRdEpmSXZtQXhGaDZVRi85M29RcDBDVCtPREJjYUdwZStZcis5Z3FzSWVqWVIrcllQRkVFQVJEWUJkTFlJakFFTTNMOEVoRWtEUElIN3M4a1l1SUNjYk1BVFlNQ2U3RWtHRE1xZkZNcWdaRUFaYU1BZGFNQ2p2QUFWS01xbVBBRVhHRXFwak1vTHVBQ3FiTXFtck1xbDNBR2pQSUdqN01rZDRBT3ZIRXV3TEVxZ2JNQ3FOTXUwck1xelBFdWQxTW1jekVrU3RFQzZTc0FhbUlDN0pFRmxpd0dXUkRhNzhzc1BhRUc2OGt0eUM3Y1pBcGR6VzdmSFdrd1FJSUhHMU1FZmNnQVNBRUlRS01MS3JFd2h6RXlGbVNhR1dZR0I4OHlCRzdoKzdLMElrS1hCS00xWWdpWFZIQXdQVTAyTFk0MEQ0TUlyVks0RmVLNktNN25iMEVMaWtEb3RkQ1crc1JuZ0xMbi9rOHN1a2RPUHZia3VTVFRPdkVrT1pxcEQ4YnFrQmNtYXJTa3ZPVFN2OXRpYXI4Rk9QZFREOXNLdk9Qd083QXhQOWRpYTZjd2FsbHViQllFQThRcEVBRkJQNXZBQWxxdWJSelFPNm1BT3UzbW1RbUxENkJna294RWFTaVREWmRvUEZ2Z0FxeXdES1pERldDU0NNeUFDTUpCRktDaUJEbEFBK0pRdWpkTTRPL0pDbUhrdTRUS3U1K3JDMkV5amlFT2pqRE11YnB6R2s1R01jc3lpTWpwUndTQ01MQXFNQmNpaUxzcEhMYm90enhpTWhrTU1HY1ZSSGowQUdaWFJpY0ZIdjRnWUlqMjR1OWpNZ0V0U3VYQ1l3SkNZaXdrTWlGa0Jpb0d0ek5UTUkwb2lnREdLSGpLWGV4a3RnSWtYcHppS3o0ck1HdExCeVpJc3lvSXNkdnVXLzhZaXR3Z0NGOGFpTEw5aXJHSVRnY0FFdHpzMXRnL0FOaFZrU1diank3aUV5N1Frd1JySXlSclF5VU9WUUtsa1M3RTB5MGJseWd2Z3lxUTh5cWJjeWhPUTFFamRBUm5ZQWF6VVZFMTFBVS9sMUIzWWdSa1lWUlhnMUZNdDFWUWxWVTVWVlJWUWdSbDQxVmQxZ1ZpTlZWaVZWVnR0VlZNZFZWRkYxVjQ5VlJXUWdXQU4xaDBBVldFVjFsNFYxVlBsMVdUVlZLdzhnVXFGeXFDVWdiUjBnYlZNUzJxOVZtMTl5eGlvQVFMbHhKejhnSEM5Z0E5QU5uRTFWM05kdG5SZDEzSXRWenNGZ1E5WXR3OUlBUkNnVjNvRmdTbDRUTVYwek1sY0FSQllBUkx3VjRDMUpZSXRXRnRDQVJSWUFZVE5JcyswcllTMXhBZGdnV1FxVFdSYUFQOWtvbGhacXRoazJsaU9UU1lGOE0wSEdBQXQxRTBxakRwb3VxWU5VTStRZGFYL1NGbittTkFDOElBQ0VSRDE3SSthM1krWWZkbitZTG43M0ZsSDJqbnl6TG4rVUErbjJVN3BOQStpdlNSVXdvNVVhbHJ4M0JvUENOcWxkZHBVOG9BQWlGb0F3ZG4vR0FBRjJObVg5WThCaU5xb2pkbW5LeERpMk5xdzlRLzFERnViL2RvQ2djOEpMUkRqNk0zamRGa01zTmtDdUZ0bFN0bTluVnRvY3FYYUxBQUZ3QUFMS0lFY2lFVW8ySVJOMklJdElBSW9RSUlPR0lDVWpUcSsrVUl1cEVMZlRObVVsWXdIb0F3SXlMaVNqYVZLL0MzaHlrTFdaTkVvM0NMUjlEQVlzRVFadFVSWW1pYlJGRGpWVmQwZGpaaTc4TXlBRzR3b25WM2FJb3ovempRTTI5TGQwSndtNDVVbWFab21oVjBCNUJWTmh6VmVoWlVtZ24yWUtZb2l6aHc0QjhnMzdmVUoxdHJlN3AyaXliUTN5cHczZjVYTU1lWEJ6NXBNeDJTM01aMDN4WXhYeDR4WGVZMVgrb1ZYSHFqZmNqMjJkWVZYRUtnclpDTlh2RXhYYnlYWHV5eGd2S3hLQXBWQUFyMkFRejNVYlFYS0N6aktwWXpXU0sxZ3JqeEthNzNnVFpXQkRTNVdVdDFVVUMxVlRaMEJHUkNHVjQzVk1wZ0JXbjNWTWxBQktWRGhGNTZCRko0QkdxN2hHbjRCRzM2QlVwd0JIY1poTitCaEh2N2hIZjdoRjJpQ0hBWmlJNTZCSkU2Q0dTakZIUzdpSGpaaUkyWmlLbFppSG1aaUhEWkZJelpGSUFiaUxNN2lHb1pWSVlqVkYzWUJNNmJoVzAxai94TG0xR01kVm1mZFZFMk5ZR3ExMWpuZVZtMzlBUVp1WUFhdXloclFZMDRrNEhZTlpQME41QS9BZ1hMRkFhdjdBQklnZ1JGWTVFWmVaQjRnZ1VpTzVFVmU1SUcxNUlEVmdJUkZBUkpBQVUzdTVGb0taUlFJWll1RmdZdTEySTdkV0dUcVdBeElaYnQ3WmFwNzVaQ2RaWkhsRHd4bzJRT1kzS0NaMFA4QUFQajA1ZjdBV2EvMVd1cEl1VWs4T2Y4bzVxbGwydmpRempyOHcwWGFEMm1lNW1CRzI1eUZUN0RkRDdFZFpteU8yY21WT3ZmOGo1cjFBSmN0a0x1RmdLN2xXdmZzMm8vdFdnOWdaM1NHSnBHRkptOTJKWEt1NWJ5dDUzbSsyM3orMkh5bTU1RlZnR1FTMlFmQUFIUitBSEsrV3dEemdBY1E2QTFvWlFDVFpReUlnUCtKdnFWV3BycmExRng1M2dCeXJzUksvRnZOaGFYUGhRQ1NucmkvamMzUThEQ01qbVZaMmxpTXRxYU56VmhVUG1XT2xTVVVlSUNLWFdXWGZtaXVEZVpobm1iL0lOdXRyV1p2NW84TmVDYisrRmpKSGR1ZEpZNnVSYm1SamJxanRqdXBobVV0MUZ1Q0Z1aFdMbWlxbzdvTzJJQ3Z4dWpTdkdteVRzM2xwVmljeHVsUkhtVzF2dGprdGFVSUdHVU9ZNEVVOEZjVXNOZDZ2VmQyVytUR3JPUzY3bVFTcU9zVUlBRmNxdVQxalY5QzdtTWN1TG9DNWtUSDl0WStIdUErSnRjOTFsWnJkWUVmd0d6TlZnRXp2dXdjTUdNWjZHd3oxc1VXcGxWYWxRSllKV01hanVIVWxnSWgvbUpUZEFNc2JnSlRmSUVrTUVWV1ZBSWllQUVpU0FML0pWQ0NMOUR0My80Q0l2Z0NJeWp1NHk0Q0k4Z0NJMUR1SWlpQ0xTZ0M1cGJ1NW83dUxUQ0NMV0R1Nk1idUlpQ0M0OTRDNHlhQzdqN3U1aFp2NGpZQzQwWnY4dmJ1N201djgyNXY0dTd1SkRodUpaanYrallDM3Y1dEl2aHQzbjRCSmVodi96YkYvLzd2Mmk1d0ZSQ0NGemh3em9aVjB6WnRJWEFCRitic3p1WnNxNFRLeTdaS0RNZHNES2ZXUThWalBjYmpINGhzRVk5c1RvVHNEOUNCZHNXQkdrQnhGUzlrYnkxa0hsaHNlQ1VCUlRac3c2WXdnTlZrRnVnd0h1Znh0QjdjZ3VacUlkOVlhSHBsZ1o1bmp1Wm9vYTVaQVBDRlMrQUIvd0pxQUxnR1pVZ2xueVhQOFd4YXAyVmFMSGZhdEJGUE85eE9QUlRQcmxsUDg1eWEvMnJXV3BWdDIxdCs1NmlWVUpFRk1MMWw1U0RIZ01GVkFJSFc2bzF0NVR1M2N3d1EyN1NOMnFFV1d6Zi9MN0pONkZzKzZxMVZKandmM0lmVzZxNjJ1NFdlNWExMjVWUnUzU0RmOHdlQWdZbkdnRTZQZ0E2Z2FBQW9nazdRQW1ud0FnV0lnRmhXZGJ0VDlVaVBaYkQyZEVtMzZvbE42MXBISm9oT3BxMmU2TFJXOVp2V2FVK1BBQUJRaGlwWGdBNjQ2RmVlNkEyZ3VrWjM5RlN1OUlhVzVXU2l1b2hPYXdzb2FJcE9wcSsrMkEyNGFWdFBhMVR1ZFZYRzZSNi9XQTY3NjdsT2R4WkFnUjJuYXhaWWdSUm85M2lQQUhsdmQzb243TUFPYkFvYjdCVFk5MTdLSllBUCtDa0FlQTBvZ2JDTHNMRFRnQlNJTUIvQWdSTFFBUnhRZ1A4V3dJRVFzSUFVTUdRY3NBQStxSUVXK0lJWENJSFB4Z0Vib0FKdHdBSWJDQUV3VUlSRWVBSWpVSUlia0lJY3dJRWlhRW9yY0lHT3A0UVFLSUVMU0FJZFdBSVpJRHV5UTRJVnI0RVFpR3djQ1BFZlNIcWxYM284emdHbWJ6dTJ5NEVJZHZvTHlBRVpzSHJSN213aFVQQVhjSUd1ZndFcEFQc1hkb014dHUwQ1IvQUMvKzM1em9JaTBPL2ZGZ0lsTUlJa2NHN2xibTdwem9Jc3dBSzkzM3NzOElJNjhIc3Y4SUkzOEFJdEdQekFQM3d2QUFUQ0IveS9yd01zY1B3NmNQd284SUlvMElMQTF3TEw5NEsrcndQTWI0UEk5L3cyYUlQQUQzM1Nyd1BQajN6T2J3TTRNQU00OEh3NHNIek85d0l3aUlLOTk0Szh4M3U3Zis2Mi8yMy8zdC85MnZaNkZVandyWmZWckMvK3pzN3dxclRXcWsvNmFrMUxEOC9qRWlmWEQ3QUJUZ3dCY3NXQnhjWitSR2JrU3FZd0NzdWxGZENBOEsrbERkdHhFb2lBODE5M2VsOS9EdU93Vk9aMlNYOW9qelh5RFhCb2dSWmM0K2hhUmRkbW9BYUlBUU1LRE5nZzhPQkJnd29HS0dnSVFFRUtDd1diWEJBSTRPS09KQ2d1TG9BeEFFQ0JpeUkvZm9TUVFXVElrQUJJcm16NVVTVE1tQUloQ1BRUWN5VkRCYnNvcmNJd3dvK1BFU00wZkFEZ0FRT0xGUmdFS3NBUUFVQWFhekU4QVVpUjVvS01HVTNjdUVFS1lGVXFNZ0ZXWER3bzdHSVRIazJka3VpZ2djVFNKaklVQUxEQVpJbWZGaVlzS05EQlpJQVBEVU0xZkxRQUFNWkZGaG9zLzFnSXdZV1FJV1hYTEpBd2tjWlVFd0FSSG14MnFrREdLaE9mRVRYcHdZZFBCeE5UT0svUXdDSkNCd3ROTk14UTRXTUdqeEd6YXdocjBxUkdFaHhmNWxoSm80TEtuQnczemxBcEE0QVZSU3NrUERWeGV4R0g0QkFoY3RRWTJ1Rjc2c0Fta254QjBpTk9qaDVQcnNoaEFtQklqeElhTkdCWDBFUkZEY1lqZG54NHFtQkVEUU4wb05pQUduelJoQVZ2dlJVQmc3QXhPTUFYckNpZ1FRb1JXSEJCREJiQTlsMEVlM1dRUWdjUkxEVUFCaHFTOEFGblRqRVlJb01WdHNqZ2F3NVd5QUlBU1NUQm1GWUo2amJERHI3dGdxQVBFYmlXQWd0RUJqa2ZrUXpPSitSOEZEYjU1SlB5SVNGWUNVamdzRVFKUGtpSjNRanlEYmFZQmliUXAvK0JmQ1dVTUFKak9LajVWZ2trdEhtbURpTmNOQVFuVk13Z0JCZHFZQUdHR29Oa01jY05WTGdSZ2hXcmhOQkRuRGpvTUVNYVRMQWlRdzJHL01DRVpUT2NLVlNjY1paZ1FRazZaRnBERGorNGtJTU5UeHdoaEJwRy9ObUdGMVJZUWNVWldRaWhCQlZ4WkNISUYxVGtPUWNZVkJ5VENCQmNoR0ZFR0Z4UVFjVVhTcndneEF4bnZMRHNDMmVjb1FRUjA4NzZBclZLYUt1RUVVb1VRWVcyMFJvUmhSZEZHSEZ1Rm9OZ3NRVWUwTlJSQnhaZVBBTEpJNDlva1FpK1dzQnhyeHFLRUJLTUlHR0lNb3drd2FBaWpTYWF4UExKTE1zVU0wa3Z2U1FEaXlPejRBTExNTGlJSXNvZGI3d0JDQ0RJU0RKeUtXK1Vjb2NrSmI5eEI4ZkxnQXovQnh5QTZBdUhLTUI4d3Mwb2s4Q0JEY3QzZkZJTU41andjb2ZOeUF4dHpCMjQzTEZIMHJ6d2dnczJycmlDelNlZFBGSktLWm9zZzBvVTVIcUJSU0tOZUFIR3VVWVVjWGEzWUJRaEN4WkpLS3ZFckVJc0crNnpkZHVkeEF0SnVQRkNFelBNa0lUZmZkL250OTh1cUNDRUN5NGdub1Bpak9md2VIbzkvUEJERHpWTVhya09OVlNPS09ZMTZQQ0JEQ3JvWU1JWFZ0Z1FwMUNkWmpFREV5RTAxbGdUYWJEU3dnOUpoQ0NERlJmSVo4RWNnZ0FCQkE0cENHWkNtN3JWUUZHRkxwNFl3WWtma1BCOEJDVlE4VUpkS1Fpemcyd3p0RkFoQUUza09zY1BEMW1RUkJNdGtNQktHZzhKOU1BbFpEQUVBQmxOa01ERFFBb1VjTDhIS01CQS94QkJBMW4wMGtIdTF6OEFybzh1WjVCRUZBN3lnUXZnNEFNNEdBQmZNSUFCZzVSbEFBRjRTR3dhc3BDeXRPUWlGM3dKQURaQWtCQ1NvU2c4U01NREFBQUtVOGhBSkR4UVJoSU9NaEl5a0dFa0FIZ0FpZ1N5Z1phZ0lEWXprTUVIVkdDREdYQ0JETEl3UlRVQW9BRVgvR1V0TFBpT0QwaWxPQ1lNWVFoY1VFUVVqQ0NFSWVTS0NUT1lRd3Nza0JvdWZBRUEzOEZBVXloSW9nb3VoQ0VqV29nQ050Q2dDRHhSTU41aENBdHFNSU5UOElHREh5bUFUUVpBRTRRY2hDNHRnY0JGSG5BVUNZcW9LV1ljRUFDWUFRcmNUV0VWWm9pR0d5cFJEVU80QVFBWWlFWVlMRkNHSzVqQkNGQ0FBdGtpRVlZd3pPRU1Xc3hDdDZRd0JDcUVZZjhUTndpREVLQVFoUFc0cDFNL0tBRUx4RFFVSWpYaEEySnlqUWJvMkFFQlllQTdjbEdBWXFEQ0RQRmxLUVVqQ0lHYVN2QUY3QVdHUXNJamlnN2NrZ0w1aElBK0lXaEJDY1JFRnhra3dRcGNlRUVXdmlDTElTQkNGbEpnUWd1WW9JTVNhRTRIUy9CbkQzcUFseElzb2FBOU9HVU9nSURMSjhoaENRSVZLQkl3RmRFUlJCUUpWaElNRWtnUVVVVmQwd2M0S0VIc1BsQUQrVUFwTmtnaUV3bW1nSjJQNG1BRWFxcWRjWlE0aFJKTVlUNWNzdWw4dWxRbU0zV3BCVitnaEd6VXdBVWxQQ0VPUWpqcTJjSmdoVnZHSWhpT2NBUXRxRUVOV2lTanF0S1F4akFJSWRWT0NDSVdrSWlDSTZpaENXazRRaE53ZU1ZenBtRUtaZVRwQzMvL2E4SWdGQkV4UWtBQ0VubklCUmJha0lWZFdNRU1paEJFRzlSbUJDSW9JUXRVYUFNY3pOQlhaakRXRUpYZ2hCdUVCWVkxZ0NFU1JsQUVKTjRBcnlqRXE2L0ZJc0lnUXJ1RlFiVEJERzA0TEduTllOclNqcllOamNERXo0cHhDR0ljQWhqQkFFWWpMQUdJWVF3REdicHRSQnN3Z1lsR0xHTVp0cWdFTVZwUmpGYTBvaExOdFVVam9oRU1VSzRTRHBCQXhydzBBUWxMV0NJVHdNQUV2ckNoaTFvazR4YXFxSVV4ak5FSlNieEJFWW9ZUmlPcVVBVXdKSUlReDdqdkhBeHhOaXBNWXc1b0ZVUW9ORUdJUHBSQ0ViRjRoQ0kwOFloRlJPRVIwTUJzRmFLd2lFeVFvaG5OcUlVZU90RUpMM1FpRm5TTlJjSTBrUXhOMUNJV1pVMkcvelFJVVF5Z1RXSVVvekJGS01Ed0FoZElJUWRseUlFVWNpd0ZHemhoRFlsUUJDdlZRQVVoVU1FTVFnQ0NFQ0FIdVRqSW9MQ2tRZ1VoRXVFRVFzVENDVVVRUWh3Q3FvTlF4UWNKUDRqREVyclVKSm9Dd0JCMFpZUWNodENDRUZUVEI5OFJqQTljNEMwWEtNb0VLZkJCRWJBUU1DeEVvYjZ4UUlVaVVBRUpKNFNCRUY1b3dRVk1JWWlGV0dBR09WQVVDVVMwbVEwOG9OSXNnSUVZTUkwQk1ZaGgwekNRNEVXYW9rZ0JMb1VnRUtnMEJPeUhBWUpVK2dFRm1HQUVVakFES1Z5QkJVamdnd1pDZEJFSzdJQ0R0RW9FMTNRRkFDdFlnU29pc1lJaGJ2SVFFZ3hiRUVWd0hRQnFjSUVPMEtVSGVvcERISDR3cXhLMGNRQVJDQUVWdlA5Z2d4SThKQUlLUUVFTE5OTVE0ZFdGQllieGdXZ0k2WklLRm5JbEdwekJCWnFRYkZhVTBVSTJDSUVDVk5BQ2h0Z2xCRGE0aUZBMGdBRUFuRWdEUElnQWlSUndGRFZTK2dFRDRFRU52M0NLaGd4QTJ0QmtnUmg4WUFkbjJDRUlmdENBR0VqZUJUZklTWVpwcUdFQUE2bkJBYXpnQXl6UUlCeFo0QU14aXJFREMzK0lEeHFpZ3pDRXp3VGxwTXNndUFDQUZ1amdJb1l4eEM2VzNvS3BMMlRxQXdpQjB6V3doQkNBOENKWUI4QWxMbUFCR2dHQUM2eVFndVJ5bklNbnRHQWFyQUNBYUQ2UUJoTUFRQm1tdU1pRzBLZ0FMcWlBTDNSVWdBVkdRRDZJVzhFRkpFSmpwVEh3QURST1VQRVBTUFhpUmQyQkRiREk1eHc2WXdvVk1LRC9KMFlBQlN6NHZHdWcyQUVrMkFVSk92Y0JwMGNRUGdzc3dhSml1TUxlcEVDRVZkN2dDZXNaRGhla1lJR0E1a0J1TndEQ0RhN2cwRGdFd1V3OGJzRVFrZ3lFTEI5VnoyMFFnZzF5WUlRemhDQUpYTUNCUG5WZ0FTUXdJUTAxQUh6UGsyZUNHckRpQldzZWdsR1BFSUlRblhHRFhMQ0Nkc3gwVGh0b2dPazZDRk1LN0N3OE94OHpCRmZvQVJJc3dSV1lSd2xRRHVVRUZLRVlRZ3M4Z1VVQkNDTElnQXo4WHhrUUFSRUV3VEZnQWhBRWpCRXN4eG5VM2hVSTN4S3NSdzc4WHc5OG9BNGdDdTU0eWcvVWdBeUl5Z1hrZ0F3d1RndE96cWlNaWd6MEFBUW16bEVKZ1JNY0FlTklRUmxBZ1JRSUlSUzRRQms4Z1ZCQlFWNXBnUlpnLzAwbjhOWWRQTUliU0lJaWlFSXd3RUVkYUFFZTRJRVR1RUl0SUl4MlBVSW1NRUlWeEFJbTNNSXR3TUllT0FJc1VFd2Iwc0loekVJdnpNSWU3RUViUGhWVXFXRTIxT0VlNE1JZTdzRWVxaUVwTUEwMmxNSXNhQUl5Tk1JY3NKSWhHQUlsVUlLUUhZc1ZuQTBYR0VJakRNSzVBSUVpZEVJZTNJSVhSQUVZWUVFV2dJSGFRRUdTNVJKNkRLRVFtSUVhVkVFbjBBS1YyV0V0akVFZzZBRXBrTUl0MU5XZWJFSVZxQktVRVVJWU9JRVRHQUVxQ0lJaTJNQWdDRUVYUEFNb3RNRC9SVTRQSUY5QTlZQVV5QURxaEJrU0pJcGc1RlFOVEFtVXBFQTJPWW53ZEFpSXBJQTU2cDhKcE1hSHBNWTV3dHVkeGRxSDVGOEtzSm1aeUVlNnBmOWpCL2hBUmNHYmhneklDRnpCVDVqZVJZaEJGNHdBQnZoQkVDUmtFRUJCRi9pQnZhMUVCM2lTYTNCQzFBMkFUWWpFcC9rQUppd0RFUmpGUmFTQ0tmQ0ZSOVpkRXVGRTF5a2JTcWFrU3E0a1M3SWtDTEhFU2JMRXZIVlFCOEhrdkJFU1U3U1JVOFFHZUdDQUIvd2tBUHpCS3B6Q200MEFwN0dBSDBURElNQkJJOVNCS0JUWEw5ekFMeVJYSzJ6RFFmNkVRaExCTmd4Q0Y5eUFRZ2FCTTBqQkw3V0FEYUNUQW53Qkp3d0NFVnlCQml5a0ZyRFhZZDBBRVVTREdTRGtFZlFpMWluQXBiREFCZFRRVjdEQ0RkUUJNbnlDSTN6Q01ud0NMU2lDRndCQkZJaENKeVJDSjBUQkdtQUJLcUNDRFF5QkRVQUNOVkFCQUVRSUFQeEFHRkQvd1JPd0dlY3NRUTR3R1JLWWdORWxpT2NZbFJ5d2h4QWtBaFV3aHFUNTNHWjBBR2M0Q0FEd3hFV3N3dHV0aFFMd2dEVmt4aUloeGdxRjJnTllRRzVHd0FTb0JhVlpBT1ZGSGlNcDB6S0owUk5abnM3SndDNXNYSk1JUlJDTWdCMU15UlQ0d0NwUUFoL0lnRFpRUXZkc0p5TG8zQi84d1Fqd3dlNGw1QnJBd1NGNGxXa0ZReHRzd1EzWXdDbjFRQm5JUURZaWdlZmtnS2N3QVJQZ1FBaEVXb09zd0FwRUFBaVV3YVJVVGpLUlFBcVFRWWE4U1BKc3lIZG9IbXlvaVE3Z2dBbVFRQTI0R3dsVXpnVXNYUWpvd0JhRkViWk0zWGNZeGtQVUJiYzFnUlU4UVZCMHlSVFVRQm5JaFRCY1FBMWczUURrVTdxbGdSWE1xRWhzYUFvOC84OEtaRkFjbk1FbWdFRVU2RXNPQkI0Zk5JVVBuRjhRTU1FVDNFQU9VTUVnYkVJakJNT1ltZ0VSbUVFckVBTWhDTUVUSEFNeEVNTXhYRUduK1lBUExOeEJ1c0VwSkNRaVFFRUlQSUZDNWtBWFNFc1hSTU14QUZkRCtvQWZPQWNBOE1FdUpJR2lEUUluSEFNekRJSVpoTUZVTXBZMmNBSW5UTU12TU1NckRNSXFWSUlkY0VJcUJFRVh0QUVvRFVJSERzRVJTRUVTcEVFYThGVzRlVUVlT0VFeG1rRWlhTUVjbUVJYXlJRUx2TUFKOE1GSDJFRDAzVUFSekVFdmZNSWh0SmlMTmF1empnSTNOQU0zZklJMDRNSW5EQU12a0FJMW9BSWpXSUlyNklJdXpFSXNCRUlrWkFFRmFnRXRhSUVUQUVFV3NFc2pFRU1WMUFFZ1dBSWVBUC9CSWRCQ0tBVENJcnlCSlhqTU1Dd0RNbXdoSU5SQkpHZ0JNQWlDSmVUQkc5UU1KcUNNYitIQkZwZ0JJcmdCRldBQk1jeUJFOXdBTTVnQk16ekRHdGpBRGN3Qm9GeEJHVmlVRmNoQ0dmQUJhY2hBQ1F5QTk4UVJUbFRRcXdHZURTeEJmMkxiRUZCS3QxM0UvUlJTVHVaZkNCalY3MUFCTXVpQkhvekJHSVJDRk9RQkk2aWZJVkFCRUZTQk1EcEJDREFCYkd4QUc1VkZTTHhFQUZoUVM2N2tCY0hBSmZRUkFIZ0NEZGpRMXlyYlNjS0VSZERrLzhnUXZiMEVLeGliU0NEU1JjUkFIMW5rSU1Va1FteEFNNDBBc3hVQktzekJOQURBdDVTZElEeURJS2lCRlpEbGRoVEhROUJGQ0lBWUZhUVBKVmdEL0pDQk1QQkJOMDdCQ1BqL1FEV2t3amI4Z1IyWUFTZDR3QTJZd1M4Z2drZENBUkZzd1RJd1Z5VUV3M0s5UWlWVUFtNUpnaWcwZ2lBMFFxVnlBUlRjUUJ5OHdCZE1nVVYwQWZJR2dSaVlwTDBOQUIrUXdhZnRwalpNeFJSOHdDbDhBUVQ2d2NvUlFSYzR3M2Z5Z1duSWdBOWtCUkZnYnc5b0FKM3lBUkZnUWpDc3dScGNnUWtzd1FVZ2dROElRUlRjQUl0VVdvZnNCZU8wUUE2b0FPbkp3QmUwQUhyQUd3NjB3TGUwNGliRWdRNkFRUjJvUWRkRVFTUkVMYTA0UVM2VXd0WHdnaW84Z3RMMlFSOGNRUlZ4Z1F0NHpCRWtDSUlxd0JTSVJHeXMyZFFOd1h6dzB3ajBRQTVNWFE4SVFSRW9nU0ZrUVFqOFU3b3hSbXdBd0lwcWdBS01DeVFJQWR5RnlWNDAvMFVZTVVaajZNQ3kxTmdTTUFINE1jRWdKSUVuMlNZSjJKRkkxVUFOVEowWlJkUUYvTUI4L0FFU2ZJRWFlSUVXM2NENS9vRW5rQUVOK0FKQ0pvRUx0RjRIeUVBd2FBSVE3TEFmL0VBRXRrRWJ1Tzh1WVVrSW5FRWkxSUVYMUVFdTRLZytodUFUOU03WVZNRVJTRUluSEVFTHlJRHNBVUVrSkd3djRrRWtkSExLWk1JYTNNQmVsRjBTZFFIM21qS2tWaW9udEFFUjNJRDdic0VXckFFc3Q4RWczSUFmdEFFV0VFRWt0RUVpUnNJTi9ISWQ4S2NyQjBFb3J3RUZWaUNpTHFUclVtcGkxY0VtVU9BZ2JFRVhNS1FaUU1HQTBLbENtbklGbXFxWnZ1NFcxRUVwNE1JdzNFRXBJRU1vYjBFMGJFRXI2OUl1QlFFaTNBQVNNT0RXZGYvcEZmenlGZGplRXd4Qm4xNkJBc2dCR0ZSQkhsUkJMb0JCS05pQ2k5bUNJR2lCaDJIQ01NeldKRXhDTVFEREhkU0JKV0ROSFF3c0hyanZNYXN6Rk1UQkI0clVFZ3lCRlh6QkVDeUJEWXowaXViQTJUaEJEb0NCRlNUQnVEWFFCOHowQXAyQVRVOEFKU2lEM1kyQ01sRENyallCRnp6REZoU0xEUWpCdUxSQkpPaHVMZ1RmRGJpaUlzaU5DOHlCRWNpQkRieXVGQlJCRGl5QkREU0I5dTF3QytnbGdtb0srbExJbEZSSlNkdnNFd2pCWFRLQ0t6eFZJVURWSU5LQ01aQUNKSVNDRTNUQzdJUkF2R2tRMXZyUFFQZ1JCOUZrMmc1MlNyWXRZUjgyWXNPRTNkcHRZZ2YyUlZ5Q010Q3QyczRrVEs1dFkxL1FCZlVQMitKRUFUei9ubVVUdGtvQXdBV0JyUWVsN1dpNzVFeUt4R2xYdGd6SkpFbmdKQUNnd0FvTXhBWVlCRUY0d0VkMHdIbVN3TXpWcEcvTG0wV3k3VXhjaEF3Z0FnVjZyeC80UWNqQm01WUU2UWg4d0Evb3dCSGM4eFpJUWpUQVFSZVUyL0Zjd0Fla3dBNmg1TlNsUUZub1hVTTBFOGNaRWt4Z2dBK1FuVWk0UVJJTTJkbTBnQkI0Z1JmWTBpbmwwaWwxSlVQZWdCVG85NVlDd0NCb1FSM2dnY2ZnZ1NXc2dSamNuRU13aEJzNVhnUlFuZ0w0UUJkTVlEUy9yaXhYeXhrUWdSUnNBU2EwZ1N0RkFTUVFncENCd2l1NFdDcUFBZzJRZ1Mvd2dhajhnRVRBYlFvVkFTRndnUUs0VGd0UTI4dzFoRUg4ajB0Z3RtaUxkZ0FFZ0VvQWtFdmc1TnVDL3hBY05VUU56UFNPdHkwaXZZUWNtZHNmWWZZZk1lOUx3aVJCcUJFS2RGdE81SGlYbzFHWGMvbENEUGtEYkRuT3daRTRBcDZhWnhCZjRGeXNnYU1heU1vUUJBb1ZGSUdRQ1pVVnNFSVMySFFJcEFBSXBNQUhvQUNFcGtBTnFJQUsrSVp2bkFBWm5NQWwyRFNqWHdLa056b0lpRVJqWEFDUTlyazVwb0NnenhFS2JBQUtvSUFCb0lBRE9FQUROSUFFTk1BSnBNRUVOSUFJaUVDcHU3cXBtN29CMUxaQlhFSm1iTkFBZkJFWGJFSVdLTU0wTUFNUm5NTFAyY1FwY0lJRlZFTnpsWGgvMlFMNlFKejlDRkRQeXVSTi9QVkliSkJJNE56YmdnUkllRzFqZDd1M2Z6dTRoN3ZYR1lJZ3hNQktkaDBKWE1CR3lFVFhEbmtCdEh0TUtQK0RMZmhsVTd4RXBRMDJ6VG0yRFpFRXBWbDdZYU50QmUyN1lKTUl4dkdBYWx2UVg0T1FCL3lCR0xqQldXeTJ0TC9Fd2pzOFNuNjJZZThtNXBJRWVzdUV3QXMzVHNvUngvRzRadU9FQWp6QXArSGtBTDMyQUxUYWVjT1JDQjA1M0hhOHg4UHRhd2UyeXErQVI2aDhRWmdiSEJYU1RJTTVnK2RreitlRTN6SUlZN1FBRUd3Q0VLaGZIRUNCN2Rtc0hIanBVY1hLRmhqQlBjWEdBR2dBRUxXNUczVjVERURjUzRoUmczQnhUZ2dJTlVhQkJ0ZWhKZ2hDMlNtZERZQUJJTnhpSi9RQzIzOFJOYWlCQlJRQkY4eXdYdHZBdU9UcUMrQUFSQmhDR055QktpeENHelVFMkJNU1JheGJEaWdCR0l4TkNjc2JDeXhBekpOQVF1VkFDT3ovQUFwZC9Nd2JlY3lLeE9Od0hlQ3gwWm1mK1FEUlJkYzVoUXpoZ0JIWUFFSkViczkzVzlmR3JVbUdQSmMzT1VJb3dPS1hmY2dEd0M2a3FFa3lCUUQwd0ZlcGVaTHp1RjhYUkJ3SlJBSEVFYTBYd0FZUXdBSlVmNmd2QUszMzllNXZrQVY4MU5EdmZpSHBPTWQ1ZlAray9QQWp4QWlSUk04T2tFSU1STmUyTFd2SC9JL3JPOXFxdkdDTHUwcEtPN2gvTnI0RHhBQUFCUW9BTUhnUW9VRUlDUTBLRk1qUVlBQ0lBQ0RRZ1VEUUF3QTdsYTVOYkhod2pqSUFDaFNZS01HRUpFa0xBQVQxYXVMRVM3TmVuYXBnd2FIZ29jZUVCUllRQ0NEeG9FT2RDbnJJR0RJaWhZWVBJeUlvQURCQXFOQUhQNFRreVZPbGlwTTVjeVJNa0dCZy8wUE9nMDBvOFdnNEFtMEVnUVVMREdnYjFlMkRCMjZoRHRoQTBrY0hCU3hJNEh3SVZRR0dEaDE4TUZseWhZbUp3NGlwR0FJU0tVOG1iS1h5TUdJa3hFYUlGaVZlL0NpUm9vT0ZsRkViUmtDQmd3Um92d011ZkJBTmVFQUVFaDBpcE1DZ3dJSUdCUjM0bFBIekJNbVZKMHdzbUlodzIyOUszQllzRE1DdDhqbnpEaVphdEFpaHVYb0s3U0ZzMkFBVENyeWNGa1M1U0dFU29ncWtadFFlOWFrQ3BFb2dVdXZmOURreXBJUUZLMVpzQUFIVVNZK3Nqbmhpd0J0dVdHTU5QRW9aWnBoWllJRmxqejFnbVdXV1F4elp3NWlyRm5GRkZXT2swY1NSUXc1eEVKWnNKcnpEbFQ2QU9BSXlyUFRJSklvYkRzSkFpamt1QUFBVldoeEpwdjhXSjg1NzRLME5ER3JySUFVMHdHR0pIT0pnQW9CTExobXBCQjJjb0lJUUxpeG93WVRpVWtpcEJ5OUtxWVdVUmJUUXlnb0YxR2pHaXBGVVlxRXBxSjU2cWk2QkZBakJFRFZHcXV0Tk54R3FiYnlWQUpqR2xJWlVzZ0E1QlZwd2pvUUxVdXFnaFRNU0NhV1dSYWpvcFlqeFdnRGdHVnV1NUk0N0o2cm9BMVJRR2VIdUNDZUVVS1FJUmtyUm80OHh4Z2pFMVZwcVVmR0dJZVNRWTZVZXdBZ2trRDcwZU9TSWdjVDZ5Q0FlS0VuREtUeWZ1Z3VBTDJLQlJSTW5oSFV1emdmVVdpMG5PVFVJb29zeUJvR2pqVng2RUUwNWJLRjZDeUhuTm9nZ3JMQUc2R0FLRWtiNGdJUUkyTDByemhrQk9DRU5qd2FBNEFFV0ZtQUJCYmtlZ01EL3pRSTJ1RXVCRkdvb3dRUVREQ3VoQkJ1cUcyS1RUNTFRWkpKRTdueHJyWFFQOG9Ca0FFb2VpYms3Mzh4elpZY0tNQmVBR2FqQXdVODlHNW91aEloYmVBMGlraGd0enJvUUp2YnpLYmxRUUdFRkZEQW9xQzYvZ0hyQUlNMFd4a201T04zTlZ5Y0FWdGxtaEJvMHlCcnNkQmVDcUM0ZTZNaWFqQ2VKaFpvaEJTNDVJZXk0ZGNLQUQ3UGdyR3NEaE84T2l1ODQ5ZFNHRWppWi9vdGFCUXhoQllBSU5Iak5UYXhSUUdLSThhZ21DUUFyNWpDSUpPZVdxOXB2emYwYWlFaUhTSU9LaGJrYWY0Z01ZWjdLbkxZSU9nQ0FFcEZ3d29CMnB5YkhBTEFRMUFqRGlWQ0FDYWE3SVpoZ3dnZUpQOU1nQk5FRVRlbTJBVEFBdVBhR1UzRDkvd0hsREQ2NityWWVDT3VEbStST1NmbmkvUERoQ1QvOGNLT2FhbHA1aFgzMjI3QWtrMlhXSCtXVjlWT2hoQXd5QXZDQWh3TVVTdWdEWnVuQVhQTGtFSkxVUmpSSUNrRm9xQmFicHBqclhLYnJITHJrVmtFTFp1MHZFOEZUdG9nRkVXc0VMZ0lqV01tNTNNUTJDdkxCR3A0SXlrUFNBQW9BdUFBTVFCaENDRVpERnc0MmJtWEVJczBGZWRoREgrcGtDbnlRQWhUTzRJVWluS0VFbWNOTkNIUWdCQ05nQVF4UkRBVVlvUEdyUUFEQkJrTndRdEJhSUFlc1ZHRVJXd1FBSVhvQlJrQUFJUVJET0lJV1p2R0paT3pCUkxVWUF4QXF0ak9jV01BR0VIc2dTVFRRSnFpVTdHUVRZUXNBSkFLVmRUWGhCempwV3dmdk5xZWM3WXh4RHYrSkFNV1NSeTRjR2hCTDEyRkNGams1QkMwYVloSnpzTUVSb1BFSVl4VENHT0J4QWlOS01LeVdKYVJwbWV1Y1VDQUNnMVB3NFljK2RHWGNCQUlER09UUWdqeDRSVFV3c0VLNTBUSWlRMEltTEFFQU5UVVFBZ0M0dzlvaTRWVEFsMGxuTUhtWnpzNnFFNEliRU9FR1BrZ1FFRlF4b1JKaFl3MUhZTVFpZE9FS1Y3a3FFSHFBaEJZWUFZUWVQRUdiRnVoQUNremdBNE9JQVFsck9BUWhGaEdKTXdDSENVOEFnQ0YyTVpMcERNOEVUM2hDSEtBSUJQOUlveFBEVUlRV0ZwR0lTUkRpRGNpNHd5ZHdvUXBWWkdNUHF1Q0ZLMXpCaXp0WUFnK2lBSVNCa0ZDSlVkeVVmdlJ6b1E5V1VRMUVkTUVFYnVqQ0VHNGdoRTBZNkFnM0FNTC9EU0tCQjBhc2dSRkQrS0o4YW9HTFE0eGlFc0ZZeENMNkVJcEFIQ0dwdVlCQ1ppTDVFTURkYllNdE15QzVpdU1ENWtTZ09DWm9IZTQ2VUFZWERJRm1KU2htTHZuYVY3NENCU2hrZTVtOWhtRFIrRnp4Q0RVTEd3dSt4cENDS0FFVnBBaUVFd0xCaUhoRzRSWlJzRmptcXZtVXNUa25CVC9RUVNzYlFwZUNCTUF0TEN2dHlxN0VCUzVjUmc1Sk5DUmNPZXRYMjk3MklBdUEyaXRrRVp1TWVPRU95WkNzRFJRZ0pBQ1lRUkd4S0lJTmxoQ0hWdG9zSVZhd1JSU2NVTjBXV0E1dVFlbUFCZ2JRSGViVVVMVzR0YUJiMnBLb0ZFd05BS3dJaGhya3NEb0Z3TFU0MzVVbFZIQ1FneElBQVRQTmFVSVR1Z01BS3NUQ0M3MTdoQjZJLy9zYUZGd2dCOG16b3dYU1NNT1BpR1dEVFp2bDNuWXBYb1lJeFFLR01BUUlHQ215WVFua0FUVVlnUWxZTUFLOUJBWUFUWmlCUVNSNE9vTVk0aGxDU0FJdkRkS0NKS1FCQlFEZ1FqTU1rYTdwREFZRGNvMm9nWEpHbUJBY3dSSjZjR2NtTXRFSEozU25CVGFvZ2lVV1laa3E0QUdMMXlrc0l5SlJDanlFb2dwNWNFK3ZBdEdKWW9paUVLcllBeStNa1FtVUdpTkJybUN5SlN3QkNEdzh1YnBPTUpCU3FXU0xTWVJoaFZEQmdHcjBNb0FSakdzM0ZraEJEb2dqR3ViSWdSQnFHTThRMmxDS083ZzBvNTNveERJT0FZeFBIS0lZb1Q3RXAwUGRpMkp3Z3h1SDZFVXZSZ1FMbHBZVEZ5L0Z3eHJlSUFsTFd5Z1pzMEFHSG83UUhmOWZGOVlNV2dCREhkUmdDSnlPd2haVE1nRUFSdkNDRWFqa0xnd3JTUTV5b0ZRNllxa0VTL0RCYWl4czRjQjJHOXpoRnZjUC85Q0VHeHdCREhuWWFudXNBMWF3a2hVbkdXRUlET2p3QjUxQW1HL2ZCdHNEU0dEY2NmL2JJOVlDVEJDaDVwQ3haUzBsSVlqREVvRFFoMFZVQVFBcGlJTVRwbUVMdGQxVzNoSUVlQVVIMElJalJNRUxnUWhCRkI0eGhqd0VJajZidlNFd01VaTJWMmJOQXpENHd4LzRFQVRkUU9FUmFwYlFIa2hSaS9kQUlRNVhHTUVVU3ZjQWFUcm5lUStnQXcvaXRZSVJ4SUFIUE1nZ3l3ZFFBaUdBOVFaaHRnUXZUSXBTbE1MaUVKUEFLVGVXOFlrNzNPRU5iNkF5Vi9FQXFqemdBUS92T1hmVzhiQUkrTG4vd2hqRzBQa2VraUZjazlhaXlVdGxSQmhDa01RUnlHRUlTOWhFSEhMR2hOQjBMb2V1SEp0RUlaSURSWmlTd0FheFFLbXFDNFE4Yk9JS1R1a3dSRExpQWFoWUFBbFB5SUlWRElnSVdRREFCejd3UXlWYXdRbG1UT0lWcVFERktUd2dBMytTcmNJZWtiZkwxVnJoNERNa0JFWklFd3Q2QUlRbFBJRlFaWDN3UWRpbU41WnZIUHZaMTM3WUhpSjZBbDZ3TGhIQWxlaVhpUkFOUUNFSVAzV0RIV0x2QXp0MDRmMTJtUG5CQ1VuSUFFRGcyeGdZUHRnZ1FIOEFzSUFQK0NBR1BzQVRoR0VCOXUvQ1BDRUdISUFNRU1JWHFrRVlNQUFSRU1FUGFHZjR0c0dGaEVXUUZnQUdEc0QvK0dZRlBzQXBXc0FXQk1IZkR1SzB0azhGQjRBTS8wQ0JmYXpCVC9UdDNweURPWnJEdlRxcklSWklCWGNRQUp6aEdGcGhGVTdCRFg3QkREQkFCdFpQQThRQUJtaUhDV25IbDB6UGIrNG1BQlNBQ3ByQkZKb2dObTZqTms0aUNFYkFCMnd1Q0k2ckV2Z0dsaFRBRDNvZ0NLN2dCcllBRHVBZ0NMWU5hL0FOQUhxZ0R1Q0h5VExCRlhRQkcvSWdFbzRnalE1RkpYQ0haT1NOZytKR0lnS2dJSktKcjJEQUUreUFELzZBQjJZT0J2cXYvd1lSQXA1d0VzT20vemlPQkQ2QUJmUkpBMHJBVm9RZ0RwcUR4R3BMR05adkNjWEFEQnFoRWRvUUV3WUJDcm9nSWVSTlYrcWd5cXpzeXJiS0Vxb0FncWdHQUpSZ0VnUUJyYTRQYkJ3Q0EzcEFDS2dvRXFwQXFkYmdDb2JnZGNUdEVPdXZndi91eVVCa2F5UXVRQnVQenlNQzRHd0FvQVVFc2ZSS0R5R0dENURTcFhCd1E0MmlJQW9teTVNTWdnUjBvQWVRQUFmaFpEUklBZ01leUZyWVpSOWh3STljREFDV0FCdFVRUmYwSUJ0VWdSUnVvZGY2QXh2a3JBbzJvUkVRd1FZU0F3cUVBSTE4UUFOaTd6Q0loemxpcjVnOHdBZVFvSGkwdzVKU3E1WW1nZ2UyUVF4V1lYMHFnWDB5OElMb2dBOE9RQ0RFWUFyRXdBTUdJUnEyd1E1VUtDSHNZQlhzd0NCZ2dBL29JSC9FNEdBTVFoaEFnUk1Rd1EyRTBBNSt5WWNBU3hIOUtnVXFzZ1U4S1htNGpRZS9FaXpCTHl4SHIrVXV3UmFLd0FKS1FEY0tNVjJ1cEFPWUlJbjg1WUxlUWdIa3dqbENnQkdVREE5c0FBREVBQkkxd0FQL3hBQUR4TUFPTk9BUFByQ0NQQUFDVnNBWFBFRUlVK0VWS3VBZ1pIQzFMRXdnZU9BU3BvRDZWc0QwRGtEZS9LQU5CZ29aY3VFS1NGSVdxdUVVTHF5Q01PQUJUSThzaVU4blNJQUtxQ3NLVGc0SXhrTnpTdUJUZUlXNERvTEJuQUNzR0lFYXFFQWNyV09VSXFmd2xtQUlpcU1FY3NZSFJxc0VhcUE1OGtVZ0JuRmsvcUN4Yk1ZYkdRSmdQdXROQ21BS1JxQ1l4TUFabk9FTnZ6QUl4R0JrQU9BYVhxRUJkUUlDV0FBQ1RNOERTZ2NEWUNEcWVHQUUvc0FPZUVBeHcyWVFmV2tKaXlrVlVrRUFSaVlUTHl3bjdPQVVwb0FPSEZRekswam1FT0lTOVUvZXJQSWJtUklSaUtBTGtyQUxnbUN2RG1Kc0R1NWRzaTBGdWd2b05xRUgvM0xBQ01CQURwSkZJSExnRFNRakQ4QUtHdFF0RXhiaEt0WmdxZGJnQmtneUNJSmdEVGpVM3V6QURtSnVFcUdMci82Q01yT20veWF4TVZlQVFrbDBMQk5DQThxekFnMENBY0VHdGZnR0E2WkFBd2JUQjVncUQ2anNVMXJGUG1abzI1Z0pId3R2SkxMa1VpZ2hsRFNvU3V0MElzaWdGVkxCVG5sSVR5S2dCaTdBRjk0RkNSYU9ocFQwZ3A3MENYSHJBUVEwYmNnZ1FmbjBLV1pnQXJ1QVVvbUFDS1FBQ2FMUEJITEdBbTdnUlZuR1VOblVBaEp4TytXeS9FUkhjemJsQ1VacENVcDF2TlpSbG95UlRrWG51M0tpQUxxaEVjeWdaSHhKZEhKSmREYngzckxQRHNMeG4vU3ZLT3Z0RDlSejQzNkNXUU1yQUdRdUV2Y3pXYmVVaC84UVpnQldJRXpqNWdIRXdBOFFJUnFpd1F4R3dBTWl3RnBZSUFVc29BWis0QWRDWUFGQ3RTRTBRQU4wNEFxZ3dFQWU0ejBZd2QzQWFnaVdUU2NHRVFxZG8vbmFLK0lheUhNK2gwMjc3NEVHQUdwc3dBVStSeXpPNEE1VW9SYU1nUmRjaGFzYzd1RVdZUXlxYkR3QUFBZmtBTjM2b0xLOGFySkNvYnE2QXplcXd6cUladnNnY1J1dUlUVk5adithdEllY3d3U0VnS3VXNmo3SXIyOEtWbG4yRkdpUGFjSTJydngyZ2p0ejZSTC80RkVCamcyMkp4RUREUUJxTUFMc0NITXlpQTEySXdUQXdRU3dvQWl3NEFjbTh5b2pnZzBDNnhIcVlDQzZ0TnY4N1FnNmdSUXdad24weVZYM0xRSnlRQWZRS2dySlVGRlJFUGpreGdNMFlBVC8vR0FibU1HZllzNE9aSUFQY0Vka1JJWUVRaUFGU29BRXBpOXVnelpybnZVaEhzQUdKVGRPU0FJRnBzZGRlK2dQek1BTWZrb1dmb0YwT1lGMFU0RjBRV0ViaE9FUFdJQUZGTFl1MldCdlJnSnhJUzhucU5RM0ZUWnBWb0E2aFlJSmF5dGR5UFVCVW1BRWhpQVNGa0hrc21BWTNLbERuRUFCaGdCVUhNRVJhQUhRSXFvREFDTVBBQzhReEN6TUVxc0dack1XVEtwRFRpb2JDc0Y4Q3lFVWRLRVF4b0FSc09JSVRFQ1JLb3dNWXNEbGRzTnZHUUp0eFczcWJxdHpJU0l0dWJLYUlyZGFxUTh1UkU5eU9RNjMvc1VUTG1FVkduZ2JmZ0VVUUFFb2RRbHZKOEliQkVJSW9pQUVFQUlOT0JqN0pPSnBEN2lDS0tGQWRZOTB5YUVoLzNpQUJDcWhkUHlDYVRUekFkcWdFVENCQ0VhQ0JZNU9JRUwwVHRoeUJwUERCT1FBQ09UZ3FhcEFDOUNCSFI0akYyUkVWbmtRY1hGRElGZzJBa1FMUDZUUFp1ckhEU2pDbUNnQ0JTRHYzMTVBQ1ViSWg5Q2dnMkdwYWFyRGdBZGcrTkNnZjdOdmpIbEpJSzdGS2JaZ1RGUTJhTGhqQ0d3Z0NrZ0JHeUR1OUJTSmJEeWdMWmpHZ3Z5SGJ3aFpibnpoRW1oZ0J0bUFOVk5nTStBWEFFckFzbDcwZE81Mm1YeW1CSnBBQnU0UkFEd2hmMVlCSWJvQkFNaUJEZHFZSVpCVWhERm5qNTVpVXlrR0J4ckxyNXpENC9wQXpjWWdGQjdoNUw3S0NUWTRsWHNaYkJEQkNJaExnSDA1bUU3aEZIcnFFa2JBbUluNTM0cVdtYk52Nm1nall2OVNvTEFzYXFtRTQzcUhHU0dzeFlBMVR3ZDhJQTdpQUtsdUlELzhPSmM4UUkwSG9KU1RFQTV3d1JYV3dQVHNSWFl2U0l6UllQL3FzengvYnlLWWxTSUtJQ1BzdVJ2WUFBSktXWXoxbGs2amxqbXVJUFJXaHpsYWdBa0tTMk0zVnU2RTQzV0JTWWNIV1JNcG9nSXE0RUREaGcwYWM1NnBLWEhmSktURFRTQmFZUkxzQm15bWdFRlB3Um40WUJMRm9CV0lZUndvb2FONXFRYUlRQWFRQUFtbVVadWZHYWlEV3FnWm9nTjJvUUYzNmFlSFdxa2hvcVFOb3FtWFdwcHdLNFFSbU9OK2RpNzJ6eE5JV0cwNjJKUWhvaHQrb1JJcUFYWEp3UXhTUWF6WkJ4SE9BUUxhbUdicmoyWUZHUUM2MnJZS1FBYmx1b2NZWlJyNUR3QkUrVFgvd1k4TWNBbGdscGdoZ21BVG91RVgzQUFCN1lBVGlPQ2lJV0txZXdnTnpnRVI3RUFZcUhLcEx4dXpNMXV6TjNzc241cXpQeHRzMElBRkRFS3VIK0FQcUZXOHBxSDJ3Q1lSMnpwREVRSW8vb0pJQ2dncExLd0RkS0FjeWdFY3RMWm01b3ROdzhhMUxRZy9XOXJlUUhzaTdOcTRrMXU1bDV1emtWdHlQVHZjbk51dm9GdHlnenREWlRDd3BIdEdlcFc1dzVnaTFqZ3NMK0U5RDFpN3U5dTh6eHU5MDF1OTF6dVZyU0FMSWdZQWNnQVRoZ0VTZ2lXcDJSdS84MXUvOTV1Lys5dS8veHZBQTF6QUI1ekFDOXlDck52QUUxekJGNXpCRzl6Qkh4ekNJMXpDSjV6Q0s5ekN1VlFSTVJSRDhSZHNNOXdhcTlHdFBWekVuZlhEUTl6RS82dlJLa0VjeFE4UnhjRzJ4WC9DL2xiYy9rS2N4ZDM2eFdjY3hwdFZ4M1djeG1XY1dRVWdBSUQ4SjRCY3lIbWN4WE44eDVOY3lYMjh4cEVjeDIwOG1WSTh5cHQ4eGsrOHhHRzd4S1hjeVhQOHlxOWN3MDJjeG52Y3lqZGN4YVBjeTUvOHhabGN5N1Bjek1PY3pkOWN5dUhjekcvY3c2bjh4dTg4eG8vY3hwRWN0Wktjcm4vaXovOTh5Wi9jemZHY3pkY2N6T084elBXdHhjL2MwY01XdUR0YzBiR2N3NjNSMGkvOUtoRmMweXQ5bjlIY3dDbXpTV2wyMHNQV3RVZGQwdHQ4MFNuOXkwL2QwZ0dMeVZzOUlwcThXYUZjMXNWOHkxZDh5WlU4eHRGY3g0czgxNC84MTROZDE3bTgxb3VkMXRNY3grMzgxWW05ekdNOXo4SGMxdjludmRsSm5Oa0pmY1FMSGRiRG5KLzVYTSszbmM1VFBkTlpuZHJubk53eC9kUzdYZHA3SE4zM1BOZnpQTW50ajY3akhSSG5mZDRKQWhFSEFMWGszZDEzZmRWSi9OQ3RmTXl4L2N2OUhjK3B2Q3FQM2R3cC9ib2hQZUVWWHNUTmZjTXZIT0lUQXNRZlB0WEJmZUJSWGR0dHZkd3pmdGxyZk15UmZjdVRuZGRMdnRydlhOYUJYZVdGbmVWL25kKzl2ZVdIWGRsSG50aEp2dUJwZmVPTi9kWVIvdWJIZmVlcmZjNlZQZHZKL016WHZlS3ZmZHBWSGVBekh0YVpIdGg1L3RpWlZkRHAvV3p4ZlNEWTNjKzVYT05CR01XdG5zZFB5K3R6ZnVQRm5lSmR2TXY3L2R6VC91aFpmZWpydk5IUnZ0SWpudUF4bk9IcG51d2xYdTdOdnN2L08xM3RBZjdOMng3TzBmM3RiVjdPN1R6WnZUM2duUlhsUzM0eWQ5emRXZjdsWTE3eUp4L3hUNzdueGY3amM5N3dsOTNrcTN6dXRUenpmNzdZZFQ3V3RiN1pFLy9uUFQzMVhiM2RDLzdwTHgvbGN6enMreHpKcDU3ZTZWM2VBeDNRWWI0YTZmcnEwN3p5RS8veEk3L1JsOTd6eWQzSDZ6emd5ejdwRS8yMUszN3RWNzN1T1QzaXk5N3VKWjZIeGgzYmRhTDZwMS9PaTM3cmxmL2tPWjdtb1QzTGRWNzBCVC9YaGR6WEtiL2xpZHpJbFp6OWR4eitlMzNZeWQva2czMzRWOTc5QVNLQXdJRUVCUUlJY0JCQXdvTUZFUm9jbU5CaHhJa1NIektrNkxDaVJvZ1dNeXBFR0xIaHhZWWtTNW84aVZKa2dBSWJWNDQ4T0lBa3k1a3Mvd1hNWElrVDU4MmNLd1VJTE9CeklFdVNBSVl5REJDVEo4R2pCZ3VFUEFxMVlsU21FRDl5bElxVklrYXNXYU5tOWZqMW84S3hZaGVTUFhzV0pGbTFac3VpWFJqMnJWeTRZOW5XbllzM3I5NjlmUHY2L1h1MzdWeTdkTTBTMWdzeWNXQzZFcDkyZktrUmNrcVVJVkg2dkd3U2MxQ0JRVEVUM0R3NWRFSFFuUU1JMEJ6YU0rckpqaXVicExwVmRFR3FKRDJYeE1pVTl1eXJ1bTgvQlB0NzVOZVdZSHZML24zODVGQ2xvRXNTNEt6VEo5Q2QxSlVtcDh3N28wT1d1QTFxRFF2K3UzanQ0WGNITHo5ZUsyQzBiQWtmZnF0WThOckE3K2ZMVDdzK3YvNzkvUCsyZHd0Z1k0ckZSNkJiWFFtb0hvTG5kUWNjWk1JOU50eDFFcFprMi8rRXlhMW1vV2hlaGZZZ2VTZHRDTnVISWlKSFhJWXFmWmVkaHhJYVo2S0tCZDNFMG5NNDJSU0FqTS9kSkoxcE5jV0kwd0UxL2toQUFVTCtOT056TmpYM29sQkV5allVZDA3cUZsRlNybW1YRzFjZC9TY1djQkJPYVZpV2pFWEdVV1gzNVlWbGZmQ3hoMWQ4WmFuWlg1dHV2Z2xubTJ5dU9aRjRDZEszV0lFRzRxbW5tQ1cyS0Z1Rkp5RXBZV21xbVlZb2FvcWFkbHFpamc1a3FLT05BanFoVlZjaGlpbWhLMUpLNG9XWmNnb3FRVTAyTkYxT3Blb2tWRkRQR2JuamowdkNxS1Ixc1M3M2s2QUQzYmhUckNiUlNxV0hYQzZWMG5oRXdvU1FVNkltU1JXdlZYWVg1VlZKa1pjZWVnZlMyZCtjMU5xbGxwbG14c2x0dDk3ZWhhRC9ZTmlDZXkyQWVSYldaWjNGOVJwcWFwQyt1K2lpbUhvYTc2UDEzdnNwaHBIYW1xR21vUEtiWElmdCtrWWJpOGVOdXFTRk5LSktKS3M2K2lRalQ2Mld1akRDTjVZRUs4T2toc1pkc1g2cWhKekJwaEtiVTB4RmNmeHF4VXJTT0ZURUdNc0tiTXk5dWhadHplaWQrWmhmZmZhVjdiYysvNXlmZStYMlBCaTE2U3JvcGRGeHFVbTBsYkwxdHRwbS9nNHFhYjd6UGtxaDFmZ2lLVzl0VlVQWDd0UURleTAyMVNsSkIzRlBydGJMR3JSYnVwaHlUMENwUGZmRk90MWtvMENyMXRxcVVqZlNTS09Nb0ZFSGVFNmExc1R3cUszK1BTckxPaEtKOE1FNUhjVHJ4SkJMREhuYXJyTGtZK0EvK2ppVXlqc2xOWGZwZEpzcXE4QWZ1eTN0LzI0MnE3Y1ltbkpwaTEvc1FOOSsrN2JXTXFadXVVa1BtQjd2d0F2UFZlOEZyZ3YzcFZTemZlOXBtbDIyNzlkYU43cDExUmdHT3Zaa1pZZU5FcStmdVpxWjN1SlA1N25naUpJLzQ5WHZNdm5qa1R3ZVNZRDdhTmY2cXR4cGUrNnFqQk9uL2ZlUE9QS290czZKNzNHbEMwb0JkN0kzL2FFdU9qdWFYL3hFQXlzZnlTMEFFUEFmQlJkV3dZdTFxbkI3ZzREN2drUStvTVJQaERVNlVnVlpVc0hFb2M1eTBSbWdzaTdWRzY4NHFFRlNlZDIyYklkRFBKbnJhTGpyb1E5MXlLZmZDWEZhZXhKaW5RcHpQR2JWa0VEckNxS1huT2F1cTNWdGVkRFJsS0tBY2lSR09TOSsxR01VK0w0bnRmVjVTbnZXVTErbzJFYTI5RkZ2YnU0YjMvL2pIaFpDQVNRUVNIUXNJUW56OXpqOGVTOWhJNVJqQ2NXWFFQbVJNSkFGTUo5dFV0aEg5QjBRY0hFOGdBQU8wTWM1RWxKK3E2SWtrT0JIeDBwSzBuN3RJOS9lSUxrUzBLMEVoVE1aWWZ3SUVEOVFmaEpWQmNqZ0pZSGl5ZzR1aklJTXhNa0pIK2N3VnRJdlY4dEJXQzh2UjU1ZnVnNktVWEhTMjJ4NHhDS2k2ekQxMFpPMWJ2akRhQTV2WitjNll0TjRKenduSXUyWVNJdFdlV2pZR2kwcGIwTWhNOUdoRk9VODZqa3ZVVVpxbmhmRlZocDd5Yk9NNk94aU91K0p6K2U5VTE3UTA2ZG1zUGd3UFByeGxIS0UzMEFQV3NsU2NjNk9CeFhoYVJKNlVJYWFEMUY3TTUwbEQrQlFBbml3QUQ2YW95TWgrVWlOQnNtUm5tVG81bkQvU1V1S0xYU2pQbEtsSEUvNTBWUyt0S0FRSUNnQlFGcklsQXFrb3dWZFlmMU9XU09aeWhTa01RMXBLbUY2MUpsaVZBQWJ0VWtDWWVtK3B0NFNBdE9CMFFkUmRVdFk1ZXA4T1hyT0xlWG55c3NBVUkvQXhKd3dZU2F6TUVuTFR1a3lHbCtZcWJUWlJaTk1kSzFkbW5Kb1JCN3lFRXpDUVZFNC9icWd3QUtXcjJBcTNubVNOeHFpZENwN1lHdXM5T2dwcVhScVVZdjVyR3hCQlpBQUFTQUFzNXJsYkdjM204N05pdGF6bDJVQVowMmJXZE42TmdIeFk2MGNYVnRaUm5HUml4QzdiT2pZK2NqWDJyU0VRRDJsVFM4NzI0Y1dsS0FnUmFWd2hScFM4TzBOa3lROTVXYmpWOU1BZERSSTFBM2hxandZM1ZPU0w2WWpGYWtjSFduYy8vRE9GSlVIWUVCNU81dFVXRmF5cGgvTmJXNWQ1VUViSFNtTENnVVNVTUI3VStjV2xMdVE3RzkreVd0Y1NCSUFBZVI5SkZFRGZGT2pocFNwdzMwT1NSOEp5eHBSbFpaQmtyQlRwVHNkVXpiVWo0ODBqWXhTaUZXY09QaHpxRktaTGdrM0dzVXBOaW5QVXQxR3R2STZKTzdRUHNxYzhaaWdPVmU4dWxWb2R5MGk4SnlKVGVUMUZVS0dwZUdWaGd4RGkzeUpYU0hDSHZUY3RiM3dKUlo3NzlSYW92cEoyUzNpTTdpNUhlMW1Nd3ZhZkhyNXM1MDlEUUlTY0lBRW5CbTBtYzBzQVZ4cld0VzJtYlNuTVMxdExYdm5kWFlZdkpoOU01OFBQTjd2SmhpOEI4YnZjSE9iNE44dWxhZDd5OGxRNVJqbitKa1h3QUFXY0g1NTJ0OURBLzk0d1FUMnIzOEhQV2pUSG9EQUlXVUFLbTlxYXFMNk43Y094Y3dEKzZucC9iSld3SjRlTUtvL1hkNy9YanJWcWI2cHAwMTlhVUVyV01BaHpmUlFlNXZiK0NaM29RNUdwWFFsaWttSVloRXpLVXhoZlhsVVg2cENGZHM1d3VOeThtYkJBZVlJUkt3N01tR1JpU1haNFhoTTZNcnh1T1JhNHlBbTBYZ3ludVlUQVNzc0pFL0pNbzhka2NpaUdLbkVWbStLNFVOandTZUw1UzdPc3paNnZteG1uWmVBT1Q4OHRYMW1yY1U1Ky9Bdmw3bk5FYmQ0YXduNjBEekhtYlB0VGZPYlAwdHg1NlU1dE9uOHJhaGZHbDZZb3ZrMEg5MXNtbU9LZ0Z5YjE5Um90bmg1Tnd2czNGb2EyS2RHSld0dGV0UkxHeUMvdlE2cHpWV0wxQUw3dWRmL3VUNUFyZnRMNEU1ZmV1dmw3ZnJPQ1dCcUF2YzZ2NGhlY0hGdk92T1BodDNXV2VlNjFpSDVkcTdMWGU2MFBuVi9DN24xcll0NjBwMEdObmVMTFYycEUzcS9WdzBTZ3pscTlvUTYySlBqaFc1eUV4bnRTMHBWa0RUS3FzYVVVckFURmVzM3hvcnhXc0d6elJtdk84ZHZyYVlPdzNVbmU5UHB4NDRwYk90bldHK3ZZYzNKczNmc3dkTm9jTnhEMWxDU2hmWHV5MmhsMjFUUGV2ZDgrR290bTg2VWEvcmhVT2NzYUZFTGRnR1lGdWlkVGNEMFFRdjBNNnU1NTdrbXNKb1pjT1kwaDVuTWtiWitlYTEvWmxPYld2clN6elhZdlE3MzdvTmQ2M3hudTYwaFdYOEFFM2dCNzJmQTJwZHVhZ2F3ZGp1M0FQNzNkUWpRZGptM2MxWjMvMU50TjJvTm1GODVCNEY5VjE3ODkzNEdjQUJMaHdBTDBHbjhCNEJnWjJ1VE5tbjRCMzhqT0dBTGtJRVErSUFTS0lIOUJYZTNabi8rbFhWZFI0RUxhSU1sV0hXVDlsOVh0NEMrWm1DcEJBRldCMTQyVjJBMTVXQXp4VjQxUWo1TlZWVEs1a0ZMaFYwakpvVUsxVVloOUNPeDlHeDJneU83OUJwNzFCSlNja3hHQVJIRzhubXdJM3AyWldNK3hEVG13bVBpc25yVjFFUnZFNGV3UjJTU3dWajBBbnkzSjNDUXhXOVB0b2V3cGs2OUI0aUJlR1dXaFhENGxHWEkxM0lZUjFwZ1JtZkNsWHlQT0hFU1oyYVk1WWhvaG9CcXBsa0RSbVplQm42YXBXWnJKb3FmK0hiZ3QzMysxM2JyWjNLZHVJazM1M1VLK0lCZEY0RXYrR3MwbVA5SzE4Y0FCb0FBUzhlTEJGQ0FDeUNBQmhDTXVVaU1BcGlDS1VoZ0dLaUJYWGNBdjdpQnFOUjJ4cWlEdHdaL3FOU0w4Y2Qyek5pTDl3ZEpTK2VMS2NpQndMaUI1Z1ZKS0xoL3ZzaHJvMWFBdWRoZkd1aU1HMGlCdnVacm5jYU1CTkNMUzRlREF5YUxEQmlCbFVaM0ptaHA3S1ZyeE9hQ09iVm9ISFZmb0pScFJHVVRMV1ZoMklVWkVtUWswY1ZSTlNKS0lFWVFVM1ZTRG1NNkthTmlQR0V5dzdFc1pVaVN5WlJEMUxRN2dFRTdNaVk3NU9JZzlFWnY0R1J1UnNZZ0lyRnYvUUpHMGhOUGFCUnc4ZFFRUHJrdjl2Ujd6UkU5VzlOd2lvaVVnbWlJU1dsWnhwZHlsSGhuRTJlSktIZUo1Q2RhMjdkbTM0Y0Evb2QrcHBpVjJsZi9BUWtRbGhWd1ptU0pnR2VKbG1hcGl3Z0lmbXU1bFZsWlp1SUhpelg0YytCbmk4eG9YcDJXZ1BKb2RUTzRkQVVvaENqSWY4MjRsUUpvZ1JrNGpoeW9pOGFJakFXWVh3RG9tSWJwZnhsSWpJV3BpNk9HbWRJSWpnd0FqQ2RvWHZpSWdmYTRpNk9HZ0lxNW1MdUlBQktBbWdZZ0Fia1lqS2dKanhuSWdZaXBpK0hJbWZDb21KaVpjem1uakJYSWdQZG9qeWNvbkxMSW1WakhsdzZvai9xbm5GZEhkMlNYYytkVmRXaDJWUGpGa0VjbFlUM0JVb0UzVUdlWGJCMkdRcllFbmhHbVZReVROeCtKTUZyaEZDN0dUZmhXa3Q3UlkwVlRWM0NGaGpGcFJNY3poM1VvaCtIa2VvR0ZXRGxKY0xLWE5mNDVMOHhEV1ZVV0w4K2ppRmxHLzN5RGVCcFNLWWtOQ3FHU3lISEg1NkJPR1luSDk0aVZaWHlReUVYS0IzMHRGM0VZTjNJTTRGcXpGWEVrYW4zUzkyWUpsazd0QllybjU1VWtHbjdneDVaYldRRnJXUUZrT1pZSW9LTnVlWlk2aXBhaENINDBtblY1T2FTTE9hU1VpWUJncDRGdDZYKzZ5SmxSeW9zMEtvQmJlWUFEeG91R1dadWZPWmlES1l4ZktvQVNFSXkxeVp1cnFZNEV1SUhLT0k3d3Q1dDF1WmluK2FhN0tJeGlDcVoxS3FkMVdxYzNLb3h5aWdBd2dKckFtSUd5aVp0cWVwcXcrYWRtMnB0a0tveVVhWnNwaUlGcm1vRHVoNWY3Mkp6TWVYV0h1WU9EUm5qSEJtalFsWVhTTlZ4OGxvV3NkaHJSMVZFTXRWQVI1bFVEWVhtL2hFS2U0MHNMcEVMRmdmOXVxWWRNc2JORWFjaHVLZm1HTmRNbGg2VkUrMG1UUXBZODE2TjcvM2syUXptVVNubFBYd09JRlJxaERzcVVTR21oMEpxaGlvaGFGUWR4R0hkeTBFZUpGMGR4RitldHA2V3QzUXFKYmhhdDdDZWoxcGVpRjdlaUt1cHg2VGQ5RmJlS2N0Wlo4M3B6UThxakRIQ2pONXFhUEdvQVBjcWpFbEFCQk11YXFabWpGY0FCUEtxalpMbXdaS21hYSttV3J1bWFDT2lqWjRtWUNFaVdoU3FNTjFxTUgvdWFxaW1tL2txb3EybXhKcXVvZktxTEdYQ3llN3FuaW1teTRZaW5NMXVuWW1xekt4dXdyR2tBSEtDekdTQ01QdXV5Y0VxelErdXlLS3VNNHZpeXF3bXpKcXUwY21xUGdNbC9zd21ZR3JoMUZDaURzVWlPSG5pWGxscXBYVnYvanBSV2Q1bGFiSU1HVmRrVlIwMkZiVmtvUWh1bFU5OUpFeWVtUXVZcE0zUkluMnZWZVkzUmt2TEpibnRiRjNFNExoN1JPMTh5WkRQa3Q5d3pjTDhITm9lcnVNaVhpUDIwb1kwN3JjZzNvdHE2b2RzS3JveUlUOUI2dVczMlp1emFyaWNYb2lnYXVuUG1XU2JLaU5JS29SRzNvcUZiWjZ3N2NsOW1jdHFudW5OMmxWNkpsYVlJaWw4NXBMczdsbUpwb3p5cXNVVDZyeWRMcEdaNWxnRUxzTWE3c2J0SXNzejdyeENMc3FuNXBuZ3Fza3dydEhlS3B3akFzaEs3bW5nS3RITTZ0Ti83cytQckFOUTdzdzB3dmhsUXZnWUF0TitiQVRkTHA4Sll2dkhMbXQ4ckFmUUxwajZMdlRNTGpBYlF2OEs0QU1Bb3dQNUx3SFBLcCtJby83T0JHbzQ1aDRMVG02YXhpWUdZS1lSOUtjRlc5NmlEMll6OU5aajVGYlZXVjRCaWw0SmVXNm1ZcW1yVCtWMUtGV3RMaFhnNHhUSjRRMkp6WkhtaVV6OHF0bFhJRVpJeWRETmxDSlBwcGxlOTJuckUraEsrTTdqNXFTTC9OaUU3bWJoVjlJZks2azZJR0xtUlc0amJ1b2hUSEpXcEc2R25pNkdSeUxuaCtuRVN4M0VrS24xZWJJbmJSM0Z4TnFFaE9yc29pcUxWVjN3ZHg2NXFqTWFXYUlybzEzSHIrcFpZaVhKWmFidWkrSmI2K3BiRGVKYjhtb3NrQzM0UkM3eXRtYU1BTzd4b21iUFZhN01haTdBSG03T295YklMTzhrb0s2YnYrNlVTOEw1eVNyL3cyNzFLVzZmb1M2ZjRxN1BqaThvOEM2WVM0QUR4ZTdQb0M3NDd5LysrQmxDKzZzdkptaXpMSEZETDdKdkpuUHlsUGl1bVBBdTBxdXkrOVR2THdxakszbnZNcVB6TG56eTA5SHVuN1Z1bi96dXpxRm5CS0tpYkNCaW9HTWl5QXB6QkhreUxVWHRUK0FpUXROaWNYQWVRL3pXMnNqaVF4QlZyTVhkUUhSVkhWbmdUdHdSTTFlRlRrZE1VeEZJVWxNUFBDVEVxSjRNVG5uZVM4TWxqZjVzMDNzUW5maXNaZG5pSGdHS1V2VWRQVC96RWVSYTVGbzNGV2p5aHhaZlI3TmRhbGp2R2JvekdKd3FLYXl5N2I1eCtFWmZTSW4xbWIyWmViK3k1WWVtNVl0bHhXYW5TWkt4OUpBckhKRm9CcHRqVFkybTdZY212V1BuVGdselVrV3l3RzF1dy9mcXZxc25VanZ5OHd3dWt5eXV5L2Zxd0M1dlV3U3dCRFhEL3Z4d2dBVjc5MWZjYjFtSXQxbUJkekx6TXNobmdzOUs4MXJ5c3N6eGJ5c0I4eXU3cnl6eUx2dXFMeXV0THArc0x3TWZzcytWcjE3T2N5YkxzczhuTXZxVE15ZmU3czYyTTErVUx5K2hidnBFdHY3TTh6SzI4czF2dDFWeWRBYkRNMTc5c0FIZTl2cDJOMTVNdGpKeE55MS82dndNc3dBS2NBY0FJQS82YnBzRFkyUWw4dEtQWndOOHNtQmFzMjZINXpSaG9qb2NKbUpPNndlUmxnYjVJM0xvMlVoeUYzQzFvWERWRnF1cjFPYVh5TjJ4cnorTnBWbVVsaGljVEd3L1N6MGhSRVRmY25qUUdSQzFaTFRoRFR1RUVoa2I4MEZDMm9BbW5aMUhNMGFSYldiUlZ4WWZXbEJ4OXhSc0t1cVMxMzk4NmxTTGRjVllNNEFQT3JxZnIvOUxzTjd2a2F0S2RTTVkwN2VBeUxkSkRmYUxwRjVaYkNkTjdISXBhYVgyOU85VDhTcGEzKytFOTNjY2lMdUppYWRROTdkVEFDOG1RekxLb3liTTMrc2djc05ReUx1TmpmYithL05VVjhMNWh6UUZlM2VQM3k5VmIvZFdaemVNYzBBQmMzUUJHdnRWSHZ0V2YvZFZjcmVTc0xLWmNMY3U5Zk9NOE83OXFuZGdab010WVBzdkNqTDROc05rK20rU3RETmlielFGa3J0WmlMdWEzL05saHp1VkhmdVNmN2VSczdnQkczdVVPY09SM3J1ZHlydWQvL3VjTkVPZ09FT2lDdnVlRy91ZXNmTm9Pb0w3Q3JOWm1Uc3RTWHN1UnZkbnNXOHUrUEwrWmZ0cWJ2Z0FPME9tcVhjQUc4TnF1VGNDalRzQ2tIc0QrbTl0K2lvSSttOXFxN3YvYnVZM05HWXpOdnEyT3dpbk9nRGxwb1ZsMDNjWEJxRlRjZG5kcWhVVHNJNldFVEVWSHB6b2tyc1MyUTVJeCtGd2R5MEV5L0d3c1RmSXI0YTFrODBuZWRwVkVFakVUSHRCS0JhQUEyZ1lCUlRFQVFpSWs1UTRzclZmRDYwMUZCTm84RENyRmxKaXRIenJGbVh1aGxIdkdHUzJWN2ZyRlBjZUpIc2Q4R3FkeHJ3dG1ySlYrb0JqR2NheDltUHRsUUVmR21zV1ZROHJTN0pxVnZTdlVRbzNIT3ExOU5tcUExaWZJV0htN2EyYlVIbDd5UzgwQXJTbklpSXlrVGMydktRNngwTnZJQ2h1d1BQdmlPNzdqckFuWGlYM1pTZjdreUp6a1FjL2pRNDduVU43alNWNzBlSjcwUjI3a1NIL2tOTkQwUVYvMFpTNzFkODdtYkk3bWRpNy82TG9zNTRldTU0MU82RWErMlloTzlsMXY5b0l1QWcxQUFVZk9BMGUrOWxGLzltclA5ZzBBQW1oZjl3Nnc5bWd2NTIzdjlZSk9BWU11QW9STzZHVS8rSUErNklOTzlvaGYrS2N0NkxRczJaSnQ2WXN1K1JrQUE2Mk4xNjh0NnV3YndKYS9BSzhOQStXTEFoa1EraWlnNmpEdzZ2MmIyZ05NbUxKTzY3YmVqTG45alZkWFUwRjRhUmpGdGJSbVFsNFZYZGdsRUJYVVlZWlhVK2plU2lIbXRpR21TNU5qVE40akxDRzV6K0c5N2ZaeDBQQ0dlaTRwRURGeDdnTUFBTmd2Sk9jZTd1VnVUS00wRUd5Z1BCQnRld2QzdUF5bm9SL1haK3ZQZkhVR29lL3FXdjU5ZktxRnVYM0djd2R1Y1RvdHh5aE5jUUNCUUFDRGdRSUVKa0FvL3lEQlFZTUNHaVlveUNDQlJJa0dJU0pBc0JEaGdRUUVCQnd3eUNBalJvMGpKMlprSUZFZ0FnSW1VVlpJQ1pNQlRKa0lSQkk0UUtDbFNKNHpVODZjbUlBbXhnb0lpb3EwYWJPQ2daa1NtZzR0ZXJRQ1RaRlVsU0l3UUJRakFnbGJEU3dGMjFXQ0JBTVNPRlRnZ0lDRFdiWnMxNzRkeTZHQmhMa05Hc2pGYTFmdVhidDgrY3Fsb2ZjdUI3a1U5dVlsUExodlg4U0w4Y3JOd01FQmh3eDlLemN3UEhreGhjV1k3WEttQU5velp4cWtBd2R1RUppQ0NOV2pNWXRZTFpwT0F3ZTA3YzZ1alp0Q2JkR3JZVGY0L2RzdzV0b05adFBldlp1MkNBY09tRGNBUWRzQjU5dTJsZmM5emxsRTUrSzRhemR2YnZ1N2VOc1pISmczQUNQOWd2OE1LeHdZV0dIQXdZTDU4dW5mZjk4Y3Zud0RDd3owQjlBL0ZESzQ3NzRBRCtqdmdBVVdRR0FCQlJVMDRFSC9EcUN3d1p3Y3hCQ25uQ2drQUFLY1B0eHdRNTF5S3VDQUVna29BTVVPVVN3Z2dBQWdlREdBQW1ZTVFNVVNhV3d4UnhsajFGRkhHSGZjc1VVWEF3Qmd5Q0pkTFBKSUpJZVVVY2tsWFd3eFNTS25sTExLQW9vY2dFZ0F0dFJ5U3k2LzlETE1KTVVNVThzdXpSd1RUU3JYWExQSUs2ZThrc1lzc3d3Z1N3Q0VuTEdBQnhiWVlJRUgvZ1FVZ2dmMGZFQlFQMUZnWVlWRVdXQUJCaFlBSGVCS0tabGtVa2RLaHhUeVVnRUMyTlFoVGgzcUZGUUJQQnBWVkZOSmRZaFVrRUNGU0NGVFFWVTExVk5IN2VnaldYWFN5ZFgvampKNmlGWUNKbElKb1pFY0VxZ2hob0xWeUtLVGZtS0pKUVlPU0dta3BCWkM2bGxxTTRJMktaNHFjRXFDcFpBeXlxZXBpdnFLcUs2SzJnb3JqTVRDQ2l5TXlzMEszYTJpb3BkYmNxZnl0cXl2eW1KQVg3TE9OWW9zc0xMcWl1QU15c28zTGJFTVdLdXVzdGFpaXk2N0RKaXJ0cno4NnF5djdZRDdMT1BOUEVPdFk3c0NZNDIxMUU0K2pXT1RSZGp1dE8yb0UrNDFHb1JiT2JTU2FaZ0FOZ3B5eGxsbm5VTXJMVFFLY041NTZBbEttd0Jvb1lVTzJtaWprWWI2NmFGM2hqcnBwVzNHR3JhZmw5WTZOQkM4RGcwNEVYaGd1V3pmWUFOQmhLL1RucTQ1RU54Mjdqdnc1ajZ2YnJ2bjVpOCtHUEtUYisrOERVRGhQUlR3SXh3Ri93QUhYd0NHQmRYenIzRUdNWlF3d3NjVkpHREJ5aVdzZklIS1A5VGNRUkJ4RmZGR0ZUMU1rWFFXQlVneGRSc2hTSjMxUFBQY2tRQWVvZHp4emp1QjFIRk9JdCswODAwczErejlkeW50YkxOTjMzY0hVOHd1eWZSeWVlYXJMSDVTU3FFL3N2cnFweThlVXpmcnBKMzJPeFhBNEFFV1NKaGloQktRR0FGOUpIb1lJZjBSTkNpQkJBMFdmUUNEQVNLZEVkQVZWdENnL1JGMDhOOEljRUFDRkNEdVI1dHlFZW80dGNCTzFjaFVuL3FVc1NSWXJJYVVxbFVINFlpdGlyVXFXc25LSVJ6aFNFdHNCWkppaWJBbEJPQUp0RzZDa3c4ZUFBRXVITWtKbXpVU2tSZ0VXaFI2MXJ5cWNwV2s5UENGUDRSaEQ4R1ZMaUwrc0lqcEtoaFhFUCtRZ2Eza2EyQVZ5SUM3akdLVUtESXhLLzlaNGhLaG1KWW83cXNvQ2xPaXdyNGlnUXlRQlM1dU1VQVZsd0lYRGpETUxBeHo0MXZtMGhZM09vQXNjNUVMeFNSZ3g0cEZiSTUxK1F2RzlLS1ppOGxsT250eFRTS3BnN0xVbEd3MU01dWEwNUEydGFUUndCZFdvd0FQcmxhMHBCMk5haFNJd2M2U0ZvTUpIQzBHT0VQbEJDNUpBVitFcHBTdlRCb1BKaUJMV1JidEE2S0VaUzZwaGpOTWNuS1RuYXpsem1xcHlRK1FMV2VsaE0weGR3WWJXWDd0QTJwYm13Z21FTTIwZ2FDYUZFZ2IyWGhRbTIxR3A1dlFjYzdibUVNMzhBVE9BWUV6VDNNeUVMaTkwUWM5NXdRY1BBMkh1QVVsYmdFcktORGhDTlM0L3RUVG4vN3NKNGIrWXpuL0FqemdBQkJZQUFRTzZpR0ZGaUNoR3pEUkF6cFVBSVN1aUVRWHBlanJ1bmVBR0UxMFJ6QktIVWRsQnlQOEFRQUNXTEtkN1pya3UrTzlDVWpCNDU1S1lVcTk0OEdVZU13N1UvTjBPcWFkUnMrbjFQdnBrNkozUENObGIwbmJ3eDJVV1BjQThvMkFmVDNvUVJCNmtBTVpCRUVHVVowcVZMWHFWUGZoUUFQeUE2djhwb0NES1h4Z0NsTWd3ZjRpRUlFSEZKQjhKR0JVQkRDdzFnZHNBQUoyeFVrQmJMVlhqd1NBbzY4Q1NXQS80cEdjN0pWQ0l4elZxbFRGd3NBK2l3RW9OQWhrV2JKWGxteW9XZG1TNFExYmNzTm51ZEFnSytGSkR6Yzd3M1FoSlVJTlNoZUNYSWlnZDcwTGhxcFZsN3IrYzhXb3BDc3JXY1JJR2JYNEZTWWUvK3hnVjh3aUZzdFl4djkwNWJmL09hNFpFVFlXTWpZM01tenBTeHJUK01ZTUhPd3RrOUZNWlNRam1RWlV4bzhNSTJRZ0NSTmVqM2xNT3lxenk4WmV0cDNpZ01aa0tRUE5hVW96MzZIUndMNUh1MjhxajdaZldKS3lsS1FrcFg3OU93RUFFOWkvQlNibENVcXBZUDhxT0pmL1JmQ0RDMHpnQzFDNGxCVitwWU14L0dBT3c3TENCLzR2Z1Nmd2dRNXptSk5XRzNFcFAvRE1XN0pZYmMva1FUWnpWczFzcW0wM2FuTkFkT2EyRzdoWms1d09jSTk3NkJZNCtoVHduTTB4SE4vbTJaLzUxS2VlNjFRY2svODVaU3BYdVo0T2RTZ0JObEJRQlpXSW9RVmRFZXNPQU5IU0xTQ2tGRVVSUTFNM0l4dU5yZ0Q0ZXgyT2FBUlNrOTR1U1AvZHl4U2RianBVNFNGdlNuWUNORThGM2RNeVBVOTVRRVYwVExrblZFckZ5WGFPamhQMzNoVHA2MTJxZTNmbVhrbHo1RG9VcklBRTdldUJES2lhZ3h5VUlRZFNRRFdxeTFBR0theTYxVkFvQTZ5bEFBVXBDQ0hWcU40RXFta05CVjZ2MnRReWtNRVArRkNERDVCQWM3SkRJQU01dGFISFF1c2pqNjNnWVFVckFBLzVkZGtpMmxBQ2JtaER4K0p3dFRuY3JHb05nQk1nTm1zbnNiVXRhc2RkV1I4YVVWMU14QXB3aXhnaGVydlFRUytjYmI1bEd5OHZ5aHZlVER4QWI0TXJYZVJta1l0a2VSakY0TGhINlo1SHVzT2RTeGtsUTl3R1VNeTcyRzFNWGlxejhlNTZCak9JekkxakJFa2M1ZkRBTHROSmIyMitSbktXeGFack15di9UY2w0eGhxZWVkSytOOGQ1ZmtGNVNsSFM0SlNtUktYUDdSc0RBQ2RZeEJNMmVvRlBRUFNsRXowR1M0ZjYwNlVPOVJPY2dBOVN2OERUczM2QnFuUDlBbDQvQWRlN0huYXlmOTNxSi9ERTJNVk9kclY3M2UxbFgzcldGUnoyQzArZ3dnd09zWUkvZlBjSjRQM0RFUTR4TEhGSmdXZU9XQVF1ZnViWXBvbk5abHBUYmRERTV0aEFFT01jVHo3SEtyLzgzTjdXNDNJS3JzbU5jN0xoOERrZmZnNHVRQUthTWozcmVZQTlWWFJCbEJzejVTUTZlekI3U0tJSUxWM3VXUlRuT0xPT1JSUE5LTzkzUkNlUTBzNUgzbXRSbGlKTnB5VHhya3BwR2g2VkJwMDhNUTNBME5mSDZaZis3T2ZiM2M0RFJBSjBUSzB2S2VVSDRQdTZVNzVKLzFjNk8vVFQ3dnU4ejFIOFpkUWlGdFZJZHZKM2RLRGZUTG9DS0dBQUNnREFEbkNxSHJBMUllaUNNK2lDVFRnRElqaURCVlRBVFJBQ0dXQ0NDQ0N6RzlrUTBTRWRiQU9SQytTUWhzSTJiSE1RM0RNek02TVF6YWszeWFHUUJIR1FCNGtRR0ZBdENqa0FGNFNjQldrUXgrbW5mcklRMWNxQUZGU3QxYVBCQmZrUHh2R1AyZktQK2ZDdGZFUENKZ09jL1dpbk5HS1BBZUVQOWVnUEFuRUE5VEJDOVRnWWgrTWIvZGpDdTFFNDhoaVA0dWlMNHBDYkh6TU8yeENudUhtOEhLTUR0V2tBa3lPYjVQZ2FuYUdET2N3a3hqdThPMFF4VzNLbHBla2tVUm93VXZvQURLdTZ2aU13dlB1QUdQZ0FQakN3R1Bpd3FuUEV1SE5FcHB0RXFQL2pPaGs0Z1Iyb09reThBRDZvdWt5OEFCWFlnVXM4QVJjNEFSblF4RkUwUlV4a1JhNXpnVkRjQVZHTXhWZzhBVm5jZ1Z1VVJWR1VSUmZZQVJsUUFXRDd4Vi9zeFdGRVJWUWN4bHE4eFZ2a1JCVnd4VnE4Z0ZFc3hhNER1Nis3QUV4OHhWTXNPMmFjeHJDanhyS2p4bS84eGttME83dFR4QXNnTVdKVHNSVkxNUlZMTVhWMHg1eHBNUnF6Sm12NkFNZExtOGZidkI1YkFSQWdBUWRJcTgwVE12Zm90SE5hZ1U3cnRQMHB5SVFjSEh4aVNIdGFBQlJvcXoyUlNEK2h5SW5jRXo4QmxJU0tQWVhDSzliaFNBZ1lBTHV5S3owaHlZSmFLcEswS3dYSXFBRndIZGVKRkpCOHN3THdnQmxoeVR4aHlVakJTVWw3cy92SnZ6cEpxVXovQTc4dGtSU2ZoRDdwdzc2ZzNDa3k4VW5yc3gybURCNDdPVC96VzBvQXNENFBvTXFydE1xbDNEL2JPYWtyeVJLcmhJQ1p4RW5XbVVteGxNbEk4UUMwSElDMEJFbVluTW0yck1rWjhVaTVERDZQL0NpeTVMMjd5cE9XM0FDSzJvQUJTSUVlY0lNR1BJTk5JSUxEeklYRGhBSVdVSUNaektnTTlESXdhejArUVNpRGdpaURRaWlJNmh3dWE3MFN2SndabEJBTWdSd0pVUkIvc2toL1VoeC9VcjJBbXJMVVRMMkhkTTMxV0E4Q1NVM1hWQnpGeVlEYjdBOThXcENHbkkrQ2JDZUJ2Q2Y4Q0p5RmhBOFlRRTcyU0p6MFNJOEJtU2R5TXFmQUNiSWYwN3cybkp0dW9rNFFvSVBtMk03Y21JNDZqREVRcUVkcmFxWVlNOCt2NFFHeS94bFBiRXFheVlPbUdaT21hV3BIRUJneGR4ekVSRXpFR2hqSEN1UFArNlJHdTlOUC9xekViVFE3QWoxRmF1UkVHYWpHVXh4RlZLekd0SFBRWHpSR1lOc0JGeWhHVVp5QldYU0JHWkFCRGxXQkRKMkJENDNGRVAzUUVnM1JFMVdCRjFDQkZHWFJHWERSRkhYUkU0M1JHVlhSR1YzUkY1alJISTNSRDVYUkhlMVJIalhSRnlYUkUzV0JGVjFSRWwzUkloVkdYaHhHQ3lYR1lieUFWeXhRQmIyQUg3aUFHZ0JIUjd6U2J3elFRY1RTK3l3bC9mVFBGU1BURHdpQitoelBla3hUZnNRQkVCZ0JFaWcySHNBQkhpQUJFcURUQWFyVHROcWZ0TkpUVC9OVEFsTElBaXJJdFZxckZZZ0FGSUFCUkYwQUZsaUFDRWljUFlrQUdJaFVRUCtoMUVyOWsvRHhBTHNTRkVLcHEwRVpsTGIwQVA5N2dBRVkxYk9zeS8yYkViR0VTN0hFeVZSMTFUZXJrNWpza1R0QnY1aDh0S2JjRXFiTVZlMERLcStrU3VzRFZxSEV5cXUwUHA5TVM3QmNTL01ETkpERVNaNVVWZnh4eTFUdHkwd2wxWnZjZ0xJY1ZaRDh5MUhOMXB2RXk3WjhUSXBTZ0x2S1ZIQkZ5M0QxMUxzU0ZJWHkxQUxBQUFnWTEwRXBWN3RxMXdkUWdBZVFLdzJvZ2F1Q0txclNnUTZnUUhWbFNaRmMxOWtiUVVFcEZMdEtxSVF5cUlZOXFBV3B6Tk9zeU5OMFZIdDZBTVg1RXhpNDJEOUpISWlzcDR1VVNIemEyT0gwV0VUMTJJckVTSStFZ0pWRjJKWk5WNHFhUzQ2dFREOWh2WVcxc2dXQlNMYlNXVWM5Vkk3L1BkUkR4U2RHVFZSRU1VaURaQUdEUExMaVROcjlBVEtDQklFOVJjaW0zVWYzNk1kOXZEeCs5TWQvUkN0K25FZng3RnF2OWRvVkM5dXhKZE4ySkxHei9RQmlVOXY3VEZzMG5ZQXZmVnN2eGRJdC9Ub3BCY2V2czlKWFpFWXBaVVVHWmNWaW5GQmxMTVplQkRaZ2M5SVJMWU1ZbFlJWmtBSWVEZEVrME5FWmNJTVp3TkhKZFlNWHdOek0xVnpOVllJWFVJSWtVQUlqVUlMUUhkM1JUUUlqQU4zU1ZZSXZHTjB2SUFJbElJSWtlRjNZQmQzWGZZSFlOVjNZOVZ3aThOelJmVjNjVFFMUVBWM2hYZDNQTFY3TVRRTFBmWUhrWFY3TTVkM012ZHpOeFZFVnhWd1dwVjRlYmR3TlRkSVFMUU1WY0FGZURNYTlsWUZYL041UUpOKzYvNDNTdS8wQksyWGZLcTNTR29CZitFM2IrWlhmdGJYZi93bWdEeGlCRDhBQi9uM1RZcXRIRW5CVEVFQ3JPdFVBdFBvcUZ0QUEva21yQmY2cUNJQ3JGRUFVUW1XQkNLamdSM2tVUjlWWXRwSklmTFZVUUxuWFF2bVRUUzFWdTZwV2VJWFhtQndVV1czVkZxWkpXSTBVV2hVZXA5elZxL1FTWGIxaDdIc2U0OW1kcFd6Vy9lUEorMkhXYzJYVisxSEpkOTJBSXk2QURjQ0EvbXRpREdEaWFrMVlRU0ZWZDVYSmUyM012cnpKL3J1ZnY3elcvNVBKL29QWHVwckpVbDFYWUwzWC9ORldGQTdKRk9iV3VpTGhleFhKUy9VQVNxM2pEOTZBRCs0QURaQ0JKdmdBQU96VXZuU2RGUjdqUWNGaWVCM0oyYnVyUDhsalBWbmtwUkxoVHYvRjF3M0k0enl1VklTVlpCSEc0ajhoVlh1dEs1VnNUQ3YyWWxBT3lmLzd2MUFOVlM3dTRtcTE0cVhxeTNwRnlidktZem11cXlTdVpFOVdBQ2FtWkVhK1pVcFdnQ2FnQUFYZ1lBNytFMkllWmtKRlpvQkY1clU2Mm1XZTRCUmdnUlJZNXFOdFprTzE0TFZLZ1RvRmdHcXdna0g4VUZab0FWYmdBaldnZ2pCUWd5UklBM1JtQlFESTVtdzJBUXRJZ1JUQWdSU3dnRU9GWmczUWdCUmdad1d3QUR6OXFqcGRBUW1XNXcvNEFRdG9BUnRBQW55T254TEFBUUZ5NlA0TmdSckFBUURDZ1lwTzIvaU4zeCtBMy9YbGFJNTJnUjhnWHhmSWdlOHRBeGNvNlExMWdjWkZOY1psYWNwMWdlbVZBc3k5WEZSVGdsTkQzczN0WE16TmFkWC9KUUxSN1duWkxRSWpLSUlzQ0dvc01JSXNFT29vd0lJc01BTXpVQU56Ym9Nb1NBUXo4SUk2aUFLbFZtb3MySUlzMklJdHdJSW95SUlvS0FLajV1cWhGdXRjT09vdEtJS3QzdXF3NXVvdE1JS3RCbXVrem9LNnpvS2xqdXU2Sm9LeFp1dTFIdW9pQU95Nk5vTEJKdXlnTGwzV25kM2NOVjdOVFFJclNJSVBUWUl2ZUFFWFNJSXNXQU1nVU5IZ2JRSVZzSUltS04vUFR0OVhaTi8yeGRMU250djREWUVMQ0lFeU5kTVY2OTgyZlZNODlTb1NLSUYvL3Fwc1JnRU5zR0JvRHVob1p1WmxYdVlOa0t0TmpvQVF4b0JjUG03d0FaLy9HMVgvQTJOVHZwOVM1dUtkcE80Z2Z1NDNDeDhlVUlBSjJJRmYvZFg3SVVxbTlGWHdEbFlhLzhZU1g3MUtSek8wNkNFVFlMWEt0YndmQUVoTEFNQ0FGYXNCRnNDQS9INkFGZWdBRDhDQVVEM3UvTTd2L2hrQk1TaHdER0NCRGhEd1AxbUJLZER0RG1BVURmZ0RGamdyL0Jad0FWZm00bDZyK2NGbkM0YndEaEJBSEFEeERoaUE4aUdCQVRnRk4xakVHaWlyVlNBREMyZ0NHV2dVUm9HQi9JNXVMNUVyWTg3eCttNkNLVkJ3WmE3Z0hMZmd1VUp3dVVwd1I4bHZnUDN4Q0ZmZzNwYm1DSkRuUHE0QkJSanhEdUNEQytEbnVlcUFIWWdCQzlBQVlVaGJQZ0FBVUxBQzhLbWZCK2dBVDQ2QUxjSFhDcFpVTklkekFMaUdOUEMvSGJpR0QvQ0VKdGlCYS82ME9tV0JDOUJ1QUxDR0hRQ2Z1VUlVeGdRQUVsQ0FMN0FHWlZpeEN2OVdBTFJpS2o0WWdEck5jeXlIWUJZZ3NSRVE3aFZUZ0JRdzFMa3Fxd2hvZ2d0Z0JSQ3doalFBZ0FqNGdPTGVoVXRZZFoyMVU3WlNnRHdYWmlpdlV5WDNjQXMyZ1FUWEFBaFBBWHdlSC83SjdmSEpaLzdCWngvQTV3L1FBQk53ZGdVb2dTMEpnZHEyQUJWSWdpRVlnaWZRZ1cxdkg2OHFBUi9vNTlvMkFTdXdBa1RvZ1RLUWdlRDlnUnhvZ1JKWUFoM29BUjFBZ3ZPcGdSNHdBUUN3QVhoLzl4clFBU2I0NWF5eWdlQnRBUURZZG9vT2dSYkFnUi9BZ1JBSUFSMzRnUkRJZHgwb2dmK1plRzR2K0l2L0FIanZnWHJQZ1lML2dSNzQrRGhZQWhjb0FpRklBaTdJZ1NKSWdod1lBbExyNkt2NmdXQWJ0ZkVWdGU4MWFaTXU2WlgvWGx3aG1BR2V4OXlZZmdFaGNBT2hsOTdPVmQzVURlcWtIMnpBL21zcW9JS3h4b0tvOTRLcDl3S25wNEkycUhvdDBBSXEwSHBBU0FRdGdJUmJrQVJrUUFaZUlBVmtnQVMwdjRWYjBJSmJBQVJBZ0lPM2ovdTViNFJHQUFRdGdBTXRlSU0yZUFPOTEzcXRid010Q1B3MmFJTzVENFpHZ0lPNEJ3UkprQVRFYjN6R2h3TkptSHRra0FSTUFBWlJnSU0zZUFRdjBJSW9BSVJIaUFMUWp3SXd1T3BJR1AycjlvSkJJSUpFRUFTcFJvVXdVRjRoVUFIWnAzM3Y5ZDd2bmV6dnRmM2J6LzNadC9uZnQ5RGdIMTlxUE44Y3FGS090Z0dPeGdFNXFHZzVBQ0FkcU9pSEZxQSt6OU04eFdjTm1PM1ovaXA4QmlzSkR2THZYeXNVb0N0Qy94Vm1aYjdYQUxlQUpLNW5ZUmJ1WEtiazR3NVY1NDd1VSs1TGxXeldIN2IvTnhOS211UkpnQUJRQU1DQUFnTUVJaXhnMEdBQWdRWUJBTmd3NE9DQUJROG1HaXdJZ013WE5XcXN2QURnYVFyRWtoQW5FcHpJaEVnTEFLeHNNRFBsQ1NJRWlIS1VYU3FKRXNDMUppWUJQQ0JZc3FiUW4wMmFYRWdESU0ycUdNTDQ4R215aXNlSUVUdlRXQ3Q1aWN1SGttUjJBR0FCWU5jY0dUSUdKTmxoUVNuUW53cCtXanVsYzBVTUJSTXA2b1R4MDBQUnV4UHRLc0NnNE1GYnYwWGZBalZod2tjSUV5MU1XRkRRWVlTTUpCZFNGdlJBOFM0TGlZUUxZQmpnWVlPQ0NKRUZLN0E3SUhXRUNCMDY5S2lCUkFPQXdCMVNLOWp3NElGcndSMHdXUC93SGZ3MkFBc2FqaU5uWVVLREQrWW1mc3dvWWVITHNSSXRqdU5JWVNLRkJoSWxTaWlHMkpwN2lRc1hMT3hvSWlQTjZ3NFJmRVJnRVVGRGl2cmFTVUJNRVVILy9BajRBWkRBbUE4cERIZ2NkOXF4MEVFS2tXbGdnUVhhZGRCY2N5Vnc1OE55QUxSUWdnWWFZcmZoRk45TmdRTVNJaUt4QkJJNmpJQWlpaUorK0NFSngwMkJIQTdJZGFlaGR5OGVwK0dCQm5iWEhRa3AvRWdDQzkwQnFRRUxMeUxwb3dZek1xbkJDRGhBK1NFT0dwWXdvNFpUamxEQ0ZGVnh5Y1FNaHBSZ2d4VmM1QUFFRlY3Y0FJUVVOZ0JoaEJBM25CR01Ha2Q0Z1FVUWQwSWh4QmxuM0xtSkVWU0FZWVNnV05ScGhCSnVDZ0dHRUY1UUlTY1FlT0JSUlI3L2JXQlJCeFpxaE1ISkhNR2dFZ1lxVkxpZ0JCRmJiSkhGRm5EODhza3lZUUFEVENiSUlDUEtGbldZb2NVYm9rZ2lpaWJEekVKTEw5VGM4UVljY0VqU1NMR0NTQUlJSElBZzg0WWttRFFDekRKdktBdUhGblVFc3d3dmQrQnl4eDI4U0FLSEdjUmlVZ3d4ZFFCeUJ5YkJhQ0hKdFc5ODhva2xiK0FCeHh1UmpMcEdIYUxnc3NjbnhSenlTU2VkM0VFd012SGVnUXkzcXN5aXlSMnE3SkZNSWFyYzRjb3dtcENpeUNOaFNDSkpLWENnUW9ncGFuQ2hSaU9kSnBLSUY2aEFFb1VYTGpOYVJDQlZQTUtMSTVvRUVrV2dnaFpSaEJGWUFGMEVvVlI0RklZYVZGU3hoaEZaRlBHRkZWWTBiVVVXVXpNTjlRc3U1SkIxMWxEa1VFYlcvMlZJRWJaWk11UWdnOWN6aEJDQ0ZDNEUwY01QYjcvdHRnNC82TkJEM1hJTVVZUVZ3U1FTQlJBM0JHcUREVjlJd1VRSVJhaHhCUk1ta0d4RDJuTjhZVUVJQ2xqeHhYVXBkR0RDZml6VXg3bCtLWWoxb0h2dVdXQUNBSVlRc2xwcHByVm0ybUNCaVRaQWFIYVJsaG9HcEtFV1dHb0FwbEZYWHhOQlVKQmZHZW4wa1BDWS9RWEFLcHlzQm9BS2lVQ2loaEF0VGZIQkNDRllJVXhSUDkybEUwUVR4SUJaVVF2d1lOSnEzYU4vRUVJRVBSRDhUd0JZb1ZRQkYrbGtRMjBoL0dERFd5cFl3VXBYeXN6QkJrVm9oaFhtSUQrREJBVjVLVW5nUVFxZ0dzbWs1aTZhQVJBckRHRUZpS1NCRlFCSXdnVmwwSVRJQU9BMXRMbENGMFp3cFA4T2FLQUdNZ2pDQ0h6Z2c5dkFSZ1p1NkVvREV6SUFDQ2dBZ2J0cERXV3NZSVlXdE1BS1I5aEVHSG94RFU1d2d4TTJ5QVVWZ0xBSkxyRGlVbG5nd2pIQzBJWXRtS0VSYjRnRkp0WndneTVBWVEyTVlBUWN3Z0F5UTFqRENrS3d3UTJnUUFRaUJBRUtacGdqRWRvQUNHcmQ0aEY2eUFNbWtER01PeVR0Qm9PUWhRV1dzQVFORmFjRTY5bUZneFRBQ3FXWUFJVW1rSUVMSGdrQUUrVEFDckx3Z1FWdzBJTVJqS2cyUS9pQkczUndneHRrSVJoVXVNRVM3SWFFSHZUZ08zVHJnQVVlWXdJVWxjQUhPc2hCRDRiQWhDRThJWmhNdUlFaHpuREtKVnhoQ1hHUWdoQ000QVU0SktJT1VWaERJSnl3aGlvNHdRbDNXZ01lM3BDTEcyei80azFYR09jSXJnQ1JHN1F0TmhZQVFBaHdFSUlXMkVBTzlrdWJPUzNRZzlsWTZEdExTc01QOGttbEZKeE9EVGJJd1RHb0FBQXVDQ0lKUTREbDNKQ1FJaDNnUUFjMWdKSUNMRkFDSkJSU0Iwc1lYQ3g3d0lUdmxJQUpTUWdCQUFUbkJCc1FiUTVjYU1FVjR2QUVKaUFCQ1VDTWd3MWFJSVJWRkU0S1ZqQUVJWi9FcFJvQU5haGpvNlJacFBDQ1JuRWpHRnN3QWhHVWdJaXBOV0VYekRDRUdxYWhVcW9hSWd1Q01BUVZsTEJUTEFqQ0ZNZFF3Z3R1d0lWbjNHQUxXREFERlFSeE5FcUI5Um1DQ01QS3FFR0xUeHlpR0pWb3hTUmF3ZGRSdEtJU21xQ0ZOQmF4aFVGZ1FhMWJnSk1UcXBDTE00QmhEY0FReEJHNkdZaGIzUEVSLzFGNFF4NGFjUzEzUmNFU21TQ0ZKckJ4c0Rzc1FoU2RjRVV0eHFBTFYrd0JHTHlRUml5a29ZczlGRU1UcnVBRkwxeVJERWVNUVE5NnVNTW5SRUZhU055aUUzMGpsTStXTmpVaitBeG9IcUVDRnB5cENPcFNJUkhLalVJVXFwQUlRVHlpRTlRZ0JDb1MwUWRJU09NUnBKREdMUlRCaUVTQkliNWdDSVBmTnJFR0wyRENDM2dvUlNacWNRZGQzRUVUc1lqRnpKZ3BCS3gxTFd4bmdNSWcyckNHSTdRaERFOFlRaHVlUVlVMnFISVFyMmdHRjg1UWhHTk1ZMlJDa0NndWQ2bURFR1RwUlZTaUQzM3Nnd0lOOUljL24ydmRlUGFqb0FpWUlFR3VjWTlyV3NOai9venVOenNHRHBGUHN4b2NhZ1lDd2NQQVFGWmdCdy9JNGhSaUNQOUNGeENCQ0RzQVFBeGQ4TU1naUpDS2FrQkVOY0ZySHd5Q0lrRUlhRVl6NmhQZThSWkFBYjM4YmlmYzI5Nzc1UHkrTzg5WktOMDdDWi94akpjMTYxbDllRFpmbi85TWtBQThwQzAvQ2NFUm9MRUlValRzRmxxQWhGMHNjSnZJZUVCM3RzT05helRRZ3lBRWdRalJ3TVFnZ3VDTVV3ZmhPSDd3Z1I5TTNZVlhuN3FFMVZCS2EyRG5IeEpFQUFXdElZRUZSbUNJRXlqQUJsSUlReGlvb2JGYlJDRVBVV2pERGFyUUNVRVVnUWtFR1VFTjRDY0lLclFnRGd1K1FnaElZSWd3Q0NISENUcU9DV3BBYlJsRW9LS0lCSUNQTi9RYkZqUkhBeTJRQVNYNGdBTVpxR0FFRmpBTmZGNkRtdFpob0hYdVljRUtBbzZCQnh6ODRMdTVIUWIvTUFBQWc3c0c0UkU0K0Z2SWNBMkNTQ1FHWklqQXdoRytnUTRnUERWVFdBRnZOQUFDaUh6Z0F2SmhnY04za1pVSmFJTVNBS2lHS1NqeEZoOGd3aEFXOEFFTDNHQU5INHpBU2FDMHdDazQwUVJRMkh3RVFiZ0NxRHNnQzFrZ0lRaFM4S2c5SXhOMEdDdEhQcnlCd2NSZlE0SVh6UWNIRThXQkM1SWdoQktFb0FRdStBRUFaS3lBRS9CZ1B5TklRaE5hMEFNcWhDRUxWNUJGR0FiUkJSZGtCNGdoZUNrVE5HQ0NFdVRnQm83Ym5SekFrREpvZVBVR0w1REZDMzd3QXJTWGJuR0xVd3dTYXVEUkZGaEhEYllnQkJDSW5Rc3RpRUpYdDhoREg4QVFoeUVNSVUxQWlFUWU5T0NLUXhEakZtUGc3aFl5WlFZdm5yS01FY2JpSEtaaC93akVtVUVSV3V4N0VKN2dCQ3djNFFwUTZNS0N3MkNJVVcxQkRZb3dBeGFFVUhxamliY1hMYVBDTTh3MWlDNFRBUXB1REVJY3lsQ0dHZkJCQmlyVVFRdHlRUDE4U1NJWWNGZ0RxZDVJaEJ1TWlTRXdReGdzd3h3b3dBd2tRUkZNelpvRXlxVEZncThNMkNPRUFoajBqS0c0Z0JCZ0lBV3FBUmIwak43MERLRmdBUlZRd1JZY3d5U013Z21pNENoTXdoeVlBZ0NWREJlSTROUVFTaFF3UWdUbVFodlVBYWtzMVJrdzFSY1F3UXVNU2hLOEFGbjVIeUR3eXg3MFFqTlFneDZFUWg4a1Y3SmhnaFkwUWlQWXdNOGN3VWxWd1NhNDBCWG95ekw4QXE2OFFSdTBBakZrelF3TUFUTXd3eG1VQVJIa1FGWnBBeGNNZ1F6QTBnOThrdjlEZ1ZJSmpFQUxITUVaS0lJZ0NJNFByTVFNb0lnR21JVUdoQUFTZ0JUc3hjRVJXTUV6SElFdkdWNEp1TTBTREVIYVdRZFZ0WUFjeUY0Z2dBRTBRRUlpT0FFalZNSGZQTUU0UFFFUVpNRVpiSUl4bVVFekhJTUZYQUVTS0FBVCtFQVhUTlVXYk1JcGdSb1NRQVFNaklBd3VJRWJUQUVMRkVRQk5BUkVtQUtZQVVBQU5FUUJISUF4ZWdJUFlBQUVIS01ZK0ZWSnFKbWdEZG8yY3VPZEFScGU1Qm1oZVdOZm1BOWVNR001cmsrWVJVQnhoSUFMREFBcitJVHV3SkE4b2xEUVdjQlJsQUFMaUFVaWFJOGRnQUlueU1JMitNQ29IVU13Vk1JeG1FRWJSRU9YQWNLL1RBSTM2TlVXTklJSmpnSW9NRmdYbElFYjJBR1ZqWUFIMUdML0Y0RGEwdmtBL0gyQU1zZ0ZNMVNDR2RpQllLU0J6R0hBQ0hRQkVReUNHV3hCRi94Q0pSQUJKOWpCbEgxQkUzUkFEaFJCQ0RCQkR6emNDblFBaGd3QklwYUlJWUVTRWlnR0xIMlNpczNBQzRTTkRqQkJrYWdkRk13Qk1YQ0MrMGxCR1FnQjlQaE5DTXpOT2tHR0NUUkdKQmtlSHlRQkNMakh3Zm1ZYVpTYkRGeGRmU3dGSzh3QUMwaUdhNlFHRWlpQkVzUmllMkJBakZoUGp3WFplRGlHRHFTQkM5U1NEY3lCR1JSQmRoMEJJMUFMTDJBV2ZpVkNHMGdCRkpoRlRIS0NHYVNmSHlnT3RmMUFWV2dJQ3RYQUJXZ0FDa21PRFRBSDZGakFCNmpGTGpBU2ZTakhCUVJkYmJTQUR5akFGS1NCUXpXQkJuZ0NLNHhBRTZTQmNZeUYvellBQUlYc0FCZklnQUkweHl0aHpvdmdnSU84UmdSVXo0N2gySGJVaDJLOGhxVlp3Tk5Zd0VFd0dtU2RRUzVBd1JOMGdkLzVRTUR4eG1EZ1drV2xob05NaCtYQUZCUFVRSEFpZ1EvVWhuUWdRUTc4UU5hOHdCd2xRaU5Jd3h2dzNobElRUmZFWWhsMGdTd2VnU0FJd2dBNFNCR0VRWEhZNDVaRVNBOFFBUjlJaGo2eUhIU3lrQStJUWNPSkFWOUVReVA0Z1IrSWdSOXd3cFk1ZzBhT3dCODRpVFBrQUNMQTRJTGx3R0lnaDJNb0R6T0FBZ2x4d2pHMHdSV2cweGQ4UVN2SmdCUmdINzZjd2h1WndhaFZRaVUwQWg2c3dVS3V3UnBzZ3ZxQkdoU0FXakxWalVUOWdHd0FvaHdrRTBqWmdEdTlqUXZFd1M2NWdBcTRnQTdNRGY5UW1jY0xZS0FRT0lFUVZNRWlTTUl3M01JdGFJSTBCRUlmeEVJelBJSVhLSUlpaEVFekVNSWN3RUVmN0FFc3RKWXFVSU1qd0lKclVVTXNoRUpqTFVJZTFFSFM1RUlVNEFGMzFRbWhKSUlXb0tvVzNKRWxXQUlnS0Fza0tJSVJPQUVZNUFJZUFJSWtlTXUyeklJakpNTWUrS29qMElJUzBrSXk2QUkxTkVNejlLb2pQSUlUaElCK1JFWnU1SkJHcU04eFhrSWExQVFGS0FSUkFBQU9tQTVLYUNPZG1jUURUSUZGOE5sbXlHY0xoQUFqeU5OYlpOQnlDZ0ZRenNFRnFBWTRXZ01aOU5reEFzQUJrQUVOMEFRTXdFQUJRTUJBbUlTK2tnRWxrRUVBWE1MRjBZUko0Q3MzN2tZMy9nUUYwQUc0a3NBMGNBRUExRUFDUWNRRnFNRC92RUxzTm1ZQTFQU0E3UGhGQkFIQUhBaUN4L2JaQTB3c3hEcEJMNWlDK0h4clNUVHN4NGJqU1lEam9BbWF0K29ablVXQU1tUUZSRmhERTFpRDlnd0F4MmtqR1NoblNrREVidXlHN0FBSEZDd0JmdW9BZURoR2hsaElnaURJYnpEQmZicVE0YXlUQXNnSExWa0FFeHlTRFJoUzJpeUJIQmlTZEZqQU5GaUI0THpyckRLQ0RVQ0JHNHdBUkpnQUUzQ2IraVFJUVNoQTJzaEJEclRBS3cxQUFKQ0J2WXBIRFRnSUcyMUNENWpBRzVDQ0twQ0NFd3hBQ1hncEZOekdadWhFWUdDQUIvREZ4eUtHVUF6R3hHRUFDM3hBRFh3QWpKVUdDZVN0SVJpQ0NoaENWK1JBRmpEQ1FwWEFERkNDR3JyQktWekNKU1R1dnU0ckhVd0IxN21HLzJMNHdDdkpuL2FZaEF5WVUwVlp3QVU2U0cxWXdCb2VBUlVFa0Fva2dSRjhBZklVQmtTNFFPZmFSVWtRUjIwb3dJTHNBaGRBeHNrcWcwbkVBRWxRNkx6RkpCR2c3cUFaZ2pMZXhmaGloc3FXeG9OTXdIZGt5RnZVZ0JWWVZRdDhRQWwwQlkzNUd3b0J5ZGY5eHhUMHdCVTRnU0tZNENSUUFSRmtRUm53UVFyTTUwSDFBaVBVV1FxWmdCQnNRUzV3Z1JHa3FZUDRnSVl3QVJURUFVVGdRQXZZaHpzMWF3cUV3QkJBd3lQMHdTT2dnaUxjUXNEa2FSSWtRUllZUVJzb0Fod3N3eUZJZ2hNMDVJQ3QwU0dSMUJ6TXdScEFsaEhNQVNGc0twUWNCUWljSENzb1F4b2t3QVNJZ0JpSGNVdWVRQU0wZ0FpbzhRU2tyZ3JZd0ErVWdQOGNNSUlUSE1FTnJBd3FxSUVUb0lJUzVJQWNRSUlqUUVJU0pFSVJBRUVJV01BVEhJUVNFQU1WMEVJc0FJRVNoTUVhbUFFbUpJRXlWQTVBcGNFMHpNREpoZ0VWeElLQWhVSW54QUlZaEFJa2FKWVdQSUlwaDBJZ0tGc2tGTUVMQU5Hek9oRHhITzQzMnV3dDQzSXU2L0l1ODNJdjN5eWdBUUFPRVVYQUJnOUtLTVEyem15ZnZROFBSS05mT0RNRVdFUXlud1FaQ01OYktNUEY3b1EwYzJNRXJJQStIb1FDTEpsZ3NObnArTVNlSFVTbWVVQkdTS3NFa1d5bVljQ0dJQUVUMkFBWVFJSW9QSU5rZ05KeHRKRG5Za0FNcklJQ1ZOVko0SVp2M0pJTEdNRXphQkJHcUxNemV3KzQ0aXdNbE05UEZJQXZhS3hJVU1BQWJFQUtvSUQvVHdEQUJjeEVOak4wYVJERWQ2Q3RnblRBWGRST1NxL0FPdjRBTVl3aEllRkd0R0lFUnArUE05OEZDa3hCWEE2SjBIM0FhNlRHanh3SVJMU0VlQkNHUkFDQUJoam5GOHlBR3lCQ0dqUkIwQ0dHQXVpQVVwdE5FM3pCa3lLQ0dXUktKVXdDbU1HQVBnSmlEM3dBQ3VpYTY3ekFDU3JEUUgyQUZYeDBCS25HQm9RWmErREdCdEJ5ejhyWlpqQjBReGNhOTFERXZKcXpYWnNFRHVRQUZPakFTZWVzWHZ1Wm9mMFpYc2YwUk9CQUVhQUNGb1FBZ0VMSmdwQ0dBOFgwWEdPUVVxQnJCRUVBQ0V4QTRMNlFYUmlFVzlNMFErOHNSZ1BHbnFYRWFwT0dSQ3owUk1CMm92RXNScWZBQjZUQUFtekFidWVHOEdSRUFlejJCaXpBQWhpQS93UklBQU1VN0RVMGdBU2dNWE1idHdFc0FBRVFBRjByaEVKZ3RIVlhkM1lYaEVUUWRYZlBjdjRhaHJkeUx2b1F4RU1NaFBvc05QSVlHamxxczg0cXN5L0Q5OGMyUk0zR2QzMi9kN2lTd1V6OEJCOE1BaDk0ejBFRXp3cjR0ME9rSTJMZjk0SHY3TTJPSXpJN2RFUGJjcmxxWTN2VEJCOEVBWk9SWTRNdm95OVRoRzQwVDUzWjlQdG9nQi9Jd0tqVVFSMHNRaW5rd1JIVVVtdEVodXBzQU1mNWRhQWxlTW1pdG5pUGQ2QUJ0azQ4QUFyY3hRT3NBSS9idERPSExtbWNUMnJvUnJwRnhnWkVSbkF3ZWViSU1McWlwUWxVNGkvRlFSd1ljdWxrenQ0T0FSQllRaW00d211TndSaDhNaU1nUnVoeUkwYlFkK2VDdDEralJHbVlxLytkcWZkN1U0UUQ1VzhFU2NTSHEvZHExSnBxQ0hRdHdhbDhzc1pFcEVBT3hNRU55T2tTeU9tSmJJMUhRVVlFa2JmQXFnNXVwRGRLdUFETFdFQU9HQVlBVElNYU1NSVN0RUFWQUNzcGtJSWpHRU10aEVJdE9JSWpSTUVqMUlJZUdNTVk5RUdZbHdJdndQb1lQQUl0YUVGSk9VRWc2QUVwVUFNcU9NR21Pb0VhQ0VJTG5CUTh2Uk45T2dFaEtJTGdrRlJ4UEFZdFJjQkVWWWtjM0trWFFBSXF4TUlrRUlJTk1FTDN0VGpvaFVBYzVJTDM2UXdRZU1FdDNFR21udFNsbk1FVHhJRVFwQ2N3VFpnTmVJRXRGQUVBNklBUlJFRWRRQUlrNklBUUZBSGhNZ0ZsMThBUmhJRXRhSUVva3dJakhJRzN1TlluWUV3ZlZNSEJsRUlnWEpQL0VmVENNN3pUWXp5QkVFU0J0NmlDTVN3Q0VKekJqbFlVYVVSQUM1aEN6Q3BBQ3dpR0JaQUdBQ3hCSjdmVEx1VkFDRVRBQjZpQUNzQXRFS0dyQmJBSklkaENtbkx3c3o0cmJvaUgvcjVQQkNTQkNvem50NjczWHEvWlR2REdicWYyQUx3RzVqd3JuRU1FWnFlR0ErSFFBOVJBQzFDQ0lZaFBERmdEV0xEQ0pNVHNYb2VqS1RUREVVREVmSi81TnNiQUxwekFvQWtzblcwR0JOQ1BlK095aE45WkFFaEFERlJBQW9EckFMVFArMmdybnEwQVNmaVpNZ3RhR2lSQkRRRFVPSDRyR1lUUGhRZTVUV2QyUldWK0N6aUlZcGp0RTlTVURUVENJZmhWSlhCQ0s0QUNBR1RhYW9UR2JRY0ZCcGpBU3gyMTE1Uk9zbmU5U0Z6RDQvODMvK2d6UGVmV0djNzZQV0RZaG1sZ09RNDRBUlVvQWhnOFlpVXEweGxzVmhSQWc4NWdlL1RiUUl1WEJCQTVEanhCeGpydHdoSFpRQjVrd2hpMFZoL1VBaW93NmhoQURDejBDeTBVd3lROFpDODR3aDNRQWpGOEFVQ0VPSkxyUnNFdVpNaGNJZ0xvRFNCZ2IyNXNpaVRwMEtGWmUzcE4wcWlSRzdkaW4walI2dFZMR2lsTm1yUjRpUklGU0lzV1M1N0VNUUlFREtGWW9VSW9BREFBQXdBRlRrb29HREFBd002aVI0VU9QVnAwNkFBRkNpNUU4SG1oeHM2blRYYzJKYW8wYVlHaUc0aG14VHEwZ0ZZRkd4NkFIZkFBUTlpbGI0K3VqWkFpd2xpdFNnRUUyR0JqVFVzTEZwNkNCWkFqaVEyaEFKWUlPV0xqaVp3bFEvNHVrY05rd1A4UWlWV09aQjdTQXZEVHEwbmh1bzFiTk1LRHNVemZpbzRiQUc3ZTFxK0xUdUh6Z1FRTEJVaUlFUEhSb3dlTEswSDhNSFc3VmF0WXoxWVBxNFlOdTZrQ0N5bENsQ2lSTTdUUXAwaDYzSWpqT01lTlhIbjA2QWtVS3BTeFdxR2NIQUhpUkEycVVFZEN1RFF4UkE0UUtISnk0aVhxd2NQUy9zdDNlaTZGRm5Rb1FZTVNlbEJCQnF0d3VLQkFIQ0FzQVljVUxIQXFyS0VDR0FDNklVS0lEekM4bG5MT0FoTmFNS0ZESmtJWWdnbnI1dnBMcDZOMllTVzBvMWd6YWl2amhrcnFycU1nOEcrcHRUcFlRb29pbEZpQ2hSR2MwUURBMXBTTEMwVG1VTFBScUNtZlhOTEtHMW1nemJZSHJ0SnFnd2lrQWdDQ0c1dWtjZ1BoaUxOUnFlTC9icVJTU3E4QWVLQUR6eFNJSUw0aG5pam9EVWh1QU9LSUoxUU13UVFUT2lpMEF6RGxwSE1GSGU4Q0RBY1dNS0RUc3h5ZmlzQ0NEdjdxd0trUXJGQWpCem11aU9PS0paRDRyYUNDYkxDQkMxdU1zT0JVUFBMQUk0Z2IxcWpqalR4c3JVTlhYVytvUVFjWjBrRGtDemRla0NLSU1ycVFBUW9aZ3VDdEJ4MnV1QUtKSjVnQXpFWHJjbXl1VUIrZWlMYUZJUW9LTlk0NG9JaGppUktXSUhST0hGelE0TVVCUmhRb2lsaVc0YVNSTUxhSXhBS2ZtaE5OUHhxdC9IRUFyNGhUcnN5QUVVNVk0U1VWQ0tHS1hsQnhjaWdNVUxBMEJTZGlFY1NHRm1ETGNFb2pOQmtqa0Q2YzZQQWxLSVpnTWk0U1BrakJRcndlSUczT0FWREFBWUJMLzZ3WnJjM1VvbHpZNTUrQkJ2RENNZ2FKSXBkY2dJaGtFVmNzT2FJRm5iNFF4SVVXVXBURGhoQ0t5bENPbGZRWVF4cHBhaGxqakZEdTBDUVdUU0FCZ3NWOUxWZ2l4U0ZzOENtQ3c5UzhVQ3lzQU5nbWxWUldTYksxQ0dxSUx6bVBtU3hnVEF4aTl1bXFBa1pzWVUweW1ic3J4K2lHeUl5Unl4a0pSSTBpREFPZ1V5ZkFTT1FXbkFab0FRaEdRckJiTlRJTUNlTUpac3k0VzNMSWc2N2RkcVllWUFFMW9sYVJjY3JSYm8reXlUWU5icW9BcjBad0k2dElRUXZRV2dzd01IU0lFcDdJc3lBZ3FsaWtqekZjV2NRU1kxVGhSWlZzWU5sakQxaHd3Y1g4YkZSUnBSQmRDcG1sb29wd3VTTVVScUtvQllnYjhEaWtsWjdFNElNU2pQOEFRbThaa1FiQVpJSWxNQUVLYStoREgwSXhCajA4b2hZVjNFUDd6Q2MvaThCaUZob3NSa1Urc1FkZWhFSVJoUGdFTCtDbkMwdndBaG5MS0VZdzRQQ0dOMWdDRHpQRVF4M1dFSVl3QUVFTHVkQkNIYnpBTVJ0VVlRMVIwQUljb2hBSk9FZ0NFSklRaFNzdXVBZHNXQ0lLa25oRHFrTGdoVmgwZ21SeFk0cUo0dk0wUm9HR1RKTlNnQWswb0lOTFFROHZMSWlERUVwd3FkbjlMbmgxdE9NZEVWWWpQUHFNSndRcmlvbGFZQU1sZkFvYWVxakZJb0FRZ2dyaGpZOHJVMEFMZ2dJWGJleENPRC9hNHlXdjlBQVloR1VKUVBDQ0V4alJnalhnb2hRcGtzNkhHSGt3Qk1aRkFaaDZpZ25xSXdRZG9PWUx6Tmpqd1lDbW9YT2Rhd2ovdmZSbDVXd2dCekFJd1FsVkNFUWdTTkdNV0RnaEZCUWt6eGhJa1F4SDBPSVJvVGhtS09KV3BTbUJnaElCczh2ZHBJUXcxalZoT1Fkcmt3S2FjSUtzMEVpUC9xSWptcHlEQkNzVUlRUk1RQUlUb2hXZkZIUkFrV2Rjd3ArcWRaVVM2Q0JIRnFqY1FRbmxraFQ4d0FWR3lJRWlwY0NTSS9UU0JtRWdCQ3BRQVloSUFJR2pxQUlDTkNLUmh6YzhBaHBWaUlSSm93QUdScXpIQ1ZGNGhCY2FNWWdyTk9JUVJnQ0FEZExUeXlmODZXbzJ1RUVrOEZDRkt2UmhFV1BJaENzK0lRb2JET0FHY0dnRUViYWlBRzc1d0ZyY1NnRWxVa0dHQ2ppbkJVL2dSRFBDNElRMTRDR2tsc2lESlRLQkRWZXMxUmk4RUo4azZ2QUVKS2lJQ1MxZy80TDF6Q0FFUE9VZ0NGUjlTbEV3RUpFNjVLSUxZcGpTRkthQUFUQkZEd2xMQU1BZ01DR0tUU0RtQ01hc1FoM01HbFJBNkNFVWpwQkdLSWg0S2tDQjBTVmlmRXBaQnJZenlLV3BPS3dKd0dzeEdWdlp6cGEyZGNTbGxmVG9nUkdNQUFOaUVNTU50bUFKNGVMaENkb01HQjA4a2Jod3ZxVUFNRGlBTjJFd3B0cE90NUk3KzFFQkx0SE4yQktGRXErNHhISWcwS1BYcU9ZRkw2QWFDZWd5S2JNTTRBTVhlQnBnaXFMSTJ3S0FFczB3aENCc2tUTHF2c1VVbzRnQ3o2dzczLytJaVQ5bGdnRmllY0FETzloQkdIWVl3UlJZd0tVY0lRNVNad0VMQmxoZ0Foem9ZQWs1eUVFV3dLQUlPQ2hDaDJkd2tRV1ljSU1xWUE5N3drVnJKdi9XNElkSURQY0dSNEJHSGtJZ2lHY1V4UWExeUVZMkNnRmtYUXk1RUVVMmNpRmdjUWhjWU9NUnZXaUdqRXJBR1RZNXBVdVdSQmhSUURHSkJLU0dOVEVRUmxFdTBBUzY3ZmRLVnVZWlhHQkFCeGdFclFNRmVZSVArZ09ESVB4QkEyTEFBQVk4c0JZdS9RZ0RLeGpCQi9nUWhCRUVnVmxCVUpMUTRPWEtNZDlPdXJmVG85RGUyY2k0RUd5K1pSNFlYQmdWNlovTk1VY3RrRU1WakFHL01UQ2lNd3JvWkVzcXZSUmxtRUkxcXVGQk5UQndqVXBvSXhXdHFNUTJQUEVMTTRqaEQ3ODRoZzlhUXdkT3BPSVhvTmpiS3lieGlwL0ZUQnVUYUFBWnB2RUxXWkNCQjB2eUFBUUNBQUU2cUhuYkFDQURLTWdRZ0QvWTRSU0lPSVVkZWhML3B4VkVkOVB2UE10d2R0ZVVHcEVBRG81d0JDeGdZWjQ4aERQVlpGN1NvLzBkY05xNjRSU25jTVlJQmd6Z25pMEpiMnpTUUJBMlFZUXRhT0dJb21qRUptNndDRENNOTNGcWN0UENpOUtDUU9paEVPNHp6eGoycGVkK0YrVWFhUmd2SFRTOUpQR0s5eTNaSllQUFJtQ0dOZ1NoUHlPd1E1My9FRjBZOE1BVEIvZURvZS9zQno4TVlodG0yTVlwanZJQUVKQUFDU1Vnd1FnME1BSWZRSElKT2pCQktwY3I2U0lRd2dzNFBVSWdqT20wcC94bEo2Y2NnQTJrQVl0YXRFOXNZM2hnRlc1QUxTYnMvZXVkS2RPRnluSW1SaGFGQjRMZ2dob0VBUUxaRGlVR25pREtLMEFoZ0JwMW9SR1NzRVJ3QUdBSFB2aGdVQXI4UVFyRXRBTEUvNjU1S1B5QndORHRrT0NndDRZL3JjZUFIY1RRSHpFRWdmWis4SUh0ZmVDREFHckFEMGd3d1ZPWXNJWmNBRFVTYThDNFV6bGhCako0SW10bDhRQ2VJK1ZPT01HbFAvd3BDczJYY21jRlhPRUdoRExCc0F2YkJkMEFtMG1sQTBBYWJCRUduNnJuRGE0d0JveUQ4TFJWTGVpdlgva0FEOUlrc2FONHdBNWQ4RC8xQVdEQUJtQUJzSThwcEdzQVZvQUhlZ1FHRHV3UENHNFFUcUd3TU1BSE5BQUc3Q3hoVG0vTkFQQXRNa0R5bnFzMXZDSUVzMGJnckNRTm1zQXBVT3RmZGtKT0xLQkRVSUVhU09FUnZDaG9ySXNFYXlzaEhBQkF2dTNtYlBETWFqQ1h4dUlwRE9RdUN1QTRFRytwRGdZRHBpQlp1a0R6TlBBdFlHQWJmaUVhaVA5QUE5Sk50anlCREthZ25IcGtBQnhnQldMR25HNUV1WlNMVEFZbWNRekZBMWlBRHk1dzRmeEZOT2lBREo3d05NYUxqcWJBWFdLTzRld0dUYkpGTFJobEFOVENMb3JEeXF6ckZGN2hHZ0FBQmxvdno5WkVZVkloWndBTEVZNWhEaFRCQ2dDQUJYaWl3T2pydTE0REZCQ3hEc0dKS0E1czIxVFBEdjZBQjY3aEVsekxQNnlQUDhUQUR0eGdFRGhoRUdSQkZoREJEZjZnUDhLTDBXQ0FBaklBdHBiQ0V5NkIySmJpRkVCaEcvNXRTUjRBQ2JwZ0V6WUJDalloQ0s0Z0xEd0E0SzZQUndJZzRlandSenBnUU9MREJpb3JEeGJoRHBZTUdUQ2hFYmJCR2FCZ0M0SUFFWDVoQ3haaEVlQm10Q3BFTEdMT1lNek1aNnlSS1FybFhYYi9wTlUrem81ZzRCSmlBQUJRUUxtV3czQWU0QUZPYndFUThpaGd3QmQ0NEFsdEoxdVFReWlBWUJHd0lST2NvQWlFWUVZWURpNVNZUkpjcmdkTjhpUVRwbDk2WnVXT3doZkl3QTU4SWZVVXpBNDhZUVJnNEEvRW9BbVVnUklxb0FMMmtRUTlvUW5Td1JSc3BpazhnQTJRa2czT0tBUnlJUXBzWUJGSVlROUlRUnB3N0VXNHlnSmM0a01BWUZCS3krK01ZZ053Z0lCd29BWnc0QWRHSUV4SW9BYUVZbzBhOFRWeWdKaUNiQSt5WVd5Y3dBbm1JQXdDNFRWK3NnNDN3RGwwQXQ0TWNnVVVEakIvNUFOTXd5bVdBbElxalNWMThTaTJZUlMwS3gvZnFRRDZneVZQZ2ZtS3dnNXFzUXQwN3dwcnF3QXlnQTRLMEVwZ0FBSElnQVlrLzBBQXZJa29GaEl1dG1BWktnSHFiQ3NyaXZCTDZHSnVObUFGMW8wb1RtLzZmbEExRkdBSUVzN2ExbXdGU01Bbk5JQXJCK1ZhcUF5VjFnazI0T3NvUm9SdWZoQmdBTVpTL2xJR1d1QVJWS0h1eUFNU05DRVV4cWZJZmt4czVQTElqRXdYUmlZZXEyQ2xnRUMvV21NdkI0QUVRT0JGbHFJYWpvSFlLcUVWV2dIWlh1RVZXaUVWNE1BTXpBRHFLaE5LNmdnTjJ1NEdoS0RHam9BbDk4Z1VKZ0VNOWdVbCtVZ0JUSU9NQW00eE1UQzhzQTBLUGNFT01vQWlNUWtyWklBTHhHUmhwcTgxRkRRUHp3d1V0MHQyWXNzREdGQU1XRUFEV0dCTzNrMW5oRU1CV0FBVGI0dDJRcU01SWtBRENxVXRYME1EaUtBTGpzUU9JRFExUk9URVN2OXQ4Q0R0UmF1alRMS3RLRFlKdkI1Z1JlOUlOS2FBQkpybloyanVDd3hoQjJMakdtTEFKUlBITGJvTEZJSW5HNHNDRktZd0dyNXNZVnJVa2lqRkhvZUM3WGJDQkN4QUVRTEJBdW9pelBpVVVMdWtTZTdzenRxdEtGZ2dmK2dCSHRpZ1J2WlNqMmpnRW1oZ0orQkVDanBCWkJqQm1vN0FDVkxGQ1FJQkNBempyd2lCRVBUMExZSUVlMDZLby9abkN3N2hFMmlCRzdCZ0ovakE4VEJBQXhyc0xaYVBEU3cwYUs3eUtRWkVLMjluQURSbEoxcmdDQjVCRDRhTUdwcGhQRVExQkZKbE9hYWhHVW95V0xYMXl0YkNKUE4wdXZMMCtZQVZXSCtFWEdjclRVSUFHdHFCRWRDaENOd0FBOURnQWZaR3VieFVaU29KQTBxZ1NBbkZ1RmIvZFN2R3NnUjRBaTljdGFOU1lDM2xLSGpNRlFBU3RuWjQ4eWcrVURJbGh3UjZJRnBLNFBmcUFsbC9JQ2d3Z0EyUWRkR3FGR0hRUUFFdzdNNW1obCtYdzF6cjFTZXdFZ0RVZ0JDb0lGVWdoWGx1Q3cxb2xnM01BVGp3REVBVzlwTENvcjkwY3dUY0lSZXd3UmplNThmUXN4RHFyZzlLRlFpdVFBSDRRQmd3b0J0bVMwR2xObUY4Z1p6NHlBejlhRWZzQ0EwZ3dNOXdBQkVhNFJ3UklRZDZ3QngrMUFQUVlBQ1NrbVpwZGxzRFRnR1lJRE9BUUE3d28yQ3hCVzcxZG0rcGF5LzU5bThGem04QkpBQjJGaVV2UkwycVUyRlF5eWVZWUFsdUlBUXdSUWQrWUFrb1Z4MDZJM2pRd0hDVW9rVUhZRzJid2pNM2NCRmJqd1dDSUJ6Qy8rRWJmbUhtMkcwNFhRUGdxdUVWS29Gdm5FRW9XL1JiZVpRb25NTUk4a0FMRk1FR3dPQVJvbUFSU3FwUE1qSVBvaUFQL09ScDhLZ0FFN2NvRUNBVmdmRm5LRE84aUdjRUEyWVZSM08yUEdBSzdFeHRXeFFDeUZWd1U4TUhvQ0FJWHFUUkFEZDkxWGQ5OTJ1K2JKZDk0VGQrNWRmZjZxUURkRUNOVEVBSHdDRmJsNFJqWDJFVXhpRVJZUURQV05mUmxrSndXMVI4azVHNVFCTGtBQ1Jtb3NjK3ErTXpvZzVHWlV2YllPNHRFSUVUT0dFYkVFRVlWZ0VVcWlHUExrbTNiRThNMEtDQTUzZUZXYmlGWGZpRllUaUdxYXR3dXhZdUtMVjFGL2lTM2xkaGRsaDRmSmpNcU5SMkZPQUpEaTE0SElCRUxaU0daWGlKbWJpSlcxaUJhLzlyWEJXMmh6RXBLWk15V04rV2lwMjRLSlFZUUJUVWJYK21Cc0lnR0JvQkNnQUxVaDVBaGJkWVc1OFVrL0pVaS9jSWp0ZDRqdW00anUzNGp1MjRpL0Y0ai9tNGovMzRqd0Y1Y0s4M2tBbTVrQTM1a0JFNWtSVjVrUmY0aGwzamtSMDVrcTFYa2htNWtpMzVrakU1a3dzWmlrbjRrYTNUaGo5NUZTRjVra2RaajBUNWhpVVpsVWN3bGRrSmgxMHJrbGZ4bGZNaWxsdVhsbUZMbG5INWxWL3JsbmU1bDMyNWxvSFpsd05BOG5xWm1JVTVsMlA1bUpWNWw0UFpsbDE1bHFINWxLMDNtS2taaHoxWm1wOFpsWEg1bWExNUgwMjVtNk41bThGWmxiblptVXM1bDV1NW5FdDVuYk9abE5XWm5WblpuTEhabFoyNW5tczVBTHdDbi9QL1lnQitXWitGdVFCMkdhQ1hXYUNaMlo1Vm1aYlhtWld0T2FGSDJUb1JXcFE3WnBvOU9hSkRtWjNqY3prRTE1RnpHS01WNXFBbitwQTUrUzBvbWFJNWVwcWxXWjVYT2FYQkdaNGIrcVJUbXBlaitackRtWmVUT1p6cCthYVRlWmxudVpmdk9hWjkyWmhmQzZoNU9xZG5lcG1GMmFmUkdhYVZ1cVVQMktadldhSkhtcWtQR3AxbFdxS2JPcFZ0ZVp2Sm1hVlpPcW16T3B2SjJhTVYrcUhkR1p0UnVwMnRtcHJ0T1pzSldxdDVHcUR6b3EwRCtyVUlXcTdwR3FMVjJaeWxlcSs1K3BzQmpxdy9PckJGdXFTYmVxVWZ6VzhQMjZFdldyQnhpNlE3MnBKRHVwRW5HckVITzY4VjI2eTdXcVhIR21DVVdwYlArWjc3MmFkeHVxWTcvN3VmZFZtcmtkcW9kZnFwVmJ1MVMzdXBVWnUwdjdxejFUcXBSVnViZHhxbFM5dXdQeHUyQ3h1enQzcXF3ZHFwUlR1em1WcXprWnVzQVZ1c2R6cTM2Zm0wTC9xMDd6cERhUHF1UWR1MXB6dDYvNXFyWmRxamVadWh2WHVlRFJxaEYxdWpmNXViMHpxOUdWdTkyZnVUM2R1ZE5SbG84THF5T1pxMG9mbWRLWG0yOFp1ejA1bTFlOXV0aWR1Mi9adTFCUnpBNnhtWm9WdTZYYnU1bDFueWhGcTFINXkyQy95MlkzdTBtN3VkQ1Z5dCsxdTV1MW0ycXpyRFFkeXlTZG1sKzdyRXcvcXkwZHFsOHh2RCtkdVVoL3E1NHhvQUJKcWZuZHVnV2R5Lzg1bXVvNW5HcVp2RlFYbTkvWHJFay91N0lYcXI2ZnVsaFp5aDEvdkhsN3k5S2YrN29ZR2NzT05iTDAwYXlqZWJ3NGRjeGZjYUdIVjd1Q1ZjcXUxYndtZmJxelhjdHdkY3hVMjdvTEg3bUo5N3pZYzVxSTNheTRmYXc4L2NxV09iekExY3dBTjh5ekhjckEyOG9rODhvVFA4dUkzN20xTjhuSTlibnJONnZKMlpvUGxabi9PNXAvLzV0V2djeVhzNjBrLzcwVnVYeDlINnFzdjZ4OE9idjFkNjFPZVpzSU5jeWM4YnlsUDl5Q1dieVIrN3lhZTh2aU82d2tlYXhFTWR0d2Q4Y0hXNXFDK2N6c004dFJsY3pKRTZ3SW5helkzOTJKRWR1NG45encvY3p1V2N3cDA5ejRrYnpLUGRzM0VkdGFzY3hTR1pwb2Y5eGMzYkdsZmNtN09kdVJVOHdTWGRuKzhacm84SDB0dDhydkhadElzaW4zTjh3Qjk5eHBuQ3h2WC9tcjBOZmEyTEhOQ0YvS2xWUGRXMUhPQTdtYVROdTdEcEc0cWpPdFlUNXR0dDU5U1grOU83MjlLRlhhd0JHNmN0UE5jVlBlTXBmTTZOUGRqTFBkbEZIdDU5ZmNUSGZNOUx2dG5WdkxiNys4TUZ2ZHFmM2N6M3Zab3grOGJEdk5tN2U3VnZuTUUzblRVd25kT0wvYWx6dkhVeFhjYXZlODF6ZTljWFhlbHRuc0IvL2NTREc3d3orOGx0WGFYaDI3ZzNlcEQxWGVJRldiNWpIZUluVytDUlhLTVRtK3l0ZnJOSlBkcTluT1piWHJmdjNLYlphZVJKWHU3cC9xanRlK2MzWE8xaCsrVDNIcXl4WGNucGZPZk4vT2o3bnN0ZGZyekxIUEdyVzVrRjM5c0Z2Nmh0bWNmci9hN3RlcGdCbWdEdVdnRHNlcFpwWE40WFg2QTkzNThIL3o3cFNkKy9MWHYwemY3UUh4L0xEWjZ2Ri82OXFSemhYNTNWR2I3aEJ6dlFhZi9xWWQvMUozNi9XWDdDVmI3SzZ6enc4YnpkNjk3WUhkemJqejM1a2IyWkN6cnA0OXp1Q2YvNG4xKzdvWi9aOGZ6dEMzK20rN3pGVjV2NnFUL1lvMW5kS1Qza0FScjBnUnJ6ei8vZDExL3pzeHZ6M3ozKzJ4cmtkL3JSbzMrWDdmL2RtNzdYL1I0Z0FBUVlLTEJnQUlNSUR5bzBPSkNnd29ZTUJUNU1TSEdoUlFBRk1SN0VxSkdqeDQ4Z00yN01HUExqeHBFaUVZSThXWklqeXBZd1k4cWNTYk9telpzd0YxS1UrZElqeXA0cFdYWmtLYlJvUllrSkp5cEZlckdoMDZkTEgwS2RTclZxUXdGV3MycDFpcldyVTRsUXZXSU5TOWJxVVlkTnQvOUNaYWkyS2xpM0RsMitoUmhYcE5Ta0ZkTXl0U2oxS1Zpa0hkblM3ZHUyc09HcFRQZFdMVENRc2VNQUJSaGpqUnlBQU9UTGxpMHpianc1d09TeFdnRnMvanU0NzRDbW0wdS9YWDEzNWRlbVFXTVRucHVVYnQ2ektXc0tEUWxVYnU2U0YxWE9OSnA3Tjg3anlKTXJwemxTWjNPZmdYbTM3QjM3OS9PZGNmbEd6TDRkN1Z5ejN0RWU5a3grdlBtcVk4ZCtUMDhldEZXdld3TnJQeG4vUEhqQ1ZCTkhyZTBYZDFybjJ3VllGMUY3Q2ZZYWZ2YVp0MWxxV2hVZzBJS0ZDYkNaWnBjeHBwbDdsem5GWUdWUVFSakFhUVNOTmhoQ0RuNTQ0SW5jNmNWWGlublo5cHFBS3MzbkgyN1FrU1NjVGRUVmFKSnZReFczM0k5QUJpbmtrRHovOVJoamRDdlZTS0I4WnlrRlczaUtsVmFZZ1ZPSlZWNlZBMkhZM3BYbWFSbmhsdXhkUlpXVlc3WWw0SUdzb2FsV2dZWjVxUnBpNHVVWFhtZ3JwcWtmbTFGS21TQ0tDbXE0bFphZFpTZ2haSU1TbXVHR2lPNUoyNGd5T2lqWGt6TkNLaW1VVDc1b0tXQ1NIcVVqY3NZaG1WT1N3RTNIcEpLakVtbnFxYWNDOWRKdXdlbTA0MjgwWnVwY1ZQczVDYU5mc3U2cEszeTYvbGxtci9meEYreWtkczZINEpRcEdydW1tWlhpR2FkaDN3RWJyV0dQY1ZqaFpaMTE5dGdCSEhKTFFHUWVGaUNBWlJLNnQyRkRpUmEyMldtaVBkaVlpOElXRzI5ckpCa2JLYVU5eWxpbnZaNUtSNnEvbS9aN1hJNm9GbXp3d2JEMjF0TjFydUtJbld6Vi85RjYxNXg0OVVVbHNCaG5tZkdYYm5LMU1iSlpUYXVyeUIrWDFUSEp3cFpjY3FLUFFSanV1NXRoYU5tN21YRll3TGVIRWxxdXVBMitteUJwY0RZcDNxSXJEcTNqYkxEeHQyTndiT25uSWtFM1ViZHF3RDc2cG1wTW5TS3M5ZFpCRW93a2dRQStSOXlTUnJISzQ1SzMyUXZ2c1IrNzZWN0hhb0ZtNWR4ZzFpMUFWM1I3clBMR0Y4dFpOZHNrNzcyczRCaHZPSzI0TGFNTGM4NlNwWlo0QUJBb3JyRm5Gdm9jYU01Wm5UdTQwNUdTNlBOQ0pScElXcDZXL25mbnhBS3hHMWRxbzlmYWVkSU5sNXFjMTJkemJmdnRCNHZOWkt2Q2xXMTFkZlUrZXVTK2ZST3VNZHdlSXg5MzNjZmI3VHplZVRkUHQvS0VEL1VVOWNiVHVhZmM3LzlsYjVYbWZsWXJQbms4WTh2enpOV2lmKzJGNmxwYmZwWGdTLzd5V3FpWGZ1WlVDd3Fkb1ovWEp2b1c2N2dxV2tKQUJDSTl0ZTUxc0xLUnFCSklIS3k5S25nQ3c1M0JhSWM3U0cxcWJEZjZYWkd1QTdIc1BNdDdZcHBjVnFiSHBTODlyendrVE9HVjhxYkM3WVVNWTd5eVQrQUVKNWdaMmlkKzQzRVp6YXpGdnBudGIwR0RHdFM2R0tldDl2MXdLNHdaUUJKTnhEWkZNVVkwQTJIWEUrdFRFSmFSajNKWTFGeUpjR2l4THVwTFZnalVGM1QyRTZxQmxSR0NFa3lqQkxPV3J3Z21DVzFSR3hYRGdsS3JEMmJQYlNlTVlaZnkyQjY4T1U5NmZMd2U4MERZSml5VmtKQWpjNUlkamZnVUxsSkxpSWNxMTg2d1FpRXM3dkNJVVZ6L25DQWZWeTBpVXVaOWZ2dVBuSWJXeU05NWtDcWRsQnpteEZlbzhUa21jZVBiSDhVTVdEUXcybEpUMHVFT3FHVEh3T0dvOFpmQUJGZ0Q1d2hCTmhiVFNNT0QyazlFMlVUMEFCSlFJaHpoSC9YNHF6RWxqNC9RSk5NMTJSTW1RYUp3Y21IQ1huK2FHY0lRd2syY2hreFFDMTk0dWdROVRwV0xJVlRqQmxWSnhCMHhjZlRNVXVNWXA4b0pWVVY5Mk9Jbnp6akp3MnRoamxuMzZWQnBIS2NoRE1IeWMwQUVva0xEeDcvU3ZVbVJMSUxkNldaMEk2WlJjSUVOUEdNdzFmaFIzZnpPbUs5Q0c5aU1oRUg2WUlwSDFyR0xEUzBxU0hTbU01elB2S1l6dWZsTkVtNVRtdHEwNmZJUWlTV2JkbE1yUVpRbkpRZENMcDZKc3p1NWVrbzkvMjJXTGN6MER6S09DV0xsQnByVW1WR29abDUxbjUrK3l0UXIzdE5uT25TZlZzVnFWYlVPRkpXbVZCd0FKWnJWQ24zbVhhMGNTMloyeGlFSUlFNUNZV1VyUWEvcVNuZ1dzSXVLV2RTOWJtbEJnc1hPUmlWOUlFeEhTbG1ISll5bGtQM2FrVGJMdStISnBsbks3T0JHUTFtV25NSW5oWGZySTVsOENrN1Zla2FGc0Mya1VBazMyOUxpNzdiZGd5ZGV4WFFoZTVhcnJEeHRubkNQS3MybXVsV1NTbVVNQlBLcDNOL2EwN2hOemVzOEsxZFFmM3BJVU5YbFVLRnNaajYrNmhCQ1lmWHFVak5YMFZXdWo3dVc0ZFp5bzN1enlwUnJ1ZUtDNzdlME9pNzMvbldybXZRdFhmVmFWbXNobGs5T2tlTGFXdlF3TUJaSmdmNmEyZ0lUV1AvWkJnT3BzdzcwVVdOM2g5azMzYWJBaXB6aERGTTdONTUyK0c0Y0JqR0hUL2c4RVAreFRLeHRDMDRQV2JJVjE1WXIwQXZ4UksxWnpsSW1iNnVmOFcxNWFxWmRGS2FXeGQvakVBR1dLcTRoRThESWU3V25rbUUyeWJkVzlidUFGYktVWTFrNVhqazVOVDZrc25senhtUG44clc4L25TdmthVWNPZVZlWnJsbDdsWjh5N1ZYSTllM1pnY0ExM3dQTU9RRFRITElEelhSUTF1WjM3aE9iSkZQUTFxQVBKdXBBeU00d21pY3JJTWRURHV6eVJHekZQNGJUbjdTeG9xTk5sOGFmVFE1YWN5ODJMWjJrRWRGN2JqdU5tUlNpN2lhZWhNaDl6YTJ6ajBDZFpEWEsxOVNzV2pjVmU5WXUwT1djbStOWE9TNzNUZkhsTHVySTNYOTVyTC80cG5OOW4welgvbTdQL2d5V1ZEVExlaDdxUnE1OUFiQVc4a3VjckoxcmM4clFoSyt2ODExUEEzNlY3LzJMOHBISHJXZDB5dXVPRU1teldWdWNqNnhYYlBJWGN2WlprYmZXbDI1Nzd0bTk2QVAyYUtmTTBwVGdUTTJqSkkrTkRFVHZPaUdhL3FZbS9Wc3hEblkwa2gzMEZZZXRkN0RJRDNMcDdXb204RjlkWTEvS21NUmk3alVKZ1l5cjJ6TnNWN1ZGbm1zeGRCcDIwTXU3WWE1Zk9HVmQ1S0x2VmY3N2hhcy90M0tzWGQrN0hMWitkZC96Y3kzZkRqZWlNcmJxajNmdVowaDRPWmVhL3ZZOXlWMjBvV01iRHhYSnRjOVA1K3hrNzN1Y1ZtNzJwQTdzM3ZYZS9RaFU3MWJGekkzV091YlZXZGI4dHlQUWJ0UzcxM1FMYWUxLzVQam0wdjhVSFpSaEJOTHdRam00S2RNNm5DU1puQ3lBT3JkU1pGSk51RVJHdU84MHgzQjJhUWlad1dPYzZjc1pFL0JaUExTbXh6bHBlLzBOdzhUUGROaU0vVWtmejJKbWJyVUgzOUdrdUVXTTlldG52dXNJdjNPbE95NjhDVXpPVmh1RitoSEZ3Q2FsYzl1Q2RFNTNkL3lscStWZmJPYkRTck4zaDExcWF2ZWRUR3J1ODdhRnpMNDNUem1OU085b1lZaWZyWjNSdS9sdDl1OTYyWTcrSk12MzJ0Zis3NTdYYTRBMUxzL0NsWHV5QTlsWmdKb2YwN0JMVTJtZHNxSEZkaldGVmhXVnZaa1VBMjFUNW9FSjNGaWVCdlhLVjVEYVlmbVM0MDNhUS9HWUEra081a2xjWkFXTVJHRGNSS25OcHhYTVpsSEszbENPcXhtV3FiM1d2OGw1Mk9rWjJMck5EMStWSVBjRTJJNmFIcEFDR0xiTjRNeE5uUGdKeGIrUm5NOHgyYlVOMnJuTjAvQmQzWGVOMlo3cFd3eHhGeExCWGJYTmk3cjVZVGNFbWZNZDMvNzEyNTA5blYxeG0zMUpWRGtobmRsUjNYYXQzL2FkNGJOTjM1RFoxZkVwejR2VTNkMUJuM3FabmJmTnk3clJnQmxGNGlBR0liV1JnRGdobWJXdGhud2hsV1BnWFdXQVc2SmcyOXA5MXZTOTFacGhtMk13UzNra1dWb3RUaFdCRkdiYzNBVHBtaUlKakFocFVFZDZJRm1ORWE3cElGcDQza1pWV21abGl3djVTeWRweUtZaHpwMFJEK3A1ajB6RjFTa1I0TStXSVN3QmlodUZvVEtLQUFKY0RmTlNBQUpNR1FNTUM3TnVJeW1ONFRXZUdydElXc2Q1aG4vM0VlRlRPaG1aVWVIVlBkYzFEVis2K1plMWxJb012T0dkQlorWDNoa1l1WjJjR1ovWDZpQXdRYUh5elYxN3pWZmd2aUhlN2gvLzVodWcxZ0FpdGlIM3poSkN5aDI0VFZsVEdaOWR2YUhkdlo4ZFBaOFJ5YU9na2lRWnVkWHl2ZU9GVGt1NW1kK2N3Z1ppQWhKT3llRjdXVlA4YmFKVXRaM3ZWVVpacGFBQTJoVzhrUlZXbVkrTkNsTDEzVVFUMVFpcXRNa25mTjRqd1pUaXNlQnEyaG8vMEp4d3FSQllZTnBzb2lMM2RGT1VObHhsbFpIVC9sbkFXUmJSUFVySGpaNlNQaGhPRWlNMldoeUNWQ1dBb0FBWmRtTUNZQUFkOE9XYmNtTVovbVcxVWlXY0FtWGMvbU0wUmlOQWpDTjB6aVdveGFPUFdWcVE1YVgzTWQ3ZkRpSS93SDVqa2FtbHdISmg5Qm5aTWszZDVDcGJBZ0FqZEIzZjFSM2tkVTNYNGp6aGZHVlpIWldHZnRZQUI2Wm1BTDVodERIbG9LWUFCNHBrSWk0ZHY4WWthRVptdnZualV4NGg0U0NrUmxKa1VkR2tReHdBTDlKQUpWWm1SWFptMGRXbVJtNWZ4NEprUVRabkJPNWgyN1hoMi9ubWZvb2lJaHppUGFuZEdQWWhPUUNmaHVTWnI0bmt3ZVlmcUJvVjdJMEZqdnBKNktqT2JYUm5vZFhOYXlvUUFyalJxdDROUXBuaWtwWllTWklZYTd6UlN4NGxiYUVndjVaUytNeFd5ODJjcXVIVklCa056Nm9XcWNubUc4SVltdzVvWEVwb1hHSkFCaDZsaFM2b1JWcWwzVkpvZFFvalhBSmpkWllqY2N6WnREVGlhTTJqYXA1bWhxcG1INjRiditENkk1STVvYzFtcHdCK1dzMHVwM0F1WmVuR1lqR21aSEpDYU16MnB3RFdaR2tDWjF3Q0p4RzlwdExHbzNIZVp3SlNIVVRlVzNnOTFxMGFXTHN4WFhRVjV4ME5weTdlWkZNQ3FaZktvZ01FS2JGZWFiUDU1cHN1cVlmK1pIemgyNXJscGtnYVZkZHlJazRSMWhZVlp2T05SQ1phRlhuOTZmUTlZbDFWVDZGT21zKzlDWWxJbWhyTTR1RmhrRzlsSGk3SkZsSFNUV3RHQjJWcDFHdVlqcVlONVc1a2lia2xESjdFMk0wRm5LL3FLRG5JWXhpOHBVanBvU2tWbzE1V1pmVlNLRnEyWXh1S1dKc3FaWWU2cGEyMnBacjZhR3ZhcGsrQ3F3UG1veCtXWFBrUjQweTZwcTlDWWlUV1pyemw2eUtPWTY4NW54d1dJakpHcHNFZWFiL2UrbWxhTnFsZTBpSUx5cVFwZW10dkxsL2JIa0FFOGtBdjNtbTdDcWs1UnFicVplaWZ6bU82NmFtd1JtYzVwcVJ5Q21rOEJxa0ZSbXdnc2liYnFxdGlSbW1ManFPcEFaL1plaFg4K1dHZ3BodE5pZHZKbWQvV0FHZTVBWlkxV2FRRDh0dFhMVktSWlJLOUNPVitFRTBwTGdUdVdPS2plZG9ETmVVSzNXQkJTWmFkSFJwWWxRYzBnSXNxMFVXMnBTcXNiZXpSWVZOT1RVbXhYZzNmY21NdXVxaHZXcXJsdG1NREVDWXZjcWlhWW1XSXNxWFJQdVhwdWFqSkhxMTB4aU5JSXA2eTRoNjNhbDk0Z3FqWjZtdWNibXNnZWlSWjZxWGxjbWFVTXFhRjFtdm84YVczS3FhRjNtMy9tcWM1RHFRajltamlxbVI0ZXF2RmRtdSsrcXQvOGpKcEFaQUFHY3FwblFZaHp1S21NQVp1WVQ3cllOYnVKUnJuTVVacHJzWkdacjdwc0s1ZjJvcXJRTzVqK0s0cE1wV25EWnFwVDhhblk0WmZrbTNabVhvZFkyWVp0bFp1eldqWDhDbVVOOUJRSTJST2hweVFDZHJZTFVJZ2tRSk1DTzFNTFV6Z2syNW41b0tQSnJuZ3ZoQ2xTcjJhZFF6VTRZa2M0SGtVNjBXVFlIVVBhUktyNmFLSHFaM3RDSUdxODQ0bUZXYkFGdTd0U0NtcTBtcmxvdTVtSE5KdFNUS29uY3prV2ZKdG02YnYrdUdBQWZBbWtDWXJZS1picFdKa0V2NnBtZnJya3hxdnl3NnVVeWF1WGg3Wk5PWWpIVGJtd3NRcGMrbnI5UDR3TTc2cjVpcnI4Slp1V0dLQUNCc3JtWGFybURxcnYxNnVIeHJkc2had1AvRXlhL0NLWnorcTY5ZXlnQmdHc01pN0syWEc2U01pN2xBaktNODNKcXhtYVNlYTdyUlNacHFsb0RTWjJSMzZyaWx5WVZPeUowOHQzYnZKVzh6eVNEbkFrVUFkaEVpSXJ5dXlGZ3lBakhFbTFJcmk2bkpDMkdSdDd3VkI2QlYrWitWb2pMaEMyUTF0VlBTTTNNNkM3U3M2cUI1bEdKZXVhclRCTWpHeUtyT0NJUnplWHE2dXJSdnlZeURHWkY5U2JjWDZxUC95OGhvNmJab1NjSWtESnlYN0tPM09zR3hPclYxMXNDS0c2S1ZlYWFKaThLU084TVltcEVYbk1KbFNnQ0pTNXlMcTdpRHV3RHVlcEVzTE11MGpLOEJXOExCR2NLcTNNdVJHN25Bbk1NamZBQ3hiTXVSZThHMmJNc0U0TXgweHN0aTZzQm1lZ0RLSE1QRCthWC9PdHk1cmtuTVpYb0F4R25Nd1duTUtUekR2M25CLy9xY2txdXVkWWEvVkVxdVp3bCttU21hWmllR253bVRVangxMVVwLzlmaXd4U2FKa0lQRkhwdCs2RW5IZXZJVXFpTVZJT0lmRGJIUUExYUtaWlFqcVJoWmFaU2ZFb2JHYkV5TGw3ZUNzOFRSbThacDB4czkxUFN6MXVUSGVUeGkyaXVXeDRQU2VzelMzZmhhREFxK1E5dStwL2ExNWx0cXowalRPbzJXRzl5dGJwbXJrRXloLzR1aE9IekpianVtK1l2Smtqd3VVb3ZEbzB6Q2UwbkM2c3V1QmN5aWlydkx3N3pMNWt4bkY0ekN0R3dBS0p6Sld3M0w0TXdBcHl5Y3Z3bld6VXk0aVF2T2dwak53VXlteFl6QnZ4bTV4RG5NK21vQXl4eTVpV3NBQ0dETGxia0FpZHZWL3pNOHBvVmR5bC9xelc5dHplTnMxeUhzMU93YzJSVlp3OTc2bTNCZHp2NnJ5bzh0dWVoOHl1czhwR1o2dVhTV3BFYzZ3eEU3a01xcGZEVFh6NE1JaHZlb3o5bDV6MkNZZHBtUmI1ZkJMZUVaZ0x1bFEzd0dGdzhpRVNMaUh3eml1eGFJVXJ4VU1QWnBsTHhrMFM5TFRHQThOaW9ZM1Mxb1FpL1hXaVpkeHlXOW9POGhZNEs4UWtoSWd6RDl2UzVOaEgwVTN1VU5sbU5wdmlaM3E2VjNsNFg4M29mc2pFRjlvYXpKcmtsdDFWS2J5Y041MzBZTjFFa2QxV3NweWo4c28xTHFwSWhOdUU3dHltZTZBTWo4ekdkS3dpcXMyYVVNMW1adDFnZ0ExbC9hMTJhOXl4aE9uTW44MTVRdGlIM3Q0TitNNFJvOHNKWnRwczM4MTZxc3pQOE1vTXlmcmNDeExPSU92Z0FncnN4ay9lSXZEc3VGSGNLU1hkY0RHK1NmN2IvRWpNMXZ2ZG1PVGRuRUxNTTh6cmptK3N1OG1ablA5OEpDMnMxakJvYWthOC9NSjU3VEtkdWU0V3dHMkZlcTdVTzBtMmE5ZGJIUzlZbHNoWDZXd3J1eU1rUVo0dEFXYUtuSmZkekxJZEVNeDNobUhIbkJzeStVMHFtQUhwVnpzcFYxSEl5NTVTV2V0dDNnWFZNNFdOUGpEWVRnWFlUektwWnpLWmJsQzk4Z3hyN3UzYXR4T2F1WVhwZUZyS3UwbXI5bXVYKy91cUdmeTZFVEd1QVl1cGFzanNPd2pxRitIZXV4ZnBIY1duYXM2YjlsNjlWR0xzeDFUYmh5bmMxbVc3bisyOHl3Zk1FR3NOWUdBTllYWHVITXp1TitYY04rYmVNTjd0WjYzZGIvenl5Y3Rwek1YMzNrNFF6TzRON1lsQTJtYlYzVTFIN09mNDNNTnI3dTE5N000SXpzMnE3ak5wN00wKzYvMTQ3TStIN013dHpMeXR6VzRUelhBaXZEaW4zRDMreXZWSmVaSGp6RmZ1VnVjZloyelFxZEUrbmw2bFZ6cW8yUDM5SmVYd2lCRk9WNzNXVW9YVlpZMzhYUUQxM2NRWG1LRzJqY1NBa3FuUVdMbHZlb01kWFJIblNWOTRNcjFsdWdKOGE5SjdaeXNJYWdPcWpISytUemV6eVdsaDZFUTkrTVExOTZYdnVxb0U2WXNncnF3Q3Jxb3U2ajlydnFsOXpmT0t5K1BPM3EvYTMxQ1ZBQlhlL3FGWUNoWWovMkNGQUJFbEFCUlIzcm1IenFuSHloWkFyc3RYN1ppVjNObWsydTY3enVBNXZ1dS9uZzNGNlpnLzNpZmcrYy96QWVuSCsvMWhmZTdjMXUxdXE2K0NHczEya043V3ZkNzdCODRmWCs3bUx2MTlGdUFHRVAxaExRN0ppUCtYOTk3OWQrNDZTLzdpQ3VydjZiK200ZDJJSUk3MzB0K0R1TzdkdHN6VUxlNHl3OHhFN2V1UWlMdXVrYW5OMzgrK0ZhWCs3MnNNM25ia21uMm41NlZZMFlYMWZWVmxNMVdNSGRLdlVUdk1FYmNaWWFSeHNvV1IvbE8ya0RXcm9JTkc4c3ZjV1RNU3dYdE4zZFFxdm1ObjUwZ3lvTlc0WmMwNi9YNk5iWVIrcjkzdk9LMGpGVy8rMGQ2azRQRUFJRUpoREFRRUFDZ2dRRUdtU0EwR0hCZ3djZ0loQ0FJQUVDQWhZUE1EaUEwQ0tEaGd3cUpLZ3djcVRGQ2d3UUlFakpVaVZMbUJWZ3JxUXBFNmJJbXhZL2JzellFLy9qejQwck14ckkrTlBBeGdNL013WkZpdUFsZ2FRWkZ6QWdpbUNxVXdNR0VCaWcycFZvMXFOWkNSeTFpaUJwV0tobWwxcmxLSlVqMndOU2xRS2RlK0JBMVFWbXQ0YTFtbldCZ2J4ZysyYmRXbGpyWWNSYjc5b0ZISFp4MWdPQkkrOHRuSFRqMUxzOXYyck9YRGJ2QXFRY3VTN29pYmxuWEx0dDFhS0dpcG8xYXdKUVpiOFdZTGUyUk55emF5dU11OXQzWE40RUNnZ29FRUFpQkFFS1l4dFBMaEQ1QWViUWkwTUlNTDE2QU9vRXJoZm5MbUI3Z092aGl3ZlFYcHg0ZU8zVno0TWZENTU5QUFEczQ4K0hYNTgrK1BqMThkdm5UOSsvZlFBQ0ZIQytBZUVMMEVBRUIxUndRUUlOWlBCQUFRSHNMMEVKRy96dnZndjNtM0JERFBYL3krL0QvVHAwYjBRU1N6VHhSUGU4UXpFQTcxUlVjVVFYV1pTeHhSUlpwRkdnR1hOc0VjY2RCZkxSUnh1QkZOTEdHWDgwY3NnYmRTenlTQ2FOdEpHZ2c0NkVNc2tlcFd4eVNvTVNpdEtnNXFKRWlBQXR3UlF6QVlVWVFpZ2tpQmdTaUFDRGxLTklKWWRFSXVra3AyaFM2U1daU0lwcFQ4TUtrOGttT2k5YXFpcU9WTXBJcGFZTXhhalFxYUJpZ0lDcE1QdnBUcTIyS2hRcm9iNDY3SzVJaC9xTXFNanNBazBvb2V6Q2FDcXV1UEpNTktqd3NxeFF5K2o2ckRERHdMSzFzVnNSeU1DQVhXOU5qTEREeWpycXI4WCtzZ28wdm9MVnl6S3lRS1BLc3M0d1MvVXNwd0xyeVZIWFpEc05vN2hJaTZ4VmNHZnpkcmJaN09KTklJbHEvL3N0dUhWM2s2aTE0WkFyNE4za0ZGSzNOdWFHTzA2NzhwTDdqanJ1c0F2dnZmSFNHMis0N2dJbUR6eURCeTRSZ1BIOHkvQSs5eWFlZUVJSUk4d1lZd0lmZFBCQmpSVjBzRUtTTSs2WVB3OVRCbEZFRUZVTzhXV0w5VnVSUkNwbG5ObG1HTUY3TWVjZGExUXl4aDkvMXBISElKdmtFY21oZllSeTZZR2FOdnBwZ2hDS2NtcWxxN1k2NnF0L25OTHByYTNVRW1zanBWNmFvQ3lWSTdNaE1BMmlpTXdFT3ZJeFhiZmYvRWduaitDczh5S2QvaXdwcGo5bm91bHZtK3FrU2RXdTZyeHpyd3BVclpRQlZLbEsxU3VPSXFXcXFFcTE2aXEwMFFSRGpQRys5c3BLZ3M4dGxZQ3FsZmk2aTlaV0g1czFLck02TzR0MEEwQUhObmJhYS8vMzlWZGJaWmZBYzhxME1qYXZ4UlFMUy9OZ0VadjlyckIrTHl3d3VEYkw2bG16WUpXK0tYSmZxLzU2MkdLTEN3SUN1SWNOT1BDeHZ4ZTNoVzNES0RaMHlmdk5PK2lnRWtCZTdlVDFWNkhoK0FWUFhvTGRDM2gvOGI1Yk9QLzJoT2hpQXl3WnhsQm1JWkVoc0VJZEMxbUNObWF5QWoyUVl3N1VFSWs2dERJTllmQ0NMenNnaXBKa29oZlZqRVkzbzVuUVJQaXpvUFdvYXlZMEd0T281clNueFZDR1Y1cWhsMnhJcGh2YU1FdFp5aUhXZkFnbWlFUU5pQU1Cb3IyaVpDOHNIU1FrRi9sUzFCNUZKdlI1YVV3RllXSkcwbVNSaXJTTklFNEp5a3N1SWhJR2pFNENFcWpBN2dCbGdNVDFEVkI3NnB1ZlN0ZW4wam5PSzIra1ZWNy9MQ1dUWU9FUlU3Q0RuRlpBbHpqaDlZa3d2ZXNkOHBBM3VEZk9UalJ5bEp4WWJ1ZXJYWUZPQWhrQTNhNFFad0FPeEk2U1dlbFZyMnpsT2VQOTVaRy9xdFZmaVBWSnh3d1Nqb3hqMUZ0SUE2bFZmV1kyODRxTFVsQURxOWJJaGl4SWVZMzE0SVl1WU5vRk5lN1NYakcxRjc3WVBFZGI3MklSY3VSbkhQVkp4enNBSTQ1MTRxVXYvaWtzZjk5UldEZjlKN1A4R1BCQ0JJeFp5RUFHd1FpZVU1MExLaUNFMnBreWVHNVFuQmwwV1FjOWlMTjdubENmU2pKaFAvVXB3eHd0NllWUWExclhtaFFrZ1I2SlMwTWNLQXhweURhcWxRMXNQdHlTRktOMnBvTTRoS0prbytpUEZ0b2NJVEpSSTJkalU1cXVhTVdHZE1TS1dyU2kyMHpLL3phRjZDU0xLTmtiVHNySWtyMGhnSXdJNE1CTng1aEduZ2FWQXpNcGlWYUFTcFBkN2U0d3NMTlVXV2hGeU0ybEtsVnhSSXpzSEFjc1FGYnVqWThSSksySzExV2xqcklCQmhqcldDWGdnRWRLc25pMEExMG1Id25LVWFLeXE4RHF5NmUyTXF0a1ZjWjNabW1XU3ZBU09ZN2NNalNnR1JRc29US3EyR0FFVk4vS3pHdTRoUzF5WVM5YjFydGVaSWNKbk4zd0MzN2t1U1p4b1BQWitoRUhZQXV6cHNCS085clJack4vcXgxWU9NbEpUb3dWWUlBSXBDMDcwZmt4Q2tyUW5iZmRyVDA1eEVHV3dReTRHenBSakVxNFQrUUdOTGxVSXBvSWorYWtLaFd0aGx5YmJncVhSRFlqRFhGSzI2V3UwM2pZeENBTzVDRlkrMjVDeUN1MmpQOXE5SVlkUFFnUVExb1JLbG9rQVdoanlKaFEra1F5clUxdFRHekkzZVpHa1RmVkJrNWd4QWtULzBTU0w4cEVKYnViaVZJRFp4TTBvbEduRTRiSllTUnBHQVpuTlpHQ1JHV0VsZXJWcjhaMUs0RGtNSy9BUWtsUDJpcVN4c3RxWEc5VlNSUEhlTVVtMXBWYU5lbmlSODZZTUdHOWxTa2xrd0ZhQlk4dmtrbE1wQXpKVjZ1SUtsYlFFbWJyUUJPcUpKdUt5YllFVlZzSUs5aGMxcVZjMkNNWDl5QXdyK0RReGx6cTZrMXZsS05aejlick91MVQ3V24veFUzL0hldzlEbnRZQUFiQW56djNsb0I1bGkyRlpsdXlrNjB6Z1lHT1ozODBKc0FGenJPZS95azBDUjE5WEg4cWw1ODhpM1RQZ0Vha0tobjBvRWRLYUplbTY4S0ZUSEgvbysxdEwzYkoyME5VajdvaFZJU29SRkZ0dFM2QkNhSmcwNW9TT1RxUjhHSkVpMXNTVzlybTYwVCtDa29uYXV1SkYxZHlKNXZpdENUSmRnbFhOSnlTTklaMWpTT21zSU1ybFZURHlJVEJIK1kyN3o0bjE2MHd1S3VXVEhGaE1rQmlvNDdTa3pPV0hWalFlcXRNdmh0MDc4NHhKeitYZ1hlN2xWZTZzeDFZOUUxV3NOalkzdlUrc1lrellNckcrTmpIdC9OTVZRRGpHYzlNUm5ON0FkNVJoSGx4S2JjdVZLSTZMR05QdzdodnRZb3FVMm1MTDdsTVdZL3pCamVQcXBkeU9tTG01clJQWGVncno1ZUZnN0QzTFV3NzdldWZuT1VNWjUvM3ZHTENIZnByNXlteFJLOXpaQ0J6WUhCYjl2U2tVN0RRVUljNlBCOTk5ZVhpczlKYi8zZHVwMmRvMENrbHpXbEdySktucmVTMWpEYTBhZDhGb3FzYmN0RzNzMXE3YVpmdlN5K2E5bDh2OGRjREJYQjY4ejVmTEw1ZDhCODVrM3o3K3lXWndpbUxXOHlJU0E5bnR5OVNDaWNpVVRBWkt5Y1NQN0pFd29EOGNMVm5JbUdqamhqYmY3Ums1aU04NHNNa0xxa21saVNRZWJVWHQ4cXVWcDVEM3JkclIrOFVRMUwzQW0rM1dRdStLK0R6NnQrOEdtdndNMkJXSFdzU3hxTnNkNHFIRC94SkZ0d3Z0bkpyN0YzY08xeWRrbE8yMGo1a0VBQURKWnRxbDA1dStNWWhKZGh2eVRJMXRaenN5WXRwY25xOUMrV3hPUmY2dUZjdi9OTzhmdmtpVHYvbEYvVFJFcnFnRTBDSDZUUDY2TFBpZ0pqN1FFRHd1TE9pTzdvRllwQ1BTZituQ2F3dEMvR3pwbHU2QnBtNlJSc3VERUtaUi91Z3F5dVJuYWswcFBrbkprR29yQ3U3N2lJN3NxTXVUUnVvam1JYVdpdW9WUE1TcVhtN2pib29qZEk3TlRHVEhucUlWWnUxdjlNb0kzUUl1am1UdGtFYndFTXcvNnFpbGNBYll6T3dtU2djdzdsQ2xWaTJsSmc4eThNOG0zZ0pyakNqck9DOENTT2oxVXVxQ3VDQTNSa3EwcHV3Mkptd1hVRzNOeHFxdGNvS3RKS2tPMlErMjlza2ZZdStyZkNrUDdRMzQ3TzkzTW1LVEFxK3RucTM0Q3NyZ0R1cmVRcytHZ00rNkxORFNsUkVYckZFZjJNcjJwRkVYbG1BWFlFQlhNazlRb3lya1VPNGhNTVZzQkFsVlZ5VzRWRWV4NEE0WXZtTUJRQU5iMGtLWkJtTExhdWxrME9YNm5uL0pmQ1p1ZmZUbmtkaEUvcWp1ZURnbC9kSlJvVGh1UU9JbC81REdKMkRzOVh5cG1tY3M1VEpNd09xRDJ6MER3TThPcFB4TTlzNnB3bzBKMERUUUhQVXM5L3FvQTBLcHhITUdac3B3WFlFSVgreXJxNTdHcTdUa1JjMHUrcFNPMzFVQ0J6eU5QYTZHdmZDUVllUU5Wa1RRcjlqb2g1VVFsLzdOYkhKd1RqNXRaSFFRWWRFUW9WRUNKTzRTSkQ0T3pnNUNaRnl3cndoQ1R4eGlaWndpdEVKb3pBVXd6K1JzSjJ5bk5GNXNMK3BDYjhwd3pRNk41WTROelo4dzBtU0FEWGtTWjhjbzUvc1NhQWNvMFA4UFJ5RHZrMktQdXZUTjEyNUhSUWJPQk9UTnhXN0ZVZzhQa3h5Z0hiYk42eDh0N0ZDSzZ6TXZVNjZSQU5BcTdFQ09LeHMvd0I4Njhxd0hDdDlVMFBhS2I3bDIwT0RzN2ZvY3plN0JBc1VhQXdIVUVYQU1FVytWTVZpeVQ1Yk9aM3VtMFhEdExpTml4UzFHQmVQYzQyTGF3M1M0QlpRZ1pSaWVpWEtCSTVpWEtiTUpCZk9xZzJFc1ovMmVRNW9Lby95dVk3VUFxQTUrN21mVTBkRkV5N1llczEwb2tDbTg1aHljcTJrWTdTcWt5ZmJqRWZlN0UxS2N5NTZSS0ZOODVGOFhCUGpKTTRaNHBMakxNNVhXNU83azVxd3dTTG9KTFZadzdzanZNNzJrczRzeWlJZjVNaGZTN3lQa0JPS3hNZ2lWRWo1OGdqeURNK1FJRHluT0lrQmEwOEV5OGdvaExZN29VOXRRMGt2TkVQTEt5cHQwN3hvMDZrMGlyQUFyWUJ6MjZRMEJGQUNMWWx6aXgyZkZFcWlmTkNmaFAvUUJnREtYbW0rQ20zS3VYeEsyMnMzUjd3eFRQcFFuaVJMZ05zVnI2VEVyQ2hMcUJ6TEV6dXIyTW0zRzRzK0RiVktCeDBqVE9yS3NaUUFHMlZFZk9PQUVwVktUWnhRSE0xUXFpUStRN3kzcTJURWQ5dEtFNzJkdmZTTGd6dkZUd0V5VWNLVngvQ0x1cG9WV2d3VkxNVlN0cENNVWZrTVlXb04xNGhNK3NOTStpTU5vaGdYWXpMVHl5d216NVFJbkVPWXoxUVArY0dmZUVITkFXeXo5MURBNm1DMENxb1krdUN6MS9UR1FaTkFkS3F0Y2FSTjNxSVFxL1BUUC9WTlNBM0JlUlFvVFBPNjhLckJmalFhNVZoTzQvekhzSEdvcXVHaDVOaWE5OXBCSXl5bzYwelY4WEtpTkNuVnhvdWF1Z093ajBTd09Ca0o4aXhQT1dsQ3cvdi96bytrR3ppWnI0bWt6L2pNbTQ1MGl2cWtQRDBoU1p3Z0kyMGpVSm9vVUYyUmlRVk5VRFFDc2pRc281N3FLUWpseWRoUncyeHRVSEQxMWdubGdIRWRWNTdrQUhMRlVYVTFLN0tzSk9SVHF3bEZzVEZDVVV5QzBiTGNGUjQ5S3g2dG5lSmp5eHQ5eXFKVXczSEZTaFB6dlYyWlVBZG9BQjVOMTRRbHE2MmNKTFJVV0FmZzBlUER0K05yZ0FaSTJBellVWXRGU3djNHZvUU4yWXdkMlpCMTJCc2xTM3lMdmh3OTJVbXl5bzlGcTQyOU4zbDdXQldsTjRSVHVDYUYwaWU5MllPNzJjYUlETkRJZ01sQUhwK2R4V0hKVW90N3NpY2Jsc3M0RmNyc2xNMGdEY3VFQ2pEcmxzUGFURzBSRHVFZ0RuNlowNTJMUnRLa0ptZ01RRytpLzhiVlBKajRpQmc3Z3crMFhkc1JzYzFCUlRwREZjZlpiQ0RkNGxNR2tTMjhYVnRIcFpoSGpWVEFYWkYvVXNIbkdnNFd6Q0hsUE00ZlljN21FTldKQWxYdVFzNnBnWkl5cVNnY3FrajFFcHNsV2lLRFZOVWh2S2kwbVlqNVlrTDN1b2laZ2k4RGM0aU1mRHRiUFJQMzdOVmcrMDY3a1JPNitZalZCU09QUkFrd0VwekhhMDlvTThuK0ZNT1ZJREU2eWlSc1kwT2V1dFlJN1VtM0ZFcDBEVmR2YlZCdkZWZ2NqZDUwblZEc1ZWZHhWZGpzblZBVjVVbC9QVXVYUFN1RUxTdUVoZGlCcTlpeU9qN1F5ZEVkbmRpSnJkaUtoVitNSGRuNnZWLzhuVmlNWGRpSUZWbU1GUUdTdFYvL0ZkbUV2ZCtRSldDeWV0K0ZKY3V6dkZFYlBmL1lTOFJYZkZ2U0hqVlJ0RnFBbk9YTFFadytvKzFnd09oWmhmTloxWmsrd0NpV3hBeS9KSHN5VzFRTjJWQ0tvMmpUWmtRbXJIVlRaNkxhOTlsYTdnRmI4cUNPTHdPNmFveXpiUUppRFlKQWlvbGJRek1udTFWVVFmT1lBZmd5Snk2QUo0YVlPNXRpMXd4Y0t6WXVlQlRjSWlGY2VqUk9HWEhCVWd2amY3UVh4bTJheXUzVTdnSTFoZnFSdFZFcGlGcWJVWDFJdnlzMSs2cGNXU1BJVXVOQkt2cFZOTmxJWGYzSXhVT0orSXhQK2Z4SXlNdlZBVnRQQXlzd3V0bkNMV3hQeXNOZCsvUXIvQnlkUFVIRDJFblFuZ29xWGVua1ozVldCc3NrbmxveGRRWGZCNzFlSEFWU244emVuZ1JTNWoxWDdDVlhjdVhlV1pibCs2M2wvZFgvWHg2TldISUYyWDExQUs4TVlJd04yUVdtV0k4ZFlBSUdacElsNEFhZ2dGa1dXUXJnWHZ3MVlBR3VYd2VnQUJFbzRKR2xBRzBHNEFhZ0Eyb1dabVllWm5JT1lLOE1VcGdsUHBFMVMzV3VXWGQyWjdUS3k3MU01N2xVeEYzeHhBVUF4WHdHREgzK3hGVGs0TDQ4eFo4MXpGQmgybVE1SGNob3JMZ2dpa2NwaTF4Q2phcmRURjhpTXpEanJKMnJIMzFwamkrRDR2UFFVOVFhR05VTUQ0aGhXL2xvSjRsSndHNDBZZ1pDNGtHcndLWjdvSXNaZ0FLUWFacWU2WTJHZ0NZdUFDZ1dEZ3NDUVNDMll0OGMzQlZrRWlTNndlL2l4NnA1WENncEwrdk1HaS81cmlWQ1hTQmFtNm1HcnpiT0x6cmUxY1dqcUxXWlFZR1FtL0Zhb3BUZy95Z0VPN3hnTFd0YVZRbXJuc0tNQkZZbHJOMWVCUWxvbTJTNkZvbVhERU92Mmh1OThjL1JNOE15SWxBeW1sWUJyZGNMMjBucjlWNDF6SURwTmVWeFJWZGF0dVg5VlZqSHJ0L0pwbVZwdm1WYWh0OVp2bGhmTG1keXZsajdyV2I5SGVkc251Yi9QZTBHeUdZUmlPYlVidWJXdmw4YWdPM1c1b0VHQUlFRzRBSGJCb0ZvWnUxeTV1MENkZ0FBdG0xbEJ1ZHJUa3RsQnVianp0Z0RGbWR5VHU0QUpxdXlBdWF4ckdBUlJWSVZQVGg4KzRzTDl1Y21CVVh2aG1jRFdJRk9ITzlkRWU4U1RjWHVxNnNVNXBSaU9SWXROWmZKb3FYdW9WcGZDcmt5RzAwSWFFWm5aQkhvY0E3LzAxcWQvdWpTQ3BqVE5GdVNIbWtIN0dsM1NuQVFWUC9wQ0l4TkpRN0hDUG90Qkw4T21aNXBPOFB3bks1cEtaWVovOWxOb05ZWnJkUGlleFJ4RVc4U2Z3eWlnUncxc0N2ZE9WN1ZGS2MxdHZuQkdYK3BQWjQxVVp0cVdIV2hBSnMxSnR3aUlOOU9tV284bllEcnVSbmRDaERkbjJqQ2tKakl6YVdiaXJDVEtOUW9XMjBJQlpOeTNwM3JNQ29qTTZTOFk3TlBaN3VKdVo0d205alBuYks4bjhwSjFkTXBOUHJXb0J6S0JnVlN4YlpsT285c1c2YUJXc2J6QnNCejNyYnN5TDVzeDRacy9jMXNYbTV1KzJWdDF2N3RqTjN0KzJWMGpJM20yRjV0MXdiZ1NHZjBhSlowMTZZQVRjOEFScjltYmw3MGI4YjBoR1YwRVpEMFM0OW00cTd0MUw1bVZrZDFjMWJ1NVk3MVZ5OWdiN1p0Y1Q3L2JseFhabDhPV1h5RDJiL3dibURPQUJUSTdubWV4V0tmNTVyRjRNWkFBY1BjUy9IT1N3eStXU3cxNFZuVVVtU0pESzBJUDFwODZQbjJub2lHNzJJRXN3SVFqbWFFQ3V5d0pqdTE2SEYzTS80UmNDQnVqN1NGMjU0ZU92RkkyeXFlbUQ1elFBaUg2Ym0xTFhDaXB3dWNqK0s0TSs0WWFaMkdHT3BvWWlrK2VMNTFXNEczeHZZSUlBK3ZEcDNXNmJmdE15MWVRWnp4TkRMbVZLSmUzT3d5emhRL2FocGNPNjRaU05TZDNGRkZJbC9UY2JWSitTQmZDYnc3M1ZYendTd0tDaTB5Y3RqVmVmbkszV09sYTV5Q1pHTVZIRHY1UXZ0c2ljQVozcHFZdkpKUUl5MEhxdDJKNUpkc0ttcGJDV3VyU2Y5c2V1dGQxM1Z0Yk1qR1pjckcvMWc5bCszWUZudXp4OTlJTC9zOW4yWFRQdnRHYi92OEplYys5MlpFZCsxbXBvSFZqbTFOWDIyK3QvVDY5ZnZkWG0xc3hudHNudlNFTFhWc0J2eSs1M3ZDQitDNlQzeEpCMkJNcDIxV0Z3SGJwdTNWMW0zTjEvUnJ6blRKYitaU1QrMUwvOS9PVDFqS1YrNVBUMmJrN3ZXTW5lQ01WVkhyM2t0alY5Rm9CMllVQUdZTWJ0SW1WYmllTlFCOWJnejFwa1hoQjlwakFSZHdOemx2R1pkWDhrV3E3WjV5RjNjQWozN3VtWmR4ajM2TGx3N1RmRFArcVVZRnhQaVJqbzl0WkZzSEYzandueUFKRDBlWDVpMkpVU0FDZWhtWjlnQUFvR0tkSnZqZE9zQ0t2Lzh2OHdDZDF2OEJBQWdBQXdaQTJPQmhBNFlIR3g0OHdBQmhRSUdCQmY4QUJCZ1FvT0xGakFFRVpPUW93T05Ha0NJdmZ0d1k4cVRIanlwVkVtQzVjbVhMbUI4VENLQnA4K1ZIQkI4UDJDUndzeWJPb0RwdjZrUkEwMmlDcEF5QUNpaWFzMmxUb2drT0dEVWF0U29EQkF3T1pPMktGVUhWQkZVUkhNaHBsT2RYQmhVcU1KQlFRUUtEdUd3UlZOQmF0eTdZdTNUQmdqWEFsMjlkdFhMLzVpVXNJZS9hdDJzTkpLYkwrSEJkdUpJcitBVjcrUERleDR3TlFLN0F3Zk5hRGhKRWMyZ2d3YlRwMDZvbFpDak5vWFNHQnJKZDB5amRRTVJ0MlJSazArQXRvamZ2QnJ0MzM5N2QrL2h2NUw5L042Qnh2RG53M0xpUnk2NHUvUHB3NDhhRi82YlFYWVIzQ3VIRmd4ZHYvdng1OENLNmU2ZUIvajBGOS9IRnU2Ly9UMlA1ZmZYcUo2ejNYajY4ZXZmTlY5NS80SUVnbmdNQWhuZWdDQ0QwaDVzRElpVG9nR3gwTk9BQWhSVEtobUdHSEhxWVFZY09nQ2dpaGdZNFlLS0pDemdBdzRvbm5vaWlBeWdZZ0lJREM4aG93QUkyenJqQWpEQXNrTUVDUHVJNDVBRTVGcmxBa1FZVWVRQ09UQlpKQUFGTExoQWxsQWNjUU1DVVdVWnA1WlJWUW9sbEFRY1VRRUNZQkVBQTVabGpGakJtbW1TNitXV1paQllRQUFFQnpIbW5uUmZOYWVlZWVQYXBKMFlUQlVDUlJSUVJPaWhHQUFoYTZLS0ROcXFvb1lnZUNpbEdrZ0p3S2FhRFlycHBwcHg2ZXFtbWxobzZhcVNsU3BxUnFaZGFaQ2RFa003cFFhQjVMckRRQXd0RThNQ3RLRHlnSzBPNDRob0JDeVJvL3lCc3NDd1l5MEt2clZxMHFrYU9yb21uUmh6dDJheEpIczFaVWtvdENhQ3R0a0cxUkZOUU9IRzdVbGxYdmtTQVRnTHdwRzFaNnU2VTAxUmlDYkNVVHZRbXdNQzlTWVhsRkw5QVdkVnZVUVJrSlRCWFVXNlZsVmozZ3VVVldRZHpsUlZmZ3RFbG1WWi9RVXpaWG5pdHRSZFlHV0FzQVdjaHV5WEJZWnNoWURKZUdlc1ZtV1dPK2ZVeXlDQ0xUREpuTVNQQXdjMElaQkF5Wlc4WklCckpRR2NRYzgycE5XREEwYVZKNElCcURkaTI5R215SVcwZDFWVmJ0OTF6VkJzSFhtL0UzZGNiYnJjaDkvVnczT1hYM25LNzRSZGdkL3k1TndFRmJzZDlYbjNtdlUzREJIanJMUjdjYzhOblh0OTgrNTEzM0c4TDdqZDY1ZkUzM244VUhQL0lJQThVUk01RGd3MDZmcmtJbEdlK0h1VUhSdmc1RHc1NFRvZUVGMzVJb29lcGx4Z2ppQWFza01Ick5jcXU0b3c3MWlqajdETG1pR09RdmZNKzVPNExJSUJranNRVEwyV1dVbUpwSkpkVVdrbGxsR0V1RUdhYzFKTjU1Wmh5dWxsQW1tSnkveXdFeno1ckp3UUN6QWxCUmhQTjZTcEYwS3BQcWFHQ3BucnEvUEduS2ovOWlBNndxYWI4Zy9ycC8veEhxdjcxanlMNU95Q3FMZ0lxYWlIcVZJQ2FrMFh1dENZSWhLOEFDbmtBQzFZd0xCS01ZQXBJbUVJSlJpQkNIU0JCaENQWVlBUWlBSU1IREFRaTR1dVZzVWhBQWhCTUFRUXlYTUVLYmxYQjlGMmtUdExpaUEvZnRSS1V0Q1JkUHlIWHRsVFNMcWNrb0Z0bCtkYTQzUFgvbEhVcGNTbE5zUmNEMENXd3VHaHhLVmJpeXNQNEpaYUJnV1ZlUEFGanhmWUNzWVd4a1NwcjNBcFo0cmhHd3Z5bExwV2hJOGNNY3pLOHVHVXpMTU5aeitqaXNaOGhvR1FuSzh3ZEwzUEluQmxna0JVWTJzMGFPWnJSL0l5U0hLZ016akxKR3FKZEVtZ2tHODFySnNtYW80RXNOUnlJRGRRYWdFcW5vZVkwVTNPTmRWd1RHOWpNWmtOVUF3NTRzTk9jWFFabmJjNUpUbmZrODU2K0NkTThrWU1QNFFJSHR3bjRJbThUeUJ2ZTRoTTRYeHh1bVlBVFQrUStJTG00UGRPYU1YaG00ZVN6VEx3NTgyL1lKRS9jRHNTRENhd3pjNHRUajNmZUNSN05PVzV6ajZ1Y2cvTFpBQkRRWVhRU3lwenBQQ1FoRUtpT1F6U2kwZXBjMUxvWC82bUlSekpDZ1k0YzZqc2hyU0NpUTRMbzc0cW4wWTBXYjBsUnloR1dzQVNCQXp5QXBDWmR3SmtnTUQwa1NZOTZWL3FvbWR4VXdmR2RqMDRCUUYvNDhvU25NOW0wVHVwYms1M1lWNmxsT2VwUWlKb1dvK3BYMUVSSjZsR25TbW9CQS9pcFVFMjFxdm1MRkFNVjZFQ3Nhc1NBQ1RSVlY3WHFWVUFweWdNRnlLQUlTNmdERWZiQUR6cFlhdzlNYUVJTjBEV0ZHRlJoQm9WVkFpVGdvSVFsSEFFSFNjQUNGRUIwZWxrbFNiVVNpNjJRNENSZGpvMEtUWHd5RThtZVpTcnY4Z2tWeTZXdUp1cUVKeStoQ3NFT2hpNkhrY1ZLN2xvaVZCQXdXcTZvdHJVUTgwcFc4S0lXdXJ3MmpYeWhpbTFydThnN0VvWXF1TVZqWlRCVG1jY1VVdjluR1BOTEJnb3pzVU1lWm1lSHBFekpRSGJKbU5Gc1pKengyU1U1RXh2T1hOSTBRL3Z1ejdRN3lWQytSbW5tYldRbkovbGRVcHFHYWF4a3BXc2N3QUVOemJLVzhhMk9iZVNydGVvUXgydTVMTTdYa2hOZ1lkNE5iODFrNWdTKzJVd0t4R0J1RFg3bWd1Y0dOd096MDVyUEpLZmV2a2tCYmNMdG05MU1NRHRqd0lNSGd4UEVILzd3QjU3cDRSSUxyc1FXbGpEZzRMWk95UzBUQkhBVHdZMG44QUVjci9OQU82WWNmM0JjT2NwMXpwNGdBRUhuSEJjaHp4SDB5QU1WblFOV0VHVU9TVm5LQ1QyUmxSdGF1NGU2S0VWRHFwRUJYSmNpTVBOSXk3emphR0VMcTFFbWxSbWtKZDNBQVVZcVo1TnVnRXBoc3RLWXhDVFRtSHJQZTNMLzh0NU0rY1NuQ1c3UGZCaUpZSjRTL2FjL01YQlZCclJmb3ZBSHY2c3FVRkNVcmlvQUJkZ3AvMTM2c0dKRllGZzk3V212ampWUURJa0FCM3ZRZ3lzRW9RZXRoc0lQZ2lDRE9NaWdCN1Z1ZFZ4UFNGZTZUZ0VIRzBRQ0NhWWdRMkhabFNFYm1ONmFDRkFyaGN6MFdkY3JnQkNscUJMR0lyRXNsYTFYdWk2cnJzNXlGaXFhM1lxNm9GUXZkMm14SlZkeUxicmU1ZHM0Tm9XMWxZR2pIQ3YyUmp4YWpONjlaWmk5Ky9LWE8rcWxZM2hNYnNlTzI3UGsxc1ZqbVlta1h3NHpYWkhOckxxZTNFd251WnUwbXBHbWxhaDVXaTFIYzNHTE4yMXByb0hsYStCTHRReVp6am9hMnEvSnI2UHlYWDROT3MyWmozTys5a3U5ZFpQbTd2a20vODR2M00wVlgvaWJHTTU1REZZTTlHZWV3TVRkbExDS0oxRDBuQnNkeEJlWXdOTlBuT0NvN3p6cFZ1ZjVNcW5aTjIzR2JaMVNQekhmWkV4ajhldzRuVUVtVDVCNXNHTW41N05CU0g1NzZFTFhaQ2dUdEtCMlZ4Mk5WRVNqSGVVZG96WnlLSXBvTjZRVXFabWpodDlvU0xYa3BpSVZZSHB3bXRJWHJmZW1OS2xKZk01dXR1V1RMVDd2S1NxQzd0UHBBMjhLZWo4Rk5haVN2dlRwdFVxdFIyOTZnSnNXbGVzN3JkVFpxMzZwdEo4Zm9CU3RlL1E5U3lHM1NxRU1SVmlESC95Z0I4VS9maHhVM1FNZExGK3V3M3ErQ1Q4Zy9RK0lVUG8xK0VBTnN0K0RHc1ExMXgzVWdFS2NEVzJmYUt0ODVjUEpFMDk3cGZScnR2MVYydGI2bmY5bnJ0WTJKZDJkTFdKT0RBYmFodTBmWGVmMnYvK1J4VlN3Rm10cHhWYTQwYm4xMXZDUWhmQjhVV25Ga1FGc1JXVTQ0TXVjek11RTJjc2NsNzhoMXdFa2wxOWMwaU81REFZNjEyYUF6TTZFVnlPbDRNNWtRT3VrbHllTkY5TzBSbWx3Qm1xRTEzeXhCZ1o2M05GY2lDck5Cb1hFUmcvR1JtdXdVbjMxb05hVWhvVUlSNEpVamRya2t0bzg0WVBrMG5Ja2gzQzR4eTVwUjMwUWpqZzVoek5sV0RSZG5ZbmhuSE40R05NTkhZanhITTZkd05NVlhkRXAzWWN0WFJ1UzRkUE5JZFE5RXgzVzRkZFZuZEI5MkRkRlhSL3VYQTBrV0NEcTJETUZZb29SWWg1YUdDSjZuUWpzbUNQMldDTkdvbzNWaytia2srTVFGQS9zMDRXSUFCMy9pRTQvaVU3ZFlRaEJXZG5kcWNqZFlRamdzVWlaR1lDUDFNZ0tpRm1admVMaHplSXNIbHZ4SEJ1Y3dkbEtpVWxCOUpsTGRRK2JxSW1ZK05tYTZGbWF6SlFMWlo0RTZROFB1VS83NUltaU1DT2tGUXI5V0JxbDdBK2tYTXBFWkJvQnVWNm0zVjcrVUNNMUpoQURnV1B0TlpDb0xacWZBQlg0YkVBRXJBQUpZTjhQeUVBT3lBQVU1TUE5bHNFOTJ1TTh0bG9ROUtNTUJLUTkwbU05NWtBT2xNRkIzbU5DNWtBUVFJRU15TnIyZllDd2tRQkVqVWtTYlFTMENVRDViRVRCY01XOGhGc1c3WVJsc1YrNVBNLy9nUkc5V0p2K3FkWkpzbVFXZ1pIendKSEJVSW5Ea0JFRGhCa0JHSUQvSFV3Y3JkdTZIVktZMFJ1U1dJbVN4Skh3LzFnZ0JqSlhtSDFNY1NXWElTVVhrRlNnQjZaZ21KMGdWSzRneVh6WEp1M00walRTaTJobERJN0dpM1FYMG5pY2ZyM1hhNXpJRGNvWEVBTGhEenBOaGdpaExWSElmTTBsRCtxR3lwV05GSElIUFBWbGZmUkhpODFjM2FBSDRSUk9nekdZTkFGT2hPVk4wQ1VZMDUwaFpGcGQwZ1VkWmNiQUNRVGRaV1ltWmxwbURGeEFaM0ttWjE3bUJZZ21hRnBtYUk0bWFtNW1HN1loMWVFaEhiNW1IUmJkSGQ2aGEwcmRIeHBkSEpyWUllWWhOOEdZOU9tWUpFcU9nL0JBUGhGbmd4aG5QaDNaa2RFZGM0YWlLTjRkUXNYSWlhZ2ltZWxPalRUVUtyWlo4SndaTFJZUEJEeUFTajJBc2pWZW1JaW5lS0xVU2xtUW1UaWVTbG5QTVQ1YjVmK0pUL2hzajV4bzN1Wk5CQVI0MVU3cDFETmVoS09CNDZTSUNsWHBENmtVS1AxOG8xWE4zdWxSNDZPaFNwOUVZd1JGSTRUNko0V2FYbEhWRkxTRUhsQlZrRmRGYUVUZ0NnZU5RQTJNd0FXVWdZbTZRUmRJUVJjSVFSZDB3Um0wNkl2cVk0cWV3UXVjQVkzYWFJM1c2QmxJZ1JUc3FCRHNxQlJBUVpBaVpBOU1nYTRrVzB4OXlVc3RLZlNFbXhTVmkvTkU2ZnJGSC8rUlVSZFJSVkVPREJqcDVBSXdRSmQra1FQKzFuQXRJRkJpS2JwQTRDRWRwWktNS1k4NFNYSUp6d1NlREpNTUhsWG1ZTXRnSUo3aXFWWGlDSkNzWUpqOUNKODIwZ21lVWdwQ0RRb2FxbWhzRnhIdUlOSXMxTkxzb0cwQW9RL2F4b1hBVW5Wb1NOaVFuSWIvVUFDbE1pRi80ZVdCN0pPQ29CUGIwQTE5RkU1ODNBMDBjYUV6ZmRnWHdsZ3pOU2JPeWVxc09tYUNhV1psY3FhdWN1WmxkaVpwYXVZSkFLdGxxaUd4b21heEJxc01IT3NGR0tzTEtDdXhOdXRvRXVzSjdNQzBGcXV4THV1eE9tdHEvdXF1V3FZYnNpRWVmcXNianV2VHBWZ2dVbDNVSFdLS3Jlc3p0ZE1FMkJpOGZvQ0Q3Tmk3d3F2akVPY2xIaWVVN1dzb2htSUt4RWpkUmFkMERxeU9RRlJGb1FBTTNBanVZR2VOK0VpTzFNckRjdFN5TGNERWxoU1dQSW1XbUtleVJZOHhqc2tEY004R3JNa0doTS9IVXMvMzZKbjNXQjdtSlNQTDBwU0Z0czh6RWhXaUZRck4yZzlSVFZvMklxak9JbWluUFZVMVFscWpST2hRU2VPaC96bkt5LzVVbnNBS29vVVY3NEZlbm9UUGZDYmJUVW5RUTBCRUMxM3RRT3pLQ3ZCQURlekFESXpvRDdnQWorYUFGQWhCajlvbzJoSUJHS0F0amM3QUQwUkFsckNKa25wSi9OV3RsRWJKbWRqdGxFYUpUajZKMzBaSmFRMGxuR0xwQWdyUDRLNHBtQTZQWHdnUGtDemc0c3JwNDhLQWttU0FrOENBNDY2aXYxSHVWT3BNbnA1STYxRGxDVllsaXZpcDVBYmVkTlpJbi9LSTVMS0ltTzJNNXlwVW1IVlptQ1VOaVppSWV5RU5oNVRjeWRuU2h1eUdodnd1eWZGZ2h4QlVRRkVBaGV4R3FKS084VEtPOGhySTVWQU9PbFdUM2J4WXpmWE5nWkVodUo3aEI4VEE5bTZ2WjdxaHQycW1aL0lxK1VyckNYaUNHbnJDdGFvaEh5RHJDZjhrNndYc1FQd3VLN1ZlUUxMS0wvNWVnQXJzZ0FxOGIvLzJiN1B1N3duODd3QVhzQXJvci82ZVFMTXVjQUlUY0FDclFMSUtzQXpnYjdKV2NMVW1hN1c2YjdUT0wveG02d1pqNjdLRzhHZXE0V2Q2cGduallXZldvU0ZPd0FxajJEUHRKbkMyVTlrNXI3d1NwdzBucDNLNlhYTTZ3TCt1QUFqZ0VBbElHVUlOY1pTaHdBb1lzWTBjOGUzTXlPMHNRRVZwMU1UcWlxMVFiTVVXVDBtaFozc2VRSjJKcDBxTjdFcWxsQVdCTE1oUzBBUjlEOVNXOGZmSXB6STJHeHMvUzZ1c0NVRkV4RVRjN1A1czR4emJYdjZzajFSUkZhZGdJemJ1TERjYUNvTkdXcVJBMEtEc1QwVmtZeUxiOFUyeHovdjRTVFRtWjBRRUFLeElNaVVQV3B2L3NLUEw4dDQ2WmtST2NYSk9MV09mUk1RQWJBQUw2RUFaSkVFWDZHZ1hiSUtMbmtFdW5NSGFDZ0VVNkFBTEtJQjg4bG1TeHRtVTVLMzBKTjZVWEhIakRTUGViZ2xNVWRCS3daU1VITWt5KzlaUVBpQU1MTFB4SElERDBtbDI4azdoOXVTYStrNTJkak9TNENudFNHN281aW50eUFoMWdraVFzS0tKTEpRNFMrN3JzT0xPaURNTHZpN3Vlb2p0ZHBrcXlaYytheW9JM09YdmJvaUVZRWdEZEtKQVljaEFYWWpuaUtvRFpDTHhaaUxwUERSZ1BvN2s4Qmc3YlZORnowMktPUmlITGRnNnBkalFQVjBLcytFM3NTYjNldWIyTm1ab1dxdTJtaS8rSXFzTDBPKzB4bSt5dW9EOFR2QU9STEFDNzhCTjYvUk8yN1FLN0M5UTcrOE0vL0R2VC9NdlQvODBVdXYwL2hvMVVSczFVRFAxVHd2RFV2TTBWVmMxVDl2MFRsdjFCRzkxVGI5dnNFYnJWMk5yQjRjd1daTzF0WnJ3WjlaQURBU2lXbVBmQjF3QXUzcjA5QkdpWEw4d2Z5Um5JNEtBSXpiSXUwcGljczdRRGYwd0NmQ3JLT0pRRVJQV0VlT1FFUnR4WWlPc3dUcHhrQ0JzcmF4UXhGYnNzbFZ4clZCUW5NbFptSkFzOTN6c3lJNXNBWVNzRm4vbmFIdTJhQmVBV1pseFJEd0VIS3UySEllUDFhNkpXUkVFcEN3TEthdVAxUW9WSWd1RXFtVGpOdFpQZ1FJeUFFV1ZwMWpqSXkveWIvc3hBSGlBYis5UGJXT0UwbDd5c2dDQWE4TzJhMSszQjVpVmRROEVKWnNWckt4MmQzT1BvcFJ4QlozM2hwNFBmb0pQZmYrbThYa1BBQXNwZ0FLTWdBdXc4aVlRQVg3bkFoR2NRUmtnQVFhSU5rN0YxRWpGaVVwVlNkNFdlUEZjYksxY0xQRTRqNWFRRklNZnovRnd5UmNkRDhSU2JNUTZySTlzZU84NGJJNDRMSkQ4U0hjV0R5djJqb2liZURRdkNlVmFMb2luczVBSWlleUFtUkhYemhFdjFPM296aXR1ZUoreUlnckF6ajBiRkliUXlPdFlHU25lWFVEdDZ5ZW1Ea0YzSWtHTG9uQ3lIWkp0emcwVDJZTzg2M25jTU44UVNEeXRoNDJwM1ladG1OZWxXTGxHSFVpcjlXemE0V2VPOEFhcm9iR21yMHAzc0F6WXIxZkx1VXpITkFYSDlQNXU5ZjdTOUZNTHRVOTc3UTVJTlZLcndBeTRBS0gvOUF3YytrKy93S0FudXFNcnVxSW5lcVFqdGFNM0FhSC9QN3FsRC9VTWFEcWdTenFsUS9xZ2gvcFB1d0JOSDdWT1kvVUZ2UFFCcDNvRnAvcG92alNibHpWWjE0QUlveld0bDdSZDAvVzZ4dlVMVDUrdjZ6V3dBL3NIcElDOGZvQU1HVHNOeVNzT0VDZGcvekFPUFR1MFIvdGlUenRpT3pHdTZJb0s1Y29LOFlvVW54b1Y5d3E0Z3pzR1dKQkRnR2RvRjRTeG9Yc0JZTUFBZUFCOHZ6c0VLRUJ0ZzA4Y1E4UkR5TFpyMTdHN2MwOGNyM1lFY1RmdmpiZDFsMVZGNUR0VERUZW05TFkyQmxDaEpMejlQRGZFQzhUK3lLeDBRM3dkUzd4djQyZTd5N0Z0RjRwek56Y2w4enNwdS9acXF6WkJuUHhEZ0hkcmI3eklxN3pWM250dDM3dHRZM2RyZzA4YWw2eDZoczhHREFBRytFQVA5R2dyLytQM0ZoREIwQWVCRHlqQXVMdjNlSkxVRjg5S1FhRG5zYjBabmUzaXNha1VnaE9QMVM4Yjh0Q2l3MExzQTFBMjNCYVBoK2RJNFhYbmkvYzQyczlJWVZVVTIvZE8yMmVBakR3eHdqS3NqZmdJMjg5SVk5OU93bGJVd0FiNUt3cXhqN1JPanZNNGtLc09rVWRabFJsMmtUTW5LRzd0M01tZEtNNFFQeTNuY0w1ZHNCK1oyc0ZkRFdlT2p4MVprTWxyZzhock4rMG11K3JZYjY3cldyOHdYRjhBVzdQdzA1M3JXNGR3YkxMNStZN21XTHV2L0xLNUJjTXZ0QjR3Qko5NlZrUHc3MS8xVUMrMThNL0FCTHZBcHZPdm8zdnRwaWQ2cGovL0MydzZvMU8vOVQvL0RFeC9FOHpBOWx2NjlGLy85aWNCOTB1L0NvZy85bE8vOTVmL292K1hQL2VyQUtPTHYvZExmNlpYLzZOWC82RS9laGxRT3Y5S3RRd0FoSXNkQWdVTzNDSGp4QVVYSjJSY2FIZ0JJc1NIRVNsVy9GSGpBa2FNSHk1TXFPR1I0d2VQRXo2VU5IbXlaSWdKS2t2aUFERUNCSWtSSkdUU25FS1R4RTBlTmxlUTZQblRaNG9WS0VpZ0dGbzB3b29JUnBNdVpZRWlBb3dJRDFnc29Qb2dxbFdzRDdodTdmb0FBOWl2RHphUWhiQUJBb1FDRUR3VXdPQVdyZ2NGQTg3V1hWdGdRSUcyZEFkNDREc2diMTY4Z3dNSDBGc0FjV0xFZ1FzQXdCdGdBR1RKQXdBRUFGQVpRT1RMa0N0cnR2elo4V2JLalNGRXBwd1pOV1hPamZNQ2FOczRnQWZESGdCQXlMdzM3OTYxYVBNK29Ic1ljRi9oZ2RVV1Y5eldyOS8vNFg2QnYyMWIzSGlCQjRpTlY3K3JkanJmQjNXbjEwVkxsbXdCQlE4VWFPaFJSZ3FVRzFDSUVEblR3NFFDdE5jUkg5aE9BTUtDQWdzMjJKOXVkb0VGOHJQdmdBVU82TzhCQWJrS2tNRUdHMHp3UVFjWFFDRkJHQlpZZ1VFVUF0VFFxZ2s3dkZCRERGSGdjQUVMRXp6eHd3dzNYTkdvQ1RrY0VRWU5ZeXlSUXd3dHJERkFER21NMFFFWUhFQWh4cUdHQWhISUgzbTgwSUVmbFRUS0tDVWRXQ0ZKS0tGRUlja29sWlJ5QlJDUzFGSkxCN1RNTWtzdnhlU1NoSmhBNEFHRU5OVmNzMHlaekFTaEpEamwvQUNFQ2Vxc2t5T1NTRHFwbzQ4K0ttbFBrQzRJYVZDSU5Jcm9oNHdxVW9oUmhSZzY0VkdFR2pyb0lFOHUySUdoSFRTVi80RlNUbVhnZEljWkJsS2hqRkJGbmFFTVVsV1FZb1laVkhDVlZWUmJuWFVHVmwrWTRkWldrNWloQ1RkZWVDR0pYNEY5UVlsZmkxVUMyV0tKRlZiWllKMGRkdGhnb3dYMldXaWxmUmJiYWFIZFZsaHBmL1ZWMkNaZWFFS0ZjY3M5OXdVWDBIMzFWU2xXVlFGZUZYYVFkd1laNEoxM1hrNWRRR2hmUmwzd3QxR0tMb0lvVVVNVjFhaUdoRC9ZQ0tXRlRjTGhneEZhZ3JpbEQzRGdBWWVaUGlEaDRvMWpLdk1tbkhEcWlRV2ZpRHE1S0tWUWVDb3FxS0thU2lxcEhvQ0JxNWdqbUdxcXNYUXVxeXl1eXNJQWdyZEtVNnV0dWNMckxqSGRtT3RMTDhBYVk0MHd5QlFyd0xDcEMxdHNNc3N1MjVycnJVSDdPalduWFVOdE1ySnBpLzhOc3VUNE91dzE1UEQ2aTIyODFGb3JMd2dVS0EwdUJmYmFRRHZrQnRoZ0w5OEFCenp2cytnYndEZmZobDU3OGYvME13c3RBcnE2RzYzSzdlWkt1clBBNitybXBGWmc0V2F5TUtCclBzclA4bUM3RGZTektuTUY3WVBnQWYvc0N6Qy9Ec215U3ZVVGRhYlp3cWgwcDNEbXJoZzBrZmdFSS9qd2VBZ0RQQkgydW9JN0xMYTdmdHRyYUxubEpyMHR4ZlZTZkFQNi9pdGdnL0E5UUVzK3NOenFXV2ZoajRkcXdxVkdIS3BKS3FsY1lFa0hmQkx5L2hYMEYzTC9ub3p5Q1lBMDZRa0o3SmVtTXNsSlRTSlFFNXJtQkNjZTBPbUJJSmpDQXh1MnA1TDR5V0dEV3RoSS9NVEJQaW1xSXY4aUdLTnlBSkYvcVlCUktIVEJ2bVRBd2svL3RmQlRLcENCcTA0MUwxZVZBVmF2bWhVT2NjVXJYSlZMWEx1NjFSREJKU3hoZllGWXlVb0NFWktsQkNZYWdRaEpNRUlSalBDRktTcWhDRmI4UWhHSVlBUW9WcEVJV3d3akZLWElSQ1VzOFl4TVpHSVNpb0FzS1NyaEMwNDBBaHJqeU1ZNGJqRUpTYmpqRXRrSXh5U2M4WTk4ZkJheWpOaXRYK0hLWE1BNlY2dFlCUzlYdmNvRk00aGtKT01sU1JWRzVGOHJiSlFJTGFLUWdsMGdVUmRKMkNnZGhvTWFPRXhocHp5bHhYUXdnbFphckFZUUc4SEZhT2t4RW16c0pob2dnUWFtb0VzTnNFQURLd2ptTDRVaWxBaXdBSFE0WXdGV01JQXpzT1JzTEQzRFFNOStCanZFSWM1dVoySE1Yd0R6Z01zUTVtMm9DYzFvTXJPWWNhN20vNXZpN0ZyWFRuTWFkcTVUbk81VUoyaGdvNXJnQklacHdpbk4ycGl6dE9FczdqQ0NJeDNpNXFJWDNuQ1BlbnhMWEc3ME1oZSs4YzF1Znl1YVhkb3l6ZitVeGpjREVCcmlwQk1YOG1YVGFCMGx6K20rQWp1Z2hRVjFZdG1jenFiSmdnczA0UU9JQ3g5NGRyTVdCUmowY2lMbHpuNks4ejNZSGVBc1dubmM0NmpwczVMeUxIM3BRMTgweVhMVHQ4d0ZxdUw1MndCdVd0Q0M3dVUxZ2ZFTlh1U0NtTzZwcFh1QXNkdGdCak1md1dCbk56d3JDd0RLeDUrY2hZVXI0K2tLWEwzQ0ZXZ21UeXNvc3VzQ25OazVxUHpWcjFzSlhRUTZZb0VJV0dBQUtiaU1BaFN3MkFpa0lBVW9nR3hrSTV1VUZIUU9zNTFqZ1ZCb2tnTDdEVEFGSlA4SUxRa3NvQUpVQ01JSU5yaElDR1k1Z3RhNmRwYXZsSmdPRmpiS1JmbExCWGxjNFc1NXU4SjByVkFLTG5CWHFuRElLdlRRRUZma0lxSWhoM1hHWlJsUldVNU1GaE90S0VVcGFyRUlWTXpDRnJScmhDeGdJUXZoM1FKNHY1dUZLSHgzdk54VmJ4RzQ2MFh2R3FHOVZQUWlGZWtMMyt6YWQ3NVQxRzkydVh0ZktpS2lpdnZWTHlLaUdFYzFOdEVJWjB4d2RBc3BySEk1R0xtcGNsZHdKK211M3FwZ3R3ckpaS05LS0FPTUhBeUVveVRsb0dJNWdsUFNsbUlXczlnVVhvc0Rqcm5ZeFNLamlTNUpjRE1OckF6SFM4a3NXTVpqQVF6MG1EemtVY0NQUi9kanVRREdvUm5sMi9pdWVSaTlrWVkwZlBsbWNESkR6c3NVaGpKWnZ2TC9scldjbXEyWmhqUHREQTA4MXlsUE1uK1puWkxwVEdqZWRzL3JMVWFqY0lIYmtmbUdVL0ZnbEM0M1RWeEhnUWE0LzhpME5FSzdXM0R3TnB6bE1OUTU0R3RMOTJpemd6U1FnUVJVbFl0ZndnbzQrWXhQT3BpYkprRWppamdQb0E1eFg2SHJNK3U2Z1p0WklBUVhTRUlOL21aVXBJYnYxZUNCYTZ6UjF6Tm9kZ1diUnRVMVZrd3RhdEh4TFN6QmpzQUdMRXE1YVc1Z1BHVkpObG1vbWpmNS9Kall4R1lzZVRBd3pXb3JHenl2RGg5amtWMVVXR2ViUE1QbTliREpqVm1YM2F3RG1FM21NZjE2czJRbU05M3FkdmZOb0tLQkNOdzRCWnV0Y1dnZk81UUlrRURmOXc2dEJuUUpBQXRBVmdNbDBBQU9RbENDSFZpZ0JDWW9RUXBDLzBEeEQ0UkFBWlJRaGlHNHdJVVcvTUFLVkVERUYrTEFDa1J3UVJDRUVNVEtrVlVFRlRRaEJDMUlBUTRBb0JJYzNQem1KVUJDeGpMbVdoVGZ2QVloaU9YUWEyQ0RHbHhFbEQ5UU90S1gzdlJFbGZBSE9XamhCWEt3cjkxU2VNSVRybFd0cE1BcUt5UkJDaStRUXNlTEVISXFoQmVKZ1FSdkhNL3doU3ljZ1FwY0lFSWJ6WWlzL0diaHZWaTRieFNLRUlWYzVDSUtXdkNDRjZKUWg4RUwzZ3VHandJV29tQUdRYlFCRTJGSWhCbkNJSWd3TkVJTllRakRNaFNSK2NWVHdReFlvQUljcU5BR0wyaGVDMmJBeEJ3MEg0WTJaQjRMY0lERDVTa1BoMEcwUVF1NE40TVh0SkFJS21oQjg3dW53bml4TUFqNVdqRzcyYzFDRVhKZ0N2OWJPRUVJdnpxWEM0U0E0WFFOa1FzY3owRzZxdTZDSDJqeWtoditWeWcvbVNnUk00eVVObGhZcWk5dU1SeE13Y1h3eDhuQ1NWQ0NHZS95M3BZRjNWUHNyWlRNL3YvV2RNM1VwaW5aaGd6WnpxZXFpQTE4OHVJQTUrS2VIdEJwOEtuTjNDSUNLQU1pQU9BU3JNQUNIUERLQUdQTXN1eHA1Z2syUGpDZExLUEx0RXcxTWtOcnpnek52b3cxdkt3RE5VclM3c25JOUdiSWJCQURPbURVNEdvcTltK3dRc2ZhZm9ZcnFnMHNtb2tJZit5WmpuQ2ZQQUFEWWxBNWJ2QUl4eUlDY2hBckROQ3VPT2NCT2tBS3gyS1pwaEFMaVhDWk1BQUdkQkIweGhDWmppbmZVcUFER0s0RkFzRUpuRUFOTzBBT2llMHJjbVlxNEdvOExzT2lqTEQvTE93UUM5OUtMQUFqTEJhTHNVSUhLenduQzcwSkFDSkFCeG1SQjVrcEFoWkxMSm9wcVhUbXJwRHRDcU10eU5acUF6S2oxd1JyUVk1bnNKYnBFQUVRcy9MdHNaTEoza0NueG1wTUtmU3RKOURRbHdndUJRZ3VKMHFnbDF4cmwwS2dDV2FnQldiSi91RFBsM0FDQjZoS0FVTEFCMHhnQkg0QUI1cEFCM2hsR1IzT0NtcGdCcElnRFF4QkE2MGdEWWJnQktheEJsVGdCM3BBSEh1QUNZWkFCNWFnQkVwQUI0YWdCZFRSbEhCQUIzUkFEcGd4SHVFeHR1eXhCR3BBQjBvZ0JPS3hYcFN1R3NNUjVKSkFCNUpBWGJpQUlPU2dCSEtnNmFETzZhSXU2bHJvNldTZys2cXVESUJyaFdaQUNEUVNWOEpPSThWdWlEaFNXS0tQV1pLby80L2FDSXVTYi9tU2p5V3pDd3RlRWd2YUFBdThnQW9HcnlaTlR3dHlVaWUxNEJaNGtpY1RvU2NCUVNpMTRBMkkwaWpiNEEzZ0lQZHk3dzNxWUNuZm9BMmNzZzV3TC9lVVVpZmhRUGVXVWllTGNpdHpzZzYra2lzTlR3dHFrdkM4NENXTlFPL2NxeVcvb0l2QXdBaUVRQWdJU1FXaXIxelVwUzZGZ0xjd2JMZjBVaTk1QzVNMnlZUUNjNFRNNytnS00ySGdVUWZna2VkbUNmNXlLU2RFaHNaOHlaaFE0TWFXNHNaS0poWFY3U3Z5eW1jaVFBSEliYWJJb3RzMndBSzJEZFpnRFRENHhnRUo3YWFla0txZUp6aWdDdGxHWXpId1FwMVE0Mms0SXpQSTRBSThzQnBNZ1F1NHBqR3F6QU5ibzh6TXJBTzFLVGk0Z2k0K2phcFc0ZjhVZ0FrQVZxRUpBSUFGRk9BVXFvR3Q5dStYUUtjRFdFQU92L01QSG00dXJrd09rU2tEeUlBTUVPQVBSbWNLK0NBR1BzQTZBWURGT3VBRGhLRWtUSURnZm9uZytPQUxFQUVSWkNBZlIwQUI1UEFEdWdBOGtha0RCc0FUa3FCQWdZa1BtbUFLV0FBREtOUU4rQ0FJWkFBUmRvQ3htbWtxR0lzbVJxQUhaT0FIcnFBSCtFQUcrS0FIa0lsRmhjbEZqK2s3STRERlBrQURjakRkYWxFRFpra0REQzRGVE1BQ1d1QVprMEFHZEtBTUZDRDdyRk1CREN2ZEFFTUhoMHhHQzdSQWJ5MFNNNk1KbWlCSzBlMllmZ2xHejVPeDRtMEswKzBET3NBVHJOUUU1SEFFTHNNQ1ZwRW9Cb0FQcnVFREZLQVcwelFHcG1EZURFdXpIdlJtQ3JIL0E1eTBRNmR3c0x5MEZQc3F5RERyRUxOd0JYWUFCZlpVQnBwQUdEaVVyZEFRbUxJMC8yZ3hBandoRFJTQUZXL01GZ25PQjJwZ0IwcmdVOHJnQzViQUN1YkFDZ2JnQjZSZ0NPSk9EUVlCNG5RdVl4Uk9CcjdnQWlpaFYyUmdDZnhnQ0F3QkVaWmdDTDdBQ3JpZ0JucEFCNUJnSDBkQUhkT1JDVmpQQmx3Z0RreVVDdFNnQ0p5QUNuSkFDS2pBQnJMQUVPSUFDU3hnSGJYUkJ2YnhDMkFPNUhLZ0JIckFWWktBRmVKUkgzK2dESEJBWFYxZ0NZWTFIbnZnQjNRZ0IxakJCZUl4RHFxdVgzTWdCK0tnWCtVZ0RvQ0FDN0pBRGdDMlg1ODFCMjRnRHFBQVlJVXJCNlRnSW9PTFlvdUxJNFhBRFhBbCtxTHZESXpvWTVubGo1Um8vNDVTVWlYQkN3dlE4aVdMWVBCbXNpYXBJQkZpZHZaVVRnMGtJUkVBQVE0Z1FXZHZBUktRNFE1K0ZoZnVJQm51UUJwSTRRNUlRUlR1QUJsS1FSSktBUkR1WUJna1FTaEZRUlNZRmhtbzloTXdRU2dsUVJTR0lXbGxEdzRrQVd6aEFCTWtRUklhb1JGd3RoUXdnUmdtWVJRbWdSaEtRUlJ3QVJlU2RtNkhZUlkrNFdkNXdSRWM0Uk0rd1JGd0FSazBnUlE2UVJFazRSTmlZUms2SVFvV0x4ZThDd3pnRWk1LzVZOGE3RmRjNEFYcThnV0VJQW5XQlY0eU4zUFpwWkxpaFhUdGNyY2kxZ1dxanZ0Y29BUmNZRmZ1VlFmMFVYWmhTMklXczdWdWpzVnVqakhmRDhZNGhtTjBxUmFMcWNaRzVMR2dZck0wWUM0c3dFc1ZRRlFzNFAvY01NdlVwTzAxeDBPalZIUGJMdU1CVG9DMDVvSUh5R0FGTHNNekFTQUdtaUFGeXBPdEJPTTA4S0lUUFpHczVDd0NzK3g5WWZOdmZHQUlySk5OZHdBQTBzQUtiQ0FZVU1FR1F1MDB6S0FWTU1FYVVxRTZEVU1SdVFZQzNjbk1hQU9lUE5BMTdza0RXSUFQUEFFNmZlQStvZUFZamtFV2hPRVM0SmQ2M1lrSHRNRUtERUVHV29BTHFJQVpPT0VJVXRnVVdvRU1PR0VWZGtFYnRjRVFxb0VRanFFSW1NRVdaT0VaMmdBVkdzRUNjRUFPdHlZTFM0SUZOQW9BUUlFWnFrRWJmR0FLREFFQU9BRUFVc0VhMklvSmJ4QUErTUFLNGtBSmNpQUV2a0FHM0NBSnlxQVhoZUVDZE9BTGhHQ09uS0FJT0RjSG5pQUhqQ0FIV2tBRExrRC9BVWFBRERUZ0ZIb3pmMWtoUGdhZ0NUeU9yZFpRSFA5MVlvV2c2MzZnQkN5QUM1NUJCMXBBQ05SQURlS2c0UlJ1Sml6QXhFb1lBSndSQjZ6Z0F0SzBXeThnRFM1Z1AvbXpBMmh4bUV5Z0JtUUFCMXJBQXNwVUExS2dCVFFGNG5TZ0I1YmdCWEtBaHVHMGZLM1JDaDZPQkRxWkRLSTAzZEpOdENEcmVSbVJFUytyQkl3QUZlWUFBRXlBbW9NM1J0VlFEU09WbURhTEJVemdlQWxPNEU3NWxIZUpKdXlQL2ppbXhXNjN0VWdBQ2RnWkIyWnhVMVg1bmVONWx2Y1RSM2NKZUdrQ0FEcUFtaTBBNHBCZ1AzMkE0R2JKZDhsNTRlQ1BvR2NwVmhYQUJONjVCRjRMb2x1cFdFdmdCNzRnQjZ5ZzdCU2hDaFFCQzJ5Z1dvZmdCa0xhL3dhT0FBcUF3QzF2Z0FqTWdBaHVRQWk4UUExeUFRaUVJS2JCNEFnaVFRaXFRQWpPUUFuaWN1NnlnQXUwU3cxZ01yeUdtcWgzendzRVlScW9vQXQyT2d3Z2dRcXdBQXhpY2d1MklBeUtJUmpXSUJLMEFBNEFRUTgwSVJuR1lCRXM0UTFtd1JHUVFROEFRUXU0ZGhqdVFHcVJBUlBXbW11ZjlnNXdZUmsrWVJtS2xoU3dnYTNmUUd3QmdhLy9kaGtPb1dxbHRoR1FBUnRFQVJra2dTdTFvQTdnZ0dveEFSTWFBUTdlQUczdkFCdU1nUmVnbGhjMm14ZmVZR21kRmhBc1FRc0FRUktHNFJadXdSVTIrdzRjZ1JDUUlSUHVJQlppNFJhNGNxc1R3UXNTb2VQVVFCRmlWdkJzT3dyY2E0cnk2TDdBSUJmeVFQRGtpNDMwYTc2S2dQK05NRHFRN0loeW0yQmNteUFKZk1VTmltaDFBVmE3eTBDN0o1YTdYOGhlWldCRTdUVU93dEZlRThaZWNVRHBhcUFFaENBSDFQc0hsa0MrUzlvSUJBRVZuRUFScXRVR0FDQmcreEdXZjVRSm1BRFZiSUFmSjg3QWNiUk1IOHRMODI5UDA0MHJXTUFDNGlBUmttQ2ZrL1N3T2dEWnhtTThSb2V4NU1JQm9Rb0o1K0xIT25RMnAxZXFwZ28zMXFZeCtBQi9xK3h0OUVkQWdpTXBGRUM5VFlCcXNxeXhCdUFacGdGTlF3QUFiaGcxOUxjMmJCTUF5RUErdDJZSDVvRENCOEFDc0VBUXFLREs4cGNTM0trR3hOZ0VVSU1NUE1ITHlPQVNBSUNHQVVBTmdwTUhxR29SMDZBSmFtQUtBR0FKZ29CNWsyQURPNkFGV3VEb2ZvQUxITG4vQ0N5Z1ZDK2pHcVRZRUZpQkM2VFpFSFlCQUt6QUNnQUFqUzlqQjNhMHlwUURNTzZOeUFZZ0FvVGhlL2tnRGFxTUI2eUJCREFnSjZ5Z0NWaEFvRStCUStWUUE1Q2dURGV3UUVlZ0dtT0FPRnVETW1oRGJSNFFxaGhMQmtkbkNJbXNMRmhnQlBpQWE2cnROQ2kwUXBHSm9YMWdBR1FCRVhKZ0NjYnhYK01SWU5HeEJKaWdCTkFVMVNLT0NaQ2drWVhVQkpJUjI4TlREYjNaM3JUVTA1dWdXNUdBQlU2cGwzaEFBMHBpQkRSZ0RXVmdGOGcwdFBRVFJ5M0EwZEpVUDJWQVB3bnVuVnZaQW1iZ1V0M2dDeFRBQ3I0QVNFdkFCd2krQjdwQUI2NUFEYkpnMmhVT0NWd0xGeDhlb0pFQUNlUmJ2czl4Q0lpVldGdnA0ZTFQUjFrcy8rRjZhWjd2VDVjVXp2NU9mcGR3dE9SeFZPWHJlUlpOL3FCTmZwZmV1ZjRJcnAxeE1lRVdEdVlMMHJVc0FBQkd3TWRiWUFoS1lBbHdRQTZNM2dac0lBNUNXZzRJM0FhY0lPbWYvZzF0Z0JIa3dBbU93QW1BZ0JHMFFBaXdJQkU2Z1JRZ0FSV2NPaGVvd0JDbVlSckNRQkUwT2hHQ2dSQm9vUmRpb1JlNGdSQU9ZUks0b1JJSVlRNWlJUXFlZ1J2VWdBcWUyZ29HSVNZRm9SRzBZQXZ3Z0tyTkFBNGFnV29kWHhTeWxtb2xRUk5Fb1JNMG9hdFJvUXJhWUtvMWoyd2QvdzRnV3hFRWdXd3hvZkV4NFJja0d3NkM0Uk9BSWJEcitoQStZUmpxTnJSSkc3R1JnUmNTdXc3UWVndUFBUk1ZTzYwQklSaCtRWUIvUVF1MGxta2JRZjhTT2tFVS9QWVRjT0VUWm1FV1lBRVhEb0ViM0hZVXVHSHVKMkVTZWlIMkNhRVlEZ0VYaG1FWmlxRVhlb0VZNWlEMEFsOFJXSThLNWtBUTFHRHdvaUFXaU9FUnZFRHNOWUVXdU1IOEFZS1dJejIzT2trN1NJclVJMGlrRWpta0FrbFJvakMyYk1HSnNzVUxsU3hiY2cyaWNtYUxMQzZzaWxEQm9rUklqcFU1eXJnb284SWxTNWd1VmtxQm91M1lqU3M1Wk1qNDhTTUgwQjh5NHZUUVlTTkVFVlJ6bkJ5aFl1U0xrQjlTWkN4Qk1nSkppUkpMdG83WTZ1T0hEaDFVaE9qdzBjSkNDUTBhVXJBd3daWkVpUlloY1B6QW9TUE5qQlp5a2lCOUVxS0ZqU0VBQUxRb1ljRndpQlFSR2lzbzgwV0JCUTBSTENpSThJREhpZzBQT0R2LzNpRmp5b1BDTEFCb005UWt6WUFCQ2lBVUtMQWF3b2JWdEZmRHBqMWJnWUlVVTVEMGNNTWtoQTdMQ29wd2NYS0N5NHdSaUR3cHdLQWdkbUVBbHgxdm1EMmdjRzNZRUdnL3lBNStlaEkxSDZaL2p6NGR3R3IxQUZaYzI1RmUvZnBMYVFwYm1XTUZ3QVV1SWRLd3FwOVlZYU1CZ0lLQXRIbXdtZ0xxWVREYmRGOElRMTBIY1BuUVJBMnNGWWFnQWh0b2wyQnRDYjQyMjNYUjZTWlpCeDFvVUFNZmZJeWdnVzRkOUNDREcrV3ROMEFBQjlxR1FRRWVGS0RoQUYvTVVRUW1hc1NpU0dJV2pPQkNOWEZBa1lNVlgxaEExeEJFZEZIWUhHSGNzTWt4bkRTeWhVaURjQUlGRWxCQWNVWWJPUXh4eEJJdHREREVFRXc4Y2NVVkZsancveVlRY0RTQ0J5QzMxSUVISHBHSWtrZ0lWREREQkJJOUlhWk1mV3l4TmNJSExKaW9nWWx2bVdqQ0J5T01NSndiWnRTQWhBNG1ETEFLS3lIVUFCUVVKVERCR2hOTGZHV0NEeVcwYXNJSUZINXhBUk5mY0lFRkZFbFpFQUtVTFNDaFlGcE1GRnJDU2xkMHVzUVNjUWdoeEJWRkNIRURGSnVBa1FVMWdrU3l5UTAzU0NGRUYwSlVkY1VUUVhDeFNnaEwrQVJqRURKSU1ZTU9WOG5BaWhzbTRHQkNCMnV4dFZZSlU5VGd3bkkxaklVcHBtUDFBRlJOT1pSZ3d3dXN5RkFvRGxqaGdNT2xJU2l3U3hJdDlNREZCU0VNTVFjcmM2b2hDQUJ6Y1JFR0Y0SUkwa3N2MUhRQzhwMGFKWFhFRVVXb1VRVXFqa0FDeENabkhHR0REVGRzblAvREVVTXdHUUlYaHNpU2hncE5LRDFERWwra1lRVVJhNndSeGtWSkZQRkMxbDk4a1VRV1JSQkNEVENLZUoyRTAwbFlZVVUxWVRDakRUT2dVQUxLTlZLY1FZUVNSaUNTaFJWWlpFRUZGMlpRWVFVVmdwc2NSaHRtUkJOTkdJYjh3c3d4eDBSREJSQW1EV0xHTDJFUTBjWVdmZUt4QmhCSFpETE1KNGQ4QXN3ZXM4eUNpeVREREtQRkZsVzBFWVlaZGVTeFJwOW1FRE9ObFpnSW9nVWcwT0N4QlNCUlBJTE1JM25VOFVZZWozaWhSUnRSV0dMSklvOUVvVWNlZWxpU1J4VGFHNUdJR2tVVWdZVVJSbURCeFRGejlLMEdJWnBvRVFVa25jUUNpUjVlSktLSklxZzhRNGdnaVVTaFVTTEJ6UCtJUVBSaERJRzRoZnRRSVlobXFNSC9DVkZJeENPcWtBZEl4SUlhS1JPSUptb0JDRGhJQWhqUFVBTVltQ1dGbFpTQlNWSzR5UnpVUndoVWxLSUtmUWhFRmRhUUN6QVl3UXdmRkVUNGlrQUVJUkFoQjFJWW9RdTRVQVFsVUNFSFQraEJEMnBBc0IvVTRGODRjSUVVZm9DRXVMU0ZCQmFZd1EyU0VvSVJHT0pKS2VnQVkwd1FnUTQwWm95TUVhT2tpS09BRnFTbkF5V1NUQVEycEo0SFJHZEhIdGdBYkw3REhRL29FUUo2N0tNSElEQWRGckJnQXd6YUVZKzZNNERieEdZQUR5aEFqbmFVU054RVp6VWIwSkNDenBZSUk1eUZDa2tBUUJPbVV5TlF4aWM5MlFFQUNWWkF5dXpFb0Frd0tHVVRMckFtQlpqQUNpUlFqMjRBSUlnd1VFRU5PVkJERXdaZ0FnWE1ZUTRBLzNDQkRJNVFCVUpRQVFCRmdGOHNBdUV6SGZSS01pa0F3QzdtRUtEVjFJQUtGNkRORDFUd0F3RDR4d0tzaVU1akFFQUpZazR5UWM5WkozU2lVeG9BWUdCQUdHQ05GZmhRbUJEWVloZUZZY1V4dXBDYUVaeG9CR1dRUVJEODhBY3hZTUFISTVCQkYzZ2duOWRFRWpZVTVjd0RMbnJMQVlUZ0owc1l3ZzNFWndVb1VNRUxraU5FSnhnUkFpenNMd3FLMElJUW1HU0ZRYXdCQzRSUUJNaUNFUXRVb0VJUGtDQ0VMVXpCQ2lvUUloRm5pQjB4amtFRU16eURHSmpBaENITVVESkRyRUkxbkFpRER6aXhDZ1VzNFFyNTZvQUYxdVVEeTFpbUE0V0pnSDJzQVFCM01hRUVQK0NDeFZLZ0FSYVY0R3cya01NWGZoYUJFb3hBUVhUU2dQOEZUQlFCdG5RQUF5WWlMR0hGYUlMRVhpQUp4alJpRDhxd0JsdklZbGhhMFFBU2tKQ3NjTFhwQmx1NGhjcWtVSVZFS0FJUWExZ0VLaVpCQ0R4RVlRMVF5QUt6c25BRE9BamlCU0VvVkF2dWd3Z2JtR3dPU2hHRUdoaGhBelY4NFRCTWVNRVhUUENESGdpbEIyelZBUkxVZUJnQVdHQUlUMGhLSEliUUFpWmNvUWRYV1VJSVdQR2t4S2JBQkZzcGdVYUQ0NjRsNkdBdEpFakJDZ1NwZ1hQOW9MeGRORUVJZnRDRUVxUkFMb3RxQzF3MFVBSVN0RmNESk5CQUUxanhnU21jUWdVTXZaUllXdURjZ0JtUktpOFlCQmVJc0FraWZNUU1SVGdERjJ3eEJ5NE1FNGhLR0VTSXNiQTNLM3hQQ1MvSWdpeVVVQVlwUEtFTUxEblREZUwvRUljY0NDRUVJYkRCRVlUUXN4czhDd3RtSUFJbnBtR0xWMHdqYzFHb2d5TGFjQVlwZkdFak55aWNKcENCQjJra3d4VzBRSVVtcEtFSlNQUkJFNTlvSHlRU0FRZFJBTUlTa0VoR01tQUJpOU1kWWhaeHB2TWU5aUFRV0J5aUdMM1ljekdvY1loRG1HN09zekFkTEJ5eGgyenMyUkYweGtVeWJxR0hQa0FESTFnZ2NrenpWbW0rRlVIRlYvdmUxWXl3Q2FxOWdYL01xNFAyb0ZHRlZEY3dERmlJZ2hHRW9JUWl2Qm9JTDUxV0pDS1JoekNFNGhHYTBJTTBEdEVMVFR4Q0R3dkJ3aHFrc0FVaTNPQUpuRDNERFRDWEJTeHM0UXppNmtIV2d0QUNPUGxoQ0hHcVFRZ0FjSW92Q0V3SFg0bFlnZnQ3TDdpcU93SUNkaTlqM3UwVy84YU1zVEZkakxjWnV4Z0JlVGRHalBKT2dRWENhQ0l6Qmh5d2JOUU5CdWFKQVFnYy9BSFFZVUVRdXJDSkxobk9ERnNJd2krNFlRWk9VRW1jTExnUUFGekR4OEpVNHhJQUVJTXdWbkh3UHdZZ0FBQ0lnSWRJcVI2V04rR1QwNW5DRCthVWdoL1lBQWdtU0EvTFVia2VVQWFkUTZNc2VueEthWFR0Rk4xRDRVSDZLSm5PbnZRQXNqQ0dlRVlJQktFSVdsRERFWTV3czBDa1FZMU9Bb0FrMGpYamN5S0FBdWhjNEFKeXZNNERJdkFjUWZwQURHSUlnaDM4MEY4eCtFQURCNmY3Q096UWhTN1lRVDJZSVZGdEVQU0FGV0RnbkNUNENRNFVSSjIwMUFzOGtsbTRZeFRRQVIrZ0piRWhRRUp0RXd1RkpjUktzRDRvQXgvZ1VtQWttdi9nQm5PZ0JBQVNleUlmT0ZFTmMyaEJFaUNrZ1E4RWs2d3R3SUYrdlRwWW9ET2NSQXBnZ1lMRWVIQUZlQUE2MERrUEh4bCs4TUVpdkpBRHFDZkRDWG1aaXpKbyt3eUgrK0svMzRFSERMd0RMS2dRNWxsd2dna013RkVhbUlJTXFuRWlQMXlLQlN4aWl4ais0SWZMQXNzUG10KzdCdndnR1Zmd2YzK0FCQ3pRZjdZaUE0bVZCWVd6R0NIZ1YvWmxQNURnQlVVQUJFUHdWMm1CZ1NIUUxwWmhBbXIwYjNEWEJEaXdDOVl3QUJaZ0FqM2dBNUtSV0hOU0FtRmxYK05EYXlXd0dIU0NCWkFBQ0pIZ1VUa2dCeXJ4YWpZd0xHb1VBbHdSQWs4alN6N3dLWnpBQ21XQUJCYUFMQ2F3Qk15VkF6YndCSElRQjBkd0EzaEFFS1Z3QzQzL2NBZGNlQWVBMEFtZmdBZklZd21SVUFkbmtBTkJ3Q1F2Y0RRaUJSSXZFRUpRNEFKSllBUjhnd2hPd0RkU0FDTXlvRnd5QUFVeUlCUTlBUVVxRVFkUHdBVmZ3Qk1oUkd0QzRBUk9JR3RCOUFWYk1BaFpRQVJRRUhoRUlBVngwQVZVVUFZd2tpNDFwbU5Fc0EydFlBcWNZQWFOSUFxZEFBaGFBQW1CUUJmTUJnVlZlQVJnNEFWUjhEN0prQkRKc0FlcXdIV09JQkNPa0l1a1VBdkpvQW1hNEFpZk1BeWFRQXVCZGdqTFFBdTBRQWl4RUF1ZlFBaWZzQXpFOEZPbVlBcmFNRXpLMEkxY0FEamZRd1Jjd0FsR0FBVmdFd3A2MEFtZGdCRzVBQlZFOEN4UkZrSWh0QkxNa2dpaWdBeWZNQW1qTUFyVVVBdTZVQXVrc0FjMzR3U28vL0FKZmFBSHRLQUpVV0NNQS9FSTNFQU1pc0NGYTFBSHhGQU1kNkFGTmtBRllSQUhOR1lEVHJKZE12QXJWMEZ1V1JFd2w3SVdOU0FENnpVY2FWVUNwQUl3QWFZQkY5QUVMQUpYZG1Fd2diRVZEcGdDK2hXRTVGVUNFTU5qV3JFVlE1QXNjbUFEUXVCYk1YTUZVSkJETmhBTXh5QkxTQkFFVlZtVlQxQUp6eEFFR2dZRlBoQUVadUFHWHVrRzBmQlRQcEFLbkZCMlUwQUdxT1FCTE9jSmRBQUFIZ0FBQVFBS3NnQUFQdkFBZndSSUl4ZVhHRUFhTEFBREdJQWdTT2QwU1dlWWg0bVlNSGQwb3NRZTRPR1k4dkdZNFJGMVRpZVpUZGQwalZrYjc3UjhIYkFFbStBRWNHS0JsYmRPQ3BCNDMzRndoakVEckRBRFp6QUlXOUFHYmY5d0RLM3dDNFBRQlhxSGR3OEhCZG9TTFYxUWxjN1FCWHczV0FveUFDeEFBdGxoZ2ltQUFuQTNBRGtBQkR1WEMydkFCRGJ3QTJIUUM2aWdCY2VZQnpNRERVQ0FlUU1BQTJsMURJemdCSTR3T3FWd2FOVmpDVy93Qmphd0pqZmdYZFN4WGlWZ2dSYmdmNnpDRlYwa2ZaaFhjT1JuQXRFSGQyNVVMRlJ3QkdrUkFZc1hmdUVYQVkvQ0FtODNHaXZ3QVFWNmNCSHdBWlRBQTg4eFQrRjNjUEVrSUI2Z2ZRTVFBZGRBY29URUdmTVVIVEZRQTVnWFROcWdEQ0J3SW8rQ0FmRTBBb1V4QlJwUUdnTXdBdktuSVAwMUFIRWxYVWh3Q3FzQUFMS2dEYklBQ241d0JYd2dDNEhYQlIxd0JXc2dRMWdBTzBGd0xFaWdlVy9CQXBRUldDai9vRzV1UVFMNTFoZ3NrS0NXUVZnZlVBTzJWeDhLb0FFNzhHOGJRRVlwTUFJaHNBdVVZRjUrcFo4bE1CWTR3RWI1UmlraE1BZGZrQU5CcFFaQWNBUFRpUXFRa0FRaDRBS0NjektKd0o1UWxSUWFZQUlXc0FNMVlBRmZVQU1kOEJVdFFBVnpZQVJGa0FVdm9BUmxVd1NDNEZZcTVnSlBlQlEvSUFTS0FHbmE0d1ZyWUFSd01BaG5zRGVEZ0loUHNCSm9tQVcrSlQ1Ym9BYXlHZ2JSMEFhSXdBeG1JQVRrUXdSUFFKVlE4QVNERUF5WUVBYU5JQWk1c0RWRUJDZFFJQVhQOWlXSFV3blRFQTNUMEFpY1VBbk1nQWljZ0ZWc3d3bUVRQWdoMWdiUjBBaVlBQXlTZ0F5UmNBTkxtRVpwa1FUQVlYZDhVQWFCWjB4QlFhdGdvQVJjL3lBRVIrQUUybmdDWmFNU0syRURjMWdURy9NRE5mRUNLc0F4S1NRSVRuQU0vRGdLaE1BTkd1dXgvR2dMdnBVSVhLQUZpUUFNYXZZR3RSZ0lFWkVIbUhBSW1QQUxrTUFOYzNBRG5OQUt0Z0FHYThBSjNHQUtON0FHekZBTVhGQUZvc0FOeFVBS2I2WVFWWEFMa3BBSGIxQUttWUFOd3lBSlhiSUpnOUFJY1BBR2tpQUpjQUFJcS9nR2VBQUgwVUFFUklBSVhYQUdaeUFFeVdhMlFuQUd1WGtEWFVBRVFZQ3EzSlYvTW9BSUFEQUh0aEFHYzJBRFRtQ1VVa0NwbExGNCs0Wlp5WElFY25CamNjQ2V1akViQlFBQXE3UURYeEFja3hzSFFBQUdlWEFMWTZBSG03c0lWUUFFY25BRVBLWXFXNlV0WUhBRFEyQUQwZ1ZnYTJGdTZ2OFJCRWlBQ0dad0lncEFCdnlVbUtQRWNpc0hBTmRRRFlXaERhL2dDUUJ3Q1c0d0hTdEFCb1Y1dThtcnZNdTdkS0pVbVlwWlNvU3BtSkRKZEt1UkllSUhkdzhBcGk5cWZ3cDFtblRuQVhSWEdON3JsVnZaQ0sxUURKV3dDWlV3Q2ZzSUNuVVhCSm9IQllNUURiSDVDeHIyY0x3NUFENHdkdW9hQlZCQWQzRmxCeFpDQ2J0d0N0R1FwRldwZVg2Z3dQMFhUQzR3VE5wQXZLeGhCcGpRWkhPZ0JuaVFCenZuQlRmZ1J2TVZxZEkzQWpVd0FtY3lYU1JnWDArd0xFL0F3ay9nWFUrZ0JqUmp1VkVvVkMyUUExNEFDWS9RQ1ZrZ0I4RFNmQ3dBZnZ0R2Y1SHlwYnBCQ1JNQUFERFFmZlJIQmszUUl1MmtuSVdsRzUxUlNkalhHR3ovT2lMUTF3R3NNU2RzUkIxL1ZTaE00QU9Qb25sc3dYOTdOd0pWeVFjKzRRY2JWUVpOd0ljK2NBVnUwRkNJRUEzTVFBUW5jbG03c0F0QUFBbWJrRndETUFOYzRBWld3QXFJb0FUVFVCL0JWQUtlTjRTVW9BUXo0SUQ1cGlDTUFhWXBnS1lYMEFQMUFsaGVPbS8wcHFkaEZFYitaaGM2a0FQKzVpSUtjQ2xvUkNmVGxBSldvQU9za1IyUnV3TVhjS2tOTlFLUldobC81Y1ZlUlFLVWtCOG1nSjhkd0FjWDRDczZJQmJ1MHNpdm9nRTlNQU01VUdWY0FBQTNvQU5nZ0FXNVVMSmJrQllkSUFWWW9BaVJRQVZmRUJpRm9TQ3FMTWRTQ2k5OG9BRnVRQVRMWUF0RWdBSDk5UWQvQUFOc2dRR25BQW9ZWUFqYVFBa1dzRjFGVkFaRS83QUtnNEFJaUZBTmJyTUtYV0FHZ3pDMnpZTnQxQlVDVjNBRGFsaVZSb29FREN3R2QxbDNnUmNFZEdlVmExQ0pRVEFJaWZBTVdIQUZjUkN4THFBRWFpQU4wcWdHc3hoRU5xQU0xaEFDY2dBVWQ0ck1PSkFETHFBQ2Zlc0ZoQ0FOdGFBSndFQUlYVVpCd1NZTnBBQUx5VkFMZTZBTHljQjFqN0FJYndBTnlJQUx4ZEFNaDhCMWZmWUpzM0FJdEpBeXpVQU50M0FJbXNCblduQUlzUkFNdmRBSm9YQUl6VEFHMURBTXBXQUp2RkFLZDcwR1dpQTdVSHNMUUtBSXdPQUVRR0FKbjBEWVVoc0c3VXNOemRBTUtSTUx0d0NONnRnTXFKVkMyUFFGTTFBWTBQRWhxNUY0d25zSjlIRU45WkVkbE5BTXRpQUVReUFMbjZRQUZCVUFpdjlFRzlUYjJzaHJBMUdBQ1pFdERhSGd0ekZxQTJBNERGVWdhME93eGV0RUkrRmhJeXpIdk10TDNNVmQzTWpMSVpMSm1ORzdtRXBubWJpQkFtenhiN0lNQUFNeUlJV0JBa25nQmFoZ0JNMlpBL0JSZ3IxaUE5bUJBcXhCM1lpUUJyb3hKelhnQmtGUUI2TERDY0ZBRE1FUURaaXdESlZBMzlGd0o1V0FDZEdBQjNkUURQdzRDY3NnQ1o5UURNc1FDVDZBQVYxZ1gxdlZyMG9LdDNFTEJWVVpLUnJBQjdveEJZWHhBVHd3R3NwZ0N2TGtsUUVkQk9ZNkNMSWdDOVBBQ1dTQUFXS2dBLzJsQVdLQUFqQVFBM3l3TU82WDBYN1FCVDBBcVV1UU4wQ1FCV2ZBQXY4MkdqNlFCWktiQXVPRkZWNXNCVEx3S0FGM2NKRGFCTUlBVEkvL2NobThnc2tqckJ2VXpkNFNVbHNhd0FRamdJSkx3Q2dhNEFPUWt1UXBrQVBnWXdiWnBRUGpad0dtZkJiMTRpdm1VdG96d3dWY1lBRXF3QVZSWUFZdTBBSkFvSkJwRWdlNitRUlNRQVNuNGlvK0VBTEh3QXdoc0NUdUdRS0Y3QUpBSmltUThwTDlNZ00vRUFJbW9BSzdjSHFYa3FDTGdnUFVaUUdHWUFnQXNBcUdFSVFqTUFOVFZnUTEwUUlhZ0FOUElEUW1RS1ZJd0FUdEdRUmxzQVEra0FLdXNsMFZmaXhuVGluMjlRVk5FQ1VoOEFKRklJVy9nZ2hFNEFKaHdEdWUrd1Jyc0FWMWtPMWJjQVBKTndBYlFBTEd0K1VzZ2dSVWtRTXpNQTNQZ0paYnlac2MzUVZCemdRM0lkRzZxVVlBb0YxWDRBTU1yTzkrd085STBBSEwveG9FMmpJbWFud0tmMUFZemhDV1FjQUhkdGNETEZBb0RFeVZQWUR2NVhzRFpvQUhFYWNGbThEdjl1ZVZ6aEFFYnNBRkpTakcvbWVFUnRnV2tJcnJwOUlXNDhVVmI5S1VSaEFHeHhBTWdsQUZXTElHbTFBSG9pQUt3YkFNbUNBS21DQUo2cWxCV3hBSll6dmhnOERRYnZBQ05KWmNLK0ZFVXBBRUx3QXhwc3hEbnlvRVZLQUVRL0FDbTE0RFpMcDJKM0FDdG53QkpYQURRakFIMW5BRUZ0QzNTc0FJTjVBRElXQUZ6OUJKQ25Bc2dPRUVjYkFFNHRtSW9iQS9qU2dIOGxuMmhaSmVBRE1DT0hBVmI0SUU0bElHdThBTXloNkV5WUpqT1FBRm5WTUZGRVFLWU9jSTFFQU5wS0FMZUxZSHBLQUlwREFHaFZBSW4xOExUdkJYY1ArSFJwSEUzQjlYR0sraEhvNGJkWTBKQUk0cis3S2ZkSzFmRzVBSjNWQjNDcUJOSXdMaUNVMmdEVWhjR01mdEMyUXdkZE1CQWQ5WmRKNXdDZHRZR0srUUNpd0hBWlNBVmdCQUJpUm5tR0RmdkR6Z0hOQTlIV1JRSC9KUkdkUnhBU3FBZEJPZ0JpNUFUcktmSFpwUkdOWndDdFFiZFJaQUNQakRCY0twR3dBeFFJRUNEU05LTEpGand3YUFFaVlHYkFBUVVlSVVHQUFLQUJndzRJRUNBRHpTbklob3c1YXRpQmtoYkZnUVljR0dQeU1BMEpFWUU4TE1tQ1g1TkNGemlZd3ZpUjh3MUFRYWtRK29MeGlOQm8zNVlNWFNBQkZpZkdoQ0NSR2lYZHFleWZJVFpBU2ZNaVBzWEhGejZvcU1LM3pjMUZDQWlOS1dPc051MldCaVlzai9FeWhSSkNFRHNxUUhEZzBhZkxDd2ttVk9NeTRBZk9UQVV1b1RMUzhBbmdqcDlFaVBLazI0am9CNVZFb1JKRVZlb21oeTlBZ01FRERRb0kzWkE0dlVvMXVPWU8ycDRvUVJMVnE4U3EwQm9zWExJMlM5RHQzSmN5UEVHVW1Zd0FEb3dBU0ppUjQzekhCUklERG1ob0VDRmJSd1lTVkhpeFFyTEtSbzB1U0RpeVU1c2hUeEFjQk5HQzJOUk4wcUJRak1FU2hMTmttQ2s4dk1tWUVZb2crc1RnSHFGSEFqQnlDS0NLRUVCV3VRWVFrWmlQZ2loeDVra09FSFQ4Z2dnd1lhTUtUQmpocEcrR0NFSHZRcW80d3VpQ0RDaWxjbWVjVVdVeEloWWdzaWhNamxqVGZxdUVVUUlpeEE0Z2tmYmNDa2t6NmNnR3VJSVpEd0FRa1p6c0RrLzVCa2hpa2xrbHh5V1dPTFpaYkJaSTB1dUpBbGg0aktJT0tHVFc0STRva2pibGpqQmhURFZMT09NRGZab28wdFdubEdrUzBNYVVZVVVZRHBKWmcyeXVqaENqTUdpWE1MS0xxNFlaQkJ1aGpFa0RhZ0NHS0pKdEpvSVl4bkdvbUdHVXlpNGVJWU9sTXhwSXNnTktpaERFU09rY1VFSk1vS0lvaEJHbkdQbUZhNCtlU1RZYkNaQlpoTUFObmloaE56SVNLS01HNTVBeEJvNnFqakRXaHlpU1FLU013QVlvdk4xSkFHRWk5UWlRS1BQUEFRUkJBaERHbmhNaWVjU01pR01JaUo1Uk5xcUVFbGpFVXNLZVVPVVREQkJCaE1SRG1rR0NoQ0FFS05PZVJ3WW9nU2JFQmlpU1ZLQ0lFN0gweVl0SWtmUW9ENGtpWkNBQ0VGaTAxUnB2K0JDVTVvUUJsS0VtaWdnUk11T1dHQ05HeGh4UXBEZnJDQkVTQWlXYVNLS2dJQkl4RWg1c3VoaUJlK0dJSUtJbTI0eklnYnJoaWlCUXZPV0FhWU5hTHBaUXM0d2toUWh4NGFzcUFESkFwK1FpRW5zQ0JFRFNOc2FXYVNUc2JRQlpaZW10RWtHV28wQ2NXR0tLakJRZ0VYcHFndW93RXdDcUFrQVBJK0NpbS85ZjQ3Y01FSEo3eHd3d3YzSkkwT1lnREtDbE1NaWVsdWpBcDRBS083TCs5Ym9vd3lQeHlwU1YwQ3l1Ni9KUmVjOUFGMDRyeHoxUy9IZlBUQk43ZDdjOHN6S2lEMjJLT0xYZS9XQVdjZGR0c3pVaUJKVldVb0lRSU1PdWdnZ3VSVDBJRDVFbkJROEltNHJrQ2lBeE5TS01HQ05FeEp3NFVpcktCQ2pXbWVNV1gva2xGczBZYUtFSUtaNHdvQUFvU3FDUmxJVlNFTlVDakI4SlFrTEhqQkN5KzBpRUllc0JBRlV1d2hHY21vUlNEeWtBZEwyQ2dQTjRwRXNwQ1Zod2pXQVE4UmZPQWQzaEFOTGR4QVRUSHFnak1rWkFVeURBQURHSWpBQ2tnUUFRVkVnQVFpQ2dJTGdoZUVHMnhoRFdFZ3hCeHMwSU1uMUdFV1pnREFLYktncGkrc2doS2dBRVVxUUtFVERkR0JCQTVJd1FWK2dBUU5kR0FLSStnQUNUVFFBZzBvcUhnUlVONEFMRENDRkxEd1B4R0JBQnBOVnhMU1JXNTJDb0RBQXg0UWdUbldrUVVvK0lBTWRLQURITFFnQkRuejBnYytvSU1mY0lRTHltQ2o2UVlRZ0VWR3BIYS9HNEFMbzRPQ0J6eUVCQU9BQ2ducUpwQU5iS0FEQStuQS93Yk1hRUlBS2NBRENpREJCNHdISUFCTW9RbDhzQUFMTEJDUk1wcFJRS3pFaUFJK1FBSUxETWcvQ2lnQkdLSUFEUzhJd1FZRE01SU5jbENHaHVBZ0JJSzB3QVV1RUFHTGdRQUhKQ2lCRXBKZ2d4YjQwVnh6b0VRNFdYR0pDNENzQ1djSUJqZGlNWWJZeEdGZ0ZFdUJBaXpnZ2h3SXdRVWxBQUFYdU1BZGl6bkFBU0lJUUFKRU1JR05sV3lnSXBCQUEwVFFnSVFhUUpRRFFRRTFiV0FGTllDQm15RUF3R0NvZ0J3bTJNQi9Fc2tDZS9KZ0JtYWc2UWcydU1Gb1FyQ0VGaGpGQWdQb3dBaCswQUliUUlFUlZRQ0RaNkxBQ0NkUWd4dU9TT0FjMUhBREl3aGlveFlBWXdRMjhNZ0JQTElBakVSS0cxVTNWYXBXMWFwWG5hcFVmZjlIdTZabXhBTVhTUjNoWkJmVkFVQ2dBQmdvSzBlYWFoVE03VTRpbGJPQUJhSVRBTERXSkc5OEsxenZITGszdi9VdUkxQzlxMFZxWnhRSWdMRURhRTJPQ1dLSkFRMHcxZ0l5U01NSWNBY0FYNURCa2RHQmdDbi9rN3ZaSFVWeW91UHNLa0JoQmhsZ3hEOFJxQUVSekFBSFFqV2lFbTJvQmlKWXdRVkNtS0lJVkJnRUZTNzFqR1lRQWhPL0NFRVFpT0FHR2JBd2tiZ0RIb0NVQnlDN0JVZzlzb2hHSXpBQkJ5MjRDUXFRNmdFU2pQY0FGRDZBT3JFN2EreCtlYnlxK1lVUEdoQklCRVpBaVJyMHFBMkhrQVF3Z0xHTWlDakFQNGU5WFhNNW9neklSVWV1QTRrcjhsamdBeDhNZ0FWLzRJRVBibUNESi9CQkdKZEl3elYwNGduL0dlVGdCVWJJNlJudUJwSHdHTmdDVmtoRFB1Y3dyaEpJdG9VZ1lLSHRac2RaM2VtVmRaYnJHK21Vc1l0Y2JtNlRzSU54SzExd2hjbnVMVzlQWGFSVWdZSlh6eDczUDZWczRTd3RSdE1QV0dBakE4SmtpQlh3eVUwQ0lBbUdTRUlMbFB1QmVFYW5rOG5sNUN4VGg4b0lES0FGT0VDQlFGQkFBaENRb1FrWG1NQUZUbENERkZ4dUlJRVQwRU1LMEVrRlRLQUpMcUFZQ2lMYXlhVVNlZ0dIUHJRQkhCQXlqVkhpRmFhSWdVQVhHaklKVk5vQURsMUpSSlphZ0FJSUNBQU9xRnhOQk1McHdRcFpJaWhZZ04yY0dtUzJRbExWWFBYcjcvQjJPU0t2RHF1M3huV3V4U3FSdWdvT0JqdHhZMWNCd0F4UXpNNERwQU1yRHI1d2hpRGcvNEFGSU5qSUZiQlFoQnhBUVkvUmNaMnBNZmNBSHBoQUEyWFdYT2trZ3FFMDlsVXAvcUVkNVdEQUFoalV6Z01BZURlOFBYQnN0aDRidWJtTDNiRkZGeEVyY01JSVcxZ0k3cGdhT3hhSVFYWVA4TUFEV0JBQkZoejJoSmo4QUFCYXNBUlNsUmw0R2RuQUhHdndFVG5xMjdTZWlQZ0FQRURIQUtIVmJ0MzlySDVQTHNlbHlESGp3RXVCQzVSZ0JDQU13UUltK0tUdFZzM1dwQUM1eUsxcmJnUkE4SUdOSkxkdUFJcHBEU2FrQVFCbGZDTUFScW9KV2pDREpMelBicWlOcXc0TThnTWRMT0VKU0xMQUwwRjV0dzVFWkl4OStaQ0p2c0NGRkdqRllpRW9naEJDSUZmcHBDNENFakVFSlVJbkVSdjg0SDNvemNndVNGQVQ3a3JrQmY4WGlBZ1BLQkZpemRtTkF0SkpBeVVpTUttWENnVEhwSE1BRHlKQ2ducTZFOGRSQlQzUHgrcTd6UjVabnYrMWZIUnFOL0NMNzZBb2FLM2RlT0tKMUJEVVFBZVY3L1FtbWJyaVdMdjZkNnRtYXUwVVVMdThqY0FGY2NnQkR1ck1YUEN1bGZXVEt3QUJDc0NBQlRDMDB0ZG5xQUZXd3VjOWM3clEzeDErcHd2TmFUMTNlcy9VMmNCRExOOVZWN2NhNkd3RU12c2ZrdXFmODQ3bmJveElyZTJ2YTd1K2JuSmg1YXNBNUQ5Y0N3RDljNlBDQ2pXSjRCdmFnYmRxV0FYQTRRTlAyQ3VMR0t1OENyY0x4RC9XNFloc0E3MkxhS3R3VTRBRXRJaS9XUUErTUFORTJEc2hnNEJWa0FVeHNDcU5ZS1BBV2FQUEFwelFjYldqVzcvTEM3Yi8vUEs5djdvYkR3UTZ0d3EzdG1xa1JvcXh6dklyQWJFbC83aXY1U29sNmtDaDVCRzcvMEFlNi9HQk9NaUZQS2dDUEpDWkM0cUVMNFFDT1lpRE9MZ0JLUENEZWZNQURCQ0RoYk1salJDUEtUc3NKQnNBTXJpa2dmZ3UyNEdJaUpBNXpRbVFMcEtjQUZpQk5ySXhwSW9BdWlzSjd3TUFmdkVDTEhpakkvc2xnYUE3QUx1T0VHQUNBQm1za3JDdjZnQUFISkFCNUNzQlhVcXhmZXVkellLa0ZhT3BGZ2dmemFrY2hmQ21sbUdFRUJnQUc0Q1lQRENHTVZBQUZmQUNMWlFaSUFDQ0k1QURMZEFEUFZpSTkva3ZoYkNubHNJZDFPSWx4ZHFBRHhpSUR6aUJFa2lCbDhLZE5mdXk1a3FCRUpoR2VUSWFqZ2dCRzFBQUlUQUNHN0NPLzFLeVBBdUFHSWlSSjJtOE4rdXdIaE9BbUpheURndG9LWDBxaWJqNnI3amF3QmF3TXdCUWcyWlFCRFBqUnNWcXBTK0FpWWlBR092cGdJVUJnQmV3QlRVZ3hpZGNLdEF5eCtwQWdRdEFnUUJCc25hMG16eE1QK3ZJUVU3ekxNNWluZFhidDlHQmdYTGJPNHhJTXdDNGhGZG9ncFVVd3RENXNRVklJeUtqUWFCNHBMMHhOVjd6U1FDTWlRVmdxd2VvaUJvRWdBVUl4Rm1MQ0dGSWd5bkl2NzBxZ0hqanliekp5YytEZ0IvN25SYVNpR21VT0YvVXNwNE1DdEpoQURLb2dGcGJJODk2UkZKY01hTVVzZ0FRZ0FTQVN3YlFHNmpLSEVxNGhDRVRQZEZUc2ZiakhJdzduZ2dvaU95NmdqUHdBbVFCQkJ2QkJsN2dCV3pJaEZJb0JmOHNzQUpaL0VwUy9FQkYyc0gzbWF3WVlEemRpUncweEFCNkU3WDhzcDRaK0FLTE16MGtBNEFkMkFVWFFBdTU2Z0I4YkFHcDY4YTRBb0NxZ2NjamNJSStDSVJBT0lJekFZSThHSU5Nc0lRcUdJSVFNQUVUa0xnUzZNMDgwQU5hNkFWU0dBTlNvSVZRNkFQSndBWlYyQU5WS0lSc0tJVHVWSVh2ZEFWWHlJUkZ3SU9YQ2NZK2dBUnAwQVZqTUlac3lBWmp1SU5rNkFOUlNBUkd1SUVoV0RBcjBLRWpxTHdCS0lFWHdDY0FjSUVvNklOZHZJRUNnN1ZZQXlXb3E0NHZBeEI4dkowQXNRQ2dlWmxlNUxlWTFNY2JGSWdPS0FHcFFZTG5rWUl2NklFYnk3RTAwQVlwWXk0RldJSDZhaTRXeFRiWTBVb1pLQUliaUFWQzRLYUZjQnYvUFhDQ0ttQUV1N21CUjVBR1VqQ0dQbkNGUWpDZ1VFZ0dXbkNFUFhBRVRUaUVKYzBHVllBRlIzQU5SMUFGWFhDRVczQUMvZ1FBSlZDRVc5ak5QakFHS3QyRHRyR0IxL3dQRThpQkVoQ3kyTnhBM0htcEtPQ0ZRcGlGVDlnRUpVRE9FQUFESWxrQzVIeWZGRmlPZkZTc1Q4Sk1vQUNtRWpDYXFpbWxtbENBSmJnQklIQ0NKeGdDRUFTQ0tyaUJnOEVvQUZBZUJVRUM3Q0FFVm5BTTRlREloNGlJU3NyS0RSc0k3RW1CVDNJbExXTXB1SkM2bXdHRFBpREhjWkZGd055QXNCdUFGSGljVXEwR2tOQXJLd2dESjFDQUhIZ0dMK0U5R0hzeFJ3S2VGOENZMnR6TDkzbEgyVFRFeUpsSHBFS3EyQ3lCSCtnQjNybTRNa3NDT1lERi81TVVRTDF4QVNxUUE5NkxWb2tJSjZvaWcydHdTc3RocExLU1N0Y1p5UTBnQVJ5Z08rQzVPNnViSmJraUhBUHNLeGtFeTFhekhBL1VnQ1RBZ2lOb0FWWmdoaFFNSFVvU0pUU1ZOZCs3SmVxSUt4T1FneHlnZ2hkSW1CRFFBWVJoZ2lWZ2dqU1VOM2dqTURHd3I3djVBR1h3QkJPUUFqZ2dCb2hzQVRDd0tDRklCQ29ZQXJtVHB3NjRteDVUSk9acnJoaTRnRkFqeWRsNXVDbGdnZU5CQWlnSUV6bTRBc1hDZ1A5SzFiaHFBUitnV200TWdTY29sNVlCQXpYd0diZ0lnUkhBZ1p0NUJGSm9obDZJQWhzNFRoTncxQ0d3Z1Z3WUE3S3BoWmdCQWp5UTBscnNnMHlJRFNlWTIwQ29SVDBZZzBWNGhNS01nakdKZ3l0QUUzamhodjlSQUlZOW1JVlp3SVZQV0laRHdJVXJEWVcyY1lKQUtBUmRVSnRlQUNwZE1LQTlNQVlBc0FFbnFGUm9pSUlxNk1YZUJBSm9pQTBkYUlGUHVqczE0QVphQUVjRmFBSXJpRUZLbUFPam1GZGFZc2M4dkpzSVNKa2pZSVExbFlNdXV6akppUUFkZ050Wk1nWGVoVlo4VXl2ZjZZQ255d2dSeE1DYWVGNHFVQjhGbUlJY2tNTVdTZ0ViQUlORmdJUk9VS3Q3NHdJc0NJUkltSmt4S0lWRkNBUzQzZEU4aUpubGZJTkZHTThDWllRaktNN2lEQUVqRVpqZU5KTW40RWZOb1RMWitRRVhNQnJOU1NNNmNBQlJTNTI3dXB6QnVvRWprQTZ0TWdvUGlDajFRZ0pFTUFNaVlJSWVZTFkyYUlNZ1lBNGZtQ3dOdkx3VU9BRnBjZ0VWeUlIL0hGQ0IzTTFCc0t4TWtSdUlFTEJoa1AyQkhQaUJFcWdpNDNreHZRS0tWclNCSVFBQ0czaUdhV2lCS0hpRXpIMEVKd2dGWG55Q2UwdWt1M20zZDFOSnMxSldRYlNjQjlDQUR4REtEVUFCZmNRZGJCdWRGR0NDZU96R0NxeXZxcG5kNDB6SElXQUNNV01qSkVzaGZlTmlBS0NFWmpBQ2pWdy81R3BIb0lTM0RDQURsVlRrd0tvSkhyQ3NYVHNjMGxtQm9neUtCVWlETkVpQXp0R0dhK2ljQ2lTRE9iakx1K0VmY0tRM3FZUWRzUHBCT25Ea1JLb3ZFdUNqL296UVhGMkNFRkFER3dXQ1RaZzdFeGpaSlJpQ0k5Q0NhSUNETmlDQ1NNQURJZ2dDZFUyNW4rVE1xdlJXZGZVRUVqZ2greXJWM0VHQkdLZ2NFd0lBTXBnQkZ0QUEvMmxTRU5POWdvWEJPZXVKNDQ0cUFrZ2dCVWpJZ3lOQUdNV2FNZzJ3Vm1yS1Z4SW9Jem1Ld3VUSlJQOEFnRFJRaG1vZ1RGVG9CR1NJQlUzb2cxcFlsMWh3aEdhSUJVVlkzU3J3QWlPUUJTUUNoVzFJb2xTWWhsUklCVVJJaFZmZ2FKQWVCRXZJaERzNGhrbzRCbzVXSW91dUNCdG9BeTRnQXBvNlhVSUlTUFR0eFZseUFTbVFxeFFnQWJtWU94d2doQ0pvZ1NGd2lBaXRHNHo0eUVoU3krMU5Qd1VvbzMxOTBTTVVLeG9zMkt1U25RL3N5K3ZvcGhiWW82cEp2MUlEZ0dxd2hseHk2aEtvUkV3VVJYUDhuYnZDeWZ1RDJKd2NITDRSV01LUm81b1lBUmtvTUpPck93dXNaQ1FNU3dVNFhTRmdCR01xQVpkaFhkSVlqZnVVcS8rN1l3VDl0WVJOMk5KTjBBTnNHQU5YMEFWUzZBVnBHSU5RWUFTWDRha29JRkNHelZxbmJpelorZUo2alFpcFhFRExtWUlVU0FJaDRHb2N3QUhBM0ZlcGNtbzVsam9UUURPT1lDUU5TS2FFZktrYWhFU3BvMFNGTU9BaFFBZ2JtTVlDbGhsQzZBVXZjSUpiQUlPRTJVRDJBNEJkS0l3Z3BCM0tKTmRmcUlRZytvVldBQVZQQU9XQ0NBSWFXWVpLeUFKaW1JWmZzQU1BbUFtd0lvT0RsSW1VZklBQWVBQXhGald4MDdhK2xJaHBNSVZTZGNvbTRJS0k4ejhaaklnSStBQVZLQzNxK0lCVnVJQlQxY0ZucmpFQWFJSmQ0T01WZ0FEUUdrVzQ5a0Ezb2dSdEFJQVA0SUlaZ09yVEF3QkJzRkVtaUUza3FlMGViT2JMNjhFVmc0ai9janllVlUwQkU4Z2U1S2lhQVVNQ0U0RUNINEdDb1VIdUt3Q0NOYkNSTkhtWkxZaUVNOGlGTXhBQ0tMQW5ydU5XSFVEVGpRUWo3d0lqakFVamJGVWVodXVMaGF1a0VHUUJIQjh3RmpBQkFtTUNIK2lpTGxLUUxtcGJCVG1EWXlhR1kvQUNLSURiSnlDQ2xQNkZZL2dGRzdHRVRJMkpGaExFR2JSZ09wNGQ0UU1RSmd3UUZSdkFSeS9Yc0NTZERXdzgyYkdHc2U3ZUFBU3JzeklCb0xHQi8vTGxCQ25xZ1FVQVVjTE1GbUFDMmMyaEFGRHJxcVpxdDRiMFdGY2RGdWlCUUltRE00aUNYR0JkTTZuVVJRQ0NiK3pOeldVRU9RZ0VhSGlFTVFpRVQ1OEJRWWlDUURoMlRTQUdWSGlFNmt3RzdPd0ZXdEJSQlpBTFNZQ1NVTGlGLzh6b2hGaDRBcXRiVnJnT01ycDY1YWpheVNEN3djR3hoY0tZckI0UUFnR1dad1MzVnN2Ujlqd1c0TjdzVFlXSUF5R2dnaGtkbDFySXpsdVloRjdZVFVxM1lCdWNjVVRIUDFuUGRGdWJ5UU1IaWhXd0JnbU1pQlZJZzEyS2dVdVNJNkc5bXhDd2hUbkFxNnErQkwyTCtMeVVjYVpDcmhWVDFJR1F1cHhhZ3lOWWd6V0loRHpBRFY3c2c5YVZWQ2JvS0QzMkFSZS84aXFzUWlZNEFoVUlnM0VNK2c2UWdSRXcyZ2M5VGgvdytTSElnaXl3QVMyQUJOVDFJT21wb1dScGhVa3dnMGF3QkRnQUJrdkFnN08zaEFZNlREd29GZ3VxK2JPUGhrcG9oVk1BQUF5Z2tBN0lBa09BZ2k5WUJtWTRrMGZkQkRCSWxtR0NoaThFZ3h0WkJQOUFBQVE5Q0U5WHdBTVBrbXdieWZWTndBTXQ0SVpsWUlTQkdOazFMenNCNmJUUlc3SHIwQzBqb01iWWRBaU52RGMwM1lnY1YvaTRWc0NuaFBqWWgzMUozNXc0a0ZOZFVJVXFrQWdGQUdjU0lBR2YxZFQ2MHNNY2tDcnZtNlVXT050SGNQWkhHTWJKZW9CcldGRWFwRzJxM1Nxd29xdW1HajRLdHh2d2FMTGpyRExaQjMvQm9aeU5xQ1FBV0lJdFFBWmVpRnptdDRGdjZ3QnVrampnRDRvVlNBTFBFSVd6MFlReGtJMFFvQUtBTUhVQ3dJQW1uZ0FvVUdHS0VvQVdGaFJBSENDUklBQ0tGUzlpeERqQ2pUQTN6anhrSlBqQkJZNFFJVThTTEZCZ0FJQW1LbjVZc0xBaEFzYUpObG1paEpqaWhZc1FFaFdVa0FNRUNKWW9ZL1QvcUlMbFNKRU5pd29zdElnS2NRaVFLRlZPUG9nQkE2T0ZpZ29rZ2cwTDFpTEtzbWJQbm1TcEZpMWJUNzR3T25od0ZtZEZsajdFWUZ5eFlpN1pqR3R4MGlYNGsyYWFPUUF3SUZhdzRldUFBbWdIS0doaDRzbU55amZXNEtrQ3BFcWtQSlkrWjhMMkNSYzJYWVZPRjhwMitoQTNic1dLSFlLdGF3eXNUbjJRMVFrUlJBeGpCUUJxdkpvMGF0S2tTcXN5ZGtEeVpJaU5YR2NzMkJoeXhNa1JSb0g2WU1mdUt0T2lUTjR6T1hIQ2k5Y2VYTE53bGQramZzK2RZY0MyNE1sekk5aW80YTlhdlhwVktYK2xRWldlRFVMSUpNUTBRZ2d4WFRCeFJXWEwzYkJaSDhCd0U0Wm0yTndCeXllMEZPTmFNWjA4NGdnMWg5Q2lDQlkyMkJDQy8wT01RYlpCUlhJSnB0aFhkYWtsMWdBV2xEQkVDRXdzWVlJQ0taU0FoSTRRTWNhV2tFTVNXYVNSSVJVQVFRQVhMUWxBazA5ZU5GRUVGZ3h4aGhlTkNFSkZIRWV5OVZRSVVORzFsa1U0c2FMR0prTzBNRUNhT0lEUmxGZGg5U1hrWDVBQk1JY3RaUUhHcFo1N29nVkJSUnNNRUlCalVWYkVReHBja0RoVUpHQnNFZ2NKRnNCSlVXQVNZZUFYWkJhVXhKZ0ZJZVRRUWwxNlRvUW5sMHZHU05hT0lhQ2FhcW9tc0pwcWRBMDZBUVEwSlZJUlN5TGg0WnFESUpyY29zY2pVWmdFV1FndXdBU3BSRERRc0pWWmFxMGtZNm1oOGhsdHREZXhwSUFIR1BoR0JpVjBqTm5YQXhuRTRJQzBBQXdxcHdJUFJLQ0FDVUJFTXRRYVFERFJBdjhUTWtpaEJUS1o0QUhFSXZLRndHb0pKU3l4UklOQXJCSEpJbU00NG9ndXJ1aVN6UjdaUUZ3SUw2TlpPTXNoczhCeWgzbXdjQXpMTExQc01VWWtsbWlSNFREREhJTEpEUUQ0NEVNRUtXalFnUWthaE9DRERsY3cxc0VQUFZqd0JCZUpVS0dHSWNvb2s4Z2plb3d4eGlQWWpPRkswNmpOOGhwc2h4emlzY1d3MFFLeTFSOWpJZ3JWS2QrQnpSdUE1SEpESGJlVWdrMW9ra2hTaWlKM0pNTG9FVWRFc2NZYmVYaUd5VEtOTEl6SEVVdzhBY1FOa29WZ1ExUW1iQnFISENhYUdGT1BKWFFBVVFjMndYalRVNUcvdUt5a2JEVTVydWVmZ3g2NjZOVmFJREFRWTlBQ2lSTmVkQXBWQzBGVzVJR3lJY0VBUTJDaXhpbVhBalZJOUlEL2ltS0tIdnhqZ0ZIRlM4SlZIT0ZRVnp4NDhzQllnWDZhRmc0NDZHQkVtMWhva1FjamhaZlFWVTJmUGtBR0QzcFNZZzFDMExKMSsyTmZzYTlBQngxQWhhTUZWTkFpVFNCNnpHWk1MYlVrNWNnZWhSd2xGR013eGxFQzRTbXk1T2t4d2x0Z1JkU2dBZ1FXU2x6UkM4bFBuaUk1REhUQUJ3Q1lSaXRFY0w2S1lFQURKdmdKUzF6d0FoaEI1Q0doQXN0VGJLQUlLdGhBQ0U1b3dZMjYxd0xERlc0SVZMbEI0S0lBaURjY1lRaUJBd0llK3JDSVB0eGlHSitJUlN4NjBRdFNLRUlRb3VDRkplN3dpVHQwQWhDTUFnSVk5TENIUXd6akRzblFUQlh5c0loRjRNRVN4bGlqeG5BQmpHR0lBZzV2Z0VNcEpQR0dTT0F4RWxWSUFpV3UvMEdHQ2l5QWZkQXhBaEw4MGdFbXBCQXhZdENnQjFoZ2duNHhJWktTREVFWWpCQUNLR3dpQ0VPQVFpNk1jQVlwVkNZSG5HaEVJMzd4QlFCb1FSUmJXRU1JaUdJVlBlQ0JFVTVZeEIxaUF3eGVhQXdUcEpURXljTElDMTBZZ3hUN3dvTmxLQ01FS0N6b0NVeW9BU1cwa1FwS1hJSlFsWU5NUkg0eWs1Z01BRkFvVWg4RHpkSzVib0l6bk9JOEM1UXdrb3BVTERJSVJJakVHb0p3QkROR2dSVGE4MTVJUUpJUmV3NWdCWFNZd2dMb3NJSkJjZk1pRVBEVFl3ZzZ6bTcrWllMUm84TTFvcW5BdEVoa1VKa0xrMEI5RVZDK1JPK2kwdnhVczlCWGxvWnF6a25mREIxZHl2VXA0RTFxU0VWSWhBMmN3QWhHR0U1OUEzZ0FCb0NIRWY5aHpHRWdNQkxNTjJOMHFaaDBvSEFocUV3YVhYR0hPMVNpRXJaNGhUWWdnYTgrNENGZk56aENaZWEySEFYeDhBbGFYY0xjZ0RBMzVoUk9EVVVvVVhSYUtZUWhBTUFRdGpBRlFucWdCQ2JFNUNGeWZRanNRc0tDRWJEQU54WGhBakRnRU5VZ2hNQTNmTmhDSGJpVENWY2NvU0pWd0lVak9MYUhoVmtpc2M0N2lUMEJnTStmQUdBWDFlQUVNMWJCQ1VPMElSaVZpRWJYZ05FS1lyU2lGZHhvaFhCYVlRWkFSQ0lJWG9IWmpXNGt4Szdvb0FZKzBHdEduREdJSUZRMlN1aDZBSW9pTUlJRG9tVUpVRmlDamZ3VkJ5RlVBUkN6UWtJSnZvVE5JQ1gwZXdrOGFGbEd5dDN2Y2xlakdzM0lEaVpobUpOdWxDMTJzTU1JUU9LQmdYYi9ia2tCc0dkd3VZU1RGWHlBRGppQkFBd01taEU2VUlBTTEwZ0REVWdGQVp4NEZ3QUVoY0JrQXdvOU9WM0VNVTBxS1hoRHh6d05tQVVDSENBRERUZ1FYNVJRTTRVbTBLRVF3RkNGR3pKaENFR0pTbEFza0lORWRLSVRUakNTUjhWSktoeEFhb0lIVnFpUVBHRFBtT0JKZmJLRHdRTllFQ1k2YlM3RUZtQkNEbktRaFRBSUFoQkFnTW9RYnRDZDdyakNHS3JZQThaWTA0cGZ2T0VObG9ncUhzNm9CMGhvUVE5SVc1Z3VNakhtb3FJR05icVk4Mm5HRUI1R0dORVN5RnZPRUJEM0x3dVlRQWM5dU1LWDZncGlKZ21BQXdnNFRCbktnT0crcENDbUVhMHhRbTgzaFEvd2VLZWo4Nmw5QWZDQUVYd2dDRWdZQVJJMDRBY2Y1Qmk5LzRSaVlWclpXdUdRZURmQmNlSlQ1N0lyTGNxVmE3d2tKUWgwbXRFTGlqcEwxeE9FVnFnK3dBVXpyT3hhYmZoRktuNHhDRmx3UWhZak9BdEI3UUFGWjR4Z0ZkczR4VUhPQWdPUVBNQVhsMWlGSnp6Z0d6RTg0QUUrRm1nMUhIcVdLZGhoRzdKd0JpSldnWWd1SU1JTXNrQ0VHK3dnQm84T1lLQXJHVjVFU2hDRktQVGhDRS93alUzVGV4RU9BSUFLVmxEMXE0c0VBVitRZ1F6VitBRk5LdTV4NGZGZ0c5ZndCUTg4WUFkaG9OemZMQkNER0tZd2dqK01ZTDEyK0lNR2FpNEdQL0JoQkxaTHQvTlVCSUFwMUtBSEdzREF5MWpRQXhQSUlBNDl5TUVUUUltRlNDUWlGemtRekUrZ1U5VTFXTUk3WS9ZREVyYVFoMGo0QkFBNUtQK0ROSmtBQkV1NEFodS9aSmd4NXV5S3Q3OTlETnV6Z1pvbXQ4SXhrZEF2NDdvb2Z4bnNnWkhLT25UQkRRdlJKV2tDSnBRQUIwWVdEQUEyRUlPWkkrWklBeGlDSEE0K0ZDSlc0UWE2MGNBSU5EQ0Z4VVBrWlgraXVnS21jQUUzTk1FTk0zQUdwdWNpa1ppRW9NcFYyTVFOb0JDRUsxeEJBeW5Bd1FkSUVDVzE3Smk3RVNqQklPSVEyQ0pIWUFVUjJMR3dUNUp4TW5BQkIxU245RDB0UzhHd0xOa0puZkFRRjg0SEdlcW5KZnlEV2N3R2ZLZUFKUURCakVsYlB6UktISVZJWk1JWTJIQ0ZaczZRZzM1Tnp2dGlJaWhMM0d2WkFXQkFrZFdVUnhuVUNJZ0JES1JDSldBQ0o1aUJHN2pCS2Z6QnRqbkRmdVRISktSQzRLR0Y3TlQvaFRPd0ZuRzBRbEpWd2pIOEFpZXNnaHY4bXdlc0FIL1JBUXo0Z2llUWdTZDRBZ3hjQWloWUgwYjQzOTdkem5nOUQwdUVRQjdvZ1JOVXdhekV3UkkwSDBaOTNCRWlJWjg0QTc2WkFTS3MxeDhjaGhpd0FKSEJ3SXVNeGVaUVhFVzRnQ0s0UU9QMWhzd2dEZ2JVRnlad1F5OU1uRXhsRXd1TjBQZWh6M2FsQUJYVXdocXRYeDhFd2htd3lOMWR4THJWbDFrc0FCbGtRSVJoNFZsUXdnVmlCQjJRZ1NGMld6MU5BUS9RQVEvd3dCUk1BWCtCaEIxMFFSQUVnVE5vQU12NUdBejhnZXo4d1Irc2x3YmNvRms4QUFuZ3dEWlpnQTRzUVJ6RVFRZFVSQVI4UUFUVVZKeDR3Q2s0WVVXc0FqRlVnaGtRZ1J2OEFicnhGZ0RjUUJUby80RVBZZ01zOVVFVkJNTGdoQmkydUEvaUFFRXAxTUlZaEFKMU9BU05KVmtLbFVBS0lJSHRpYUlSSG9tc1RSaVRKRUFDSEVCRmtBRXprSWlPU0VvTGxBQVQ5TXRENkYxSUROUTkxVTdrNmFIMStkaTErRUFRK01FLytrRVF0SXdZWG9zRnBFREFJTk5RVkFFak5NZ05PRUVqQUlNbzZGSVc5RUExU2NRSS9FQ09sRURNNkY3KzdaUkVySnRqK01tU09JWmQzRUFlTUEzeUZGb0xWTWE3QUVFd1FJTGZ5TUFJTElFUTlNc1E2SUJKMk1EbFZVSFd1UmtlK09NU2xBRGlSSTVZZkU5RmFJTXlZRVFBQ0FwbFdkYTZGY2tBRU5sN0xhSnNjY0lySElkbEljWWVrdE1uUGlFb1hnSy93UUFQekZ4L3NZVmpvR1ZGWUNDUlBNQVAzUC9BRWp6QkVTeUJaRXdPVnpvY24zVGNXaWJoWHE2YXgyMFhPQktFQjBBTEQ1VEJHdHlBRHNXbFpRak9NYkZBK0VVbGNiVklDRVRCTFRETUhqaENLZGdnVkw0WFdyeGdXVHdBQklERVROV1hmSEVYSDZ5Q0xmNkJNTlFYQWFTQktZQ0NId0FBQy96akZSaVp2VzNETDBEaFJaUmZCT2hldWhCYlNsSFVRNTJGQXVCQTk2U2Y5amhFdXVCQUdFaURIbWlHRUdpQk5PeUJtazJqL2poTkh5akFFSUFCTkx6VURZREJVRmhBcVptQXpIUkFjY0xQTmtFTFNJQW1BUHhCTmRpaU1BVFBoSzJBRkdJQXk3RmNKd0tBTTdIbFBWNUx1bUhBRkh6aUw0b0JEMENoWGZyZlZ1NWpQcDZGQjJUUSsvaEFRUHBCRjNSQnBWaVdXVXJMUG83L3hRcVF3U21jUWhPY2dqQjhRR05XaEIwUVEzRUlReERZd1R4aWhBYVVBR1g4elJPMHdCQkFReW53Z2lwRWdnZlFTRmNBQ1FBVUFTQmtRaDVveG5LTTBPK0ZDZ21JZ1Njb29Ca0VRUmZRRjMvVmpwUDIxOEE1WmtZNHhoUmFWc3hOUWV4OHpnT1lGQUM0SmwvbVlRMFNpVVJzUUpsR1FBUThVZ2tveU54VWh4UDBnWG9BMEJFOFJhb1JTYmwwYWFhQjZaRllReUtXaFNFd3c2eUZSQVZjQWtnSkQxM01hUkYrU3VibzNSV2FSUk9rZ2ZTSlh3Zzh3Ulg4WXhlc2dpeFV3eW80Z3gzd2dERGNtMTB1MEFBNElxS0dWSHFwRHd1Y2dyMXRnWmdSekEwZ3hnRHdRWlpTRUo2R1JBU3dRQWRvZ0xvNVdMZWd4UXdrQVJXOFVQZUEvMFVCT004QWxFQWNjQkVrZUlFTjlFQy9qTmdTcEJVVm1NaS9WQmRkb1NjTDVjbnpFRVFBZ09aSUFnQU0rQnRCQ2lhZ3VoNmxZSVFDbklJekJPUVNkb0V6Qk1FSStJQVlDc2ExbEJ3QUVLaW9CSnhsRFJSLy9RR0JmaUtCWXNEc29FVjlhb0FsTG1HbExKaUZpazRBUEZoR2lNRXBXR0NDTWFXVHdOcEZiRVFXTEdudGRZRVBWSlkxTUFRRjdTT01sQTRVTUJ5alZrUUhwSUIwSEVFVjZJSGFMTUpuNk1JZE5NSVJ2SUVaaU9BdkFOZGhERjRnSnBsMkJkbW9xQ1UySGxyd1pNQWt2QUlaQU1CR1FGczBJSUlHOFFrbkNteFpYTXNzWHRRQWFJQU9ESUdUQ1VHNzJJQWN6QmdxcU1GUjV1bllmaGVwNG9udEVJUUNpSkFLL2Y5RUIxU1hEVHdTam9UZDBMS0ZmM0dKM1lKWG5zd0JJWnhRdDl6ZHM0amZsRHBtdzRrdEFMaVlEcWdRdVpyRkNxVEFySWJGdGRyYWtBUUdHOEFBT1NBQ0FLeENLc1NPWUFybVg0SWpTL2hjUU9IdHRBU21COUFCcDM0aUhmaENLb0RDa3ZnWVl0UW55OEdBSjl4YnZrVkRVcVhDS25CcTFFckxBV1JBQnNDQUFEREpOLzNCdDMyT1JIUUFNbG5pRmFDYXJuRkNjZWpqY0NuQW1iWWhSOVdBRUhqVmRFaEhGV0NHZDhCQkkraVNiQUhBR25SSEhrQ0RabHllRU1pQkFqamp1UlFBb0ZDTzRzcVVYOEN2WXhSRzY2blBKdWhCSDRSQ0g0ekJFWTFCSURpQmpVUkY3QVZXMmdiam9qSWUrSWtPREtRZ1J2REJDM0pMOElBRmk4ci93VXQxRlEvNUFHQlVyYVpkaEZ5MEFLU1M3UWlYYll0QWhpR01nMWZNNHA1QVFDZldEa2pBUU1DS2dTK2NvMTZlSmF5T0d4bU1ycDZnQVFCb3dCTHcxb3lnQ3BwazV4QjRqendTN2tWOHdBam9BQmVja3BNMFM4OHVxck13bnFTQVJRaGNNQ01JVUMzc3J4eFlRUkhrQUQxbGhBM1g2Zy9vd083bEFJNWRZYmJTNm0vMFFCem9pQVhFVEYwY0dCc3NFS2d1UzM4eGNPSGFVKzNZd1NrazRDKzRBUlRjYm1vVnh6WTRRMjRpSWJmQ3dENkJwdXkwM0hvQzVrVnNReXZRSUZxUWNZc1Fsd0lVVGcyZ0NnaDBYTVhlWlhaNjV4dVV3aTFFUXFqZ3NmVVZtUWJFZ1EwSUFpcW95VFlDaVFWRnlocWZGR1NZUUFrWURsMFJtMWtvLzhBVmJFSVpaUjdjK3NhcGpFR2N5Wmt4eE5sc2hNSWlxRUxidFYwQUMvQ3RaV0ZJYklPOFNkdEYvSEgxcmJJM1VXenlBbGVDVXREbHhBVGxEWUhkbWUyNEdOUTZrL0JCd1ltWUpIRlo4RmZzVEVGLzlaZC9zWVExSU8wT2R4TWJTQVFzRnV0RmRNTUtoQzJROUE3UFBjQTMzSXhtdUlrTlpBSVhWNEdialVFbmFFSWZHSVVlV0FJZzNFSW5SSUZDcWxsaTFVVmU0WTZSYklBWDNBRXpGNEo2a0VKem5sa1dORUhHeGNEemNja1NHSUVRVEJOTDdNRDRDSnV1MlhHb0ptMFFCTWNsZnl0QnNNRGlPYTZrMURMbEZPRTNkMU5KQ3NtUytJa3B2SUlwa0VxMFVLZy9SNlZGbE9uMGZvQU5vQUIyUWNBS1VFQU0rTUplVk1TZHp2L3F0N0lYelVFZXFOSUJIL0FBQ0JRckJqbEVtdkt5Q1RpRVVYSUZSSHd3UnFBQnNhS0xmVUVHdXRERUVwalJqS2xCTDJRTnh0U0NlS2lHTHVCS2RWUUJkbUNES2lpemFjekdJdWhCSitqQkVSM1cvNG8ySFI2QjRXU0VISWVBejBrS2hRSkFERnhES2dRQmgzWkJLa1FET1NrdTZBekEwdWxBQW8vVEFFeEpDRUFDSTd6YVdqeEE2OUVZQ1VYRXVleXg2UHgwV2RqeHhjVWdDemN5REJ4QWZ6bDFweW1BRkJqQ0pMQVZOODN2QUNSQkV0UUVzTzFKUk56MjhicUFDeFEyN3h4dlhiQXY3TDUzQjRUbXJNbElTVXN4SmRpQytUeHVzZXJnVTc2dUdBVEJvNkZGQVpnbUo4QW4wVUVGNGxpa3RycXo1NWh0SnFkUDVTZ3VHYVQvQWczY0dpV2tRZUJlS0VpTVFCTnEyell3QStzNnd6Ym9CeWhjd3phQVFvcFNSSE4vTUFsRUFHUk1pVStwclEya21pbHdneW44QUVJc05VdFlnTG1sUUFvUWw4bG1CR3Z6S2tFTTNXbEhoVG9NUVR0SVF5MUFRZ21vS0VwUVFCcGNBRUxFWlV2VmdzUEFRamJvUWgvb0FjVFV3aGtkUWZ6eUg1NHMyU1pFZ21WWUFDaE13alIwUlpQNHdsYkF3QWY4QVpHUEM0UkwzbkwvUlBkOFJVd29LbTVmQkNXTVFpeFVvdzNZZVo2blZBbEhPSi9ZZ2U0S2d3N3ZDVUN4UlE5TGdSSEk1WEIvVjArZDkrZWdBUnJZc1JpeUFRc0FPVVU4d0Y1Z2dBeFFZaG5VTWhwRVNsS25Ud0dnU0ViWThRQ3dPZ2lSOVBGT3IyL3l0WndZNUFnMC8yNVo2RUFPcElCeVI2NGQ0SWZETmNZQUFEU3g0cmJKa29BR21IZURUNm5sNEFRb21NSXBQT1c0MUdLNzhmQ2hKZEJhMlBGZXNDUk12WTVlc1NGR2xHUWJkZ0NGSGpxZTR3UWFSTUFETEVDUlVNQWxXUGhZUUo5NFcwRWlyR3dnM0FMSWhBSzVEQUFZUEVJZTBLR2JaQm9BZHNDYWZrbFF3U09KbE1nQlZ3UzRna0pXVm9RZlZFSXI3QUtMMzlPUTFhUGtCWi93NkVRSXBFQUlMSUVjbE1Ecm1LcVI2QUJsWksvL0prMG9oSUlqU0VNb0JJSXNpZlE3Njd5Y1JBQU9vSFZHb0lFbmpOc3FxQUVoRUFJMXNCUnY1NmxHMFlFM1ZBUWRBQmhCVERCM2tRQWM0RUlxZk9COUpCVjhlcnFVVmtRUFJ6bGt5TXk1WWxjTnNQZjFzZitRRmM0SWtIeURGeHhNbHYxdklEeUNKSGlWR0kvd00weENJaVNDSWhpdXVjdnp1WnlwQXF3QWkrd1krOG9xQUs2QW9aMEZ4Nk1GMk50M1ZOYjZlUHUxRGp3Q1o3c0NMNVNDQjdDQnA5K2w0NHVwY0licUFNejdra1JBQnpBWCtiNWRKaGhSMHNCOGR0Q29IcXhNcXkrcW55QXEzdmF3VnA5RXZiOEZSTEhRY05FVVkvVHdncFBlaTlkWTNzVnZSdGpCSlRTUzVnY2dDNVErMFQzQTVuZjZURW03WDFZdjZRTEF1bUJIS0pSMlZNalZuNGRFRGVCTTllODhBNmtCSkNoOStlUDI1aU1oa3Exd29XcU81eGJ1c0lVT0d6QStvSThwOEVUQWJrTUtRQ2dBRU9LS0NRVVlNSXhJSVJCQVE0Y1BJVDRjRURHaWdpVTNNRDQ1TWtUL3dZQ0pGRUdHWkFOZ0FJWjk3RGFCZ1hSbmpKTWpZaDVFZUJBeVpEY01mcEJBRUdPT2hSODdmdngwa2RHQlpNT1JFUU1BS0VEVGc4TUhIME9tMlFXZ2cwZVNSNnJrY2FXclVOZHMyUXJwR3JOb0VaNDFSM3g0UklJRXh5Q2FieDlDQ0lrR1FEZTRFVzFOa2dzZzZWMi9mKytPVkdDaEk1c0hLVlpZVUJ5QmhaZy9mOFFnUklqR0pvWnVNT2djK0R1UkJaSWxTSWdXaFFxWWRHblRKQldrSnZ4eDlHblhyMkhIbGoyYnR1bStORzlUM1BzUUJvL2F2MTBmQlU1YitIRGpnRDEyQktCQUhKQWJTd2dYRFprYjVPQVdBMHdjQVpPbnlnMGJKa0swc1BGOFNBY0xFMXVYUm1PMVlRb2ROK3EwaWJ6Nk5CczBHTkNFU3lXZ29RYzAvM1RUMDgwaE5HRHd4WnR1NkFJZ1FaRFFLMENCRUc0aFpROWVIZ25CZ2hCQ01LRUY4R3c0NGdnZ1FKVERndU1BbUttaDlBb1lnSzRFTGlFamdiNFdvTzR1Q0dDZ0tFQVNqYnFMaDEwdWVlc0JDSFlodzdRT2VvQmlreWR3VEZMSkpabHMwc25mbEZsRktZb2VhSUtMTEthYzdjWW51WFJTc3k2VjNESk02UndTRXk0SUJramxxQVREQVFBQ1g4dzhjVURLdkJuRWpFb3FlU1djTDM2cDhUKytwcVBJbDJwU3FTUVZUd2FrVFFFaHdBaWhJZlBpcEsyMWorajZCb0FEWUZncXRnZGcyTzIwVjBhNUJrd1BTRzJxR3g3KzhCU3B0eWJhaFJJd1lZMVYxbGxwcFVsVGlXck5WVmZTaW9OSXhsMXJsVEUzVmFsY0FZTVNycmhvQ2Y4VzJGRFJJUWc4MGNDaHBocnFab1hVV0hqQWdnaWdRc01ERnNBMU00QmZmVzJJM0ljV2hPMWNpRmdqN1RZTmxsaUNvWWc4cWxmQnVwYThCcFJLcXFFSmhtMmlHYVFMaDA0QlpSc0F6REJERENXOThXV1ZTb2c1NWgwWVlQZ0RLREdhb2hhNGRJSHQyT09QUVE1WjVKRnpCSG5kSjN2MUt6a05mRUIyaVJKTWtUYWlwaXlOcXlFTW5ISERqUkUwQm83Y0JTTGllRGowcEJ0QmgwaExHMkN3MU9LODFVa1k3TGlFazE4cTRRUURrckhPV3V1dElSS2FJcSs1RGx2c3JjRWUyelpWa3pyWkliVXAyc1dLRDh3cyt6U28wR01QYWRjd01FRURFNWdvb1FSd1pFNU5OTmRNbVdTU09UQUp4b3JZRHBqaVk3Yk5qbHp5eVNtblZlNy95akUzTHVXN25BNDYwSEhIZlJMeXpERzRHOHdXM1RVMzg5VlpiOTMxMTNYZDNMakxZUi8xZ1FmOFMvZUtlWTQ1QmxldWFYL05McEhKRUxMMjQ1RlBYdm5sbVc5K3VCcW9LTU1GRTI5b1k1QXJTbmRlKysyNTc5Nzc3OEVQLzhrcFppaGpzUFBFVDEvOTlkbHYzLzMzNFk5Zi92bnByOS8rKy9IUFgvLzkrZS9mLy84QkdFQUJEbkNBZlRHZzZnQ1Z3QU1xRUlFRWRPQURJUmhCQ1U2UWdoVzA0QVV4bUVFTmJwQ0RIZlJnOTNJRHVRWGE1aTRITkNFQzA2YTZGQUpxaFMxVTRRdGhhTUlVaG82R0xGUmgya0FIT3I3Z2tJVTg5T0VPZ1RqREhBWXhoemljWVJCM1dFUWxMckdHUW1UaUUybDR4Q2dTa1lvOHRLRU5mU2pGL3hncTBJVU1SR0lXdC9pckk3NXdpazMwNGhXN3VFSUdDckdLWCt5aEZ4Zm93dHVjRUkwb2hPTWE3VGhHTFNvUmkzMFU0Z0NNbU1RQUFKSXZCZkNoSWFFSU9rVG0wSkI0Wk9NZVlWakhPdXB4Yldkc29CeGRFMGVLVURLQmxmVExIQit5cmhFS3k1UGtVcHNhUjVpKzBjVUdsTGpab2lQRCtFbzZwakdQYnJUaUk1bG9TekR1TW91SjFDRWZmK2pMWEpaUmtNTDhwUzM5K0VZek9uS1BtTlJrRFNlSlRHZDJNcFIzeEdVU2E1bk1QdUxSajd1c0lpcGZLVWxhUnBPYnp5eG5Od01KU1NuU0VKQ0RIQmNpcHhSRkhDNHlrWWhjWkEvWG1jeGxhakthNXJ4aUE2MzV5WEpaTW9UbkROUkJOK25LUzY2cW10UUVxUDVXQ1pjeE52L1VvU0RoSnl3RHFzOUkwaktPMXp6aE9vZm9UVjUrMFlnaEhXWVRjV25NTXFKVXBVVlVwakpGK2syWXRoR2xOUDFoSHZQWlRKcVNrWXo1N0tjZHQ5bFJYWklVaUQvTjVpeDV5dEV6S3BXWExqWGpJNU9KeUhZR1lDbEpnZWNTNmZuRXJKWTBweG9WNXgyTjJzV0EwckdTRWFYb09Lblp5b0dLVXFHZFRDVkZBMmhXb0JiMG9tNTlpeisxZUZTRDRsV3ZJNVVqVjMvcFY1dGkwYVJQSEt3VGZVbFV3S3IwcFlTVmFVMkpLVmpJQnZPV1pRMXNVRis2ejZRNkZwSmYvU2d6cFlsTXpHSVVxWmkwNnlobDJVMThCaGFreDdRcVh3aEp3MFhHZHA1S3RHZExpNWxaM1hxMmxrajlwem5SQ2xSUElwU3NiMVdyUllYYlVER1dVcUwvSHh6b2FlK0tYT2F1a1pQanBPUm5wd25WemlJV21CN3RhaS9sV2RoMFVoYTM0UzFtUzFzb3o1bEtkcWZmVmFkMkNWdFlqUm9RbXRsOUx6bEwrMXVZcXZPTjU4VHVhSzA3MTgzS01MSkxKQ2t3OWFuRHF0SjJrYmVsNmpzZkhHSFFUVFc4TitVdldQTnJWOTVxVThQRFBhNTBGeHJKNFU2M29oWDk4RU1aV2tLSUtuZkV5eFZ1Z1Rkc1h3Q0hNWmljSGJCdVYycGpHSHRVeHlJZEpoRlpLOHp6b2plSEFraGtlNGY2VlBheTlMQ0s5UzRTTlZ6anArSTRyLzdWNzE1amFlWDVDbGEvd08wdVNGZnIxQ2kyODZwUmhhMFVDVmxWZHhaUnpZdmQ4b3duMnNvQUwvU3oycXlyaDdQOFZvYnFXYTFzVGJGY1RZbmkvS0cyeFh0Ry95Rmx2MnBVS2thNW41TGw3MlE1NjE3RnFoYXlPeDF5cE10YllTVWErWW1jRG9DbkVReGZLWS82c2RyMWNXYWx2RnZRWGhqUllMU3lVclVNWEc3YXVha1k1dkJKV3h2bUJ3UFJua3E1TEpvZnZXWUpvN1NxOC9WcU5TZXFWM0tPZGJQL1RER1dyeXhnRXdQMHhDZTJaSFFmcW1jQVdoc3d2OWFzdFA4YWJiSDZOZFdteG5GN2RSclRIYnZXclQ4bWNwQ0p6R2xQZzlxa1RoYTF1aU1kMmxaTHM5eTk1VEkrMXh0YS9Eb2J0YkxtNTMrQjNNWlk2dEhON0JadmhMSFpTRVBTMDQxVkxiYVNkMGpoZTdZNW5zWk85b2pYbXVnQVgzZlpJYmR6YWt1TVVCQTdsTnZUbHE2MitYY3V0aFYzNGVCbWRNRGxqRk45UTNuZkdPZnh2Zi9YQzNSVEgvbmQ5U2F2TWVsdDlKeit2TlJKVnJmUWcwN25xRWYyemF5dWVaTE50ZDJhZzFQa1BLVjFoYkhwMGF6MmtNekRUdmtOUTJmeFFpNVc0bUgzK0RiUER0MmNrL3prMVUzdWplRU84NVUvTzZGM2YrNTBxU1BYK1JVMHhDK1hPbVo5UzJpdFAzYm5tbVY2cFo5T2FjWmJNY0ZGSjdLdExlL3dTVU9hOCtTZVBOWjl6dFMzVDVuMC84MHJkaVZ0OSsvMjFvMG5QNjFyUTRyT1lqYXlwR1VmWW5TSFNIdEIranJVNlJ5OWlEOEh5K3dpbnFBcXBqc3BCU3Fid0dQN3pnOWNmb2V2L2V6amwxWEFkZTd6U0VFTFhZK2ZHdk00djI5OXQ2eGU3bWFlL0pEM1pvSS9uKzd2cDl2Sk1aNTZ1WmZjek1yeXRmWFVuVHFIdy83LzZITHBmLzBSdnJnUXM2ckJJTXovV091TjJxeTdjdXU5U00vdHRDL0Q5Ry9XUUM2MVRBdkZTTTdGOUM0QzRZcnZraStUeEVmbVdDeXRDby91c0d5YUdNM3FzbzYzUHFybm9Ld0VtNjZYNG12SURNdmJZTEQ4TEEvVkVrN3kxay9mOEszbm5JajFVckFGUFMvSDFDKy92R3ovMnUvQ2V1cjNmbXFHWWl2L3hvWENudkRoYkdzQUhZemlvcEQzRGpEM29uRFg1SS9kWHREdUJzNzB3aW42UnM3dnFFK1NQcER3S0xDdFVnY0R1NjJBQ3MvcjVvNzRUdS8xdktxckZ1N3hISXNGSSsvbmlzN3RGb3NHLzNBSGx3b0kzKzhJWFpBSCt3c00rMjNwdGsvOWlzcjZBQzUwa00wR2oya1NmKy9qSU9uaTBFK1JYT3FxaGkwVWZVbXEvN1l3RUtucXpFNHhGU3V2NEJnUERSa1Iyb2pyRERuSjhCTHZEYzNRMEZRTXovNmkrZFlIK1Nhd3hPTE1CNFZ2R0VjUTd6QXZwcEp3KzlEdDNESXZBUVdSQm5YcHB1eFBDQnN4L1dxdEQrR00rcWlSM3l5dHFTNnhEcXZ2eVo2cEdvT3RCOU1telFCbHdaeUo2Q1p1QUJtSkFCOXNxMmhQekdKUXZhak1ISS93MEVTckFWMFIrRXpPdDVLTEJEZVF4RTRwMjI1UkRmdm56akxNbFE1Tzh1NHdEUHNLN3FnTjUxWXRxWEt3OU9LckJ1SHRHVFZTMDF4cUdFVU5FRUZQL25idjF3VE80QTV4M1lycXJBd000UXJSM0FMSkR2a1BuV0RQekFacGttcExGRDFSQU9PUkFBa0FIcTB3cE9heEplZnZyOHl2czdpSUFmbVE0RzVzM1A5a0VmQ2UwdGxVYmlyZDBOWTA4QllUOHNXZ1R4L1hjYWFJN3lzVkRhcmc2dFR1Q3lRTjBiNDRNaTNURXNpZ1NSdHREZ0ZqenlycGkraVFNdVRJOGY0cXE4VVF6UDdranVyQXlpNkZiS1hvOFNFYlRaaXFrQXFwU2dEYU1RQis4cVFzYnJ4YXNwMGlrQ2pOSy9iQWJDWS9yaEtQclNFTHNpNy9jdVkrc085SXlPOEVqMzBBY2pMWjhLd3lhaFlORGlaZFV3ZnZ6Ukc3VUppU1RpMUJoOU1FeWNoMDg5UEdwVGFaeURlRk1PR1lURERoTWdpOXNSNXhzT3JpYnhsYkxUaTdzaVV6VWRlZ01jZ21zWWhzejhIRzVTZHJVekUvclIxL2Nxdm8wcXJFRHpxSHNoUkJVdE5zQ2pObER3R0owU3hQVDQxVWN5dHowUTJkVXU4S0VnVC80ZWY1dU03azlrNFhodzhpcDFFY2hZNmxuSW9pcmU0M2VUTkJGZFEyY2EwM2VSTTRPdzJLVWhLOGxPN0x6cEpDSmZRdXdRc1JtYlBIZUk3cWxpN1VvdE0yeTVPMWJFK3JwdERJRUtreEJmQTdSWkdld0RQaVBKSWUzUkcyK0JHd1lCQVQxUk15cDJpdXRFanRNTk1Ebit2NUJJMC9iNDdyTGpEdWxMUUR0VExSUWpNRFFXbVdpSERXeURMWXZna2pDOHcyNVkxQncvTkJGMVF0RFpRdDNjMFVnZkRkZEF6VENyUktxeFAwTnM4U1RaRkx5UzhMWDZ1a3dCT3IzckdJdExNZEYzT0pHdE5PODQvakNuQk9qVElScXhQWGFCS3hSSEpIUi9RTHEwdzArKzQrOGRNcG8yK0NUbE9oWEF6UHF1c0JVMGtGcjdIeDhtMGo0VFJVLzc4c1FTRjBPazJTT0dNdzYwNnFUSTNKKzlMVDI4VHhMTm15SkZkdlJrWFY4bUtVaWVyVUhRdUFPeVZNQUwxVEp4a3pNTWN6blpvdzdVcVNWc052TU1jdnBlck8yQllWVVJ2MUwxT09TTk1RL3l3MUlMRlNsZXl5L3Y3dTc0alU4VFIxSWxYeUdsdUw2S2pyVmhsMFN4RzBYYm5VQ1l0c04xTVZPVzExVk9FU0VCTXhQSVZUVlMwekd1blZXZFUxWUhPSUFQUVV3ckF6VDNtelY0ZFZNUlZ6VDdlcVR4TUxGQ0h6QzNWUFVRMjFXYm5yMXNRMFdTMDJBYVdTRFgyeEtoMHlXNEZ4VzAwVHhJNkw4SDR4RGtscnRKZ3hDTkZVSS9GSlh0R0xYYjEwTjB0VkVPVVZaemVOVkh1V1ptK1RXSFZ0QmgwdXBkS1VWcEh1UzhHdVh2L0ZMQ1BwZGZUOFVBRk5sVXNkakVXems4MkdsYW9LMWtVVDA1QWFGbXM5Y1JDWE5pYzFCU28wcjJQNVQvdzZjYnlTVTFHUHpSYmpjMGxicmtpZHI5QW1rZ1VubGMrWXJjTjhEc2xRbFducnNjaVVsallmbEdlM05HZkx6M0M5ZEVFUHQ0aDQxbkdGOWpobmxOSzR5a1BMNzhDSVZrUXp6ZmRDNzB6TmNTMXBNQUN2Tm11elNrV3YxcDRLb0dBTGxqc0pGazZ2ZEF2aEtaVGthd0VyRUdvMTlMeUNpbllKYzNjenNIZHZybmN0Y0Q2eExTdWJxeERwZGtpak1zbzQ5YkNJdGVqWTFXWTdUVGVsOTlQbTdWWU5Wd0N3OTBzVk4xNnAxMEVIZDFYLzFpTmZseWlGRTFSYmxVYlJLM016YmIvT2RtM0JGRmZETnQ1T053QWdRR3YvVTVjN0M3WW42M1JYVytyL0V1c2MwMVNIMmpOMzd6RlJDMVZ6MjNjejNSSStVMVBRa085YVNRd1hsL1IrSHRoM1YzTVgvVE1FcTg5VnNaUnpBVmRnUTFWeHR4ZG5SWGh4bS9GendYY2xrN0kxMmRkTThSR0U3N1drb2pWVTFiZWVESFowd2ZPMlhGUlBlN1dIdXhQQytsUjBEVE13MWJmdG9ITTR4NVE2aXpaSUQ4emRXcmhIeFRCSmpjdFJwZTFiSVZnK05Ramh6R29PcjB6R3lKSFVQaGlHZlFseEU2bUVyL2RtMFJob2F4Q09NcFFSWlhEay90ZkFqbEdNT1RkYXBWT01GZmJCckxZbkg4eFh3ZGFRWExSK2c5V0g4ZmVIRVZOWTQvZC8yYklLend4M1paaEFMUlBlRWpWdEwyMWVaOWZvZnEvWTlnNGgrNU9WUk5aLy96aFpOVVdQQkxrWVNkM1QzejVWVE9rWVFjbTRoQlhVak5PNGNMTjNscjFYalFXMmhwc1dZeXUwY2lsemxkOFVsMzA1aWYydmtQRlhSYm1UZFcrNGEvVzRWd1Y1bWZWM0ozblZtTEFUWFN0MFJNc09Yc2ZUR1hQdFZNZnZ2TXFzRkFuVWpqT3pOQTlLWlkrWG5OOW5VdzNTQ0crMFphTjBvNXB5Q1QrVlI0TjVpV3labGRIWWUyTVpscVVYZTJrWmNzbllObFc1amUvWVhudlpmTVUyb2VzWnZYYVZoVzVMZFllVmtMM1dhM3V5bUF1QVlBbjJhM2Q0TVI4YWthRTVGR0gwa0lkMitCVHdpV0d2TWtNUFI4MFhCZzlRbTl0WFBhbnlVZjlScHBVVW5RV0k1aTc0SWV0d0ptbVNJZ3M2aFBVWmNyLzNaL1A1bGZmNXFHZlpuLy90ZWFoRkZaaWxNSTVkK0UyaDZKNFhPbFIzbFgvakVabnp0NlAxMTZJeE9xSU5scU1qZXVJTzE4Z0lvSHAzOWs2bm1YM2w3Z1FiOFVRRHVKSVB0WkxKMUxBa1ZwWEYyYUFNenlvNytaUGpxalRvS3B1TVYrdW16d1FIMVpHck9rS0RscWdkZElRWEY2MlJtbnFUT3A4YmQzc0ZPb3dKRkRnRG1rczNPMm1uT3JHbmNBQ1JXWTl2T0ZpVnVhTlp0SkQzTkd5eHVqc3RtN1hMQzJraFdiYlRzWkYvK1UxdnE5U091SmVEOG9WZldobHo4V1JBYzRLTDE0TDM1NkxTcS91YVRZdFAyWnhOV3FwRnRiTjlrMllmdDdMMW1aOWxtWmFyTzJoZCtYMFR1cnVEbWFvdHI3TjllWkgyMkZjWFU3V3pla1VUczcwVnRoM1ZXNnh6R0pyL0ZmYTFnWkt4VlBxa2l4VkVpN2kwUlhvZWt5aWtKMHUvYzdsTkxWWVRxeGl3K3pPaWtwU0E4QkNPRzIwUG9kVmFCM3FWb1RmellQbTZUVGl5cjFlNzd6bkR2ZHVwbC9weHE1cThhZERFT1ZMQUhmYVFWYmVZdTlaMHFkQjBIeHAvVnh0cjlkU1ZyL3A4YzFRMkoxYW41SkVBdDVvTHhYUDJBcmd5ZDF5SmYvc0JyM0xKWjdxdnk5bGszVWZiR2hMM3FGWGxSaGtuVjZ1SkJSZW9UM3pFWTFtbHNOdVZwMXVNS3h6TWk1cXBJemVZbjV1aHFaYVBsK0syR0hhaUkxcXJmN1dQNVZ0dzMzdDB2eFBHb2FpMVczS3JuSkNsYlh2M0xBdUFWOUZPMWJzbldRZ2QzVkhDVUMxUWFUU3ZQVlBaY2k2Q0pmaDRsY2VtaldObGwyOGgvMFh6blNmY0lwKzZaK0gwd2ozN3c3KzhwYXliaEZOOXFiOFh4WVVhZmNkN3d5OFh1bSsxekVGN01WbVU5L1pjbWRXYmF6c2FvdDBieG84WmtPZlhod2QyaUZsN0JnUDlpSCtheUlMY2FxMFd2VzM0VHJWWnl5RlAwbEdRU3U5MklIL1h1UDhhNVZpeEg0TkxQNU56V1RFMHFFMll4RldkMWdrM3JjVWN6ZHRWaEpXYTNZa2F4Y2tiMXhXYnUyc1p0RTFWeEcxWWlQdWNZVS83aDNrU1dBM1dtSVhkMkgxNGRYUGN6VWw3bXU5N2RBOFpxcG5kMEhPYnE0Vlkzb3k5emp2YXhlMDBtWHM1eTFYYVU5R1dEajkyZURWUXlpR0lNMHRPQWdkN1ZUalRnOTE2WDBFVmFLbmIzYmNjb0hVK1FuRSsxY1hiNS9mWm43VmIzUnRiM3Y5QjE2bHQyYnI5bmZ3QTNwY2FNNGo3WEpGMHMrTVJsdG9ybXFMdlhLeWovcG5GMms3bHU5aUJXS1Vldm8wQnk0alQ3SmNNQ1pBY25wRTRyVEd4bnF3NUdzWi9QSkh2bE1CM2ZGR2pNNjJtVFBvU3ZMaUptMzVHQndrcmNhZU5MK2I3OEpFaDJlaFhYWDd0UGRiNVhYQmZtN3kzbTRTSjN0NGgrM243M1dlUi9oazFYL0xiL2ZFWCt1bEhzZEg1dmVpN3Z1dGxuQXBYSE1qekY5aFBXOWluc05lL0h1SUxlZUxCVnNlaFBYVzFOaDc5L0RDRC9KbW5QdVROTGw4TnVPb1crRzM1dGIvV09WemJNUEJyQjUzZnVkeTE4ai9IM2ZENSswQjNPOUxMK09qdi9iSEgrS2c1ZkRzNS9PaUxYcndobS95Q25yUFBQUHpUV3BwL0dHSC9zOVpkenhkd2g0eHJVMzlZOTVpZWZCVWdDQVFRS0tCQWdJSUlCd1lvSUNDQXc0Y0hEU0tVYU5CaHdZZ09LVjRVQ0hHaFI0OEdPWXI4V0xGa3hvWUdUUzY4cUpBaHlZNFpIMVlFNlJDQXpKY3JYeEtZS0dDaVFvRTdEVUpnS1BSbFNwd21qK1pVT1JOaVU1c0JiRUo5T0RWcVRhdFhwVnJWaWxXcjE2MWd2MG9kdXhXQTJiTmkwWjZOT25hdFdyWm80YXFkUzdldTNidDQ4K3JkTzFjdVg3Sm13d0l1QzlndDI4TnBFU05PSEZoczJLNWxJMWVGekpVcXpNc1dEMnB1ZUxtaFo4MlpRWFBtdkxuMFo5T29lM2I4ekRwMVpzK3RUM2QramJuMmJOSzJjK3UralhvM2JkOHdnU3BzaVJ0aWNkK1ZnWmU4bUZDNGNKUVBPVDdrLzVtVElNWGhFajJpWkY1eDlFMkh3bDJLVm5wZEpVZnlSakhTWEJwemQ5T21XR082UkI5eUlFL25QSXRDVDdwZUtVM3UwY21uVzFYSmdaV1ZaWTVOUmVCakNRckdJRjJMdGRWWFk0WFY1ZGRmR0dhbzRZWWNVa2poZzRyRlpSZGNJWHBsWW9tU2tmVVlaQTRPMWhGVWsxbTJXMnk5MFhhYWFqM2hxSnFOcGZWNDQwRTQ4a2pqa0xEMWRoeU53Tm5tbld1dEpWbWJkNndkQjFPVDNuRUVYWEJFcWJjUmVOT0pGOXAwcTMycDNIQWlJZVNjUlVjdEI4RjI4MjNINVZLY3RVbm1Ud2VkQ1pTWi9YbFdud0RDcFFjQmNka3AxZWQ1Mk9rR24wN2FaUm5BbndMOWVSUitSUEc1VXBZRlZPcVJRTXZkeVpTQTZkR1U1a2N4VFpiY1YvL3hWZVlZZ2d5bWVtS0RFMzQ0NGx0dWRTanJyTFRXS3V0aUY4THFLcTRlb3Roclk1UmRwZXFxTUxJWVk0RlBNcWxzbERrQzJXeVlQOXFvNDVETGlxWXNadFE2bVJ1U1NHcHJuSkNnNGZSdGs1Z2QrcGxMM0xtNUpKamZldHRSZlFybEoybVdXMW82S1VZamJibmxlcGhxaHVtVjVMSFUwYjh1V2VjcG1oNDVHc0FCaVhJcDNxRDl0YWZTYXN1bDVCUERqNEswMFU1M0VoRHBweWxWS3ZESDh5TE1uOFlSOC9kVWZLVWVLS3BLcEVKMEtxdVNEZHRxckh2bGF1dk9QTStxTTE0UmlnaXNYaUZHU09MUXZQcDZJSXN0Tm1pZ3FDeHZXeTJSbStWSXJwTGpWdDFzbEZPREsxdVkxb2JyTG0ra0xTbWx0bFNDTnZGSGFUdlYzdHYvck1tWmJrNXNGbmQxa3ZOeGVWR1cxa25hNzVydzVxMHZ5WW9LRHFkMkVYL2txTHgwOW10ZWV1ZnRxOUdlNzcwTEVjU1lNZ3o0bHYyR3Q3QjloTk5aVkgwaUUzY21RNXVqQnlDLzdQa25iTXN1UjJVUUFCVU40SkR0dEhPMW9PNnE5cDZXMEg0RmZkZlBIdlpzL1BFUUVsMWgweld6bXFEUWhmRTZkUFRGZHRWVzBzUU8renJXNjFMcnZkaEpmZy9iMWx6L0tQN1lMeG9Jcld2b3QzLzNqZG45NnlOb0J2ZTBFM0daeVZrdzJQbVRkbWhuSmlFSXFDYUhwNDhONTB0MmFoeEd6dmFkTTJFc1lmTDZWM2dTd3JlSU5LUnpuTHJYYy80SEU0c0I3bElMdzA5UTlyWXdpeG1FWVNOMDNLSU9oakdmcEk1ekNsSFlBREZpUXZyUi8rbGdDcW9JVkhCWGdBSXRhSHRUbWQzc2ZFZEVDUTNQVlJxU0h2S1d5TVM4cElneHpXdFIwYTRYS3lYdXlqQ0JDUllWVGNTN0t6b0lPRi9yR3RXOEJTVW1XVzFyUUtyVy9NUVVQcWw5cjMxamE1c0FxNFF2QzhacmZ6K3gzK0V1V0NlZVVGQlBkY3VPZS9oSVFJWWtrR044OGx0Q3dEUkJRdzZFSVQ0WmllaEErTUZHMFdSemRoTFlTQWlIRUV4VzUwM3drVi9HRklaQ3hRbmdBS2NVeUFFWWdzcWdmTzZFSWZHa0t4VjJsRCt4NW9Pb2k2UUZOeldUZ0FsU2Z2MkNpWUpRbFR1bXlTeHFQaXlpTXA5SFBPSzF5cGxOak9ieHNIYzBYNjFLZWxPRUhsOVNwSmluMVdRd1NJTVJNMk4ybWNsSUtUWkJRbWNhdzRZdHI1bm1qUC93VEtQNXhGWTJkakh3TitDYlV0ZnlpYlU0c3E4MUQwUGNrT2dGeVlBdUVFNEVrZFFOQ1ZaRzNmU0paSkJTSkNJbmVqK25iS1FBUVBGWVJoZTZRSkFKQ0dUM1VhQjRIQm5SUXc2SEpaOGFJQVZqd2pCVXNuSlJxUlFBQklDQ3lsVytjb1VwYVNVS1NUZzY3YXhwbHpBMW9NRUkxVERXM2E4bmppeFpTbnNZdTFOaEpwbXZvNWxVdmZtN0l3Sk5tbGpONnF1TVJqMG8vbXFxNE13bWlJQzFJaXpXTElwaHJWNnhxaWVqR0xGTGFzbEtsam85czVORXdoT3BhQXhqUFdkVW8zdjZabDFaNnhZWXczWWFkTlZwTTZUalk5OE1lSktTZ2k2Ujl5UElDT3ZqU3Vid0V6b21KV2xJVS9qWXcyS1FLS3JNNDZUNFdNZVZjSXlrajlYL2xDSU5pU2ZWb2xhMUVCUG92UXJWc1pqbWRDR055bTBpMTZSS1BqMXdLQ3NNN1dSanFERkxKVVNtRjNraDVRcVZudkxNTUdXZHdsM3ZjalBNcUM2emlNWExrRnlFOXhkb2F2VzdUcXppRmNmcFZkOWxiM3BqblJsYWl6YkY5anJOclc1dEYyNzh1ajU5OGtpeTlzdnZHZXVheUJwOWliNWdDcVA3MnJXK3UvMjFSL3R6VTk5S08xbDU1UzIxQ25TdHBGb2Jyd1V2OGwyY3lheE1nUklwMkc2WU5aaWkxSWJ0d3pGQStlMlJGQjR1UXp1Y3g0bEc4TEd2YloxbEZheVFuV0xVdDRtMGxFMkJXd0JHclJJaE5jMGxSbkVxRk03dUJKZUw4dGhRa0h1UUQxWVNoUFU2V0EyRCtSMzZpQ3VJM3hHbWJhckwxQ0dDMWJ3NFM5NVYvNDJJUkN1Qzk4dzUrK3FGc0NmVmE3cVpXTlF6YnhUTDJsUnZVdFhPOFlYajl1eHJOOUVJSUFFOUFmU2ZyZVlzdTFwTnN2NjFGb0RUZHI0M0JoaU43QXV3b3E4Rkc0MVVqWWJiS2JHTDI1Ull6Y1lZMFEyMm9KNUNJMGtRanZBQW11WVlJZ3M2a1J1bmNtR3JKSUJHSnlMckdpZk0xcGhpS0g1YUNkbGVHL21Va05VMFR5VUszY1UrRnRWQVZyVnZhV3FtM1JZa295TnVhYVJtK3JrRHJPbVVDN3RZcFRCYUtZMDY4cmNSL2x5dXFWM3J2NjBIVkRoMUdGSnEwa3VKeWNjbUhLenVXcS9yUEczcUNrUFl6SzUzMFh4bTdrSnZyTnBMYTFxVlpoaGpFVnhZYWtWNDdBeWU4S2dCQjFsNlJ1ZGRKNTRqUkVwOGZvS2w1eHJMbVA4dEExdmtqQmpYT0xQY1dhUkpGMmttdGQxMFRBRFUydFpHS3R3Q0ZHQnRBdmhzWUJNQWs4cEdOcks1UFd0Wlk5VGJHaDFJMERtTVU1Nm1xZG1zM0FtdktZcnRIeXNiY0RXZGlOTW55Y3RkSmxMbmlFUTJ4NUJON3BsK21Oby8vbkVCU3Zuak5ZR2QxZmJSK2xDQS92TnBtMXJjZVp3cHR3MFoyWU5kUm9aTDVSUjhWSWJ1cHhLVDNtV3RrSmdGcjdOOWs1bmZpTmNWWWU0OXpvQ0xOWndFVjYvMW5xaHdQQ3ZjcWJ4YmtZeU9TWms4N3htdXpKb3IycjFIUGpVeTBNRGxlODM0Q0UzeFErdVg0b1ZXTkVKWWYxelY1MWVFSkNaeGpoWEpLTkNaZElRcHZ1TmVOYk8vWGJOVzZVcS9Pdkw1MUZ1Nit4eTJLTDc1UUhxL09VYi85WjV2ek0rMnJHTzYvYTBYaE5lckpEdTJWYmxCbXRCT2RoNWhHTytWei8zMm83TDZmSnBwMlZ0cmR1RUNEaWk4TFNHT2xmNUlqN1hkbGJYVVNSZFJTaDZ6RUpUbEUwVkJZSGlYSjBjQmJ4aDJMd1poT3h6RWVmUDJaVzEyZUVpVVhXR0diNG0zTTRiSGVGMjFadVVsUldRMWNHWG1SZXJsSWwya1JaWUhjWkxIZWJPaFoyNGtUKyswSXhkSGNtcWtUNjFYY2ZwVlYveTFnMEFZaFBGMFYrT1JUb0NVWXBDbGU1dTJXczhtZEQrWFduYTFhajR4YXIveFI5OTJZemNYYk8zbllpN0ZKMG1IVVNpMGZEYzJocitXZE1DR2F0bldoZVRXWWpFVmhscTNZUkNWSDZWVk1VRmxjNzEyQUtpbVU4bUhhc2lYaHQ5M2MxbElia0pHLzNhb0l4eGl0Mkkvd1hOUGFFbEMxaEtBNGlpVUJVS3VNeDRmSVVvb1ZXWHU1bEdXZzI1REJIaGdCVHdheUhpRzk0RWR5SUhiTkhoY2xUeGZ0SUlKcDFibmRUU1M5MlV0V0hta2dpd3g0M2t5aUl0a1kzbzFhSVNwbDA0OUVocWo0WHBuQkdqR09Hakh1SU9DSm9SQ2lGaXZOMkhqc3hrTDFrcDVkSHpOdG1yUzluMW04bk1kQTIwVGhXTGtBbUtpZzF4WldHdHZDSDdMMTMxWXlIV254WHlwcEhTRktHNllkSTRmMW9VZTgzMXMrSTNRUm9BZGMwQ0Vjb21kZEk5WXAzeDVTQUI0V0ZNR2VYVjhlSVp5TjJMM3VJWW9KR1RSOWtqVmRpbi9wMUd6TkVrcVJHMDl0aEM4TllDTG9pZzI4aWMvVlRodmN6SWVsVko5cDJWWndmOVVGbWd6R1RoNG9laHZJbGlLSGhpSzl2WnZSMFJuZDlad2F4V0M0bFdMbC9kZURFZUxtbmRNV1NTRDNNTlBvS2MxalZabzBiaDZOTGg2SUljankzaVZPWUlBZ1NZQVdwbU1DV0NNWURsb08wZ0FDZUNET2JLTVVmaU14RGd0a1lWT1VwaEN2WmFFNFRkOTVNZDhzdFo5cmFSczVzaGF3U2dhWEhoS1doY1VDTGw4Q09tT3NoWnJCdmw4V01pTmQ1bVFoTm1HQkxsc0JSbFR2QldZZHFsN2RKZUlKNlllcUFOQnlKZVlrOG1Ib21tUWVFaWFpWG1HWTVlUUM3bVEyOGRyWGdkMktPWmpUVWdwSWVSemZIaVl0OWFadFdTQVNZWmJtSWx0cmhNM0g1VmxmSmQzSWJPU2J2TjNKbWlCMGxSNE50a2hOV21LN2tXQ0o4S0N3WEwvblpuWGluU1duVWJwa3d2bm5hYnllVnVHTm4xNVlHL0ZjU2JIZXM1eWFYbWxOVDlZakZ5SmpIL1dsVmFqbGZFcGFGcVpuem1DU245R2xqM0JBRnZabjRLR2xXblpYNUEwY2Z6bGpOZG1OVXNIaFhkeWgrbW9semFYZGU2WWwxc0lPZzRqZFZxNGZaZ0Vob2Q1aG5hWWZGbllTblMzbXFycG1KQVZkYWdFb0FTQUFOMm5hcHN6bVdObkgvblhVaFlrYkVtVmxpSUtvZ2RRbGdWNW1JbnBvbm5JQUFYcG9seDVvc2lIa0RXRmRXL29kU1Rxa0FQaFVuZXlKbUlYa2NoRnBSOUdNazNXRTJZWFhIVHlRSnJJZDgrbGlTQTBKK3BoR2Jham5DeHpMTmdsSW90blJjMTBNekpwazNINlRFbGtWbS9XUEJWb2xOdFpaOTQ1aTdGNC8zbmRXWlJKQ1ZjeTZIR0RwWU1tdDZpK09DMXJhV2hXTTZCYytaV1NHcC82aVpiNldaOENBS0FJSUtuMm1Zenc1R0x2bWFBNnNtQ2h4WU1vMm1GeG1YTjNlSFcrVnBaa21Yd01zS084SmxTNlY1bXRLbmFueEhNSm1VcExCNWxWQ3FGNjZHSkdtb2RIT3F0bHlhSVZHa0xvbUczQWxsakNwNFI5bEhXSjJhS2dlYTJvSnFTSE9hdldPcHFoZWFKSytvN2lhcUlmV202eGFaQkVnVUkxYWtoUWgySm9TRlAyc1JsL0FxYklwWnU1U1JJa05LWXJKMGdJUTJWRVZUdm9Sek1PNTZlQ0FTdXdtQ3ZiWllyUFNTdk9lYWNBaDBWdTFrM2NlV2ZXK2FjV082aDdhbkRVZFJqOVZHRGxLV25uNHlTTUZuSy91RFZtcVl3NzBhbUExditWWDhtVjlHbWZtZHA2WFFtellubU15UWlnZ0xZVHlncXBoaVpQc01GL1A2aVgrR2VZKzhkOXJlbDliMGl0SVFxWlpRaVN2U1doYmxpdHAxbVlBM21PQS9tUmd3bHNzNnB6Q01rQXM4cXBaM2lYNmRxUHJncEpMN1FTeDBXUVNYcXQyanFrQjBDa0JnbTMxU3FhVzN1dHZucTN4a3F1Z0Fta3FoU1Bob2hDNzllYVdPaUYvd0ovaG9Vam1sT0hKM1N2aTNNZDYxYW1seGc0enlVVFVFT0J5RlJPbnJoNDBObGRDNnRkNFdVaCtrWmVrY2RObG9lZGhLcDU4OFkwQXRzeXFacysvdFJPaUlxREFtWlB1d2lNOVZRazVMTmZ5bWcvK0Rsbyt0bXBDSkNmOXRrVHcwdHg5TG1Wa3VxVmZKS3prRldXdXR1RGR1VXZ3TGFnRzByL2ZubTVoeUtxaDIyb3RFbTdmRjUzajVBeVVWWXFvaFQ2b3grcXZlaUx2WU9wZlR3cWExcVpoMTA3cS9vWmRkVTZvZG1XYlY1bkVWUktML3lWY3dsUWtBQU10MElLdDNYcm9uTWJ0M2Rwd0c2YnBIaDdvamIzbzlNSGE0bFlRalZWWTRrWlFnNkdoRnQ2cFo5elU0MlNYT2wzUjVjVUU4RlVuTzdtZDliVlZwZXJaUy9KUldrR3V2Wkdpcy9wYnhxWXNEUHBWWEUyWHFaTGxLV3JuYW5DVFVpRHVTY29ubngxZXNLb3FFOEp1L21FZWlSYmVxRzNsczZiakM4Ym55NXJxVlpjdkpvYWFDMExhQ3hhbHNuN241dnFhOEFXcVFYNmcyalNFK3JYUjVZcG1yZTNXNStadCtVYW9VU2JrRTQ2am1rU0VwSENhMXBKcTQycG1uUzUvNzFVZTdSYWE0ZEtDcXVqcVpVTThMLy9lNFkrNnFxdENYZW9KRzRYSktyS0Y2U2dDYmRGZXNseG02MUErcVBjS3JjL21yVndiS3hycTV2WEsxTk1hbzdPVmxJYTNFSk9GbFNRdkJKL2NpLzdBY0ppU3B0TWdSdnd3V1dicHo1NzFzSUZHNVJpWm1ZNDJia3c3RjFzdGp6aHBNd25pTU04U1pSQzJYbEpvNVM3dUpUblJFWmlGSXpvNldnZmw1NW1kSlppR2M0ck82bVdPczRxKzVVNDI2Sys2N3NyQzJqSUJxQTdxM01CT3FBY0U4VUNXck1neDU2UWVsUXBXcUUvV0ppd3RteGh1NUJHS3FxTjNGdlU2TDVpUEtFbnk2cmt5N1RvR0xaYk45RXFDcUo3UEpwOEs3OUVLcitkTE1haWVpZVdlWnByeThsdlc5S1kzSzBiWGYvU2JHdXRCdHpIalRsVGRtdWllN3pIN0ZlTzd4aCtnUGlZTU8yUU5aZVFZd2RaSDdtRXpIWmszamVCdzZrd01pUkt5SWx1QTlCbE1DZ3NPcFM1d0l5Q1hTWE1yMkxNbXd1VVhBVEVXejA5Y0xaZUY5dHdsVWZONURtN2dSV0RJc3VlT0pqTklZdkU2NGtqL2ttZzhtbkY0d3pQOTNsSzQ4ekY2L3lWaURUTy9MbXBkM25QekZ0WFBlcWY5TG5Gc0JlcXFsRlgxZ2grKzJrLzFmcSszWGRLbUh5a0VscSs5UnVyaVRTcmRoWEtCSERTb0ZuSlcvaXJBTnpIcFgzYTJKcmFMcnJhbi8yMnJZMmlwTDIya2ttV3FIM2FLZDJ0bDJ6U0t1MjJHeTIxTHUzWlRJcGpGdHFhMlplazhuZVhPalYrMGNaSzhlZVFoa2pKRFphWFVUci9ZYlpCUy9mS01OQ1ZuQjNSMUd6Rk10TGxFVk85VE9mRkdHUUdUVEtNVlRSODFZVEIxZGJVTk9PZGJ4ZGJsTG9CWUlPMUkvUDlzZlBGbE82U2VzdnlsQTNWVUxYcmxBRUtUMTk4ak1jTHRuY3Rud2x3cVRwN2x2UnJsM0ZOdk1zYnhvcmNvL0RNMTFnY2hFR2JzODc3dGp3SzJYUUwyUHBwa0liTTJZaTB4MHIzdjFMYjJiQjZobHZMQUF2QXJRTnN5U0pldERXbHJJUHB5YnZkeWFtOXdFTnFBQ3p0dnEvTm90QjlBTVVxNUxNZHdBQ3MyejJlMHJkZG1remVtTGZKNDFMTHRiUXFybUpJeDdJRzA2MTBmeFdaalNSVG1YNEkzZVI0YXZHYUd4NWwzWldJaVp2STNVaVpQdG9aM3M0RGkraFY1K1d0ZUtVWW5aNmJiKzBOLzdFSEY5Wjh1cnA4aFQ0UVo1NkFkZGIzbmNUK3ZVL2FqRStNT3BYN2haYmdYTFArcWF3QWlyeDN6Ykw1NmJ3NE8yZ1cxN3huR2F2R3VCTUp3S2xsdWVrSXJzNDBHOGFhelY4dXV0SExpNkp0Zkp2SW1yS0oxTklHRE9vQ1BOS2YvZGpXbXFKZjY2MEwwTnA4VXVzSmpOdkFmZEs3bnExNTJMYllpc21vQnVORUN1UXVDdVFuamVLNStvNElYTnE1VGFRQTdPd0x6TnBDeXR1dWZadFREb2plV3JkSzU5ZzlHdHhUTzkyaFBXVHpONk45NjRYUjF0ekVuYlRrK0ZLNEIzMHBtVzU1ZHhsTjRlWk14VU95d3hWZXBreHFTbDVHeE43cVhjemdSZWM1cVR4MXZ0N016R1kvbkxFOERKNzNUVmphb292Y1k4UWxwOFFkRnk2Tjl2OUdYeU1iZ05YV1ZDbUV0YTZzMnpmUFpHeU1YVm5QZnpiWWdzWXhOZS9GRkU3cWl0eWlwVDZwUFNyaDVyelpSbjkxeWNwKzdiNk1BT3Jhbjkzcks2cTEwZDU5WHp2a1UxL3V1MzZYTWs3WmJ6dnNCQkRqUDJxa2lKeko1TDdyQTJ6a1BkN2thTCsxcFFuazFuNEFRUDdhQlluakh4N0tKMDIzU2c2L29CbnVLQTNsbXd5M1hqL3NCeEQ0YVcvMmVHM3JTanExcS96VHArbDFZN2U0OXdoYXZxVi9Gc3JaTUg5a1Z4ZGpGVlJpbjRMVWttaDNid01SdHBPbUJYL3c0RTBWQ2MvREJEdm5ibG84RGJ1QmRBcjdZMmJ4T2F6VmVzcGVnSDY2R3V0V2g1Nm9HdmU2WjRPbzI1eURWS25QT2Fpb2JNVG9BbDZWekRqcEhON1hEUjcvYVA1SnhZYW16bm1OcysyK3FTMmJ5SW04OUFqZ3RhcXV5UE1ieGg0dWEwbmZ4YlI5cEFYTjJyMXRyU2x0N1U4ZjdhNTk5blZyMjhoTkFBYVFyY1B1b2w0UEVBWUlJQ0JBZ01FQkFnZ0pKaHpZVUtIQ2dROGpOa1FBc1NKRGhCa2JHb1M0Z0lISGpRZ1BGdFNZY0tUR0F5Y1pqcXg0VU9BQmdpZ1RaanlRc2lMQm1DY1A0bXlvVStaUGhpUUxMc0RvRU9NQkFUVUpKQlhBZENuQnBFR1pJaTJBTUFDQkFBY0tDRmlLRkNrRXJsaTdjaFZRWUN3QnNCQ3dIc2k2RlVLQUFuRGxibzFiTjhEYnVIamxYZzB3bDIvZnVIc0JCd0RRdDNCZnhJa0JGeTV3bVBEandwRWZOMVljVi9KbHlKa0pBN2pNZVRObjBKdEZneVpkbXZSbi85T3BWYTltYmZvejZ0YWVJOCtHTEp2MjdkR1piMlBXZkZqeTQ5NkdoV3NHWGx6eGNlVEpBd2hZbnB4NWMrWEtuMGRuWGgzeGMrdlptMnZYdm4xNTArelZtM3J2amh3N2RmTHArNTYzL2gzOCsvY0o0SU9YdjFSQWdxWDI3M09WTDU5LzB3VGtRMkMvQWZzalFENEdCRUNnUUp3Q3hJK0JCQklja0FFRUlzUkp3UVFHSE1pcEJCa3dhTU1EOHhOQVFvY1NwSWdBZ1U3RTZTTVBQY3JJUTRKWW90QWtoRndreXNPTWlEcmdKUlliRWdnQmtISktxU0FoRStJcHBwUmVyT21nbll6NkNTUVVvd1NTSTVwTUtncWhpWUJLRXNjbUwrSkpLWlF5aWtsSW4wcmtTQ1V0aVNJQXBCcXZ2UElnaEtaNkw2R3drQXJLcTdIVWNpc3FQdit0RW11cHFyamFLczYxNkdLTEFMZmdLdXN1UmZPUzZ5MnNIQTNNTDBxdkd3d3V4b1pUYmdERUhNUHNOOElDY3l3QVRqL1ZyYmJTWUZOTjFkUllqZTFWV0cyYmJiZlljc010Tk50ZXU3VXpXNGN6OVZUZmdOVVV1VkdqTTFheDZjdzdWcnBqdStNT3VtZWpYVys3OGNSekw3MzJsbVZXMnVQT2MyOCsvK2FETDl5bVJBUnd4UHVXOHMvQkFKSHFUOEVEMFYxUVFYa3BETEJDQ0Erd01FTUdEa3BBM3dFREhyQXBFLy9GYjhUOENvS1h5VGh4WWpPaUl3VVNTS1dlR1BxU1JoY3ArZ2pJSGhHUTJDTVhtN1FJSXBpTXREakpMWk9NaUdFNEdjYVlveWdGV2dETUEzU0VNc1lod1hSem9STlZUaElCaW1sR21XV2xhRnk1SjZEL2lncHB6YUZJK21ra3BxSitUNk9wdWhvTEthN2FFZ0NzT09NMEs2dXJrdG9LVWJMSWRxdlFyZTlhTksrMXdZNExLNzBDaTJ2UnRvMHQ5amk1aXd2V1ZFOURWWXh2WVR0TFZkWlZCNmMxVnNScnhkVzFWMnZUZGJSZElkL04xcjJCKzdWeXk0blRkbHJvTnUvY09jK1JiZFk3YktrRnIvVDJvbjN2V21uTFF4MWE4Y1Q5OWp2eXhMVmQzUDRnUEppczI1c2FlTDkzQmNSUVg1dUVyeEJEREJ1c2NIbDZEVDRRNElIdzQ1ZDNxN0hNNmFrdGV6cHlJQU5nWk5vZ2oyYkVrbVNRKy9XWWdlNDU5aWhHaWM5WDBlS0JGcGpTZ0IxYitobGtLVEVpZWt2NW1aWjRwWm9SS1VreVk5R1FnSWF5TDVHcFJEU0JFMGFReEJMNHFld2kveEpjNEl5OE5MNmlVQXlBYnNvWkIrLzByN1BFU1Mxak1SVFl1Z2FvclNHcVVHWmJDMThPdFp5dHVKQlJNR1FPcEJxVnRyaXdCWWJOZWR0ZzFzWWN1NFFPY0theWpPYUdHRGpZU0s1d2g1dFY0cGJveENZbWpuSzBvcHl1Y25XcjNBZ3JjOEVLam5GQzk4WEVKRXRaMmRLV0dMdjFPbWRaNjNUUHFoM3I0QU90YVpFeGpLVXozYmZlR0R2NzZLZDN2ck9kOVA2VHgvMmNpNCtETkZqQVJuUXZRODVMZUIweTM3L3N0YndNMFN0QlNKa2tWNENXbEpFb3JDSHdLc3IybVBRK21WWE1lK2piMG9wUzhpT1lwSzk3M1F2ZktWM1NvdTJsVEdZVitkSEtTcFlpRitGRUpDVGJDVXlJSWorUVpPd2x3MFJSelNCWU1pOGxoSDR0bWYrWkxvOFNRUWVhREdVVUJOS1liR2xCbDhYRUtGSDZpRkJRMWtrbkthMGtHWEZLVXJvV0ZSR2laUzBpRW1GWldvaVdzbXpOblczQmlqejNSTGUrc0lVdThhUUxvL0ltbDBVcFNpNVltY3R6SmpWSFlvWHFpSlh6RFdVV2Vpb2xSbkZ4RXpVY0ZFOURPSXRXdERXT2swMnZaaVU1eUlYVU0xM2tJa09GY3pjd3BwUnozckpVNnBZbHh6TzJybmJWV2wxNE9sZFQycDBPb2VvWm8rbm1ZOGZlNlJGY2dRd1h1WUJISDBFR2NwRGcwVkIvM2xVaEIxVUlZQm1LcEljZVJDRUlBVTJyV3JWWEpPazFwQThSVHloUkFXZS9zaGVqRWkyb215SVpTTDlnUkNHWUxBZ21xZVFlaFlDV1B2UmhsU0RkUTEvOEdGWk5pZ0RUSlVpN3lFdi8xc1FpK3FXb3NNVjBXTTFtUmtCam5xeWE2VFBTQWVYS3NQb1pZSzl0blZsTmZqa1RuV2xwYURiNW1TMHQyeVV4R1MwbHdjUlIvTjdrTXpmZHFTaDhXZ3M2RXpJb0ZKNndiR2ZqaTFnTVpaWkJMUWNzZ1lyaHRIeXJGWHZ5cFM2Um9sUmRGc1Zjd2VBdE1RY0ZGdUFTVTZ5SDhvMXhyY29vRkYyVlVWVjl0NG9kMVM1dlFHWFNrbVlPb3IveW9rbzM1N3IzMHJHbE4wVWpHdGVJT3U2b0VhZmhpVjIxc05WZnBhNVJrRWFORCs2VXVpNkM3U2RCZXlRUVVvMlhKRWNxU0tvR0t4NGtBL2JJREMxUHc5alVLbFcxZWlhQTBXdGdLWUhYa0U0aWt6SEJWWHhGMnVWY0VjaWtCVWpzWTNtbDdDcjdKVEc2THROanEzVVpSMnJaLzcyS2NheG5GYW5KVFdhaVA0bkVaSmhtMVJGSlZybktIYUdvZjgyc3lmOE04S01ZMHpoLzNadW1pNStKRXArMGJFa2xNMmFUY2RsYWpWd01Td3dab1ZtQTBpZTFpTTBwY2U3YUNha1NUN1ZjWlo4UU9KUTltWU1RM3U2Wm40dUtHMkNBdUpkKytpVnZrd3JpcEt3TEtpUm1OOUljUlpWRXVkdmQ3V0wwb3BaR0RVZzNmZEhIa2RkeEhLV05laDhOVVZPUDJyMWZaS214eE9nc3p2RlVwck91YjM5bkp6dlYyVHJYZXdTcTdkUmw0QUVUOWFnSVBpcUFnaWZpKzFoWXhGUU5zWVU5bk9GSGJsakRlT1VxVjFVMHZJRU5xR0dtbllqOWJJSlZNcXMySkVYKzJZS3k3QkVyMnhoOFFOWXNTSENjdmlndlJONW5Nc2duWjJSQnh2KzZhSUFXTVpLU3VDay9sNngySnZKYjVma0lIbVdheUsvS0h2T1lpMnljTXBFUkdVd05KRmxCRkVzakNGYmtzemRTVTVQQlhIRU02a2xMZEtMYStNaFNFOXZpYVNuRG5hZWZVcGdVR1hKRlQzcCtwd241b2hlOXROQXZCR1h1M1A3WjZKT2lXbTlCbDNUUkE4ZnBUMyszY1U5TTRoVXJuWFR5RWs2a0hrMDE1dEpiOVdGZE4rdnVoUyt6eWtoZjlaUkg3TFhHNzMxbi9kTTdsaDJwd2dhdzdYb2Q0TFlqZGNISFJsZUhnT2ZIWXlOb2VCRktYaUtUcDFjTU83dkRDMHBBQlJCUWdRZ2hIbWdWd0NyakFWL3RSOHFyS1hPRmtUYVBoRE9NazFsa0dER25tSXBzSk0zYXhFWlNpckZmQWU3d244V2IzOW1qVVBqT1I3OEM3aVQvbCtXVHBVbUlNcVg2N1pqaHdGeVFCQmp1TWMxZVdhOTNaWGhpRjJSOGlLZU0zRFdoMmN3T012dVJ3RjZDNVpzWlVReUw0Z2k2RElQYjl5QkVPSGsxY3BxODVBVUIyOHJ0K2NKMXRnVnM4YVRobnZiWlQwSGI1ZWVJUmd6UWk4amVvRTk2aUViL1ZLWmxaVVdsZ3pxbVc1eXBrNmhPKzZqL2l4enpDZzcwU3JVdHNwdjJVcWxXODdxdlN4YWJZaU00bWkvMklMdjlVcnZicWJXMUl6YjV5S21rRWpDMlN6djRVQmY3MExzUVFSZStTeEMrazU1amk1Y0prNUI3Q1pEazhiREhlelpwSTd6RGd5VEVVN3pDNHhjR1lEeXUwaXNQZzVjTGs2QWt3eXFSSVJwYnVoTG1tNGtKSXJKbHNpc2pXUjkwVTU4WjRUS084U1cveXBuby96c2d2cks5b3lneUxQdENBOENmNkN1bWp3aTkwTnU5YXZJWXc5TXNDZWllTzZ5QWdydXlLd08rNHFzZlpFbyttbUMraEFQRE5MTzQvR0VSL0lreUhUa3hvN0dmak9zKzJSckVreHUvcTduRThjc0ttUnMwdHhnVXJ2QUtuNnNPbG5zL2Zyb2hsZ09Md1pnLyttdXV5N2t1Qk5RL1N1Ty9wdE0wQUhTaVdkUW9CN1Ewd3psQUF1ekZVbXRBa2tLaUIxeTFyNHNqOVBnYzlMQkEvZUlwUzJsR0M2d3ZuNktwbWZyQTJBRkJCdU8xYTd3ZC80Z1grMWd3YjNTd0E4bTcvVEFJaExFWGZZRVFkTnlYRG1NOHd5dkNmUkhDNWJHcklqeThERnNRZTd4SGZKU0FlUncrQzJtckNldTJCdUtxbElrZlo5S21NSmxDb1FFNHpTSStaZi9pdytMN2tZS2prUFJ4T05JamtwQ0pzcm9TUHZwaHZqNU1MSFNMbWRYYWtSMkJ3NXRRdU4rYnc5OHpBSDNFUStCenlJVU1QbnMwU1dUQ042RnB2c0VxTXdJQ2ljRktMSWFZbVRXcGt0SXFMVnFLa2lqNWlaSFRKSVd4UkhSS09aSmdDdHpLQ2tCeEZLM29pN2RnQy9ZalJhejhvVk5zbTRDeXYxUzhGSzA3RHQ0Z092M0RvcUpMd05VSXdLVkRRUERpbFNzU3RhdGJ3T3J5bGZ5THkyQWt4cGN5Umd5VXdHWVVuV29Vc005NU5Xc0V0bXcwd2NGMHNBRHpENSs2TlFZanNQbFlzQlVzdHJ0ekVIdUJRWHd4a0FlSkVBK1JGNjZxZ0NDTWtNUURQSFpjUEhzMFBNUDdRZFRVdzlJa1BNTWJRbXRyRU9ocENWM0N3cDloR1p6L09CTEEweXlIc01LMjZrajBDYjRyb3owUDhaRUJvcEdKWWNLVm9iNDNCTW5FaWpLZVpDWEVFc25qSTdqaTgwT1lCRTdnQkQ3MGVVaVlQSUFNcUJsYVlyN08yckhzNUwyWUtTWXMrNTh2WkpLOU1xWXE0NllxU1NiN0NZcUNxRTl2NmtrUDZwT3B3Sk13T2JJNjZ3cHlncFJJT1JTd1dJcnlxdzREVFJ1eHVMbFNITVhrSWlqNFU3VDYyNHVlKzBwUmNhaSs0SlJKR3pxeWxFVzJORXZCMmE2SW1weUtFaW0zZEV2UmVNRDArZzJHV3RHNnBFc1Z4Y3ZFSUtpWWdrWldjMFk0eXErL0JKMDVhcDArS2t4YzQ4RFlvVHVqNnJWcExFRnQ3S053dkk5M0lTcW5PcVFPS2FvUTZSZXVtQ1RRTkovUGhCQWpGTTFxTTgzRDgxSXcveldBMHh6VENsRThvTEdnRDRQRWJ6c1NtR0JQbTFpUWdWaVIzNU5JaWJ6SGwzekk3ZXhJRkRHNEt5TzlqYW1mWExKVGh5a2dtMUVtOUhSTzU2eXJIZGtZK2FuT2Rtdko3THhPUisxSVBqd0FHQURQSGVFOVlLcVpTRjBtVFZYRUFsckRVTjFOcGhGSjE0SzlSbndJbzZSUCsxU2EreXlKcWpFbmt2TlBvSnhWc2tLVVEra24zV0s1ckdtS1U0U2JlR3Fock53VEdaSy9WWnkvd0lCUXVTaU1VbkUwQm15djg0TEY4c0lvVW5zNmpkcW90SXc2RWtYUjBNaEZ1bVRSazdLNkdHMUZTSk5SMFBGUlpJdzFIcDJ2d1hRMXYwUzdBb003SUozWEpHMVNldjNSQXh1WGVGMFhHQ3dZRVVsSENER0l6RndLRThtcURDSEhyQkxZeXY4c3ZIMVVLM3hzdkI4RTA0Z1YwNGl0MkhoMFdCVUxSRGw5VTQ2QnZkY0RQTkxhQ1lkZG1idDZUaURwU0Q4RW1lQmIxQnZMcS9NaE1ueTB4MzNiU1BFa1NNRUNtY2x5MklYa1RqN3NXUVBJQUo5MVZBVHdQWlVFMnFCdFRwRmNRMDZ0bVpHMHprbk5yS1JOV1NCSnBWUnlpZCtqUHZvNXc5Q1NDWklZVG9ORU0xZjFUN0VkUk5CaWlLV2NDVUZCbTZROE9VMzhNMS9GczBqQk0rVnltK2NpVm1GVkxvT2EwTGJKbTdiUlVHZkZVQzBLUzdLVVZzTjRTN1MwVmszenhXc05OUVU4dWxZTVJuQmRyMkcweThIbHk5RnhxWjZhd0I3VjBYYjFVZjdDdFhsMVRIelZWMkxyblNZVlhhTkMzV0hUSXdLRHdmdUkwaEFKa05nbHgzai9vU3JwMFJmSm01QUVBMDNiMWRKb2M5aDdOTUlNT2MyS3BWZ0pNTHpqUlUwZk5KK1hiUW1ZdEt2MCtUQ0pvYkVuYzFuYnhDdFZhcjIxZ2tqeTFOU3BkVW50dkVPN0lyZVlkYzdvamNtQVUwK0M4MGQ4N0Ztai9kbWV2VVBzekFDaHhVNm5sWjlMQmFZMUJMNFlvMDd3bGRRMXZMSk1iYmZzZExHZERNTmJTcTJrQlRsSkhEa0hwaytteENDbnNCTkM0YTM2UERuZXNVcE5YRkRuVWxaamRhNFlpbHVmZzR1YUU0eCtvcHNnV3NWbEhWZkNKVnhzZGJxM0RLL0VWVXRQZTBXNHpDSndGVmNXZmxZZVJpa1pOU05sU1ZlL0JEc3oybEUxc2k4VHBNYTN1OWQ5RGJiRWJHTFJkZUlvTGt5OTh5UGVxWTl5U1JjRTJlTFlaZEl1LzJaUzZTa1lkRUcyQllNa2U1RVhxaEl4NE4zSElGd1EwNVRZb1QyOG5TVmV0NnBPR2p1KzlzVXF2dExPSjdPeE0xMFJnRk1yRzRQT2I0dmFQU1JKK1QzYThiWEhuZDI5UEwzSFg5b1lWR3JVN0hVcmlleFpEb2pmbytYRDkvVlpBRWFBUzZXZi9nM2cvdTNmbHF4Zi9tMDRqd1MrVEpVNFh4cXNtMGpVS3B5SmdHeGdXODZSQmdaS1dGMnorc1FTdFJnaE9jRWFWQlRGcHFpSzNpS2hzQ0ZGdkxVTENQMmhIT0loSUlybXZvQXVVcG5Rc1BSUUZ0Ni9UUE1vWFV6Y1dGRkxVTHZoeVAzV0YvWFdIdGFjdkFSaWM4MWNKUDVjQS9OQUpDVk0vMHBTdGhOQktZN25LZFlqb2FKbmNnR2svNERCMmdVZVBWb3djR1JTNERGWTIvK05GN3ZieklJd0hzbXprQnhzbnRkVll4NWtXSGIwVEl6K1VqZmU2TjZ6V0RpbVg0cTF3NDNXU0sycTVGVlNwcy9EV0ZlcXc1YWxzVWNXNmV0c1drcTkycHp0dytxY1ZJWkRrUnVUTVZGVldaLzlUWis5UTZFV1U2TDJaS05HV1ppRTFCZzc2a2l0em9ORGFrck5MRVkrdm9BYnl1YlUydmdwR3RqU0VvcExDSi9jV2lta1ZhMk9ZS0hBaUlQUnRrOWMyM1lLWWVGeVc3aVptK1lvdEJGdUxndjl5bU8xNjczb213N1ZJdjc3TkY4TVFIQm1EVjRrTlJLTlViR2NYTDRlM0J6ZU9uZUZxV1BrUzFwRHV5V2U1Mm1jWWdZekhYdXVaeWJXYkhsbFhlb3BNSHNWcXNnVVI5SW1YYkxBUWVsNUh0dVZQSUwxRUt0Q0NrUHlqd0wveVpkQzBtSzdVeVJwNHhkMjFFYzk3RzNOa3Rqa3hXamZrMWd2SmVyVURMN0g4Mk9Kakt1WUZWUkdwbFBpSSttcDVyMmtibXJxOWwraEZWcEtWbVUrUkpHZWRZQXJBMjlQem9DaHprTXhCV21tM21Tb1RtOVAxbTRDVGl3K0pEaEp4V09ETzA5UjdzOHFNMVdKZ0syZFVZcnErekphelU4N2l5MHVlWXBndmhvKzRRdGlOaUVPNWh4OW91c0hsK3U3dnBURytLZGoxZXVIY21IRWplRWxrbUVtNG5BWU5seEtRK2RPZVZHN1hFQng5ZUVnM3N0MXJ0R3prK3dtYnFPNG85Y2pCVkp5bWVMVWRXTGJJZWloZXBkOUJ1MWlxK0lUUEplaWVoZC9NYVNBVFhLQ3RSb1pEQkFZeEVFYmRKY0xNeVRZUmpaOFljZCs4Y3ppN1QzRC8rT0FDaGh1NGNib04xNFFEaGhhK3BYajQ5TkRqY1JEQnZDOXJXTHVxWjVxTXFXMjdCVlQzbDd1UjYxdVI0MHhTRTFxUjVWZm9zWE9wV2J2OFZaSkNTQnZBOGhrNCs1a2xmVFpUdTV6UGt6a1JrL3ZsaVE0K2M0cytNN3U1dzA5VFA5cUcvR3NxVDB5Rml2VnpySzloZ3VnQnhhdDZoR25WalZicjNBS1YxL3JGbUlMQXQxYnFsUVVlTEtoQ0RWV3NHUTBDcmZyRk5hVURNZm15S0NNVWduc1MyTVZFeFhSWG1UY1ovVU5GQzluRnpWc0ZUOGpZeFJpdkl6cy8zSzczcWtqQU12c29ocnliZ2ZkMGkzZGVQNVJmVDUzaGRiaTFUVnlNQTdIY01UTVFNb2p2ZHRkdlJ1WTJMMVNjb1FLSWtGajRxa3E1amtRWll1azJVWnkwdjhzd2lMVWN1VFZhTTlNM2pJWDZqemM2RG1uNzk2alZEME05RHFkdzZSR3d6alh4NUtHWGp5Y2RLQ1dWRGRmMlpQOFpLYWVWRUkvYXFORmRLQzlRd1FBYVk5aDlKUlBiMG1YOVBZTzRKUHRRL2srV1Q4OHlVYjlTZkw4UTZhRmsrckQxRklsTW93QXBxUEgyZHU3dlRTclZRK3lHckp1MVJHQ1NnbkdrcWpZU21NbVAvUWJtNnZBaTdJWUxnbjk0TEx2OVV4WnRPZ0tEQTA5SXNJOWRzbG9WczVvRE8rQ0ZYQWVyMWg4bkJaZWJMbGNiQkpQNXhabjU4akdSbjI5STVxNjV4T2t1MnljN01LUFZ4dG45eFRNNHRNT2FIbXZZdGwxY2kxMjk5M3B4cU55WGQ3dFY2aktLaXJsOStlUmtPR1JKTUY3dG1UTHdXcEx2TUxUS2pEL1JWNHZQZlF2dDNPVlJJQXlYODA0WmppaTlUMmk5UmpmLy9tYlhraU9GTlNYek03akN6NllEM1NIL1AyWFRDWHNYUGtyeXdEaWpYNVBGbS9zWjJwQVAzN2dvM21XbjM2Yzc5bWhaZXFsNW5PVHhHNUtUaVg2NXZUQXFpWlE5eVdtZmF5U2dYcW1GVThnT2ZvMWRLMUNWYmcxQVFnRUN3Z2NJSURBSU1HRUJRa0lLRmp3b0VPRkNRc3NoTkF3WWNLTEJ3UVFLTUF4d0VhUEJ6eGF0T2l4QUFHUUFpQVVDTkR5Z011WUVHSzJyRW56WnNzQU1YSHF0Sm56WjA4QUFZUUNLRUIwYU11alNvY3lYU3AwQUZFQVVxZE9IUm8xYXRPclZLdHU3ZXFWSzlhcVRhMlNaV3BXcUU2MFR0T2VaWHUwclZ1ek91ZlNwU3RBNTEyOGRmZnkvKzI3TjYvZXU0SUREQzVNV0FEaXhJb1RIMGFjWURGandaSWhVM1lzNERIbXlwbzNYeGJBb0RQSHlndzVkODVNK1hIaXpKZ0pvRTZnK3JMcjJMSWZmMDdBR3ZMcnpBd1M3S2JOMnpVQzNneUc3MmJOMENDRDRBZVNDd2llM1BYejROSVJmSmFlWVByd0Nna3FNT0JPdlFJQ0JPREhJNUFnWHJ3QjhCTFNwdy92SHJ4N0JBYktyNi9BWHI3OTh2TU43QTgvWDM1OC9iVW5IMzhFR3JnZmdnTHl0NkNBQnpMNDRJSVpSR2pBZWhRbVNPQ0REaXlvb1FFYVpzRGhneEtzSjJJR0VraTRJQWY4cGRqaGhnYWNPQ0YvTDdwbzRYb24ybWpBQWpjdUlCQ0NBQmI0STRROEVxVGdBUXNzY0FBQ1JTcTU0NDRHSEZDa2ZFc2V5ZDhCVHY5YSthUkJBeFZKMEVCWkV1QWtSZ3dzRnhGQkZ6VVVFWm9ZRWJBbW0yZ3V0TkZHYTRZR0owTjBOaFJBU2lITlJCRklBZXpwSjA4dC9XblRUamtOMEZPaE8vVmwxRmh2S2VVVW80YzZhdFZYVXBFVkZxV1ZoblZWWEphdXBWWmNjRDNhNktTTmhncHFxWDZwdWlxcnJmS1ZsMkd4RWpicllMVGFxbGhqbGlGMmE2NmFOWVlhYUsxdE5wcHRpbzJtSzJpVzZWWmFhYmZWNW15enRKV1cyN1N5OWVZYWJKanR0cTJ3dGdHYm1tZU9ZZnRac3JWNXhocTN2eFVYM0hXMk9kZnVidE8xUzUyOHlRMUhiM2ZuYlFkZXZ2bUcxMjk1OEJuZ3IzZ00zUGZmZlBDSlo1NTVGVWdBWG4vdW1WY2V4VDlXak4rRlBoN29ZNFAveVpkaUJSTC9JbkRqZ3l2T21LTEpFQ1lvZ1lZY2NwaGlpUkt1YUtLSkZrWlk0WTB5Z3ZnaXpEUENnT09DNjhrbjQ0d0w4R2YwMFJJYWJTVFFSejk0SUFNTFJGMGxrMDhleWFQUlZTNUlZSlZGSHZtMVFGMWZtYVNWQkdqNXRkbGJSb1IybW0xTDVEYVpabWUwWmtFTnpjblJRbmh6bEtkTk04SGtrNkEzRFlxblMzZlZaRGlpUUNXNitGeU1NaVZwVGtXWldoUlJqRVk2ZVZhWFBxcHBwbHFoZW1sYlM0MFZldWFiaW1ycTZKKy81U3JycmYvVmw2eXg4enFacmIzMnVtdnM0RUwyYTdLa0xYYXNzWWc5K3hoRDFFcTcydkhRSWc5YnVKaGhteHQwc2FYYlhHTGM5bllaYTZnaGdCaTdvSkZyMmdHUGJmLzhjOUpmWjFsMXpmMFduUHJoLzF0M25iM1NKVGV3Qk4wOS9KMTNERXljbjN6ZHBjZXZmUWlHSHY3TmgySDNNUTk3N01PL2hsRk1nZXdCVW8rQ3RqV2JJVkJCR01vQWhrYWtNZ3E5cUlNemtoRFJacFFoL2pTZ1F5V01tUUVhSUtFU0dvQURIbW9oakNpRU1oZlZUSVF4QXlFTVNXWkRsUkZ0YVFzeWt0R0lKcUVLQ1kwL1VSTUlqNmoycENmTnAwa000dHFWdnRZMUpFNEpTV0pUMjBEWXBpVXUwWTBBWXRyaW05NG14b1dBa1NBUnNWdWNFRk9uTmU1TkFBWFlVK0JZOGpjLytjU05QSUZKU25LU0VzTDVCRkdKODJOT0NqY1h5cDNGY3AreW5FNGtoVG1uakdwVG52b0twVHIxcVU2bGppMmx3NVRxS0ZuSlVMbXVrNjJyVlYxa0owcGFMZVpXdWhOV3NQOUs2YnZPa0NzeG8zbGxaYjdGTEdxQnkzak5tK1VzbnllYmFlRXlsOVpUVi9UU0pUN3FMU1o2d0puTnRLNFZML090RDF1M1VWOTFxak12ZUZFbmZ0Y1oyTURFazUvdWtPYzhDUFNQQXIranYvQk1iSUFGMUk5OUdFWXhEanlzUk9saDRIbmFZMEFZMWNoaUd1UmdmVXFFSDVHcHpBRkU1SThHVVloRGQ2S1FRUnlxWjRWU0NGQVlwb2hsNjlFUUJ6TEFRaFZwS0tFRWRkR0tRT2hRbWVYd2d6ZlRJWVE4Q0NHa2JUQ2hGcnNTU3BrRUlDY1dTS1ZRa3FLVHJ1Z2tLalp4UzFQNjJ0U3llSkNCR09CTFkvd3Btc1FFMUlhSWlRRUlxVnZkOG5TM091R05UVzRNVGVENjZCTUEvSWtuaVZJY29SWjNsRVBSSlpOb2tVc2lGMG4vcWtaMnBYT2NJNVZZSjdXV3lVM3ljNlJENitvOEtWZFZnZEl1czd0cnJIQVZHRjJoc3ErNEtpWmxpaGVhd0s3eWxMY3hUU3B0cVZqZU1FK1hqWDJlc253RFRHRnVhM3FkMlo1aWhQbWIzM2pHV3RKenpydVd1WnZtVk1jZ25yRU92WTU1citnWWJIN0pPYzkzQmhiT2hPMG5uUEc3RDhUVVUwQURDbzFoRldBbmZmRGpUZno0MWtVY1N5Z0M4NVBPaFo3VFpnbUNrRDhYV2srT3dwQ0RNWUl1em9qSUlSUTIxTGtubktoekpiU3pHcm1zbmpSOG9RaXRPNk1haHZTSE9KU2d5djc1eFBBd3pZZEdvaWxKRWFRMW1CYkpTVk1LRzltb0ZqYTArVmRxWDBPYmdhTjJWS0Nha2NGd2lzaEJJQUlSb1lZRWo4ZUpFMFlXY2hJNy8rWmtjSDhTaWxRWlI2ZytBakltYXgxa1V4eFh5YlplY3F5Y08yc2o1UUtxMFlIVnE1ZzgxZW5jT3RkUDZtVldQZ1pNWUY3Rks3eWFzcTZrTE96dWtIV2FadzRXeWVKU0xHNVNhUzdWeEFaN1ZSN3RiSmc4RytINDVwZGVKczVtbVplWThXMTJ5Mll1Yy9uS3JDN1VudmFZcVhVT2NhcUpMem1MOHp3VmNCakZxUFBOZDNLVE9qUUtqd08vMlZ2cDRqbTU5VGtQeU9yRFR2UG9VMFhNblJtRlJsUWgvNWgwZy9ITm1ZVkNHRU1LdVl3LzBVWHZETm5yVVJwYUtMb1hKYThNR1FUU0NXSDZSQmJkV1hvYktpT2FiZEJnR0xKMDB4akVKQVBBWUdsTEVqQ1ZjQlFsWVFNUnAvVTlHNVlTRENhSHdBMUxjTXVJUXk0eVlUZUp5ZjlNZVZNVG16cnlFUUxNUkhBeStXTlVyMXJpRVlQYkphTHJLbzFSakc0V3Q3VlNadDNLdXg5cHVrZVdEcTVpZmF2bzFKcHVWaGw1eDZIOE1aRnBOOHJjM2M3Sm00R3k4M3FYR3VBOXMxdDhWUmJFdmRXODRoMFdzaEwvakRMVmJENTArUVpkbmVVNGRKaDNyV051eHpYYU1UTzduT09aOGxGMmZkc3JIMmhManEvVnlyazdOdWZPbmZIbk1QM1pxMzcxb3hlZ3hka2VCNm9uUC90ano4UFd3d0g3WkZwb0ovcXRpRVNrYXVOZVY0SWdhaStNaHZqRUZHbHNvUm5jb0FlMzIwOGIwdHJUWm1lUlJhL3Jhb0IrMm1ZdmZHK01zc3ZSZTdwb2FSTDZXWWhtRFYxTDI5ZHB1VVphMW5Ba0liRWwwVC95V1ZvU1lRcEVnWUJSU3ozL1JYQ1ZnTHEybjRwUklobDI2dlpnR1NlUEVBUWtKSEVqSHZ0R3VEOE5qc1JBT2YxTlVoOEFSWjY0VTVkamQxcmZIVzlIZ3FWem1vdXhwK0JhcWhtN3RmZjJibFcvL1QyWFdnMmNsRVFPdU1FNXM3d3BUOXg1a0kweVlGVWpXSVN6MHNyTm13MjNxbzlsWXpJVG1SZ1AxMmd4cnZHUkwvUE1zMkhYdHRvTXpNMXVLK2FzOVE2L0huWm5BRDRzT1lXK1AzNENDRUNiWjVOQzhXbmdBR1hBbmFXSEFMSUhCNVNITzRuSW9ra0FPNVZJMUQzZ0ErSWFpN1RJQkdKZGhhUU13NERReU1nSUJ1SE1nOEJkRU0zSTFYMmdvNldJUDUyZ1FwVVFDdzBVaUVUWFJGVlV5N2pJMjkySVE2VklDYzFRMWEzYUJUSklwVzFRc2VGSTN3R04vdzhCVFFiazF4Q3FGQlVsa1g4bGlSU0JUVUZra1VQNDE1Q2tEVVNzaVVENGxFMXhVVUowaWR4d1lacDBVUmN0UkpuVUNaN1lUVW1rQkJyMmtVa0FpdWt0VGh1MklhSVEwb2tweGV1dFh1eXhXS2FZMWUyVjFZdmhuaVY1MWVtUWp1L3RtMXpCU284Qkdlc1VYMTRWeHNDcGt1NGtuMllzbi9WTkdUTFpFckZFSEM1SnkvY3NWcFdaVC9tRUMvdUlqNXFsUzJoeFZpaE9WakJwQjdld1MyeXc0dm1waTVqQUR5d0tSMjlzaXlxMkM4NXgwL3psQ3p6Tlg4QWtVQUl4a0R3TmtKMzlId0FDMXdFaXdBRWVvSW44VmdzNWpBSkczYUpOb3pReW9EV21IWVM0a0tjOWxITloxdzdPekJDdEVFWXBWQVhXak5peGlJWWd6Yys4eVAvTFRNaDNkUWpMTklBRHFHQUtRZFFOM3FDRk5NQjZzRkFNNnFNL1pjQjdiZGVJY0FBTHVSQUQ1cUNMd0oyRnlCb0ZTcUFETElDR3JNQkRQbVRUQU40UCthQVFCb2hLWmMwUy9kclZXRTNYdkpTWFJGNUM5TlFUY3RFVzdZaWFaSkhjZEpHV29BUktnR0ZCb01TZHhBa2VuU0dlbUFTSHhjUWN0UVFhdW1HNXBSNGNQZzVTcEFybXNCNmp3QjRqeVo2bWVBNVY1Q0c5cmRWWExTWG1WR1hyQ1I5V0Jwa2lCdHpzUkViQk5SbFlRZ2J3dUpJYUhZOWpIRlltSmxhMG5DWDJDSS8xNFJMemhRdGFab3YwZkZ5WnNVYjNzQ0w2clY5MEdCTmRnaGwzc04vSnBSbkprZHpKaWROcVZWWmxzUjl2Z0piTjRVdGczcG5OOVV2UzJRZi9Nd2JYL1R6TU1KcFRPTVVIQTVuSE1pcGpBYklUUThtUU5TNGdOWjVtTkY3akRsM1h5TlJNQXRvTTNLRlFqWmhJQ2UwampYaVVpZHhJQ2NVZ3J4R2hSN21UQ0psZ0NwNWdQRGFBUGpJZ2NxYlFoOUNNUTZtZ2h2U21QZzdVZzl3bWJpYVV5ZGpJUDM1Z2JZcGppM0JqQmFZZ09nTE56OWhYRWY0UWo4UklFR1ZOa2lqaEZjR0ExVEFlMWFRVXNDbEoyTVJuRnJMa1Rxa05sN0NrbW16Sm1zU2s1VEZWbkpRaG40ekVTalFFU2ZTSlZObFJIdm1SVUFLbDZxR1lITmFZak4waGhtNE9XSGpGSGtZbEgrYWVwY0RGdXBVRkhxNFk2R1FsaWhvR3dJblNWaUlpSTJyR1dJcUdHdFhTS1ZrR1dnS0x3NlhTYlZBY0ttM1ArRURMLzR4U2p5aHVtY2VWbi9vOGp5dUtGcGVkR2ZrdDVuQVlVM2VRM1B1MGk4bHR4M05rQjVnOXFjMVY2VzZvWXAzZFhIYmtuTCtvQnpxOTAzSkJqR1lXR3NVa0hXeU54Ly9Ja0RLR1ROS2hadFFsWjNKZUl6dmw2WjNxS1ltY3pFSnA0S250NEFldDRFQ2FXajZTV3MrY1VNMW9ZOHV3akFUaGtFQ2VpRUZHcDBTbGtBcXlERHVwb0VSdHFncVJrS1hDWTIvQzR3bE9xa05Kd0czcW8wSTVhcWMxWjNwTklIb1pWS1cxNE5uOTBBL21pTkhnbmRQNGtIc21TUkVPNFpMSTUzMFpEVTBKbUpHOEZFZ3VvWUZkb2RXZ3BFMkJrYksyaVV3aWhFSU1Ga05BQUxlQlhvS3VZWWoxWklsRktJUXFUbDJBaWlMOUlWMGs1Vml3WG9hZXhmK0cxcDY3TlNXOFJTWG9xTVdOb1lXaGxGaGNvU2hkY2VVb0lWOWo5R3NqQm1sWUFtejBCUThtdGthTU5obGFqaVdPUGx3bWJoa3huUmxEZklaeGdCL0ZXbHh0ZU11NE1KYkRtdG5KeFlZcWFtbVUxdUpnOG9ZcWRxeGVUbE5na215WDNod3VUbFBONVdMK2pJZjk2Yzg3QmN6U1lWQi9PTXlkTVl4dkNhRDgvUmJRenAvUEtpT3RYYVBSTHFCcVppcEJKbWVlaXNodHVpQ05WS29OT2xSMXlZd0swWXlzMGFOd3hpTU5mWWlMS0dwMEtoUUtWdGVrbXVDazZpTTl5cU9wem1NOE9wUUR1QkJCU2hUYzlxYUl6Q04wMGkwS3lxUGV6dU04aXFjL1ltcDBpaDFBeGtpbnFSM1Z1bHFsRnU2R0dNa0tNSzRRNWxwRlhtUjVDbUgvZlhsTmZCN0p6MmpOZkZKTlRqWGhyOFhVNDExdUYvcVVnZldVR2FFSlJXUWI1WVZSUjlETmdmTEVuL3lOSFExT2hBWVM2dEdFNUxnVlY2a2JoWnBiVWFhclduMW91MExTVTNwb2h6NmxwR0JGdW4wVnV1RXJ2K25yOGYwcjd1QU84aEhzc3lpZmpnN3N3b2JHY1hBdlIwaGM4QmlzV2I0R1hlNFNacmxpOUJRcHhxb3ZMMTBzeUJuRWtITHNiSFJzWUVZcCtxSGZ5QWFIZGt6cCs4aFB5WlpjeU43WmR1anZhMW5wbk0xc3pzMmZaT3BzTi8xZkFScVFBclVUMUQzTTBpMGRCZU1aTXk1a05EWnRualp0QTNBQUNLT3RxYTZtQ0tQcW5rcmRwRktJUDU3STI0WnF6V2h0Qy8yajJ2YXRxWDR0TjZadERXK1VRVlpxcGFvUS85cUtiUXJHNHp3dXJVVDU4SWZNN1JFajU5N0tJOXkrTGQveUxYTGFyUVB3YlQwQ0x1REtvSWtZWnd4cUZBY2VsRzllSFllc3dPUDYwSW5nNmdmMkhSQUJZZUNsVk9RQ0RkWW9rZWQyemRVY1Nkbzhub0labUU5Um1CbHB5UWFRaWR1QUliZDF4RWprQ1lQQzdsMzhKQnlDNiswU3lxR29HRmlONkNBNWpya3FwWXV0NjdzNjVSN09YaDgrVGxTZ2E3anlCZk02TCt4QWI0c1dtYi9tRHNFQ0QvZ0tyR0tnRXJVV3kvY1pSN0YwTHkwelM1QWFUMjE4ajJXZ0Z2UXdrL2g1WE1nVmg4VkpYR01lVS9hWTM1YjFobmFVYkpwRktXTzZySlJDOHpKelU1VENiTUg4aTNqQVR6WHQzM2drTU03NUZtekZSOGdZblRLdTB6aEhtdi9ESUMyZFJocWVKbTBIbnlZSUUrUUl0L05wM3FrSVoyb05YKzA3MmlZK2lhT3FBaTdhS3JFS0d1VGR1bTNjZnJEZEl2RUhxOURTTGpFVVF6RkIydTNlTnZFU1IzRVVQN1FVTndBSVZEUkdyKzFCTzBBUE55YzlOdXJnYXBvTml1b0lHWUFZQXg1Rml2R0o1SmZhcmVkNXFtTkdFbHV3RWR0S05SSGcvWm9jSTBrVm5VM2E0TEhwVHQ2V1FFQ1hQQnNnbjBUcjlzbUREazVLUE5WTU5IVmRMSEx0aHBVajcrNWVNRy9rMUNzbE01SWwwOTRsdSt1TEhjb0FHTVViUGNYcVNjVWtmM0lvaS9LcWxESmNtNUsvMmdyRHhaSmIrazZ1a0Vzc2U4dkVTdXdzZSs5aENkWXRhV3pDT1o5cWtCbTN5SExFcGg5akk0OHN0Mi82S0JQL21VSFdsTW92eVFhVFowWEhOUFB5eVg2SGxRcndOTy92dk5BTHYyQ3BMdmFMbXhiZDBBRWFCb1dtaVpTekFNWjJvVG1nbko2bWFkNnAweWF0Y2lwbkJ5dXRQQzgwUWY3MkNBUDNRZy8zRC9kbVJEMG5FSDl4Q240SVFLclFFYmR3REUreHFrYVVEL090Uk0wanB4YXhFczhqQlFoMGQwZjBkZXV0M29JQUJUaUFDR2kwUlUreFExdjAzckwzUSt0dGRxdVFFeE5uNElxdGg0QjBoM2h0UXM2cTJjVWdSTElJREV5a0NGa2tDTjJxcmRvcWVWSXVFR2Frc0Q3NDRlRklmM2xrMk13VWs5QXhTd28xSGorSkhsdXI2elliUWRDa3RWSUVWSzhFSVJlb1RjeFI2Ykdob3J4aDdyWUVWMEVPV2hPU2pDTkZYZFI0alN1bDhCSXYvNDgzNWFXOEVaQ3pCSkFIZ0FjOEJTVzd0YXNRM3lHU01sNjlLUFZLeGxkQ1lpd1Z6L0FvdGx3Q052Y3VEMTlqUnZnTTlwTzE0bVZwb2x6T01tTjlINWF4Ny9pQTRycWcyV0ZmUm1YTHI1ZGRodldFaDhwNmh6WkRjNWRXS2N6TzdIY2c1bVEyekdQQ1ZtVk96QUVxa0FBdVl3YUU1Z0hxMHppWEI4cXNaZ05HR2o0cm9ENitzNlhIODI2WGNIQWo1NllUZDZjdjdhWnZ0eEpMbEVIWGQzMHp0SGJUdHdzQjVITTNNVVhEOTNxUE4zalBlZ044OTNyYk9oMGdaNjdMWTNxTEFIcVR0enpPNDBhcjk2Nm4raFJEc1hyRHVuYS9iYUtEZE9EUzl4U1A1eFpMKzluNUpncTRDQXA0TFlHTDE5VFo2bm4yMmdMMDJua3FUYS95bXY5Rk1namhwYkdVS0VtdzdWcC9aWkhSbUUzVXhEc2RPNXZsZlNHQVJnUkpFSVMxTW5WSmNJUkllRnU0RGZ5NHVhSGtOUEtNMnlHTjIzakMzL2p2NXZnaTdmZ2w2Nkc4Z1NnbFZVNEJQTUFHUU1ER2Izd0JsRFVFREFCTERFQlpsN1crZ1ppaUlQbncxWTVmRkorUHZZNlRMMXhtTU5uQjRVYkNlcStadzRaaWU4c3ZsL21ZVzVtV01zdjMvU2hzc0tKamhFLzZ5Z2JTZTF4d2NOeHBuVXZUUzB1YXM4K1Yvb1lzSzZtWGJkWXR4c3RlMXErWGZqWnJ6WXU5NE55ZXcrd0NVek0yUHlhWkZpTUVkMHdFTHhvTTBZdzdOVlE3bzZvOGx3ZytoL0E5TTJCd3gvTUhienFvTHpSeER6Nm5LekhnRDNIaE8vRkM4MjJvSi81RHU1RC9EOHQzZXo5eGR3djBQS2IzRktmM3JOTUFCOUFBcDN0K2Q2ZjNSbSswQXd4N3JaKytyVGNBRHlRNzZjdmo2anRBNnF0M3NnYzc3Y08zc21OMDdRYzcxNTVnREhaYVJRR2txbEs3NE5YZDhKZG5lWlo3ci9GSHI1VW5ncXMwanJnTTRDRUE4M3NObFJTcjlkOVVGb3BrR1IyQXRZN0VIM2NKR05XTnRlSmtTZmlKSFlWZVI3eVJ3QWNLaTVNYit5djhoYjZGSThkLzdIbHk4VTc4OEg1by9hOWVXUU9FaHdFUUNuZ29NTEJBQVFnRUNDb2NFQUFBeEFBUUkwWU1VR0FpUm93VE9YYjArQkhrUndFQlJvNE15YkVrU1pVcFQwNU1XVktBQUFJeEdRaElZSE5tekp3NVkvYjBLYlBuelFRRWJ0YWNXZFBvVUtGSUJTQlZ5dUJwLzFPcFJHMDZSWkFnQVZTcENIQW1PSERUWmt5d1laOWlMVnIxNWxVQlY2OWk1Y3FBd0Z1bVhMbW1kY3VnQWdPb1Z4bndUZUFYS3RTc0NTb01ManlZN1YyK2hSa1R4dnUzNzEvSmJQTldrS0MzTWw3TmxTOXJ4b3VBZ1lUS0NDUVlxR0RhQUFMTHFTVWdTSjNCTld2VUVpUmthQzJCZ3dFT3BCSHN4azJiQSswR3dJY0hEOTZBUS9IaHlIRnpTUDdjT2ZJRzA2a25yeDQ5K25RYXo2ZGI5eTY5UVlicDRqazRtRzdlZlBidzU5RTNNTzlldWdNSzhOKy9uMysvZ1lqOCs5SFRvVTZkaHY4YUNKQTYvVUJvZ0lmODJqdFF2Z2JvRUdFKzkrWjcwRDhIRnFTUFB2VHFzekREOWp6MDBEMEwwWk9BUGdNYU1FQkVDUnd3RVVVRE12L0l3TVVNVnB5eFJSZGhjSEdCREJZd1lNY2JGOGp4eHgxLzVKRklIM2tjVWtnaUYxaHh4d09TM0JFQklRL2djVW9rbmF5U2dBV3lkREpMaHJ4YzZJQURDQkNUekRFSk9OUE1Nc2ZFaUlBQURvREF6VGdMRUFCT09nVW9vRTJHOEF3QVRvMHUraE9qUGdIbGFDTS9DLzN6ejRvbVV0UWlqaUxhNkNHSkdKVzBnSWdlc2hTaVNpc0NnTk5PS2VvVVZFNC9EWFZUUmlkVnROS0RBQmhnQUFCU1JlaWdoZ2hLMUZHSk1wWElUMFJiMmxVa2xYeHQ2YVdWZmowcFdKaUNDa3VuWkpYdGFhZXdhbElxTEtLT21ncmF3YVJWNmxxbXRIVzJLYlAwOHVxc3VhZ1NpaXlpSkJ1c0pybldtc3lzdHI2SzY2K21Fbk5yTXMreVlpdXl0cUQvS2t5d3h4N2phMTIrRXR2TXNRb0t3eGUwaFBzeVdMUE9NbnQ0czlId01rMDFCRlNqK0RQUlVMT010OW9zNCtDMDJ6STRMYmZXZ3RQTnN0OUsrODFGQTRqRGJUbm51TU1PdXVvRzVPNW04TFQ3VGpxZXVSTVBhUGpPczVtOG9VR2tJQU1LY0s0UXYrbm1FeUZBcUtmVGI3b0g5Nk42UUFHcGU5cEJxaWx3UUFUN0drelE2UWErbnJEcnIrRUxHa1FOTlF5eDdiZzlwRzNGOEJ4NDBRRVZEV2pSYmhuTGEzSEZGV0NFOFVZWWN6VGd4c1FOUUVGSEI1NWtVa2NkRVJjeXlSWDI5akZKeVYxYndFbk9QZis4Y3dhMDFKTExNZzhvd1BRMHpUenpBTkZaUjVNZ09obHlFd0k0MzR4eklUZjNUS2pOUUFjVjFFODRFVFdVMEl3eS96cDEwWTVjYlRSNTVKRy90TkpGUXgxMWVsRkpwV2hVU2JFL1ZkV0hXbjBvVlFnZUV2K2c4aDkxVmZ0QkQrWFZlUFpSZXA5WGsweHkvNlZpangzcnAyYUIyaC9hWjh2RkZvRGptdGExQ0pnVnFUakZKa3JCeWw0TW1LNjFiTVV1WWFHTFVOQUZNSUd4aTEzdjRzb0RKNWdZZlBuTFlsN3B5N29NNDYzR2VMQjFpOW5NQ2czR3NMd2s3SVdncVlEQzhOS1p6VGdNWWpQVVlXZ3NScHJQNE9VMFFYUk5FRzlER28xVllHU21zYzBRS3dDeTROQkdaY2twelltT0E3UHZ6QXc1MlBrUHpxNm9NK3Q0a1dqZ0VZOER5aU0wQVpGeFBlY0ptOUdjaGpPenZmR04yNW5hMWFLV0gveEU2RDFEZzJPRFBFU2gvRURvalUvRGozbjhVLzlJUGFJSFFnNDRFQWcrRkNKSDFnZERIRElqRzk5bUhoYXBDR2hrdk51TUFpZWpKYlZzY0RQYWtlTU1ZRGtla2ZLVG94UVNLbnVrSkNwUmlYSUd1QkxvUHVlNUxvMXVUS1JMRStwVWw3bzBpV21YWW9MQW5SU2lwNHNFeWt1b0N3QUJpTmZNUHdHdmVJZmFDS0dZcHlqbEljcWF6ZE9lODdaSlBlcHQ2cHVlSWhXb21uY3FVMUVxQUFNb1NLVWc0Q3AxSXVTWTZ6TVVxdHJudnZqWjB5WDQ3SWl4WXJLU1p1SHZKejdoU1U5cWdpeXdER1VxQjVRSlFzOHlyVzFCUlZvUWpjcXp5RFdVdW13RkxldDZZRm9TS0JrR2ZzV0Q1NW9YU0dWQ2w2YUF0RjVaT1ZpK0FpYVp4aEFHS3dmN1MxeldvcFlKNnRDRkJwTmhYL1NpTUovL1lvYUZMZ1FpQzJWWXNSa0NrVGN6UkUzSG5HZ2EwZmhtWTZLQjRoT2Q4eHNwRHFjMko0cVp6WHEyczY1eU5UdEt3NkxOdnJoRk1jS25qT25SMmxxckJzaXRtWTBERWJwajFyS21IN3RHalFZaTBBOEZBRG5JdlRhSUFnY1N3WVBBaGg2MThUV1FiM1NyMmVURGdVS0dUVCtHUldSaEIwc2ZPbkJJa3VZaFczdUVCclpJUGhLMEZpb1BCeks1U1JUQlFKU0RnOUdNVUZ0S0lxMW9iNTg4WlNxWkZGc2lFY2xKVVRxU0xKRVVwYzVkQ1paWkVwMllTSmM2MVBIU2w2elQ1WEhEeEV0bE51U1pmTUxJNmU3VU96NzlUbjNaSFJTZ01OSW85TlhLSXRhY1ZEZWRGNzFMYmJOVTVCeW5ldGY3S1czYWFyeTJtb2ozRW9JK2pLaFQvM3dOU1VoSDlwdVFWckhoSk5Qa3IzWTlRang5SGppZ0NSYkxnZzNLNElNdTJIL1FTbWhTSENvV2lUNkxva3RwaWw0VVdsQnlTWFNoWk5Gb0NEbEtZc1JNWmkzNU1nc0pQWmd1bnJMcmd5dEVHRTl6Nkptaldxd3ZPRzVkNng1V0dSLy9ORE1XdTR4bEpxYVhJUnVNWXBjUkRaRlRvMFBWdEhDR0Zkc1lhNlJxSEpWQkVjdkcwYkowU0hTY0xuWkhRT3BoYTRESTNNYWJXWWRBQkJvcld6OHJ0QWk5Rlk2SlRheGM5d29ocVFYb1BoUzRJMS96Mm1lby9YblBldlpQbnMwMlY3azZyYTk2YlZxQ0tMUkdCTFcxQVFkS2tGdmxRMGp6SEdoQ1hpdlFwZCtZUjBXcXJXMXIyNlNNVmlRakZLMzJSVEhpSkpOWXZUZFhwM0p4cy84bEpaRWtOeVFud2RKem5mUHQ1NkwwSXk1eHJrdkUzZEthRk1MTDFlblNUSGc2M2JLWlhleUV6R21ZdU12VG5JS1hYVUVCejc3R3k5V3Q1TnZ0YmtldlVOemtuam1yMTE3cmxkdWI0RFFuZWJ0WkszWUNRSHdCTUloR2xwZStXeEd2Vlg3S0pxRHcrMnhSNGJOWXdnb0pQeFdjdjJYdDcrQVBCZ3BDcGFWUXFtd3dLUUp0TUUya3dxMkxnbXRjQml6eEJudXlRWSszaTEwMHRha0lSNDR3eUxCRjVQRHk2Y24xc3BtRUZaV25vUG5Nalh2NFpKcy9acVU3L2FrUExhWkQwd2h4NWsxbURRTU1vSm1pVzJ5cFNSN2liSHFEeENaYWRhcFdYUTZKdXZ5Y01acVpybDRsMEg3U1hLQ21FV2crWU5mTzFPUW9vSzJ6dVd5YWZXdi9YK2RzTmp5YnpjNkJsYnVlNGFobnVpc3Q3bnpWKzk3dmJuZEQzdkhQZnVaejNCWE5ka0xydmZDRUw3emNFL2sxd2pLVzdqd1liR0RkRXpZR2hkcHRJc0tzaUVJa294Q3BLRzhXMGh1TllFdjZKUzBKQmJGMlFPcFJjSHBTSmk1SnYvWDFqM1o5Nnl2OXVuU2pLOTNyaE1uTTFJa0pUd3RoNXBxR2p5ZmpKM1A0eTJUVE1ObjBKK3Y2enBucG5LKzJweThSNzJudnZJd3liNmEwTDI3cmI2L2M3QTNudWMyOVBmU2FmN3pocFdZNzRXUVE4TjAzZmN0emxiUDErK3pzcDlQKytmVUFRUVFTcWVRQlMxaUNaZUNXeWVBU1RIOE83Z0FOYW9BUTZxR3FRcUVJaXVJZVNBSUxxaXRvaWx3ZUNJRk1pcU5pd3FRc2hvUkVDaXUrLytJckFnWlpRaXBmWWk2RVFFckZaRTdtTUVNMVlnNEdkUzdLbEtybm5reW5SdU9GTkdQbmpJb0hvY3lvaXFnMFFxWXZnakExVXVOaVpxZzFOc1kybk01a29JNnFmb1BMdW9wRXhDT041S2pNOUlNR3VxN1B5T3pzc3FiTXlPek82S3JNL21QcnR1N055dWJ0SXFUd0JnU1E4b29DdnJEUUFBMEU5bzRHN0M2dTdNN3UyUEFOOWE0T0lXVHYvQkFQQS9FTkF3OUMzTEFQOWN6T0RISHdCaEVSK2NvUENiRVIvYkRSck9iUjZPNUJFbVRTNWxCdUtrM3o0TVlUMGNORUxHbVRPQWx3U2hHMlVzOXlXRS8xZ21TM2pNUklPRWRKWmtuMk9pZVhjRzlMY0duSDRxSkx4cVJNbHV0TUZ1TDQ4S1Q0aGhFWUQrQ1lxc3Y1cnF0TnJ2K051OXJudTRpbjNqQmwrN3lQR3JjcGVxanhldFpMbk16TmV0QVAvYmpwL3p5Q1UrSk5uZTdMZHlJRmVzcngyVGFBSGRrUkFqWWdJY2lIVlFyZ0FlcXhIbUVBQnVvUkF6QkFJRHpBM3V4cGZuWmxKcGFKSk9hRUFCR3U0QUtLS2lUdUFJQmlKaDZTQVRrUW94elNwQlJ5ZndqQWdSUXVMVlJzeERpSUErbGlYdUJDcE5ZQ0kxT29KQmtnaFR5cXhWNE9YUERscVBLaTZCNG1Kb3ZxNVlTc1luaWo1cERRSm5HS1ltcHdpSHFRTkp4TXAxeER5RUlHQ0lreUNZMHdDWU1JUnBBb0tHMWpaRXBqTjZ6TU9IVERSS2h1NnFKd09kQnVQdzZ0YlBUdVBDSUU3T0FRRHJPT3JzSlFhdlRLcnVhcURka096eExORFF1UjhHaGdBcUQvWmcvcmNBL3pzZzRuQUJIenFpNFJUOC80VWpEMWNnTDIwakR2RWk4TFV4QWIwZTRBRVREbFV2TDBiQTdwZ0FMb1lBNUJRTkhtVUFRaTh6SURTd1EwY1pFZURRUXVpNUUwYi9ORWhOUUFaL1JheTNKYWMzRUNwMFU4eVhGbWN6YVZ4SEplc2RaMnEwb1dvTmRtS2RkSTUwZlN4Slp3Q2RpRUxaZVVpL2k4WlBoTzV4ZUo3L2lBa1U0MHdrOTZCeG1Oc1pta3NTSnlwYnN1SWp1bHJ4cS84L3Vpa2J5eWtSdS9DZnkrOGZ5cU1Sd2R4VkxnTFZYNks5djhzUndYWUFNZVlBTVc0QUh3c3g0andCNzdNd0pXZ0FSWVlBVllRRUFMTkI4ZmdIenF6ZitLWjFWMjVVNUE0a0ZUQWlNUTBpSVA3aUpqb2lFZjBpRnhna09ocFFNbC8zQ0RHbElBR2xKRVM5U2liR0lFSjZpbjRBVmVQSktEUUJJRDM4S0RTQklCZEJFbDRTSmhKdVBsWXU0QTJDSmdkSERJYmdnRmE2N21STU1uamREbmF0QmdqZ2hKZStnMGtpckpoSklvaXpCa09tYnBwdFRWZW9NMG1DNDNrTWhqY0VNM2dLTTJzc3BGY0NOdm9MREx0RW82cnBLdDhvaXRtbWF0NUtycnNLWXMrNHpyMkRBTkF3blFFdTArNHZJUW9hWXVEVEZRNzFMUDZ0QlFDNU11OS9JTkM1TXZCWEV3S1VBeElWVlNKUlZSRlZNd0QxTVFBZEV4SDlIdUpDOHlLd3NFZUVEeU1GTXpSNVVDVEpWVXYwWVRDOHM5R0trMEdRbHVVTk5DWkVSRjNBTkZHTWRDR0djRkhNZHlIS0MxYUdSWEYyZEphbE5JR0djQlV1OUpZditKOW53dFRHcXBXVzJSVElnejJNd0VsNDdUOTg0aytMQVYrTmJrZElwUkdPZUVtWTZ4K2FidFFhTXZlcVJ2ZURnaVVyZ3ArNjZSdk54VlFiRlBYc05yRzhWUEc4ZXZHN3VSM2NCeFBldnRQZVBwdXNaSCtnd2lQL0Z6QVNKZ0FWWWdZVmtBQlNJZ0FsamdZVmRBQXlhV0JDWjJCSEFBQ1NaMkNqVEFZZTFUZktDSE8rZXJkdXJ4UitwUFYwQmlRdk1KSlJLU1dSRHdnVnJuZ1lqaVhRQUtLRHlzcENTUUtqSjBRMmVDS3g3T0xvaUNMbkJVNWVpbDR6NlNCRHZvQkd0VVRHNVV4enhJWVY0b0IzZTBCV1ZvSm1GeVNHdFFLWiswTlpBdU5yVFdpR2pETXBveTZaQXlpS0txWXBJUUtiZTBORnhtYjFiR1phQklOb3l5TjF6L0pqZEtKb3FnS0cvRUkwelBsRVN1TWpqRVEwV3lpa1Mya2pvR0YrM0lTR25DYk96aXpLN1FjT3dJVVdvUUx4SDV6QkE1bFJIN2NuSUhWVkV4dFRCOUlWRXJOUXZwRWxKRk56QXBGVklmZFRBYjFWSS85M1JKTjNVRDB3OVZGMEwra2k4MzgxUWhwRlEzOHpOeGwvRStRSGQ1d0RNZGdBY3NKRFFYeVRTUEYzbGpOZlZJQ1FWbWszRlNyN1ZRWkZoZGJ6Wlg2ZlFzUjBoZThVbHVyMGM1eDdmQzVOZDRrUmVEODB3MmdKbDBDVGlWVFRtTlQvaU95L2ZjOS9pd2xaaVVEMUFlbEpsR0luaHlCWHdlSlYzUEZYckNDMTZuVVlBeFpkd29oWUN2TWIzcWxSdTFNVi9qanoyOThkK3VDWG1jS1ZXNFUxYnE4MGZ1TXo5WFlFQUQvN1JpU2FBRU5DQmpSd0FKa0lDRUwzWUVKcFpqK2ZNQnl1Zjl5aEVDSGdBR09KaURTV0JBOWZOMEVHVis1R2RZWUdJbVNCUW9HcktpR013alZkU0FnbGdpYzRKRXdXVkVNUlRoZ0xpSmF4UXVjRlFwZGt4cUxTckhqcmFsMkdJSFg0N21kaEFsaVJRQndpUUdZOUJKamRBbmEvQ0kxRGduZVdPSmFHTkxWNk5LZ3pBcWc4Z3lrT3lPTzJhTzQ5aHQyWFp0NFRpSjFOWTF4clJrd3BRcVg4WTRpb05GbENOd3MzSXJGeG5NeWdxTndNdzl5dW8vemhET3dGQ1RJZGZQQW85UThYSXhDZThOczNDVVRYZFJRM2QwVDlrWDhGQXdVYmQwWDlkMEczVjBMNVZSV3prd1JWZVc5Y3gzUmZWVStjcFRNek1TNVM1VWQvZVg1MjRPYi85M21FT1ZzcGE1TkpIWE5GMDFWeld2ZVFFSHRxUVhObEhMOVk1VmNsZ1A5WFpMRlova1NJSkVuTVdadDJCeFNnaUFSOGJrSGQyWE9VOUhsdzVnQTRDdmROejNXbmtuSVl3eGQ1UXBJUjZVR2R1RXUvd3RWYm9UWk1XelViWlQvYkx6Z0F1NGdPK3ZQY09QUE1NSm92azFnZHROZWRUdkh5VjQrczdWdmw2RkhoOUFRRFdBQkpBQUIwYWdCRTc0aEVjYXBDZTJZekhBaGVteG95TUFCVWlBQkVhQXBrY2FCMlI2UVBOelZ2WkpaVTJpVFhwQ1ozOTQ0U1N5aUVGVUt0NGxXVVJVcUtONFJMMmlpWDhZTEdRVVJkTUZJOGRraW10MGpNTzRSOGU0aDBib1ExTnNMYXk0TCtJQ0JjdjRpN1dhcTNNTXEzc0lqY1ZZakdrd3l0ei9HamFjMUdKMlk0WjJnemMySm82VDZLNHJCbVFRSUlsOHcwcUowQ2pkOW8vWmRqZmFGckhMMUNxM0RDdGw1a1RTbEV3bE95c3AyMjhVMTR6UWlBclRJemthaENzVHk4LzZNQzRMbFM5SmQxSk5PVEI1UUpaTGV3OHRGVkpqZ0ZIcHNwWmxHMUk5ZHdKOFlRSmdHN1luNExiNVVyVXA0QU1tUUxWNW03aUpHMUtCdDVVWjlYUlArM1dCVjFJLzRKVkx0UzVwbHpGL2wxU0I5ekluQURPRldaZzFNZEsrZTNqRFJwRmk5VlVWeWJ5YitYaGRxelo3MWZXYXQ3MFg0RVpRQUFaYXIvV1FwSHBkYVp6ek83OTd6UUNFYTNRS1lBSHVHWFVJNGdBZWdCZVp5OWdXSXNDWjA5aDRoOENuSzU5OXh6cDFCZm9BR3R5NDdmclk3YjNBLzdQNzluVThGZmpjOERXOUlIaGZ4K205d092LzlrMGM1YXVhd3ZPZFBGcW1hYnFFUjZBSFJrQUhSdUFLYUpxbXB5Q0VBelFDTUVBQjl0RWVZUnFrcDJBS2RGekhjV0FLWkJvRkZEYkFOOEtmVGNJZzgrbXBxeHlLUGE2b1NaUXJ3a1NvOVVlb1JmQmxGMHBFZXhZa2V4UUROVWlFOUtKSDE1eXJhODdNTFNhRlV1Z3FVaWpINnJ3bTFWcXRmV3JIMkR6UDg1eHIzWm9vODFwS1o3Q3RaM0JrbkU3UVIyWnVsNjZ2Y1dwdTNiWkxZY1JrQUh0bGJNTmxiSU52TDUwMGJBTk1uNmc1L0JabTBuUTZUT1EvNlBhcXlrUFV2eU1ETFBrLzNpT3VWaDFwS0puVjRXZ01zekEvUmh0cStteVdGeldWVjN1V2JWbTU3WTRHWWlCUmEvODd0Mzk5dG5tYkFsWjV0M083dUh2N2RIM2hBMklndUorZHQ2bGR0NStkTG5FN0J1d090NWU5VVozYmxIK2JVbUc1VVhXM00rZFE4blpaZHhudk1qZnozVEVUYkFMcjB2eGpOQzB2MHM0YnZVV2tlVE9nMzRFMVlmRXhWMSt6dnJsWldJOWtSYjQ1bk1OWnZ4dGVXYk1FQXVDNXdMT2ttS0tWeStPWitKWnRHSm5wMlFoQ3Y4NUV1aVppVmdUc240OEpmUHJYTzdlVDI3eExtNnJ4dk5yMW5CUWwrOGlUZ2NkUFVqamNnZU9yVmxBOEpGaittdHlOWUI4Z0FtYmF4bW04QjQ2K0JvNWU2VDhBeVVXYVlrRzZZbG1nWWpkMkJHWTZwVFVBWWxGQXAvY2tJelNDaHd0eUpCb1Myb0JpbUZpVzQyU1dScHVhWjUwWXFodVN6REgvRkNVUFNFeUd3aWlVOXFRWTBNeXZQTy9wSXM3RG1LenBITWU2V3ZEdFhQREYyTS85dk9iYW1raUZhR3R2VXZFQi9TYWZkSWxnNHpaWVk5T0RzRXY5R0Vhbzh0RTUzU28vMzlJSnViRjFvMjZuVG9xMHFHOGJtVTFoWnZXMWFveXNJNVBTU3BJcFdXZlE2SXZVMEN2eHpFOUQrM01QczlzbGxiYVYzYmZ4a05namxkZ1RsWFNEZTVVRms5dUp1OXU3L2R1dFBYVnord09rM2ZrdjROb25ZTnFsMy9tdjNkZ2wxYm1odTl5SGU3bXIvWFJWVy94LytaZDlGd1NnMjNmWlhlNTQ0REk5bGJMa1gvNC9VL0tFRjVyTmV3VUFBc1NLRlE0SUVuUmdBR0ZDQXdzY1pIRFFNQU1LQnlnTVZKeTRnQ0ZFalJrN0dtQUlzdU9Da1NoSS80NDhpWExCZ1pRbkNUeUFRQURDZ2dJcU54d2dVR0JsemdVNENSd28wUE1uZ1o0NWl4WTRpdFJvVXFCSEF3UW84UFFwZ1FBUW9rSzlHdFdxMHdGYW4wSUY0RFFBVndBRndKb05jSlpzV3JGbzBaWkZtM2JzVzdnQTZwcTFpemV2WHIxdzI2Nzk2emZ3MnJCT3dSSStTL2h3WUw5UUF3OG80R0hEQXhZYVJvem9jYmxIRHhtYk5RZlJEQnJ6Q0Eya1NVekJvWUdFaGltcFNZeldFSUZGaEFnUEhoU0F3QlFwVHE5Tmp3b29JRURBZ1FBRWhBc29maUM0OHVYSkVRaHdYaHk2YytFSWtoOUlrTHk0Y093Q3VCUGdmdk03ZytkREVSQmdFRjU0OVBNM3B3ZTNQdjBBK3ZubTZ3dGdnQUEvL3Z6OEVmRFg3NThCL2cxSVlJSDkrZi9IZ0lBR0tqamdBZjVWWUFDRUVDSlFBWVVTSU1CQmdSTWFTR0FHQ0Z5WWdZQWNWSENoQkJCSzhCRUhLSzVvZ0lvWlNNQkJpd1pJOENLR01LTFl3RWNvY3VBQWpUZTYyR09PUW5MQWdaQTNOaUFCa2tJK1ZLUUJEUlNacEpKRk52QmtsUmswY0dXV1BCYkpJNVVOT09DbGx4UndRRUdZWVpaSkE1VVVvTmxBbWhTSVFBT2NJbEF3QVEwVGlGQ25uVFRvYVNjRk1VeEE1d1NDQ3ZwbkREUlFRSU12ZXhxYTU2Sjc1bW5vbjRFU09zR2ZsVlpLZ1MrQVdqcW9vSk5lK2tFTUgzUTZhS0drbmxvcXFYN3k0T2Vrcm5ZNjZxaW5ya2tyQlNCTUFJS3RkNDU2YTY0OGlQQ0JDRHlBRUN3SXdJcVFxN0hEMm9vc3NpQTQ4T3l6MEJiLzVFQzExbDZMTFVYYVRtUVJSTjZHcEZCRkhvR1VRVVlsTWNSU1NSQ1Z4Rks3UE1sMDJ3RVB5TXVVVHpQZEJCTlFQY0VVVTFDM0xZV2JVa3ZoZEZWdVdGWFZHTUpWWmRVWVZWbGxSWlpiWUpYMUZWdHFTV3l4WUdXWnRmRUFZSGxNMTExNUNlWVhYaUVEaGpMSktiZFYyRnNyRzNieFdJbzFkckJNRDZ4Z1dRMmUvUkFFejFEdzNFTU9QZnlnMlE4NllJWkVDYXFSeGhvSlRvOUFBaEttT2IwQ0NyUTlFRk1CRHl3QVEyMFBTTFpVdmNZaGQxd0F4ZzBuQUFRQ21HM2RjY2Fkclo1enpibmQ5Z0hKcWZlY2ZBZ2trTjlONkJFZ3QzM1hDVWNmNE5VQjdoUGloNXZuNEhQUElmZ2ZnUFBwdlYrQUNDaTR3T1VPV3A1NTVwc3IveWdnNkIrRy9xQ0FIakxvNFliK1piajY1WmVIZnZybEdiejRrWXd4N2lpamp3YlEvbUtQTWY0K280bzNTdUFqUWptcTJLU1FUbWI1cEFOUUt0KzhCTTQ3UkdXWHpuOUpKWmpYWDlrbDlsNktRQ1g0RGN3NWZnTmxPbEJtbVdwU21hYWJiYllKWjV0dkhvcW5uWERXZWFlZWd0TEFhYWN4bkVBcC92a0pmNWNxb0FIL0JNQlVrU3FCREZUZ3BTelZ3Rk5aS2diOUUxUUNKNGdxQXlxUVU1WWFWUVU3UmFkQXJRbFFFL2hBcjRKVnJHUGhDbGk0V2lHdUtQQXJZOG5RV05ONjFwZWlSWWRuMGVGYUE2SFdSSDZvTFc5ZEpDRVpRUWhGRXJLUkJZaHJKQkFaQ1VqWTVhNG9qbVFvQk9DSkZhdFlSWnJRcENZRTJFQVhYZEl2bVAvWUpJejlPc3BQOGlXVW91Q21qRVFKMjFLNndoV3VZT1VyRFNQTVhCakRzWStSVEdaMThSaGY3SEt5a2YzbExuUXBaTW9PcVRLV0djWXhqRVRrSXNOQ003YjBCZ0liaUlEVFNJQ0RLZFJna3orUVFTYzd3eG5PRUswSE9yQ01aVkRqdE5LWVpnUWYrQUFyVHpNRnA4VnlDcVpVRFFsWXdJSVZSR0FER3pqS1ZJampOcC84Wm0xVFdSdmE2a1kzNUFDT2JzeGtuSHB1QXMzeE9HZWFqcHZtTXFGWkg1L1FSejUyKzl2aHVLbTN4K25OUVlCYlFJSXV0eC9KRVloMENNamNPdEhwenMyNWpwMGYrZERsSm5RaDB6bklicFlya0lmbWlhSFFrUzRERXdwUmpGNUV1eG5ONkVvZk9WNkxrSVRRRlNFUG9rbXFxUFNTZEtXTFlnbi9vMWlxMHBZNjJxVXJYZTk2Mk5OZTg3SkhwQ3FoTDB6aUt4UDV5SmUrTjVYcFYyd3kzL3JhWno0NEhRcFJKRHlVL2ZiRUp6L1p5WUpFTFdDaCtQZEFvMUtLVXdEOFg2Y0FlSUVKTURDcWcyb2dBQk80d0FsUWxhcUNvcXBWaXhxRHFIYXdVcUVxVlZrMUdGVlprYXAvSVNRaG5YZ3dBYmpTNlZad3ZkVmNXMmdzRk01SmhyYWlBUHFxeFlOcDFWQ3dEdGhodGFSRnJXeFZxeUxaK3FGRmlHaVJjakZ4QVN0NHJFaFFnaTRwb3FTS210MnNUYnlvUnA4VUJXc3dnZGNaaTVLMW55QWxZRGhKWTFJZTQwYXZQRVdPWHBtWWJiSFNsYlM0TEpGcEVXUmRBcmtYbEluc3Q0UjBKRzhUeVRLTjZYR1FpMG1NVXlKSjI2UGdaZ09VLzZUdUJoYndBQlM0WmdTYjdJSE9odWFab0IxTk01WkJBbW5PTzRJL2RIZVROZmdCZTNWV2c1N1ZRSlRrSFEwdkJ4YWM0cWd0QU1PNUc5eXNvMHk3dllkc1pJTm1NcU81bmVzb09HL284VTUxOXFuTituaXpQWUNqc0g4ZXA1OEtKK2dqQ2RMYmdBeXdULzlrTG5UN0RIRkdEaUFnejNYSWRaZERVWVJDSnlFR2NlaWYvZ0VSUW5kM29ZUGE4M1FHUmNDTldiU2lFUFhJZVU0aVh1OFUrcndpSzRsR3krdm85RUlLMGk5eENVeldtOUtWU29wbDhKbDBTalpWMy92ZUJGUHk3WFJOYzVwZm5IQUtQMFNwT2FodVBSVCsrS2MvcEg3S2YzUTJsWjBmV0tpcld0QlVWL1dxVnJNcVZhS0d0YXQvaHFxZUR4MW8veVZRckZUOWsvOVl1OHBCRFlKS2dyTVNWS3hLR0ZkQnlaV0VkYVVBQ3BVbHcxK0pXbGpQc3RVT3BZWFl3aXAyMWRhYVNCQ0Q2T3FMU0FSZGxWMGlyVStTMmM1cWRpWHphZ25XN2dXVU5lSUdOeitaeWI2TWNrYWNCRXczdmpTWUc5OElnWWpOc1MwVWU2NjFyK0xJdC9CeFl5WUQ1Qi8vMkpmZUV2ZTR4aDNNSTVPcmJZenhNZHpqZG91MUh5YkhpR25sS21kY3dBYTArd0gyOWd3S01vQkNHYURRczgrQWw1VGs1WU1NWkJDRWd5czhhRExJUWI4UkR2RWdDSTB6T25OYUJFYWlyNm4wbDc5dnM4NTRHTEFlYVJLNGJ2enRseklUTjVScWtvYzgwT1FPeSt2RFRaaFB1TUtMbXliazFva2ZCZUVueEp0emtPaGszQ0RQZ2JnNlJEZWRRQUgvV2lMWG9VaDJseHZ4QVVJa3U5MmxxSjRaSXQ2SEp2U1JFR21keVJMZFhZNFFBaVVaZmYyaFZ2Ym9reDRTSlNmeGFIck40eEpLVDFxdDdIbHZwWFRIc2trYjhLdWNwaS9ONEh1cFRPZDBKem5wZE14N1FsVGgyVXduTnlNMXpoVHNId1l4cU5SQzNmbUJGd2dyQlN2L3Y4eGp2dkdjSC9TZ1Q5Qm5RaDlhejVrZlBlaWxHbFU5cHg3MWZ5NVZvMXZmZWdvbWRhMm9VdXVnWGdXb0VIN2FXY01hRmdoQXNDeGYvZDczd0M4K3FnVjcvTU0yOWxxdTFsWmt4ZVV0a2VUYUFDdEFTUk4xM1M2WnpHUUJsRHpBZFhQeUU5VW1Hd0pDeVpleWtSMXNwUXc3S1VTNXliOWlleFhhUHNXMkRKdjNjcFdic1lzQllDd2c4Mk8zL3o5dS83OUZiaVV6Z090bWJzNFZGb2hVR0Fsb1IrOFdTWkpVZjlHRkZONDNFck8wU1EyWEEyV2dnVGtnQlZKUUJobVlBeUdJZ1EzM2dSdm9nVklRZ2h3SUJTb0lCZjYyZ2l2b2NONjFTYTFVRWtOUkZSQ3dYOHV4SGQraFRlZEJIc0tFTjNZRFRkWUJZTkFrVE53MGN6Q0hPRHhYSGVoeE9RUmdBT1dCWWxNWWhRM2lIejFIZFBMMFlBL0dJRDczWWYwa0lIYWpFaXF4aFVVM1Q3V2pkUGYwRVJVUUl2bkVFRDRtVUFmMUVRc1FJa1pYT3hBU0kxTUhQTFFESTBHU0VEaVNKQXVWSTl5akpGV2lVa1V5UFJ5RkpkdkRBUm1BaU15RFVuUlFVdW9ESm1LQ1BTM2xQZWtEVS9JakoyRDJKbTVWUDNJU0ozVkNLMEFGVkR3VlozWENLUDl3cG9xTnh6K3lkMmV4bUZTd2VDa24wSGkyaUhtMnFJdVhWM3E5cUlzWEFIckFHSXduQUl6RldJeWdwM2tYY0l6R09JeSsySXVNRm1oUmxYcXJKNDJXOTJpT1JpbDBCbnNaMUZhQlludzhZRUsreHlvdkZFUEFoeXk5WjN5L2wzekhoMWpSNG1vcDBHcEgxQkFOd1JIUk40KzVSbG00QmdNbHNZOWMwMWxic3hMYnB4UDNFa1k1UVd5bFJVWm1wSkRKOW43L3NteXRWUy9QMWh0VWdWc0hNMjhNczF6cGxqSWIwekY0QVRMQkpUTGh0b0RrVm00WWd4aUxkRzVSRVc5UUlYK1I5SUFJbUJnSVUzOFBJMTFlNFFFeXNRSlBJNE9ia1lGUzRBSkMwSUZCR1pSbDBJRmRJQVJkSUFWbllKUm5jQVpKYVpSQ09aUWQrRytpQkRYL0YrZEZNSUV2aVpNY0REQWZJQ2R5NDJFMytwVTI0YWVWWlZtV1E3aUU1R1FlV25tRlRaaUZCc0FBNWhTRklFYVhSRmNnWG9oaTdYUk9LbWFGL2VTWERZS1BXZmc2dFVPWWhmazZjQ2gxdFpNUmlTbDFkY2lZajhranRrTTlXdWNRZitnUVExWlJTQ0tJUE1KUlR2SmtsVGhsWlZlSllmSlgzcE9KWFdZK0p1VlhYOElEWDFJbWtyaWF1U0lDYzNKbW9qaWJ0UWtvYnBaNHBtaDRqOEtLanZJbnJ4aDVCNFJubFVLTHRjaDV0cGg1eVVsQnUwaU1wUWQ2emltTW9NY0gwVW1NMFhtTXc2aU14T2dDeHBpZDFpbU0wMm1kNHptTTEvbWN2eGg2VjBXTWhPSm9kblpCR1FTZkpNUnBkREludi9JQm5pWXMrZmw3eUlJcit5bU8vek1FQWprMFdPdG9MYW4yYWtBVWF4eFJMbk5JYXdZQUE1amxSRXJrTGlVQmtDY2hFMWpFZmFrMWJBZEpScVgxTGhCNUFPWlhXdElsa1FSam9nR0RHMkl4UnpMSm9uQkViY1hWWERJRFhNRjFNb0UwZ0wxMW93VTRmL1BYTUErSWJUeDZiUkx6RmhVSlNUQXBHSVNFRkkveEdCdWdBQ1RBWGdkWEJpNUFsQjc0Z1p5QkdVSGpCaStncFdmd0FrekpwVndxQlVJd0EwZVpsRTBKbEIyWUF6L3dBUnJRUytaM2xrTVJIaGFHY2taSXAyLzZwa1pvVGl1QlJmSXhoaUtXaFVKSWhUN0hUL3MwZEVMbklKMGpoR0ZJT2lDbUVpdlJUbThJcVhrSkEwMzNxSVZwcVk2Sm1JUVpvVm4zRVRDd094bXhvSTVabUxORG1IV0lkbi80RVAvTGs0aGdGeVFNRlQwajlTVko4bVJ2aDRoWUpva0JhbmMyQlQ3bnMzZW82VDU3MTFlelNWT3pLVk8wWXB0cjBpZHE5bWFQa2lxUk5nR2E0Z3N4NENlUVp5cExKWXZPcUp5VmQ1M0tHRmJuV1l5ZUFJelZlUUhncXAzbUdaN2dHWjA3Y0FJdXNLN3Rxb3pzZWdIZHVaM2llUUU3Y0l3eVlKNzV1b3ppU296S09LL2J1b3dBRzQxL3BveUUxbnBjQlo5LzBrcVlKaXNMK3dFOEFGZDFkU3VZOW52OW1TeTJVbnpFcDQ3UFFueURkUkFVOFN3VFFSQW84RU1qbXhBWFVYMUtWSDNWeHk0bDRiTCtXQklSMERYWU5SSVhOeEpiWTI4NVd4VGhkeHVsaFMvNDBxWWthaHREaXh1MjhYN3JkN1FTbVJ1d2RSUk1teFMxaFJScUVVZi9iREVXTVdNeFpXR0FiU0dqTUVwY1hKdWpMNU4vS3NPU1Z6c3hEcWdWS3hta2VzUVZEdU13MDdZd0MrTnRnU0dUdmRFYis0ZTFUS29BczZHM0NxQUFHTkFCR2pCZkdqZ0RKYmlVUnRtbFhYQUdVRUFFWndBR1RMbTRUTmtGTGpBQ1g1T1ZjR3E1T1hHbmxuc1RWMFNXYUVsaGVyb1NvYXVuUEZHRlBLRTVRd2VvVXppRkQyWTNJSFlBazlxbkdUQ0ZzdXU2QUtVNXRJdGlIMEdGbnBxN3IwT0hpMm1wNUxKUU1pS3FuL3E3aVJraW52cTdFSkdxbkNwa1d0ZVkwak1qQ0NHOWk4aVowN01RZmlna2xSaDNKaVdKWmxlcmxlaFg0MXRTMXFJK3JibFN2UXFzNDJPc1pQWjNJeFJDdGRLSnlKcWJBdFJXbTZKVWlkWjUxWXBBLzRIbWVWZWxlWmJYbkFHYm5mVGFyL1dLbmYrS3J3anNyK0dwQWhlZ0FpZGdyeEhNcnV3YXdRLzh3QlhNbmYwYXdSSXN3ZlVxQS9VS2pBdE1qT282d2g5Y3dpSWN3dDdwcndCN3J0cTVuZFlZVnBWSHd6R3dTVGE4VlZ6bHNBd3JLaVhVc0puR3NIaENWM01TTFBaSkxCdUxqdi81ZTlVQ2o4cTNXTllDanlTclJDV0xBZy82UXhLUmp5dzdqeVN4ajF1VFhiVkJzOWwxczJQTWZSbHFHelB4YTFxa1drZHJYWlJVdEVmUlM2cUZvaVFhTnN2bWtMQTFBTGpodEJOWnR4U3pmeEtqZjM0c0Z2YzNTTndHZ0kzMHRiejFXOXVtZjVLa1I0M0JmMlNMYlRJWk1YckVGanM2dFZBUmJRVVFYZk5XTUZkQk1IUHNNSGJNeWFVOEFQOUtlaHZZSlJrcndCcVVjUms1RUFkRXFaUkNrTGlMU3dSZ2NNdGVXZ1kxa0FMM0VoNmlaUytaUzZmUXhMbWlGWmJISE14aktJYWpTNWVlZzZpcHU4elYwYWlOS29UVS9JWXFRWmRVZUlhT21qa1BlbUloY2MzZzNCRUtvYW1ObVhVSTRSR1ZWVmtJQWIzbFVpN0s2eENwcW5WQ2hrU3A2cW5aYTBSSWxMMzQ3Smx5TjVvbTFiMXpaM2RhbGo1L0pZazdwRDRGblpwK3A2dHJJcHNqeENyNEdkRzVSOUhkU0VLU29vcUJZaW12cDcvR3lYa2VCTURZNnB6L282LzllcDNxU3NJWFFNTDQrc0hxZWdJc2JhL3FLdFBiR3NINHFnSVR2QU15c0FNN3pkTTl2ZE02L2RNK0xkUTJqYThUZkFJWExNRW12TURzR3NMZFNjRXY3Y0gvSjh5TSticXRNUHljTlZ6RFVFVldvbElvWnhVcUhoUXJsL2JEZEVVc2RmVnBuOVo3cE9aN3lPSUF6bElRQWxFUUJqRVFjRjAxMjBKWjFOY1FKRXNSKzdpUFdydzFGM2R4M3Z3QU14dkdOQnZHWGlNdkVGQWJPT2dTQm1rVFdsTUFHQkRadDlIR0JSQzBscDBVYzV5MC8rSUJSOUhacGR6WlNycHNiUnUxWlZFVlZTdkljZlF4Z2Z6SFZUdGNOdHJJZVpUSTR0WXlhcUdSZm93VlU5dmFRdnJJYmR1MmFuSGFRSHJhVU5IWlVlRUJ2R0hIeVAyMHBYV0RLZHFRS3JwK04vZ3ZTaG9CR3ZBQk11QUNTZ201bTNBR203QzR1ZUNsVXJBRUdxQUExTVZHM2tmTWUrb1R3MXlXUUdHRVdLbVZZZ2hHOHhLNlZyUVNLVmFvS2Rhbi95cXhvS29McURBZ3VxL0xFTXE3b0FUK2RDZVdFUUQremlEMm9BaWd2T2pDRUhVSXo1WktoNXk2RUtCNmp4VWhkY3hiNFo0cUVRK3h2QTZLRU90YzRmbHNMZnRzUkplSlpTSmxtZ0xkdlg1bExTSlFkMjA5dmc3UW1qY3VBcmVhNDh6UzFyOGlMSGhuTEgxRlUrTzRhZU1ZdnhFYlZ5SWtuNXBDS1I0MGkxSzFuRjh0S254Z3c1YlhWTXFKaStVcXJ1UWFqUFlhak1wWW5TNnRqQThNakJVYzAyWGVyamZ0MHpldDVrTGQwMjErMHk2d0EzTE81anN0NTI0TzFEbnQwenJONTNyZTUzNyswM3h1MHdqTXJ1b3FyKzc2d0NqY3dDemN3b3ZlZVBuV3cxK05hVjFkUWdvNzZaY1d4RWZzc01mU0t4dnI2YitIQXM5aUVIR2RrLzl4VFMwRG9kZDFQYkxxUEk4dml3SmliTE1rOGRlRmpiTmpETWFJalRVQWVWM3c4aEliRUJsdlRFbERleFMyNGNhZXpjbDZEQUdQMGRuSkRobTNBVnVoYmV4NVRMWEhmc29BY053ZWc3V0FuTzI3blc2b0RaSUJPTnNrS1lBY0UwY3VzKzI0cmJaa1N4WnVHeFZWRVRIQnZUQkhRUmJIZlJ0ZU1jZkx0dTY0a2U4VWVZTytuYUxPclRDODRleTM4UUFLQUFJWGtLV0gyOTJPaTh1TEt3UXlnQVFSb0FDTXpWcVlXOFkwRWQvckRicklYS2NkWDhaVlJIN1RmTjhaMFU3WUhLRmo2QkVuQnVBak1mSW5MMW1idXBqbDR1QU9taElQeXFpMFcrRU9TdUVnc2ZNTWlzNGdVVm5tb3ZNNjc4NGwvdUZFNUMwaFVtc25xMWo2L0JEL3JLWTlZQUlDWHdMUTJSUDExL0lsTXQ3V2Z6VytGNXNyVXY4bU1iUlgrVG1zckVMa251WnBucUo3bk9ZcGdCSXJkdWJrcGxKNU5UQm9EVXhCZEcrTnk0aDY1VHF1NVNuQ1VCMnYxOW1kK0tyVElxeXVHQnpDZWc3b2ViNERkVDRETzYwQ2RmN21LdkQ0a1IvNU02QUNMcEQ1bW0vNWtRLzVrRS81amUvNWRVNzZqWi9UY1c3bnFXLzZicjc2VHgzQkVBeDZydy9WUjcydForN0MvaXJETlB3Qk5VejNOZkJuc21McG1CN1dPMXdzKy9ucHgvOTdsd1FDVHJQODBHSVFKTkJEbzc0Q0lLRFhKR3Y5S0ZBMUVlQ3lVbHg5T0h2cnRHN3JOTnMxWHZNUzJPWEZ0VUZkRS84WWtqMjBqYzE5Um92c1NQSFplYnhhOUsvc3Bvd2IvNTF0MjNoOHlnQXhBSUNIQWdNQ0VBUVFBSUJCZ1FVQUZBeGcwR0ZFaFFrQlhNU1k4YUpDamc4VEdyVFlVYVRGa0NRckJoalo4ZVBDaXcwdk9uUUl3ZVBBaUM4OXhvd0ljMERCZ2p0M0xqem9FU0hNQWdVZ0ZEVmE5T2hScEV5UEJvQkFBQUpVcWtjRk9JMTZWR3BSZ2dNZ0tIaUE1SWVVTGtLNmJDS0Nsc2ladFZBMFlGQ2c5T2lCQW5TbEVuaHdZQUdCQWd2cWJ0QkxZRzlmQWhzRUZ3NThRUEdDQXdRVzY2MjdZSzlrdll3ZlA3WXNXZk5telRBa0cxZ0FPdlNDREFZOGkrYWNRYkpxMGdzOHE0Ymh1VFZzQTZaQkk0Qmg0SUJxMXJ4SGs2NnR1blpvQXc0V09FQ1JJWGxvRktZZEZNL2c0TGxyQXl1cUs4K1EyL29LNmYvU1VYU1hYdnc1ZVBJT0dwZ3ZMeDFFK1Fickc5QkJEMzQ5Q0JFaVFGQ2dMd0svQ0I3MSsvT1lRSVFKS0NEd1BoNE0xSThISGloWWNNQUpKZ0F3d2djL29PQ0RCeW1ZNElNWUh0eHdnZzFqc1BEREN5WVljWUlhTG9qaHhBdFFSREdHR0ZoYzhZUVZMNUJSeGhocHZQRUVHMVU0WVljTGZMeEFoaUNEUEVHR0UxendNY2tnZDVCaEJ5ZWRuT0ZKRlhhWWtzb3ByOFJTQlJWbTBGSkxMcjNjVWdVWHhQd3l6QzdQUExQTUxNOThzazAzMTdTU3pTNnBaREpKSjMrOFFBVWM5WlJSVHg5dHRIRkdRUWNWVk1NYVByamdneG95QkhIRUR5eEVGTklNSjUxd1VrZy9BQ0ZUVERNRllkTk1Vd0NCQkJLbTREUlVVVThGWVFWUlEwMy9kUVZYWDRVVkJSWWlpQUFGRkZaQUFRWVVGb2lBVjE4amVJRFhCMUI0QUlZSGpsMGgyR09YWmJaWkRBcDRBSUlOcFBWZzJnZU1tbmFEYTZPTjY0RUJIcWpXZzdnOGdNQXJnb3J5aXFlZFBQaUpJSGJWNVNtbWRRc0lBRjJrNmtXS0laaHNFa2lqa3l5YWFDYUZBaTVKcFpSRTRnaWxpU2hpcVNhSEdhckpvWlpZRXFqaWhXVGFxVng0TS80cHFJTUdma2tobWVyOUNDcWt0dUlycXFTZ1dpcW5wWkphS2x0b2xlcEpBeGRlT09Nc0tORGFnZ2lmeS9BQkE2K21ndUNxdXdyQUN3Sy9sSVlXTWNBa0Uyd3l3UElLTnVyR0dITnNzc29PMEMwMHZTcGpiRE93ZzkyTTdBVjI1ZXhzMTlabW16WFQxdlpNdHM3WWxrMDI0Vm9EL3kxdnZIT2JMYlM0MzBiT09PNmFzeFZYN0tSYllJWEVzVXZPT2hpczYrNjc3OGc3RG9iMHV1Tk92ZTVFNkc2KzduZ2dqNDd6NkZpUDlGSTd6UlMvK3pMdEQ0UUlQeENCUWdCZEJ3RkNDR0dmZllMYU1jVTBRd0VwQlpGREN5bTFzTVFKUjBUZVErUmZaRDVISEFldDBjZ2ljUVRTU0IrTnZNQ0ZKWTJVb2ZzNlpiaXlTUmZBOS83SktHV0ljZ2N1MXdkVENoWGNuOEdGR1Y0NGsvNHd2MXcvZnpObllGL05OTTM4My8vOGh5WUNFakJLVlZJQitSTElwTzVsYjN0TW1oNmhabFFEUHB5b0JpZFNGQVpUbEtGRlhUQlNHVXFVcFRMMHFCRSs2bEs4MDFTcFFFVXFVb21LaFRqZ0FRNm1NQ29hem5BS3NDSUJySERGQWhSRUFQOVh1TEtWcm94RkxDTFdhbGllQVJheGpnV3NaVEd4V1JCNDFyWXdZQzFzU2V0WTJab2lCSzRscm5CNXExd2FPMHE2dkRLQW44eHJBRjFSMTBHTThwT2VrQkVpUG5uanZseVNrWlJZQkNRYndTTWVEUVlVbHJUa1lRcUJXQ0EveGhBQWpNd2c3Q3FrUml6bUFhaXc4U0hwaWxkQnd2akZNYTZ4QUFSNUdTYVRBak9hMGV4bEVIaktKNk0xczJobFMxb3g4MEFIUnBDRG5La2xGMFRvV1JlV3dBS2hnZElvV1RuYUFhaUdGNzB3TFd4aVl3elpkRG1ac0cwTm1NWDhaZG8wWTdiTmVBWnR1ZHBWM1hhMW5lTWtUakxQVktabW9oT2F1d21ITlhIekcyZlFWazNqcUdZRjJYR081SlJqSEdpZWJaMkpxNDREZEpXQmMrYXFuSlAvQ3h3K0haQzV6S1dubjVycjNPZkFBeC9wRUpSMHBIUEE2VkRYT3Z1b2JuVVVzcDN0WmllZzJuVnFVcitycUFnVk5VSVFEaTk1STFyVVJ4RkZJaEs1cUhrMTBoSDJBa1VqbFhLdlNOZTdYcEZrT3I0Zk5Xa0g0eHNma3hJNHBqSm9pVW96YUJMNGVsb0c5UWxqUzEraUgvK1V5cjhYS1BVRlRWREJDNW82UDZqeUw2cEhYZXBTanpwVnJNNmdDVnE5S3BlU2VqLzk5YTlMVmkwVC9zQkV3UEYxejNzMkRTb0RaYVE5UVFscFNCS3N3UThzZUlFZlhHQ3ZlNzJVcFV3NFdNTHk3bEVWWlJXcFJnQ0N4ZkxnQXlRQXdReHBlS29jVmxhSEtiaFZabitvV1Z2eHNJZWYxZFd3ZUJYYUJUekFpYzFDN1JVZm9LMVRxbFpicXozVy8xZks5U3h5Wll4bWtFVGpJeTk1eVVwcVRJM3BvaGdaNGFoYjNSSlNZbm9zR0VZcU1ySGxlZ1NRRXhNSUlLV2J4MFBlSkpFeDhTTlEyT1dUY3JsclhtaWtKQ2QzSzhsTmRvVXA1dDNKYmpYcGxFMDJ4Wk13czYxUi9ES3RLdnJGTDlINnlnQTZnSVFjZE9FTWF1bFpMcUJ3QlJZb0lGMUw4UXRkbG1iZnZFQXRXQWZZZ0dZaXZJQ3BTVVpwU2d1V0wwdGJHYk05dUxUS2JNNHlTMHNzeVNnTGJYTGpqT0xZcVp4cU5zYzZJU1pjTmRNR21oQlhMbGZXNUJ1TzExYk9haXJ1TzlZRW9xNmdxYmp0N0FvNWozT05xMXlUcSsyQTV6dmNnZktySEVDQ3dFRjVuNW1iRHdyV0E1NFZiSm5LcnBNTzZEaEZ1Z054aWdSbGRpeDlVdjk0b040NWxxS2RpbDJuZWljcHdacFFvNVlDNllNK1NpSkVTVkJRbnFnUmptcWtQZXp4UWFiWU0xSUNnK3JXUlgrdmZPVHI2Wmh3S3I4dGpXbEw0TXRmVnIvcTFmazV0ZE5UblNwVGx4cnFwMlpWMUpybXRLbVRRRlZPUC9XcFczcDFFbUJkMVUwck5VendZNStaS0MxcFM4OHBnYi91M2dLUlpDVHRYZSt1Zk5WclgvMjhvZ3Rhc0FZcE9wUUZGVVZZRXhXMnNDR1l3QWcrZ0lQSE1yWlRKRmpzcUhCQVdjaUtTbFhuenFHcWVMaUNGUENRaHo2TXdMdFhBRzlnOGRDMHBXMWlhazJyYjlVeUMxcmEyc0FVdmVVdGNjbDJBOWlhMmJNTy9pNDRmbmUzWDFTanhoWWlYSXJIa1NGbG5JbEo4dGpjaWRuRUlTQzU0Nzc0YURIL1BqSlN1elh4Q01STWpsNDN2b3ZobXFUWnVYWTdSdlltNVZ6bkplKzgyRHZLbDEzcmxKdGNDczA1Q2NwdG5USmIzbEtBQWpUd2d5NUlBUXBwZ1NVUmN1QURCV1FSWmdtZUdyUzBPSzBOQjZzdnl0TE0xeTI4QUMzMlVqSVJWbGF3ME1aTVhkRk5iU1ZPKzRjLzdKbGdTWE50UHJibTI5dnA0N1p6aHpPeVVaeGs1TGtjeGNsTmNXOER6VDJWSStSZDJTcXppYk5uRUNXbkt5SjdaZ1d4UWM3Z3FoeTRLc1BxeXZ1ODNKYlgwMC91cE1vQkJ3TGQ2Uk9hVUlXZW1YWnBMalBxVU1jN3gxcjdRU0s4UFVlbnpjRnFKNnJQZmxiUnNvbUVhSm5TNkVnMUxiNlBoajJsWWJ2MVNYR2xVNVI0cW9LZW5xbW5hTzJxcWIvcWhsVkwvelVKTC9oK0V0d0EvdkdUSC94U2JjSUx4cC8rSm5EZi9XNUl2L3ZGSDM5WHU3LyszaisvK0pNUWZ2R1R2Ly82bngvL1k3WDV1U3I3dWFvdXNaK3lPaXYwVVNBNlliNG1PWkxwRVJLNzBoNFhXS2xCNmF1KytpdS9hcllPNHJORTZhQnJNeUVjMExiSElzRnRpNkVwa0tISEtyZkpNamZMUWpkMm03ZDVjemNVMElBZW1qZGFlUUFXNEpVSU1KWmxtYmQ5WTViVGFwYlNlcTFsZ1paalVRQnRDWmNOS0xobjBTS2o4NGxwY2FNemlpTjNzYmxHT2dvUG1EaUtFeTZkK0xnM3lqaU5JTU9PNnlOQllwaVAyNGpvNmhlQjRNSStJaTR1SkM4c2REbDF1Ulo0K2FTaW9LOXE4UWt2cWlUdTJnbmFvaStZT1RqMm9pUlFHaGY2dXYrVys1b1pyWnVXcFhDWFVxSVdLcHFpQ0VnQkhYQ0JNc2dCS09pdk15aURFZWdBbWJrV3JpT00wcklpYVlFd1hkSWxMU0k3VXdRN0NJTWF1Wk03c0NNYnNDTXh0YXZGWGFtN1l1RkZJVEl4WC9FeFhpd3Qwdm93cFpuRkVrUEd0Q25DV2dReHlRaThaenlieG90R3lOdXN5dE9zSDZJOEhiSXl5UUc5Si9NT0IwaUJLYnN5S3BPT2JSVEhjQnk5OVFDZEZTQ1ZBMkU5VHZFVUZFb2hUY0dVTlBzQWU1UXpPUnVzUlhrVVIzbVVRL25IYVlNVUQ4UWd2ekxJZy9RelFKbVJDVndSUTJ1Z3Q0SSt1RUlnSmdFcUZ4QUc4RUVTU3R1ZjdPTWZLWmdCai9USVVGT3E3dnUrL0RzL0pWQ0M3MU1DOEV0SklrZ0NsSHdCSWxqSjgvdi9BdkI3eVp0OHlSZElTWnRzU2FueXlaLzh5WmY4Z3BUY3lSZW95WjEwU1pZMHlmTXp5ZkxEUDUrTUtxa3F3SzY2SHhlUUg2dGN3RXNURXd2RUtRZXFRQWVha1I4UXl3dklBV1V6Uzc1eXRtWXprV2lMRkxZTVNHN1ROaDFRRkc2RFN4akNBY2FDb1c0N014bWlyQlhRZ0JsQ3R4eEtnUlZnZ2NGa0FSS0lBQktvUVdDQmdYcVRsVjdCbFdHUlRIN1RJa2xrcldWcHJTWGNnRzhCdUtLN3BDMTh1SWp3TFRSS0wzaVJvNCtyR0RJS0xwK1l1TlpVVFVYS2lEYkVDTmwwaVhKeHJrV2lDRGtrT2ViaXdvaGdsKzM2VFRJcWwvVHlsczNFT2E4NHVFM3l1UUhZeklKd3d0MVNBTkRrbURYNm9nS2dMeWpjRnVZc0YzQ0JGdHN5LzdwVWpKYlZBcVV0N0M3WjZzN1Z3b0FIQUFzRm9CVlZ3UUVOSU1IM1hFTHh0TTZqMkphK3NKWW9wREFJVXhZTU93QlFJcnNvTENWVmpCWjhFN0ZrTk5CbE1aYlM2cFhRSXB0ZU9adGdnVkRKMU1VaHV6RmFiTVF0R3Jxa3FLU3VJQ1B6TXFWL2t4WkhoQzBxS3FVUzdiZGU2UlZhUEJ0NCs2RWRzbEJYNGJ4YjRUeFYyU2ZMb2pJcTQ2ZUV5bEZ4OUp4VzRRSElZcFZNRVZMNmtNY2puVDBTZUN4ODVCM2RHU3pmQzBGRmdkSnFJMGdUQVNtRW5CRzZFaFF0elo0K2NSS1orcDZiY2hLYmNoUDFjWkkwMGFxUE5MVXRxYXBWbXdFM0VEV25CTXFnVkFLWmRFa2xHRW83cmRPVU5JSXZJSUlpSUFJalNBSWk4Rk0vQmRRa0VQOVVQdjJDSkFEVW9md0NRWFZKUW0xSm92VFQvVU5KUjRWVVJzWFRSQjFLb1VSSlBLM1RPWldxbWd3L3BnVEtxSVNxcE1LMXEzUWZyT1ExcXh5ZnJjeWVyOVFlUGRIU0hDRExYSldCREF6THZFckxhS3VCRVFEV2Fhc0J1cFJMYlJzQkhDaldEOUEyYmdPM3g0Sld5Qm8zRlpRc0RmQkxFckJXRFNqTWMvT2h3WlFWZDRzM1dtbk1jVjJpV2t3NzFOck04UHdXVXFwTWNObk1EVGk0dU5pSjFWSVhsaWdJb0lndVAySkRmckdKTXZUWGx1aVhmNVhOMlNURGdNV2pocWlrZ1dqTmU1VWtLL1RRbnZDdUQ2VzQ0RXlYZ3h0RnBwaTVBaEFhVEdKT2Qybk91SGpPanAyWEtMb2tLcXhPZ3ZDVzdnVE5RNnlpenZ5M1k0RVdCZkQvQUM0U0dndzR4YU5iRnJBb1Z4Mk1BSUN6V0tXWVY2TUxUMnU1cncrclJRSzF6MlV4MnFWRnU2VmQwWE5kMmw0VXJRamxqQWY5c0tPYm1ZTmIxOUxrQ2pDRUk0MlIySXBMcjlLTWl3S0lUaE9sTDZNejJ3MEFpd0VBV2RqcU4xTUNPR0NoMjljaUlsczVtMnJjTE0yaUZSL2FPMnJrckhTN0ZWZXByRlU1SFJNQ2dSQUFnWEVidDFOcFhISmJYQks0UzhNNkxBNzZSeW9GS2JiMG9FVGhRSU04RVY2bFZhK0UxZEcxeWlISkFSbVlOS3dzZy9pcFBpNVozZjVSS28vc3RFL3pxcWFpbjZiNnZ2SFQzWi84MUUvTlV5UEEwMEQ5VTU4eGd1RWQzaUpBWGlNd2dpd3dBdVJOM2lKbzNpMzRBa0NsM2tmMTB6NzlVME1sWHAvaC8xN3NsY2tpVUFKQUZWVHduVjVOUlZSSFJWU2psTW1oakVtZEpBS2ZWRW1kQk1xU2RMV3BsRFExelVReUVSTXRJZDM5NWJVOG1WV3ZYQkh0NlN1N01zc012S0RPYmJZTUFraGwzYllQMElGZzNUWmhwY3NISmtFbHhXQzlwQ0YwTzh4dDFZQnduWlVRN3RzSTZJQyszYmVBMDdmTGxDS1ozVXkzL2RDZWtBbm82b2w3dlFaS1dBaDFvYzJYWUlnRFdJRjlFVGsxVERsQWtoaURqVTBpL3RjakxzT0lhRGlmcU1LR2hTT1g2OUNHMVJpT05WbWthRTc2R3NRdmVrNkNlOWRMTWpCeHlSaDU5U0lEbzg4dDJtSnArWlkwOWlJbjNPS2dmUzNXNnN5T2ZSYWJwZU4rRXpodFNjLzBCQXNXbUFJKytJRDVCTGlhcTVhYlBhWG85UDg2QTJVYUFEM0ZSV1RSdER0Q0swb3RmTk0zZkx0RlNRYTR1RkE0cytVdEw1emhpdU9KSy80SzZ2UUtUSFpPTnpJd29VbGpyVnZDbnh2RmY3TlllR1dXZ0pQbEtab2llRjNQOUh3dHVwVlFJcEpRQnUyaEVjWUFuaFVXSW1wTVdmbmxDRWk2dmxXQVk3WVZ6SEs4RkFoSFo2NlZ3bkc4Y0xWbUZNQXNFa2dCYlRhVnlCV1ZEd2dCQzdBQkc5Q0JFaWdzRDBKbkJtNjJEQlRMc2NUVkhJQlYvaVhkN29Ibk1vQlZLWmkrK09FU2o3eStySm9xS1hnQmdCNi9BSVRmcFJ6VW4reFVtYnpVT3YzVDRpMkNMVWhlNXBYb2g0NW9pTGJvNW0xZTZJVmU1alVDaUZaZTdSM2U2L1daTEREZVJqVUNSQkJlak5ib0luaFVsZzVVa1BiL1V6MlZhWlJVYUoyY3lhQThWYWtjazl0MWdWYU5uNjNFWjE3ejM5QzExUUZla2JQVXdBbnkxUTVrNm1BRnlHWjlGQXFlWUFnZXJBc2VBWEFqTjFGSnpNUGM1c0tzRlJPT2dQUThGbHArQUxpWW92VTBzS3FMemxPR0xlUmtZaGR1bzlTOENCNUlBMSs0NFRMNmxvdG96aXFFcm83TFlZcnBPSW9BT1RnY1dDTkdZamc4dzltTW1DcGtiQ2FHWWNmMmlqbUd6akh5dzFHQ1FxT0lUck10bCtjYzVBUFQyTS9PN0FIWVdBT2p3blRWYkZLR0FJSkk2MUlpaUdjeDVIbE40KzFNQ3ZXOG9xMUR6NERUdXRoYUZvRVRhN0V1Nnp6V0FENXdndzlnem1CNTVTcjY3RlBTWXBRbHBaa0J6ZnZjbHM3c3QxaU9idGlxbGprK3dtcFIvNjNLYkZkdDBWZzJaczd3MWxwN1dSZmpGQzZOZVpiU3pKWlhsaGFmWGEzTm5PTWx6S0t6OVlEVjB1NDc5aFl5NElFalJDM2Z6dVBmTHVzSDZBRFRLbUdscGR0aGxOQ3ZwaFZhS3VFUmJrOFFmc3dVQUFCclNJTUJtQUVkVUlZV1lJVXYwSklpYUlJTG9CVm9obWJFREhFY3JKVjNzMFJzdGtSb2pnQU4yT1p0UmdGUlNZRnhDd0VxRUFSRk1JSWhzSUltc0lBU0lBRWZ4NEVnbDF5NlROWVRESElIdG9FTFNQSjJGc3Q1SnQxTVZLcWVmaDgxQmNrcEI4bUFubE1oa0tyM1pVbjZEYitkWE1rdzMxTkVwV25nVFY2TFJ0NG9LSUlzWUhPUFZ0NHR5QUlzeUFLSWJuTTV6NElvWUY0c2FGNDJaL1BsUlY0NmIvTTFmK2psN2Y5b2lWNWVORWR6NVYxcGpWN2VMQkIwNkZYZWpuNVU0eVZVUGYzVW5GUktxUktDcWR6MEYranBubDVkS2NpQkhIQWYvdDNLMGMwVExUMUx2a0kyWDBYTEJWNWdHd0RuUTRsUFpvMVBhdlh4WFA5eHlkVm1iTjNxYllhM0Q3NFZCWGZ3RGVqWnNDNXJGS2JscER2cnBIUGhxdnRzY2VFSmVmMUNBNHRyc1RYYlNyb1dnTzFDSnU1cnd2WnJ3TTZ1aVREWXdqYkQ3SXJOYysrWGpxQVhneGdZeUg2NVB3d3ZQdndLY0ZsQ1ROYVd0cDJpZ2dPTGZUZWw2SnpqcjNEQzlVUlpOWWJYYXFsUDQrd1c1a3p2MU03MkZlQUJHTkRqbzlDV2J4bmthSGZDZVQzQ0pGeVcxN0xaMU1MbEFDOVhQU2FCUENIdVZaWmJnTHZzbzNnVzYxei9WNWdWVDFoMmIrbnVUT2wyTFdtcE9yYnRlQlNsZWR2R2dHVnZXemF1MlZQdVpJU0hyYkxWR0pCdDcrbEdWeFM5N1JLdDVhajNXYnBWZ0FZbllicXROeUhFZWdkMzhBRlhjQmpOd1hCOVRBaUh0Mkdmd2NNa2dRSGdna3NvZ2J4cWdoWXdnU01JZ3ptNEFTRndBUjNJa3pSSWd4YllOb0c0QUI1SGdoSFFnUm1vZ1hJT2dSYXdBQVZ3Z1JZUWt4YXdnUmFBL0JIZjVrMkJadmc4OGhFb0FSMG9jaHpRQVFlZXkySlYxZ3V5Z1FsSThxVVd5N3hpOG5ZdVMzZitBUmM0M1hyT1gzd0dTWkJVMDZaU2dnMEg2QzRJQTBNd0F5NmdncEFVVlMzSEdVMFhndDRGM2tEZDg0Nkc5RWlIZEVFSWh1Yy9oa1JvQTBFUUJTcndBaXk0LzM0c2lBSXM0SDd1ZC9RNDN3THVwM002TjRNdHlBVTVoM01zMkFJakdBVDE3Mmp4M3dJdjhBSXo4QUlxYUFNc29BSXpNQVB1YndTQU1JTmw0S0NCQnJONHlhSVFTNVlpRG8wWUlXSWtpUklsU2I0a3VVaUVTaEVsTHo1K1RGSWs0NHNrVnJMa3NQS01rS0NSdTZ3a1VXR2xpWXVhTGk3Y3ZIbmh3ZytlUG52K3FPR3pCbEdpSDJwOE9Qb2h4SVFRU1hHTUlBRlZLZ2tTSmFhVUlJSFZhbFVTS1VoRTBCQTJRZ29VRWM1R1lHRTJ3bHEwRVI1RTJBQVhnMXdNRmpBOFVJQkJyOTROQ3ZJT1VPQkJ3WUFCQlFvZk51eEJjUUVQaVE4RFNGdzRjT0VORUJTZ1VMQ2p5UWNRQ2dBQW1Dd2E5QURRb0FPWUhvQzZOR3ZUcVNPVGR2OHRlM1pvMnJaakJ5aWRHemJzd29zZkRNQlFnSEJoREtLTkQzZ3cyTU9HeFh2ei9sV3dZUzlmdW5qMzBvM2VGNjlnNDRzOWZHOGNQTGtDQ0kzUGgzOVFBRGdHOHg0Z1dINndZc1dENlhMLzVuMVFIMzc5NUFXYUR3QUJCQThNcUYrQkQrRGxRWHY2TVlnZ2czZzVxRUFFQ3JRZ1JBNGhXQ0NYWlhMVjE2R0g5MEgzRjRjTXhxV2hpWG5WNWVCMStYbllJSVJ3d1JBYUMvcFpaNTkxZVYyMzNRWW5TbGVqZFQzYUoxMTBPMHFYbjRZTmtxamZXMGdxQ2RjR1MwSUpsMXRwblpYQ2xGZGV5UUpaTEtUUVFWb3BjRGtXQ3hwNHBjRlhacGFKcGdaa3Nya0NDV3UrQ2FjR09KU3c1cHgwbHBDQ0NSYVVrR2NJWk9JZ1ZRa3R2SlQveEF3MXRGRENEenJvME1NVFVGelJCUldKZEtKSUlvcW9NWWNhYXJpd1N4STRXSEZCbnhiUUdVSUxPT2hRd2doTE1LcERVUmNVaGNPaU5RVDFnNjIzQ25XcnJSZmtvT3NQTXVURXF3ekM1dUJDR1RVSm9ZSUxVcmdnUkxNcUNDSEZERks4SUVVTzBzN3dRZ2s1dk1EdFJRNVJGQkpGRlNuUjBTQnFGR0ZFUlIwWmtTNUVXMERrVUJFR1lSSEZGbEhVNjRVWGRlanJ4UnRlUEtKRnYvdGlvUVVXVkxTQmhSZHR0S0ZHR0cyWW9RWW1Yc0NoeUtSd3FGRUhISE9Fa1VnYm1HRFNCaHh3ZUp3d0ZtMW9JVEljMFVnQ1J4dDExTkhHR3lrTHpLOFhVVkRSY1JaMVpHRnlGbGhBTkVnV1hDaGt4UmRuY0RHSEVCV0I5RUt5eWJvdy84T3lNd3dSZ2hNMllZMFRUc0hxdEZOUFAzbGRGRkd3Zm5CQlVraWR2ZFFIT0VBMUZRNVRWRFVGRG1TK1diY0dMS3dBSnBoaG9hQWxsVmhPMmVCYk8rTGxsd0tIUzJjZmNKZjU5ZDhBalJjUStXS2lUUzZhNVlZOVBwa0NGcENnd0F4Y3VHQkJZRTFNRUZwaEFKeEFSbXVHN1ZaQWJhdVZGdHB1dGNVZWUyMjMzM2FiN2F2RlpycnB2bEdtd0dITkVZYWNjY2NEU1NPVEtpSzRJbDFHV29kQmpnb0tSaGdFQXlnWUhHSGZmWmRjaDlNbGVCbU8weDJPbzE3TTZ6ZmQ4Z3pDZ09TTHppdnZGZ1orZHdDQUdxZzhva2tpQUhpNTQ0UkxMazk5MkpITDRKVEVJUUxXSlVVTzZzQURMT0FnQk1aRlNXK0p3RjdTa0FZQTZDZ3UrUDk1RUFZb09LTDF3U1dFVGVMUVcxNmtJUUI2YUlKTlFvRUlGOUFrRlVZcGhGUFNrcFZvZUJhL2FRa0Zib3JBQ203SVF6T0pKWWgzVzlPWTdHUUJDOGdwVG15aVcxY0V4YmFzdEVBRFBraVVCdXJrZ3hMUXFnVUFhRUVJWU5LQ0M0U3FCbGJZZ1E1WVlZVW5tREVFRjVCQ0RYb2dFaWtNZ1ZXTXNNR2dRbUNERUF5aEJDRUlBUTRTeFFRWkpLRUdJV2hDcUVMQWlpODBhZ1pmcUlFT2ZwQ0VKalNTa1V6WVZRNTRkYXViK09wWHQvSkpUWEFpQTJBQnF5WlNVTUVvU3prRGFLbmdCUzZvMXJSbWNBWXB1S0ZwSUJFQ1NKaVdrWElweEYwU2dVaTgwalV2SXpEa0lBTVptTUMwWUV4QWFBR1p4alJtd0FUMmlIN0ZMR1p2ZUZuL3pCaFdCeTN3S3dyNmlnSy9va2xOYVRMTUREUmpHTTIwWUFhVWpRd09rbWdFSExRd3NtSW1nZ28zRzBnVXNtQXZJelJrQ3cvcGlFWG14Yyttb1RKWnFIeUJzckJtVUt3cFN3VmE2OXBPR0txMVhZMU5iRW9oaWczV05nS29yRTByZ1pKYlZlaTJwaFhjVFc5YTBrQVB0ZVEzd0tHbFNmcUpqcFA4b2pnT3NYUkhNaTJQWWk1WHVja2NSaktTS2N6aEFrT2F5R1VPTVR6RjNIcGM1enJEa0s0MkhhaUJER29IR3RlOXBuZTNzNTFybkZwVjFwd09BSk56RG1DT2c3Z09za0I2Y0pNZWRoeVVGcE5HQUFZOG1FSUVZc0NIS2RDbnJOakJRQWNVMEFFWU1KQ0JaRzJlWHZTS0FSaUVGUU5tVyt2ZFZnQlh3dHpGUlFpYVVKSGUvNkpYQnpIb014MU1pMklmMEQ3OXpBZ0dhUzFoQi85NkhTcWhOUUlkWUlFSk9xQ29GL1RBQWw1NlFGMGxKTnEwMUhXbEZDek5LdElRbUJJcHFZUG5ZK0FDVmFTQUtmRGdNMlN3eGdkNHdBUDYzSkFFRjRYT2FFUFRnZWVGY0M4c0dFQVR5QUFBRnB4dlFpR1VFQXVtaTBFTG5PVUJZUHBMQjZYVXdRMTRhUVVkME1BRDByQ0NTMXhBUW1hQmdRVmNlNWEyQUM1dmFQSFNhMjhvVXJLQWxJY3BXQUVLeE1JbElJSkpBeDFJZ1ozT1JLWXBSQ1VGQTJnQkszYlJBaG1naWs0YUdFRVZONndCRTlUV0NqVkF4RVdzMEFOV3pLQUppT1JERDJqbHFoSjh3UkJXMk9NVGV2Q0JGaXhCQXdvb2dRbVlnQVFMdEFBSlNGakNDRXFRcXY4U3NPMEhOcWdCMjFERnFCRmNWQWRRMXNFSG5qeUNWdldBQ1VUK1FRK1dzS2hGOWFCWE9uQ0JGVnlnaHBoWVFRNDVrSU1MS3Rtclc4bWdCM0grNUs5cThra1hoTkpZVVpPYUZKSWxMU0hNQU5DQS9uT2duU2JMRjVDckloUkp3a1RjNWN0MnpRc0wvcFEwdmVqVkJpOGdySnpHVEFRY2J1SHBVdHdDRXBEd3RCWWc0VTUzSW5ObVdwalpHeG9oaVpsZE0yVXpReGs1YVgxcWRKb2hETkV3SnpJQmtjNWZ3d0VRYitqMUcrcndoa2Y4YTJCUldEWTl0MUN2S0x6TElVUlFneUR3UlFVaDBQSWpxWHhhUUp0MVVJTW10Q1lGeGZNRmhxV1RjNTk3VjdhaVZVOXNjQUYzdHdyS1U3bm9SZVcycGpyWktkOUtKT0tieUlKZmxLYi9sTGNSY0NCak5kZ2hJUkhKcGRGQnprMERNeGpLYk9CeUVTY01jWWh6bU55STVxaEdMVXpyQUlBYTBxQm1CYXlnd21kTUo1ZWRna1lZVGFncWJXcDN1c0lNNkhxVFlVRU1CbUNCSGt3QkE2QTVIbWdvU0ZZU2RMZUlMQml0R0hTKzErNnlsb2dCQ01BZnNCTVlza3B2dEFyZ1F4SUcwSUUzc1dBS2F4b0JDM293Z2krY3dxNUQ3NEFZeEtEZ3FJL3A2a0QvQUpTbklJYkFZb0FQZnlpREcxaHhDcXRQa0t4SEdVRVRtb0NFdS9uQUIzYzdhMHJSMGwzWStsQjZvdTB1bVVDNk45RnFvQVl6U0lJTU9tQ0NFbEJvRnhjc3J3S2FJQXdGa0lBUEgyakNCWXZEV3VZWlJ4ZzdHTURmRnF0WjZXa0ZMSi9wZ0p0NmlCWVM3SWtGLzU3L2pDSHVEbG9TQUtBSmxHaENZUzdBbVYxOG9MNDdxUGtGTHZnQUh1eUNFcGZBb056ZzhvRzRKRVZDWUNudlc3cTd3UW1lcGJnU0NtSGZETS9mQ1IzUjZoM3drZy9PSXBZYUpoZ0YvUjRMV05LeXhBL3ZZQmM5YU1JTTBtQ0ZJVmdCSmFoQUMrU0FUQkNDTE5oQUZ0UUFFMXdaMjJoQUN6UUJLekJCQ3pEQm9KakFFRnpCRXp6QkZYUlpEckNDRE16S0NDREJxbkJabyt4UkhHeGdEaURLSEtEQ0RjekJET1RBTVZpQkZSaUNESmlZRHJRQUpiQkNDOWlLcDZoQUVhU0JDMkJSR2Z6QUNMaEFEMGdabGkwQmpqVktFekpTbzdUWkQ4VEJseUZoQ2NSQkRoUUxGaVNCRUlSQkVlQUFGdlpLR1A1QURnQUxHTlpFR2FqQXNmK2dJYk5JQzdVVTJneGtTN2JFMGd1Y3dhRjVoRVVrV2thTUJLUTloS1E1QktVTms4SmdtanhOQ2hWd2dScFF3VEpwQWFkcFFhaEJBakxjQVNuY0FTL2NRU1VpQXpMd3dpMUlRaWtFVzhzQUFpQ1VBaWhLZ2lldVdqSVpFeHl3V2h1azJpbU9EQ0NNb2lVTVc4czBRaU1jQXpFY2c2dUZJaWJjQVNBTWd5VGN3VEJBSWkrOFFTa0VEQ1JJQXlUa3dhaDF3akthR2lROFFzeEFXeTZBd1RUK2pDeXQwalZ5bTdNOGl3c0UxTGlKbXdxQUk1K0pHemVTSTlZTVN5VzV3QmdxbVJVVVFRNWNUUW1RbVpOQm1ielJXOXZVWXoxU2hiNWxoZDI4eVZlVXhZRHhrT0ZOQ1hnUlpGeUFWMkc0UllZa2p2OGN6dkVVUm4wb2lNSk5IR2oveUZScUNJOWhwTWJsZU54VFFVYnRSRTVPU2NaVDJZN2xETThBaElBU1lJRWhVQUVBY01FRmNjRXVwSUFoaEE3MlFJQjNpSWZNVFFZSmFJUDB3UUFHTU1NMkJBRVJCQUVYTUFNR1ZVVVBhY0FVYUYwRXhNWUhXQUVYSk1FcHlJQWRZTURiNmR3bHZBSW9DSUFkRk1ibzhjRXBrRUVUckVJTWpNQUhkTUFVbk1Mbm5hV08xVlhrbWNBSVNJRU8vTjM2ZFlBUGRCZVVEWjBDMUlCYXJsL2FhWUJzZElBRm1JWmR2UkJkQ1dZVHVJRVA5RUFYRUVFWDFJQWZSRVYzVFVGeEhSNy9nQVlMWU5CbjFGZGg4RW1RaVpGMXdXTUk2SUFVZk1FUW1FQU5kTjVNOEk4d2lOYjZVUWZGQlFiaTBPWDZBUUFpcElFQ21JQVBqSUFGbUlBSi8wU0FEM1RBM0t4ZmF3N2NCL0NCWFhWQVlBU21ETlRBTGxnREFKekZnalhuS1FBQW1iQkFWWHdHY3E2ZmNmTFhlbTFPV01CRmZkbFhDVWtJQTFIUStFM0orVjJKREtHRldZQkdZTVpBR2tUUkFPekNMbkNCakNsREUxaUFTSUdKQ1J4WWdrWEFDRnpBbVh3Sm1XUUZ2bldtQ2JTQUFvd0FZVENCRHZqQUJRS0FEYVRqNVNFQlZCeG9CN1FBMyttQUZSeEtuOEJoRDRUQVJWaUFEc3hBRVVMWkNDS0JsREdCSUdpREUzakVFOWhBRVdDYkhIUkV0TlRZSG5FQkY3U0FEdXdScWhEU0UxREJEeXhCR2p4b0NjaUFHeVFob3dpRmlWcUJETGdLRW41U2wwbmhGZjVBQ0tpWkRTeUJIT2hBSEtoWkhBaEJIRGdCRk5CU0RpZ0JtZitlZ1JCa2dSQkFnUlRjQUp2ZHdBMUFBUlJnb1JRUVdyUUFXcHFtYVMzVjRSa29BUkVrbXFKTmhMcVVpN3pJU3pBdEJMNHMyOERvU3p5RlFSaGd3aVJNZ2hvb1Fqc3BncWgxd2lQZVFTY01BeTRjd2l6UUFpMDR3aWRvZ2lONDZoMEF3ekQwb2lRQXd5Y01neWpBYWltTTRpY2N3aWVJUWl6aWdxdUtnaVRBcXFzQmdpZ2N3akxjd1NHTXdpUm9BVGF3NmljVXd5aU1BakR3QWk0Z3d6RGNRU25jQVM3Y3dSN0F3aXc0d2lGb3doMTh3aVM2QWk2UXdpTUkyeHNNb3lROEFqUXNtN041QVVTY0FhR1NDNkxWVXRNa2kwZklVcllSRkVIRkJQL3gzd3VjRWh6KzY3U2tJYlMwMlNwWlNJMDJTdzVrUkEvTVNvdTFrY1AyQUJML1V0bkVRbGtOWEpSeUpaOENzTTFGWVpRRmhBREhNbGdKSEZGMXBnQ0QxYzlYV0lXUjVWdkpOc0VKOE5FRnFOSDFtUVYrZ2RXQTlkQm40SjBHOUYwRXFDU1FBY0FGeklFVjJLZFBOY0VjWE5BRldBUHhuVTRFWE1QS2xRWVpySjUwUE01L3JNZDhFTVpPWFE1SWtrWnJ3RVlLQUlBaWRJSVRZRTlydUFBaWhFQU1OQUVQK0k0MWdBSlZ5WVpHVGdZQVhJTTE4SUFuZUlCc3NNQW5ZY0JnbEJ4bzFKWnJUSU10ZU1MVzhwU0FFc1lIVEFFTHBFRU9uSUVNWEVFV2RNRVh2TUFTektBbnhNQVU4RUVRektBV0FVQWFUTjhlZFVzWXJJUXRWQU1BZU8wdW1JSjFwUVhRc1JZQVVJSTJnTVlNVU1JcURJQUd5RUFhZUlKZW5LZjAvd0JBR1R4REVYQ01EV2dERlRSQkdPaUFJYWlCSVZDQzd4YkIvVGdCSVdTS0lOakFEYXpCTVdCQkN4Z0NIM3lCTXRTQURuN0dLbEFDa3o2bEhERFNobDBaQjNacEVGekJFVnpCRWp5Qm1wMkJIQXpCQ3dnQ0ZRd0IrZklCcll3QUh5alNCVkFORjN6QkJSaENFOGhtWGZrQWd4MlJXQnl3U2VuTm5FU29tWVNGMTFZWS82ekpuZ1JaQzNqSmR2SUJTUTNBRkZnWEFNeEZkTGFubGV6WDMxQ0pEU2lDSVBDUHhhNlhCb2huYlNpQVNQa25jQ3J3Z2RsZkJBUFJ2UmtvUDJyQWhkNWJuM0RzMnp4UmtjME5WaVJsVXRZSmczRkZWc3hOQ0pTSlZkaUpWZEFKaEgxWUdzZ0FFY3hBUXd4QkhEaUtEZ1FCb3doWmZkVUpra0Vaai8rVndBQmNrWWVad0V4ODdFV05JS3BjMlpTdFNwRWxnU0hnd0NHcWdDQllqQkZ3Ukx1VWl4RFFxQkFZQVpobUFSRGNnQkpBeENZSVFTS2tLUmFZd1NZY1F6QTBRaGlvd1NEMHFkUGtUQkVRUVJhWVFSWlFBUmJzVWloL0FhRmlRVXNJd1JkOHdRMkFyUk9BZ1NmWEN4YkFBU2JBd1JaY2t5TGNBaWxRQXkyTUFTVGN3U2gyZ2lpNFU4VW9BcXlPSWpMMEFpMW93aUhVcXJRZUFqZElLalhBUWpMd3dpenNRU1pVSWlCNEt6QWdneWhVSWpES3FybitZaS9ES3F3S1d4M2dBUjQwZ2lqVVFTTzhLakFVQXpjVXd5ZnNBUzVZcTZjZUFpWmdBN0NpQWloT3F5aDhBaStvQWlWcXdqRHdRaklmZ2pSOFFpY1lFekxBUVJSc3lxYi9oWUVpbUlFODhaSS84UkkrVVlFUjVJSVNMQTFFa010RTNLR2llVVJHM0ZJVGZBUmlvclFieklBYjlHdTJxRktadHBrWllpR2VNU3lkeFJtWGhWa2p0UmlYYVJJajhWOE5BSUFoUElNVDJNQ1UyUUQyV29IR1VvUVYyTUFoR3NJU3ZBQU9EQklsdkVBSW1NQVNLQXdZQ0FFU3BFQ2VNTmpjcEVDVFdjbHdrakJhaUFVS2xDZ1ZVTUdDOWxUSmVRbDRZVkJvVUZCOXlUWE9UaHhrQU1EMVBFQm91QWxoUk55T2RHUm9ZQzBBeE1BRnZNWklXczdoQU1BTjVFSnl4STRGck1FelBFTWE3SUpyRklET1lTUm9RTUJzVkZmdTJBWU1UTUZzTUlNeWdBWWlyQUlvL0FJaTNNQXZWSU1oakNUdUFJQmZ6QWxubG9BUEtJQVBsTVl1LzF3REFPekFCNERHQlhBeUZEREVFVHlxRzNCQ0RsQ0JJZmpBenhJZmNXREFDc0RBWlB5QkorekNLdHpkYjFIWGRHbVA5Z3dHY01RMUFPamNHbitCREtTR0NTaUFxUXlBQ1FDQVlBNUFDZlRBQytoQVhKL09GRVN0emkyVmhJQ0doUFNWbmxoZTRMWHhDSWhXQ2pSU0NmZ1lBSGhkYWEyZlhVMEkzZ25tNXF5M0R5aVhCZkFCSy9DQkNUUVlseFJSVitQZWcvckFENmdBYjFxNEN5T1Jxc2paZUZzQks2Z2ZVNllCRndEQUtsVDIzNnBuV0hzRldaeUZnbytGV0t4QUMxaUJMS2lXNEMzd2YvbU5tZmdtY05ybEFTTllnejF3aEk0eFY4eUpnZUxBaFNJWmtsMW9ocldORDA4QkVtQkZsbWVGbkhDNW1ZQjFuUFRqdnJFSldQK3pTZDNFWGxKcUJZZHBIWVFwVjV2VG00Y1ZHYjFkQlZUSW02cVFlQktVQUlXK2dCd0F3UkVzSWhRY2dScDh3WndDT2hkUUFSQW9jaTRBd1NFS3dTYWNBUndJZ2hrQUFSQmdteEZRSTd5Y0FSZ2djaElValJwd0FSamtBcjdVd1Jia1FzOU1ORU44Z2J0RUJCRzh3Q1p2d1NCRVF4MTBUQlVZMHhzZ2d5VzB3Ulpzd1N3Q0FpVE9naWFJZ2lUQ2dpTkFRaXdxd2laQ3dpYkNJcS82MmpJc1E3QmU2N1Erb3lVZ0E3U0tRaW1VQWlSaUFqQjBZakMwQWpDOG1pZ2dRenJQY2gwQVFpTUFBeWJzYWpXWk16SW9NeS9zUWEzeWdpdGd3eHRrZ2g0QXdpMjhRYjI3SWk4Z0F5bndnaTdRc3k2NFFpM2N3aVAwUVNiY1FpSWtncXIvSllJaFRJTXBLSVBEQkVNc2tNek5BTk5BK05ORkFKTWlJTU15ZkVJVWdNRkYvNkUvUVJ1MUNRSWxxL1VYRU1GRm9QTExzL3dMd0x6a09rMU1neUVXbGtHYkdnMmVmZEluZ2FFVWdpRERDbjJMTlZJakxjSDkyb29NUE1FUmdFRWlJS01XS0FMT1VNRWNGSUVOV0lBVnpNRWVtWUNuY0JFVFNMVUcvRWtMZUt5UXQ2YUNFV2QwMXRWWjBFVllBRUFTQ0lJS3NONVpvTmZtRkFtT1lFK1A4QVZ6WE1abFA4NkErQVZnNUxkUDRWVEdDZFhUR2NmdkRBQUk4SUI2WUU0RStEWUFmTUJGa29aZEFjQ0pOMEVJTUVNcnBJRTFQR2RwY0FFM1BLZHJORUVNeEFZUHpFRmxmNFlOQ0lJaCtFNGFhSU5nZ2dZWEhNTjltZ1lYZ0VKMS80SUF5ekVsSmN5QmFheDRDc0FWWVgrQUJyaUFBcmhBRW9pOUFwaFJFVERERUV5RDYzTEJBQ1FCYWY4czZRZUtiT2djQ0crdDc0REdZb1FHemdMSDJQNE9Cc1VtSFRBSUFKeUNiOTl0R2hEd2VsV2dEeHpSWFhTQUg2aEFFdmoyeTVtT3pFVWM0azhHUUdCUXNFR2dnb0VDQjJ6dzhDQkNCQllqWkNEQk1HQUFnQUVkSWhoVThLQkRCd3dkTEh4VWtFS0RpUTRtVUdyUVVJSUVEaDBhY0dnZ3VkTENoU0lmUXBpUU1vUEpTaHdsU0VaUW1lSWt4bzRkSG1wUW9OU0NqRjB6TEZqb0lCTWpqcFl5V3pTWnN3dEFCSkltWkdxSTBDR0ZqeFFtekU0bG9XR3RoUmxmRkxoSTBuU0hCUjBqVEdydzRVTkRpSk1XdUh5eFVNSW5ZZi9DUDBtVUdGR2lCQTRrTHBmb2tIeDNzY29wU0RSTUthRjVDbHVXTUZXR0ZyMld4TnJRS1Vpek1NMkN4VXpVS2t0UEtjMFNoK2JTSTBBdmpxbGJNMjRjdUtlMGdGa1pTWEhHT3VRa0h5SUV5Sk1lVU9SQXlTRW5qcEFiTjQ0b0NuTkVDSE1vUk1Cc3VnSEVpQm9uNTg4REVaSUxEQmdxVk5Rb0FxT0lWaTlhMUFnUkkzYW9HTGRKelZycHBaZG1KdUdtRjBXb09DT0xMSXpBb3BGR2lBSG1rR1dXYVVTVU81QUI1QTA0Nm9oa2kwand3QU1RUExRZ1JKTllwT21qRGkrMGFLT09ZNWFCWTVoRFprSEZFa0RnTUtPUkdMV1FKQm90QnNIa2syVU9LWElXSXo4QlJoSkppb2tSR1ZHT0JLU09LZXVBUTVJN0pBRWt5MkFhTWFQL2ttand3R1VXWUQ3NTVCQmFacUVGbHd4TFFZYVVPL2FZaFJBQkNhRkZFMDF3U1VhYU84dEU1UTFrTUJrR0dFVUVDVVlOTGFJd2cxQXZzQ0RrR1VXMGVNUUxTTUpJSkpnNk5VRUZGVUVnZWVRUkxSQ0ZKaEE5UEkxQ1VrYXh3TUlMTUtKSXhCWlQxRWpWQ2pYVXlHSVFRNDdCd29yM3FDakNDQ1ZleUVIWUhHUVExb1V5WE1paGpCeG1rRUdHWkpPOW9SSlRydWpCMlI1eStFSGJIM3JvWWJJbGxnakJCdTNhczBHT0s1NkFvZ2NtQmdOWDNMdDBZQ0lJSFJoNzRZY1JjR2hoaGhsQzZJa2tIeUl3Z1FXdlRFZ2hoUlpxMktXSkFSUUFRSUdvV3JCQWdSenliY0VFQzhheW9JV01OZ0xBNFlJRWVrQUJoamV5NElFTlJLWUkvd01BZUtBa0RRQk9DSUdWYWl3YW9JQUNQRkNnQUlvcUtzQmpqMjJ1aUdlaGhRYUFrbW1RMEptaWhocjZ3QW9MSEFZNkFnQjJoZ0Rvb1gyMkNPaWZmWTdnQTQ5M0hzQ0RyWDhHNEd1UHJRYmdnYUUzVUdDQkN4UWdZWVlJbm8wZ2lRODBha0lHQURCQXdvUm5jZUJXQ2hkYUFBRHFxVU1vb2ZDT1NwanVCU1BLTTRLS0pBRGdRZzBid3FBQ0FDdm1DTUdISFVEcW9BUUFUaHBCQjQwR1dHR0hGVmdtdytFQkhwaUlJUlRpemlnQ2hqdnlvYmlTTkdLaGh5YStpRUZyb29jZXV1YVJSK2I1Wnc5c0xtQ0RBVERZd0dNRlJyQUFsRjFrVWNaak82cEJCQ2tGK0FvQ2tTNllRQUlLS2FUSW9Uc3BoSUFDQ2lYaWlEOExJb1NJNC84SktzeDRvbkFrZXZCQll0RkRrenNmbUlRb0N1akFXaHFDRVF5WVlCVVg2TUFBQUNPTEFkUkFHQ1JJQVFwUzBKQ1NPTXlDbENsSndSZ3poWUxoQUFjMUtJbFBOR0N4RXZnUEpVd0lnY1Jhb0FPTmhRQUpROGpCRXVJd0NCY3dRUWZlNm9IcFREY1p5VVJHQjB1UXd3MTZjSVE0Uk1aYlYxZ0NFa1l3QWloV0pvcS9xV0psQ0lQRjJraU1KR3NoekZEQzBrWFJ4S1EwSkNUaEMxdlFtQkhNWmdwVzJjMUtwaUNER25UZ055YjRBUmN1MElJMEtFTUJPNkNFRlhyd0JPVElnUkUyOEVJUmJCQ0hHN2lBQ2w0SWd4WTZvUWhGeEtjVDB1aEVKellWREVFUUl4YVFVSVFqUU9tSVpHaWlFNUtZaGkxR01RY3VjRUVKWi9qQ0Vhai9jQWhOSktNWnZaREdIWVpSaWtVSVFnMXpnQVFjd3NBZ0xHU2hDQXZLd2pIYXNJVkJSS0VOaUNBQ0ViWlFoeDBsQ1JqREdJWW1nQ0VOWkpSQ0Q0bTRoYVRhd0F4T1lJSVpjRGdHSnN3Z0NXQ0dnWjFoQUdZampzR2xhSVFoR1B2Unp5SEtkQWhnVkZNU21RQkVLVXJ4Qmt2Z3dSS1NFRVdMdHRBR0xVU2lEbmlvZ3lXQzhRc3pFQ01hVy9nRUhQQUFCMUhBb1JPUUtNVW43b0FOVXVCaUQ4bTRBeTJJTWFkbUpDTVpqaEJRTEVpQkRFbjBZaG00REVZcjRoa01TV0NDRUtiZ1pTOXRRWWhKekNFUWlWQkVKN1R3aGtSQVlrOWpJSVVxYXJFSFBkanBGcDNBazB0cFFRcXRZcklUaERCUlJ5R2hKVWtrUWcySndGRVlHbEdKLzJOTW94S3ZzTVVjaWdDR0Y3Z2dmY3VhZ1F0bU1EajFRR0VJTnJEQkVJNlFBeWlFNEFoU3VNR3dzc1d0T1BUZ0J6bkFsaVRWZ0lwWU9HRUlRSENzdDRnVm1TV1VvSHowK3MxUFNxQURGU2hCRFVLd3dXWjdZaGFxak9BSFM1QkNFb3FnQkNIa29IQkRnRTh3NXVDRlBLQ0NFSThJaENJSVFZVVdGSUVLUnBBRERtd1FnaEFvNEFWelNJSWNmb0NEQ0dBTUJSZmdBY1lhd29JcC9NRU93dENBR0ZpZ2dLWTF3V01zV0JzRWdvYmVCeXpnQVdIREdVVmdzRGFHdFUwR1NTZ0RGQVloaXlDd0JRRFNzd2pVQnNDQ0Q1REFJd3J3d00wcUFnQUlxQ1lDRzJqSTg0ZzN2T0lORFFVVnNZSXRyQUNBUzZ5aVpnQWd3UTV3VUR3QXhQL0FGSlFvMjg4cVFna1RHODBRQUVEQnoxUU1nQXRFSUEyeThJUUIvVmN6aGpHdmFNY3pRWEpia0xnZ3gwRjlJV2pCUkt3aERJY2xMeUZCYXpMSmdyWXpuVzJnQUFjeG9BRjdFSVFhaklCakFwWkJFNzVXTk9LSnpjbGk4NWtuRERFRkY0U0FsNlFibUE4R3dBUWZCTUVRMWRBWUFBekJDWXZ3Z1JqbmpJWXRPUEdMRzhpQ0U0ajRCUlM2OEFST0dLRUZRempmRGQ1emhodElZUk5QR01JTndpV0VhR29oREp0WXd4bzJFWVNFWGlFT1hXaXREMVlJRXdBazRRSVdrTWthcGRzQkEzYUVCUll4aWNSazhBVW16Q0FOd3BITTJUU2dBOUdCZGlVd2NVeE13Q2laSmlSQkFTWjRRaFo0dFVvcHZPQUxXUmdDRjhMUWhCYUFDd24vT21nc0Vrb0FyaDR1NFFsUE1JRU9jaEFIS2ZqcUdNMHc3UTNpSjUwY0JLRUh4ZUhEQzU0d0Ftdng0WWs5ck1FUGkvTUROMFJYQWJ2Z0F2V2d1Qm5EeUdBR0ppak9HbW5UeHNXRWdJUTVTQUlYV0dHRkdoQ21KYlg1ckdZTVI0THFQY1ovQ21DQzRnQ3c4U0MzSU1oeU1BSWhVT0VFTDFEQkNZMFFoQ0p1MFNsUk9TRVFvZEJES0hLdUJVVWdJeGF0d2tJVUl1bUVwV3BoRHNld3dpcVNFUFVrTkVFRlRaaEJEakRYaXpCQUF3dEZLS1lWRUdFRkt6Q0lHTFM0aFJjZ1I0UnFaMkhzZ3pDREdjSlFDVU8wWWhScHVNSVhmbVdFYWhjaENsallRaTZJVUlUQXgvYVp6aVFDSXFnd2lFRlVneE5oaUFZbklNK0Z0OHRDOFlOby93TWNpTFFNVWV5elNKK3dFQzd1b0lwaGlFSVVnbkpSRzU3UkNtSlVRaENtTUVRbGlER0pTUkJqR2NVZ0JpYUE0VTVSS0FJVFZvMUNIdklRaFZiTm9aRjZjSVV4Y3FrSFBkUmlETUlYL2lNU29RVXY5TjBJY0NmR00yelJxNk9qb2hPaFFBVTFNSW1LVVNVQ0ZWcm9ReFg2RUFnZ0ZBRUxZQUJDRmFJQWhrV1VRaHJTNk5TcG91QUZMendpRDVmRWhUU29nUnBvb1U0Y29SYVNZUmFXQVJpSWdSdHNJVmFNWUs3U1IxblF4N0F1SlZKUTRVUWtDeERDZ0JDTVlCUE9RQWlVNEFHNzR3ek9JQXdHSVE2Z2dBb1NvUXFFSUF1RWdEdUVnSzUyWW5CY1FETFlUZ2g2b0RITXFEUkM0S2lPd0FaY2dCVzBqU3lFSW1CTzRtRTA1djhzaEVMV0RNSUNiT0FKQUVBSHVBQUw0cUFGamdBTWJzQUpiQ0Jpa3VBTFVtQjRESUlnbkFjRDBNc0RNQUFHMEJBTk1jQU1NZUFNSWVEQU1FQytDdUM4ZHVhOUlFQWgzT3ZBMkdZRFV1QURTcUJoZm1aa0lxQUZKT3NSU09zVUxvQUtacUFEZ0liSFVFekhLT0xFTEdKa1ZnRENVb2NIdUtiS0h2RnFsRWRvcUN3U2g4ZGplR3hxcGljRXBvRUxBSUFLbnVGbHVPQVpub0c4a2lERG1zQVVBT0FWVEN4c0Vxekh0c1lUd2l3U1djQUtYQWQ1ZUVZQm1tQUMrdXNCcGdjR2FrMW9ETUlpbmdkb0RHSXFhb0RlOUlJRlpDMENha0FHVHFFR3RvYk1LR0puZUN3aEhrQmtMT0FIUXVBS2JtQUl6TUFJcEtBYVRxRUZySUFaTm9IL0NqRGhDSUxBRlJYaEdRUUJWNlloQytBdURQSWdHREJoRGJiQUROcGdEYkN3QzlhQUV6alFDUlFKQ3E0Z0NKNmdDMjdnQ1c0Z0RKamg3UmhoOHpxaHBYZ0JFQ3poRGhvQkVHNGdGN0lBQ3BDZ0M1S2dCd2FBQzk3eGRBQmdKanhHTHpwQ0w1akNCV29nQjJUQkRLNUFCcEJGQm42Z2Nnd2hCQWFodEdiTHRxZ2dEdVNnREtvSExZamlKUDRtQ1pxbEJFeWcyZEN0QjJ5QUNaNmdPSjdBRDRMZ0pKRmdLM1ZnaWE0QUhhOEFDc0JnQzRCZ0VLRGdDSzdqQ1g3UUJxb2dGK0RBQ0k3Z2ZOVEZpWmdnRGdTQkN3YkFXbnJnMzNxSXJrS3JXeUlqaWdnRENSTERNQkpEQjJiQWg2VElNVUxMQ1g5QURvVGdCZWJLc2FxbEJoWEQveVhneFlTTXhnb1VRQWQyd1FXRzRBek1RQkJ5WUFEQ1FCQzJMUVNvZ0JBS2hRcGlRUXNnZ1JwaW9SV1dJUXlpNEFnczhncUdZQkRDb0FvSW9STzg0Qmlvd0FLSUlBeE1nUXUyN1lja1l3UzJqQml0UUJoT1FBWDJ4ZXFTSUEwYXIwWGFZSmk2TGduY3dBMnNZQmZFTGd1d3dBd1N6d3JvUndoVUlBYWxnRHkvNEF6YzRBV2d3QTI2Z0Foc0JRc0dRUWdVQkQ0RXdReG1EdHMyQ1VCb0R4aGFRZlVxSVVHSklReFFnUllVSVFxS1FEMFZ6d2h5WVJQQ3d6L0JBQThNQ2hmSUJCaG1BWnZ1QUEveW9FUFdJQXlBSVFweUlSS2lBQStxQUE4MElSaUFJQThDZ1VTQkx3OHNJUkxnYnhFV0lSUDBBQnV3NFEzZUFFTXNRZmxNWmY5REdnRVNqT29OdkNBUjBBNDlpV21ZR2tRTndvQktIWFJURXFHb0NHSDZtclNUQk9FWjhvTVFxbUQ2QktRS0lJRVdVQ0VVRkNFV1FzRUp3Q0FRakNBS2pBQU1zQUFWaktBS29BSCtPcUVQSG1FWVJra1NicVQyQ0NFUjNLOEw2RXBaeWdCOXV1QUZiV0FOY2tFTnZFQTkzQU1Nak9BR2hJQUlESUVacUtBN2dPQUcwQ1VIWEVCYmRHQndyTUFNNGlCeFNnRGNFbTRsU0FCaURNWXJza3NtRE1JRXhzSnd4R0lzY0RXQk1BSld4MkpYSTRBanBnc2tyc3dnQk9JYTJ5WjZHQ1paeVF4bklBQm5KRkVTeGNBT3l1dTkybXRuVU9ZTkZ3SjJHQWE5M2t2RWxBY1hBU0N5OENNUnJ1REV1SUM4bnJWc1FORmowdUFTeUVaclVDei9BS1pIRWxWbUFENkFHMTBBWFRVQ2FJQlNEWVFMQndBZ0N3U2hVZGFNeUdUb1kxQnN1a0xndUtoQUJUekd2enpHR3BSaEJTZ2llUnFtQ1Y0R0VobG1JaWFzSXF3aHd3QmdGK1pnQUVMZ0NaUWhEV1lBQUdZQWtKQmdjNWlCQzY1QUI1cGdLb0tnREdRZ0NIQkRESmFDRDhyQURVWUFiTUJtYU5TTEJSYUFCVllnQWtiZ0MyUmhCdUJ4RG96QXJHeXVGMXFCRU9BZ0R5SWhFWXpBQ1ZyQXI1d0FDSndnQklaZ0lwOUFDSndBRGo0Qm5XNUFGSHJ2RTlTMkdVWmhxSW9BUWRxZ0ViNGdET3FBU3dDZ0VZQUJHVzRnQ2dBQkU5UWdCSW9nRjdTZ0Rqd1ZDYXJsQ2xJVkNYeEFXQUZERzZhSEZWNW1LaVNtQnBqZ1l3RkF1UXFIL3dWOHdJQk1vQVVlNW1MK3h3ZVdvQWkrNExUaUlHWkxBSys4NVFKTUNDd0Vobk0xNENTV1FBYUhwUXZDYVJBdXF3ZktNZzdPUUFxTUlBdWlBSnIwQUJBNmdSZ1NJUW9FQWFTaVFBOUtJUkVpQVF3aVlSTTJRUXJVcFNLNVFCQmVnSVpreUJBYTBBYTg2bkk0WjFOdFlBNnNvSHhLUUFaVTROd2tnNGQwUUFaV0FpVkd4eEM0d0Fha2NIdG5JQXVrWUFpUWdJZWtnSCt1U0FkMlF3ZUtvMzg1SzJJU3AySEdZbllIUUNkcUVDdWo1bzV5UXJWS1lDeFlZREJNd0hEd29tRmNEUUEwUURwcm9JMTBJQnRyZ0E4Q014dTFoYTRHNFJpSUlSamFvSHFsd0I5WjRRdUFKdzEyWVJkWVFRME00VDE2eVY5M1JRMjR3QWk0UUpXa29QOE1yTUFRYm1BVGhNQkN3OEFNZklYOUJFRlQ1aUFLNXVCRU5tOUlGblFTM25ZU3RLRVJKTUVSUGtFUmNtRU56SUFaMExPSmF4TUlvaUJQdGFBOUhrR3lrbUVZT2tGTEZFRVRLS1NnT2dFWEhNRVljT0VRVkFFV1lHRVArbmdXQ3FFUTdFUVYrT01RQklRYUVMQVlQZ0VYSHBta0NqQ3FRdThPdEtvVzlHQlUxbmdMdG1DWUdNU1lvaFJ5aktBSVlNdnJZaXRPd1lCRldsUVRNRUVSQkFRVkZFRVA4T0FSU09FVytrQUxCQUVNMUdkT2hRQUwxU01TemlBUzFvQVIwSzhQWE9FT1pvRWJZc0dwbERRWGhNVUlCc0Y2M2Nld3NDQnp3cUFOcU1CVG9RQ2JpVUFOQnVFTEVBRVJzdUFVbElBTHZIY29mNE14d0UwSFdSVTBnRUwvSnJ5aU5Rd0dneG9pQlFiR0szYlZLT29aSXpLSVZnR0dWbmZWbmdXYWFYWVZBOFlpZGhSQUlFSW1vWGRNYkJUZ0RkZEdESnpCR2ZLTENNd2dHaHJoRnpiaEYxcmhRUkNoRnArQmJNQnhEbUVBYlVvYWJUd2diV29Hd1NKeEhMVm1iRTdNQ2hUQkNqYndBbjRtRExUQlhjdG1BVHBNWFFIQUV5aUJ2Qm9tRGJpQUJTckNBcDdCUE5MTkN3VEJwa2xHQVNZbEZqckJBcWpnQ3lMbUNjSUFGUjNtQ2ZKdk0zUmdEUlpCL1JSSFlvem5CQllHRkd2QUVJUkFhMmhGQlpMQXlDU21iY1RyQ3pOWERqS1lCZmlBQkJTQU5TSWdaRmhEWkVZbVo5SkdaWDZHREVRVzR3em5DZ2JnaG1jdENKd2hDSEIydnpCQURJSkFCcnJnWjNsbS93Tmc0SFo0Smh5L2NXMjZncTVSQnhDM3BySDA1d1gwejZpb2NBZ3NRT3dzVlJDOEFEYXA0QWhJcXdpQVFBMnNRQVZjb0FnSVZSMEhvZkZDZ0FnNGdRdk93SnliZ0E4NDk3anp6SFU0NFJveXR3ekFqYkVzT3dtMnpDVElnc0EyUndoZlJnT21zd1Vha0hSSUFINWJteEM0QUFmQVFCQ3lnRy9hc0EySk5hRU5ZaHhSQnI2amh5TVl3Z0pJNEFPRU5Sb1Y0QXZ3dXlNU3lBaE5nQWtFL0J5SG9QMXNJSU05eGdLZ2dLa0ZJYm1LNHdyT3dBZ2lIRU9sWUFtdTRBZWtnQWpXNEFwZWFBQmFBTGtjSm8wVW9BWDg1eThzd0lWYVFNQjlnT1ZhNEk2K0lEbFFVQWlrUUxrWUExeDZ3QVVDaVY0STZDUU14Z1Q0d0Fwa0lNWFZCLy9laGlDREJ1WW9mQ0JlQ2tZbGVoV0JSeUFFd29Jd2lNSUhXa014YWdBSEhNNE5ETUZudVlCcDRXVUp2bUFYTENDSy9FMWJjcURjYnVDWmRwSVRKbXF0cUFBUlhrQVdyQ0I5cnNBRWJDaCtidlpZeXVBSGNrMEdpS3l5czlFRlhPQlpac0FOa2dWYmxPVUZyQmNKZ2tDeCtDb0VETUVRV2lBSGl2ZzZiZ0FLbHVVSGJJQit6d0FTN2dCTzdrQk1SS2tXWE1GNXNVa1JKTUVNb0FFN3FnQVFIa0g1b3NvUkRxRk9pa1FUWnNFUllNRVI5aUFiSEVFVkNpRWJiajNYWjJIWWh6MlE5eUNRQzNrV2lvR1E0d1RYUzBvUGtncC9LS1FSNWtBOXFZQUxycDBLeEs1WFREa0xPSUVZR29GRXlNb0xvT0gzcWtDWTRVMEpzZ0FNdXVQL1V1ZEhzSmlERWFMWENVSkJFNmhCRTBnaEZIck9FUVNRUlZDaENqWWhvUVJTUDZqQXNFclFPcWc0bTd0Z0NTQzdXN0lNWFNDK0IxaXVpTWdjTVJtREpiNG9qR1NDSktROGd6UUFCWmdtWUJ5Q29IR1ZLR1RpbndPbU5URGloRlRMWUY3VllNaUNOVmdBb1B2NlZ6MmlEY2VSV0RuWEs5MG5DSHlnQzRBK3pZTUFBS3pSWXg2ZzFuNUJ6MnptWjVRQkZEem1HaXFCdzhibUVsN2hHZ0pnSXBnSEFId0JCbkx4WnlTMmJHWWdESXpBcjI3T0NVZzd3ZEtnQ09DVmFLWXJCeXcxRHNpYW9SdFlmMFpHWFJNTVh0TlZ4L0xlcDUrMTZ6bVJiQlFtSmkvZ2FZR3IvUGd2RUhRckZyd0FBSERBTGI2QVlaQ1dZeUpnQlF5Q0J5YUEvMk0yWUFWZUxNSGFVQVArNEFQRUlQUW4yd2Vjd1EzMGdyTEhwL1NEWUdNVGVnWFd4c0NTOVFFcVVTQUFnQXlzNEFPcWg4bU9RbVQ2T2c0SkdqZElKMVdad01hSElIR0U1UW9Vb0ZrYzVpeFE0aWdzd0FRYWh3OElXREdLSXdSeXpSRENJQVRTNEJSVTlndEl3R3ltd1JBc2dJWjZZQWtHS0N0a1FMd3dJcndvTXdVa1JxSDMybU5NSUdVWTJtUGkwUDVESW5vRUczYklFQ0F3YkJDSTRZRUNndzhHUHVqd0FBTkRGaGd3UkpEWVFVTUtGaDFnUkJoQWdnVUxEUnBZQVBDaGdhUUdNUjFZaUFHcHdROFRKRStRSUNIcHg0OFBBRlpZeVh6SnBNY1NKaWFXdEJpeTVFWVlUSktBaFBqaElrZUpJNG82UVlxcVJjaVNIa0pjQ1A4NUEyV0psYVk2Y0hLWmtzS0NnalF5ck0waG9hQ3RoYmNSVXFRSUVjU0ZCaE5EakJRNU1pUkVCN05JaEJneEFxYXBuQ1ZENUZBcFlpTkVpQkozZmJUUTBNSkNDUklwVEpoUWtTWkxEeDlsWENBcDBjTkZIQjFYZnd5NWtlUEpsUnMzY20yNXNZYklsazFFMnR4WVZzbUpqU00zaEFpUjBxVk1pQ05TdmhDUklpV0hqQjR5Y3BRSi9ZSkwxaHc5YXVTNGtPUEhqeDdlbzdzbzg3eTBETzg1Y2doUnJ5VHIrdUhwbTA4dk0rUUpGT2xYZ0IreFlRUDJEU0JIaEFGSEpkTXcwNFlrb3RBU1N6S09PS0tJRjRua0FnZ1FSaVRTQ0M2TzBPTElIckRBMGlBdXlmVFNpNFlkN3BGTmh3ek9jc2lLS3JKNENDMGFPaktMSnJnTUE4ei9NSjhBZzhvYzJwaENpVEpBS3NPRkZWUllVVVFSV1lSaFJpNW5xRUhOSTJNUWNrZ2VRQ2dpQ0JCcVhDbkVGMWxJY1Y4T1VBREJCVENpbE1MTktOeDBRa290WTVDeUI1dGo2RkZGSUhsRTRVUW9UaVFDaVJONVFCUE1NMDRBZzhrYVRqUmlCaGk1UE5HWkRqMUFNUVF6Vmp3UnhBOVN1S0dESHlNZ29jTUluSTZBQXc0ZzFTRERDQ1dNcGtFSkplRGd3Z1U0b0VyQ3FYTEZhb0pjam1rV3dsMnhscEFaRXltY1dvSUpKb0dFS3FvMlhHQUZBQ0VnY1VVUVhVaHhBd0FBbU5DQkQwSElFRVFRU0NEQ0RDSUFtTUVKQUMySlFXMFFpRlJ6aWhoQi9OSUVBQU1Bd0FJZjBHSUFMUm1lUUFzQUdaVmdFZzBSQUdBQUFRRFZUSElLL3dBZUZBd0FId01QNE1FQTdSWUFMY1BzMml2eHd3RkU3UERFRUFNUVFMc1RkOHh1dXd4RG5MRzlISHRzTXNrUm55d3h5Qkd6N0hDN1gxaGhRUkU1Rk9IRlZLUm9xTWtlMUdoeUJCQ0o1QUJBQjM5aG9FQkJSaHV0d0VBREhjM0NGQzExZ1VnWFFUampqQjEyZ0NURzFqNzhNWUlkMTFiOTlRY1JQVURDUmtjZkpGRUVmK0hBeWdrbUlORkNEem5ZQUFZWXZnM3h3eUErTVBFd0N4NUk5QkcwTGVUUUhGQzNadkhGRUVkajRGRUhIeURSZ1F3MWFPQ0NEajFaOGNYUWY3V2xBTWNsV05CQkV4cFk0R25vTGVoZ0Vkc2RSUENBNnhHMHRiWkJqVWRrdTlvUFBPREJRTENYUFZGREIwR3Ird0FGVFRIRkNrWTMxSkJDRHpETVVQL3JyUnNkQVVZc3JEQ0FBZ0NrNFNNQUUzUUFnRERLV0hEVENCb0FzTXNwSDdGVWVoT0drT0Z1RURXTlVOTm5RWFRxQXhLWldqRkRCeVZ3bk5MWkdDa2ZBQ3pBTUF1WUlBSVJDRUdyZE1Db0ZqREJCeU9vUVFvUVNFRUVRbXNFWEdDRnN3WkJoVE13SVFkdWNNRVB5RmNDOVFpQk5VdEFsUUxPQUlnM0FHRUlOaGhDRWJDQU54dTBBRmxXWUFZVlpzQ0ZJVkNCQ3dQVVRPa1VZSUlreU1BQ09xaUJEdFJqQXlGc0FRdzMwRUlpa0hFSFhwQ0NGRktwQXpJa1VZbzh2QUVRZUhoREtiQlJpbHZNWmdodnVjRXh3dENDTTJ4aU9EY3dBaGFzb0FaRFVDRU11UkRFTXRwd0Jpbkk0RGtmbEk1enJtQUZMa0RoQmxESUFoYk9jSVAvTjNwaGh0QlFCQ3JDb0lZd3pNRU1ZVEJFTk13d0NDSVFnUk5aNk1JTGt2QUNLRUFuTzJYb2dpZXBGZ1F6dEtJUzJ5Q0NGdW9nb0R3QWd4Q3ZxSVFsaXhBSElTakJDRjdZUWhpSW9ZbE9QSUlVamtnR0xJeGhqREdNSVJCNnVGc29oQUNFS3VSaEVZdlF3eUlDRVFwdUJ1S2JVWWdDRnFoZ2hqZGdZaG10R01Va1hxRk9VOHhCR1laUUF4ZW9VQ1FrQ1lFSVZEQ0NJcWloaHpIVXdSSlJxTU1XQm1PRU14aFVDbWQ0Z1VLWnN4VWl2QUVZaHlqR0pDYnFpREVZd3hYSk9BUWs4TkFJWUN3Q0Q1K2dSaXcwb1FsYTNHSU13UWdHTVBEUUJtSVVveGpBd01Vbm1DRUk0VmhCQ013SVF3aVNVd1l1Tk1FTmZDalBwdkNYcVZMSi8yUUVPbWdCRjlSZ2djZjR3QVF2K0VHcVJuQ0JKclRxVkRwb2lnbXRFSWNsaElCWHB6SkJDNzQ2ckNUTWdDaExrTU1SMUhvRU1Cd2hFY0VBQXhEOHN4OWlFTU1KallSQ0VBNUp0UllnSWdoWGdFSVhZTU9KTFFEV0R3QllCVE1Bd0N6NGhhUjVBNmdZdEtyaFBnaFVqR01RK0ZmS1lQQ3ZhNENDRDBkckhnQTAyN0tScWV5MHFFVVp5MUNHTWRaeVRHUVpLOWxyTzFheWxMRnNaQ0Y3V0drNXBvQWo0T0VXcElBR0dMYlFBczh0TENJaEM1a0NJbUNCQWNyQURhcU1SakNLd1FscXJRUWtJM0JHRjZEQVhjRjJRYnRkR0FHN0VxSTA0akYzQUJhSXdBb2lZSUxtVmlZT1JoQUNGUWdSQmlIZ0RSS2xxQUlXVUVFTFFoaWh1ZjhBK0VCVDFFQ0lUa1JCQzE3RVF5UnVvSUJEMmdBaUJ0VE1xeDUzUUpEZ2dGVDRlNDRQTE9BUkgyQmt3MndqUVFrVWtKbTN0QzR6MEpwZTdCQzRrQWNZendJTGljaEVrQVk4SGxTREI2RlZYa0dtbHoxS0VFeDNEMWl2OEhKM2tPWEtLdzFwNEp3RktFR0pEelFCSXhJWlFCb3VZUUVTQUVBQkxWRkdLdHpsQTBSb1F3SHBXd1duV2pLVEFaVGhDNTVRaGpZc1VDMG1MTXNFWmpBRFRIS2dIRm5JWkFvVFRrbnJGbExCbEtRQU01aUp5NmxxVUFZY01DR0JMVWpETG9hMjR1WEdKWFlXcU1FUExzQ0ZHUURnQ1UrNFg5ODhWZUlXK0NBRkVLU3pDbkt3aTZYYUFBc1Flb1FtQ0hHR0l6aEJQVmpBd2hGYWNJTWpSRlV6Q21EL1JSS0lLRG9MREVFUU5WMGtYNDd3c3hrMnhnSXRDR3lZaEpPSFVueUNFSHJJQXhpaUVBWmdCTU5RUitHQ2t0cUFpU3k4WUJyVHNJSU5qb0tKTU94bldXYXdSUzhZQVFVaW5FR1ZXY2dGRWJnZ0NET3NBUWlSQ01FY21GRUVJNkFDRllJd2R5Nk9NWWxXTk9JWlpyakJMenI1QzJaQjRRbzlDQUVBV2xBRUxqUTNOMW9vUlNQdTBJZ3RFR0VUVjZqUEUxcWcwQ3M0eTNCZitFSVRSTmlER3lpaFBZd290aFdza0FUaDFMd3BUTkdxRUY2Z0JGSW1JUWxXVUVJb1lzMEZMckJ6RkVoUGV0Sk53WFIzeW5PZVlCQkVMTUtKdDA1b3dndDFxQU1jSXJHR05vUWhDMWs0UXhhc2tBVWlESUlWWjFDQ2JSQ3hoU29NNDBXeG9FVXkvMm9SaFVCVUlRcDR3SVFvOUg2RDFmakhCcmpaUkNTNGpnYzhyT0h3WXFBTkVWemdnaGZjWUJCWkdJNFE3SlB5NlBUZzhwZm5GQktZd0lSY0M0SVF6d2lFVzUrd0JQS2txbld2S3NGalVFVVVPZHlBUHpxQUM5SE1ad2hXY0NFRU52Q3FIRnEraGp6a1FROTZLRVVmcWxBRklNaEJEa05JUHVuNTA4alhRNEVaaGlqY0ZXcHdTazZFb1pObVlNVVZSdERsUmNPQUIzK1lncnpzSlZsbzFRdGFBVWkvWmswQml0SGFpd3l0bUFiMjJBV0IycWIyL3ZqUC84bG11OXJXMmxhMy9GZGFMZk14eVhVOURKTTJEcUVESmRBQ0xaQUNIVUE4QmVNQjhkSTZJNUFDYmRFQlhDQUxXUkFNZzdBRmphQXZRUkFOclJBTXYzQUtHSUFwZnYrd1YzcEZMZHdWTmtIZ0F4aGdGaWtnQXlSUUExUHdBY0xnQmtTd0JDY3hBbWRRQnlVVkMzaXdCWlZnQms5UUIzZHdSWkNRQ0Zkd1F5MkFYbVlCQUt5Z0RVaXdCb0JBQzRmUUN6VGlDSThRQmFWd0I0ZXdESXFnQ0ZGd0JGbEFYelpRUXI3MEF5SEFBaVFnVmdPMGdPMWxGbThoT2lsaEVSMmdBQ1JBUWhvd0Frd0FCb2NRQyt6eVBLL1RBUlNCUUswekFFM1FCQit3RWYwQ0EvSVNFZEFDaVVpamlOZndoR3F6QVcyeEF0ckFDZ0NRT3hIQU5GRTJBTk5qQWpnQUFEdHdBU0FCRVE2QkFScGdCOHdBUkQ1QUVoREVLWDRnQml5Z2FRcVFIWnhnRFRqQkNXYmhCMGhnQVIvQUIwRlFEVzV3TFYxUUI1Q2dDWW9BQjF2Z2NYci9kUVV5Y1ZTUVlSRzZjaXNtRUFJcGdBSVY1STByb0FFa1VJc0VCQURNWlFMS3NDNUxnMEFYMFRyWVk0aU5RelIxZUVDaXd6WTFFRUV1RUFLMEpnUnJaUUlLOEFSQzBGd0RVQU5OOEFOSGdrYlpBMFFkc0NtL1lnSWxNQU9ySWdNcUlBUkJOME5XY0FZWnRFU2xWa2hjOEFNUmxnSWxNQUsvSkZkVllBUVVvZ2hHWUVNendBb21FQVJlMGtzdjRFdFpZQVNiOEIvbTlBbkVZQWJNTWdoclVBUlUwQVllUndTSVlCeTVBUWR3RUEyRzlWMXVnQWlEMEFhUVJ3U3FOQWlEa0VtY1VBbkU4RXFwNEFheXdBbG1BQXFWd0F5VjhBekJVQW1WMEFxWWNBeU5RQXpBY0F6UEFBclZNQTNWUUFuVklBeW5zQW9lWUFkZElBWTJFUVJsLzRBVlVna0ZSaUFJV1NBSE9UQUhQcElHU1RBWWdqRUgxZ0VHVkNBSVZ2QnFMa0J6Q21BSWhJQUtoT0FFVkRBSm85QU14aUJSU2hlYWt5QUlLWVVNcFRBTWQ5QkNlZkFJV3ZBSW5YQ2FwYkFNeFFBSWtHQUdXNUFLclNBSVhoQUZsakFOdldCdmJWQnZXb0FnaERBTXlkUUhmV0FKWDZTY0xZUU1vb0FNZ0NBSldnY01jR0FKWEVRbXlJQUpsb0FIY0JBTW51UkpVZ2tjWE9GSnNPRWxnNlZzWVRNRVJDQUxacUFOT2VVRUFLQUd5a0JpOXpnUm42T0pNZWdEUzdBRVQ5QWZOeEFIY1lCR0JYZ3gwUElYb2xNQ3FBRUdiL0FJdjNjTDBkWUgxYlFmSWZBRVIzQUZGbUFEeGNjWGZjR0FDbUFXRzJCLzBQSTU5a0tnK2xjeEZmOURCcUJnQndCd0RhMXdEUjBEQWI1QW92bzNvelI2ZjdlVk1yclZXck0xZ1B4WGdENjZPd3pqQVFoNE5CWVFFV0tBQVFiREE2dGdna2ZxQTF2akJ4cHdMWmhnbTZKQURMeXhCc2R3SnFQUWZ0ZVNncXAwRE1WUUNVeEpCTXBZTFZjQUFKUkFDR3J3VlVpQUFVN2FoeGJBQ2tvUUJzdEFOZHcxTGlub0dFeWdBU2toY1dLaE1jckNRc1B3bkxFZ0NZbVFDRldRQTJqVUFsZ0FCYlFXY3NoU0JFbVFCWktnQ0l4UUFpcndCUzFnQk1zd0I0d0VCUzl3QlVMQWdEMmdBMzFqQWorUUJDV3dCRzBWQ1ZnQUJFRHdCTkRTamhQaE9vYllPaXpBTmp3R0xkcEFDYXZRTHcxaEFSY3dEZTBYanl6UUxpbndBRVdhTzd6RE1LSG9hTEwvZzRBT29hdEU4emdSMFdFZE9vdlloU2wySUQ4OUVBUTlZQVdVSUFOTkFCMGZzQXFVd0FxNzhJTE1ralYrSUNxdnNRV2FBQXlLMEFKTHdKUTN3QVhSMXdPSTRBSktoRlE1NEFLalJwRXprQU0xZ0FNZE1FR3hnZ0lzY0FFeThBSXpJQU9nSWhjZGVoQVZ4QUovUnExRTB3RW00QUpKVUFUNVdJTXNrRjRYMW10NG9RTWg0STlmOEF4QzB4YlpJeVNMcUFNek1BZHpNSEltbHJBak1BTU9ld0Z0OFFPbEl6b0M1SUFwMEM0VUpCZEU4elVGUzAwMmNBVnlBQVJnUUUxUGdFaHRtS3BuWUFSYVFBZzFxd05aNEFaSUFIbFg0Qm8zMEFMVE1BbHFBQzFXc0F6RU1BZ2owUkluc1RWYmsxamI4QUdwWUFxc01BRGJkUVZpaHdpSS84Q2VuREFJUVRBMGZ3c3RkaUFMWGRBRk05QnVaaUFMWjNBRk5yQlhaYkFUWFFaZG5EQzV2NkMzdjFDNGcyQW9aR29HaWFBR1Q1c0VhVUJ6VklBS2tCQUxzVUFGRUFJSFVRQUZvekFIRzRBREJ2c0IydEVkUDVBRFRxQUNnZ0FKMU1BTms5QU1FNlZPbkRsUnpkQU12Y0FOeFhBSHFvQUxIcklIanlBSVlHQUp2SEFJbjRDWnE5a0diWUFIVnBjSWhKQUVnakFIZVJBTW5SQUdZWkFIa29BSFdCQUdqeEFJV3FBSVgxUUhYd1FNZDBBYkhCVU5lRkJTZW9BSHM0UUptbUFKMHJ1ZGNQQUx0bUFLdGhBTWhOQU1rSEFMV05jTHo4QUlna0J2enpCekNzQUZhU0FMc29BeEd5QThHK0FKSCtBQU1RQXRCZEF1TVZBWk5qQ3puditJYkZINHdRQlFBQUdBd2dYNE9SZHpQUUNnQTBhUUI4MDR2TWt3QnFFd2EzT2dCa0RRQ2JmZ0JFN2dHSG40T1NEam8vMVhmalZLZmgyRHhFbXNmLzBIb2pmNmZ3QTRnRks4TWcyRGZqeXFNaHh4ck5kek5FSktQTVJqRUN3QUt2RmlFZVhqQVNjaE1XZWNnaGpBQ1FNakxqNXdBM0N3RExKSkRKd2dCcTN3dTZBUUJGc0FCZFRpQi9JU0JLdEFOWVJjQmhvd0FIMklQV1lZQW9oUXVRQWdCdmFpQURoUUJsSTVDRlN6dDg0d0FMbUlCTTh4QUVsd0RITmdDQzh3aUYyQUJXRUxMYjRHRkFia0EwTXNQaEhBRXFSU0VoM3dFcTFDR2tPUUJZWmdCbWRRQm9jRUJJVHdDZElXQllvS0JsN1FBbEtRQ0ZGZ0F4MjZzUXBnaUxYLzZqZ09RVFRROFZTSXFBRENjQTFUZ0lobElTOGQ2d1llQ1dNWWNEMFJZWWdGRVQyd3c0NHBVQU0xc0FFUE9ISHBZYUdpZWdNVUNodVQ1MmxJc0FSSVVCUHdFell5UUkwOXdBU2JNbVpUa0llNXFBRmw4RmVzWEJFQVlBaW1BQUJEa2diazR6MCtoUk16VUFZNk1BQXhZQTBsOEFGV3dBY3FZQVdLK0FVa3BnQXlJRE9DZGhkc0l6NnRvd0VVQkQyNitoSHN5RHFhVVJadUlUb3BGanNLa0RweDBBTUE2bWJPZ0ZqRXN3RUQ4VEJ1NFJZcGNHRWIreGZnMGl2V2tBWURBQ3lxWXdJcDl3SkZBQWFLTUFkQThFWm5JQVRQMFY3MjBRS0d3QVU1a0FVMzBBTkRvQWF4RUxhaW93QXpJQXRxY0FSWDlrQWVGa0R5QXpaM3NiWjIveUFEWm9BSmJ1Q21ZdUFCRUlRMWYrQTFOK0VCc2pBSGlGUktiZ0FzS2ZzWVRMQUxyNUJMZzFBSnZVQU1qV0M5VUNsQ3RSc0VPVEJZMzJVdGhTc0x2eEFOVW9sSUtZaEllclZkWVNOeHJzRjVTSUFEbVBNZi9ORVhRMUFERitBWTNnRzdzSzBEM3NIYjNzRWRUbEJKZ2RBSGovQUllbUFNbWhCUmhOQUx5YVFKam5BSXFrQUtlaEFMMHVBRmFuQmdtUUNHR3lJanN6QUxlL0RjSlVVTHdKQWpNdlVKbXZBSmpoQUxqa0FJc1VBTkw0TGVuNEFMaDFEZW9pQUt3NEFKbUFBSlhnQUVVYUFuZ0hBSHVNQWhzOUFKanFBSnNGQUlqdEFMdzh2Y3lFUU52dHNNbWxBbk5tQUNJZG9XQS9EQkY1N0NLZE1FS0lDbXlxRGhkR0FLei8rUUJDUlRnQ2tjV1pGbFd3d1R6aUxETHRoakFVVVJDTkpBQ25qU1hOb3dEVGR3WUZXZ0NHSEFZZGlUVzZSRmdDY0RBeklxTVFFQUErVkhCdXZTeEV6dU1hc0ZvbEljeFZPOG83V2xYQVB3QUM5amZ6dDZBNmhBQmVLRWlqeHdQWWxvRnRIYXpLZ2NNMnlvQUNHQUNZMUFCRzVRQ2Nmd0N3dFhESzF3bGJ6UkNMd0JCM1dBRFljd1VhM0FEY3VnQlpqd1NyQ0VMbGRRSE1xb1YrVHlWODRBV0NNd0tqVmdEY0lBQU1wUURSN3d0ajhTQUs0b0Ezb2JCRGV3Qlp6d0M1d3dDVnVHQVQyZ2VUMEJ5TVF6QlNOd0NqVWdWZ3FnbHpMQWc2V1NCQjFFQkkrYnErbWNBMndYY1NVUUFSRWtBNDhMQUVjMVpwOVRHWkpNQWdrYlBVVC9veXNPaUlOdkdEdEp6YkUrVUNvbFVCRzlNZ0p2TVFKSkxUNVNzQWtoTUFROWtBVWpCbWJrTXdKbGNBR3pZa0JHMndFdElGWTkwQWdWckFLMlFBMkVVSVpSY0F2NGRRZW9LUW4zTFFxeGtBVlFJQU11NEFabWNBekg4SUpNOEFTY1Z3TjJjV1hVTXdYM3FBRkw5QVUwMHlvcE1FQXRJRjdteU5JZ1FUUStJTHNodndNaml5cnROVUJ1Z1FTZll4WWFjTTgvWUFVeTBBTFZHTkhzcFFOZGdBUHZiZ0tyT0MwUmNHVW13SG50TlFBbGtHa0E4QXlWb0ZUVGNOMXl0UWxyOElJM1FBUlFnQklHUVFJa3NGNnZRd0lmY0dHUVFYM2JDQUJNd09uVzBsaGw0QVpsOExVNkFBVXhnWHMzZ0FXYnNBbTU4SEJJMEtYdzR3ZFIrM3JMLzBLTkxla0QwTlV1b3BPTDFqS0xTTkFEU0xESjEzSS9NNkVCYnNvSm1OQUdOekVJd2NBSlhUb0NmMUFTenVBRzNqTURSTUI1cTR3cW9PYUFWelkzSlJDaUtjQ0FEa1FhY3BBRmNJQUhtZkFHTjlBc1JTa0p3V0RaWDNUWmxoQ05OWGtETGxnMTFhTFpwY29vV29FZEROUWQyK0VDUmZBVk5kTWVveVJDRjZET0Y5RDhGK0FDZUJVSmVWQUYzUlFGb2hBSVJ6Qk9Ua3NGeC9FTXQzY0Zhd0FKMklDY29hQUpwREFHcGFBSHlTQU5nZUFFakFBRWJhQUk4dndhY1NEUDRhNzIvdkhwWm5DVlVnQVFGb1ljR1hKRGlCQWpVYUxVS2RYSjBhRlp0QnhOcEFhTGxzUmtFdmM0MmxOb2o2cFFOa3lZaUtEQXBJSUJLUWNBQUJDQUpmL0xTNVFjc0J4UUFJRE5BU2hUMG5RNUlNREtsaTlmUGxpeFlTZFFuemlSV2tDNWdTWUFDeVdhMktJRTRPaExiY3BBdlJJS05BTW9VSFJZUW9BQndCTVpvUy9wdkFKMWpZd0RYNVF1c2FRRGFpNEFYNzdTN3VYTEYybmZsenNEMHhRTTRBRUdxMCtCd2xoQldHVmdsU2tMUk5CUVFnVWZDeTJFY3BrR0FFU1RKRTB1Y0JIQ3lFWVJOYlplQUVEWlFoRWhXM05lbmpMRWJCb3pIS3dWMUJnRWhVZ2pUbHVpWWVLMFp0bXZHMjNNck5ueUJnNmNSbS91SEpvMHFWV3daY0FPWVRxR0tSb2lLcktlTERuRGhSa2lDejJDZE9sU0pvZ1BsQXBXa01DQUFjWWZPM3dRVzZNVVE5Z1VKTnhBWkpCS09GblBqU0RLa0VHREVXcEFZb1QvRVRUd1FZTVArTGhnQ2dCOGtDR2FWQnE1QVlvZ05CaHBKU0cya01JSERDTFlvQU1XZWxqQ0FzcGFDQUVKRm53QVFKZ2FGTkJBZ3c0czZJQ2xFVDZvNFlrT0ZHREpnc3cwRzhDcEVrbzRJeUV3Z0RqQ2hpR1drR01KSFpaZ1RjYVJPdWpBQlBnaWlHQUVDNUl3aEFrVExEQmhSd1pOa09FRkpwb01vWWNma25naGh5SVFRcVNGRmpTdzRDVWtleUNra3lQNlVnREpEa0lJd1FJYjRBZ0Rqak9xSEtFRklRUlJnelV4ZDhTaEJoeENTRUhSQ0hTZ1pBWUxjTUFoaFFoWUFOQ0ZMSXdBQTRzc1pwUkJoaURzY0VNSUtzSklKSWNXRkVqaW1FNkVhS0hKSlpBQTRKaG5ycmpoQ1NZMFlJS0pNd2JKeFFnaWxoM0pCeDlNQU9BWi95NEFPT0lHSnhSQkpRUWJxRWppaG1VWndlTVJJUENJNU4xUzduaGppeUQ4WUNFQ2xpS1l3a0dtVnJLQnp4WVFZWVlaNURZWlpKTVBvYmdoaUNBVUptS0xHOWFvWTQxbHIrZ2lpSVVaMXZnR1AvekExbytHUVZ6allTSTJDUUtSWTFieFliMUJmQkRqaWg0WTlBTUpQMEFFT1lnck1LNFhnQnZpbFFTUE51cDF3d3c3TkE2Q2lHaWVJS0lISkpvdVljY1NtcFlRVEIrYW5yQUVFMEpZNG9rYmxEV2ltVkVtc1lVS0o2cFk0dzFSTWhHRkdHNktDUWFUTnQ1NEF4Qmt0S2dEWW9TSmFLT05MYzdvSW9jZVpPaEJoeXVnNktFSEYzSlF3WVVTZWhqaWl5S09FS0tJWU5SbzRRY2RjUGpnQXhzdU9PR0NDejRBUUp0SlRER0ZrdjhFVENrOUNTR0FzS0dTYVd6aElvUW5RbWc0QnloKytNR0lQZ2hwSm94WVVHbkdDaHZJdGFINEVFWW9JUVFjNU5RZ2hUVFJUTk5HQUdZc2dRa2tsc0F5QnptNHhtTTZpWFRSaFJScVNFa21GUFFEQ2NrSjlwMElBYW9ORGpWSk1wVnNjc21sdEhEYWF5V2dFdU1mTVAvdEx6TDlBK0JUQUFpQkFpWXdMV2d4eXlxRWdrREE0Qzh4KzN2SkJsRHdHQUxHb0FrR2ZFa2F1TkNZQ1NLSk5WOFF5d0FjVUJZQVZDTU5qbEhBQTRDU0JDc2tRUVh2VThsSlVQSW5MQWdDRlhOQTBxRlU4QUlyNUNBSk80Q0tTVmdZQXZleHBBV0NtQVArSHJDdlAzeUFUTHY0eFNrNElZdFRpQUVER2tDRUJ3QmdCeDdZWVFSOHlFRTFER0dMVnRqLzRoV3RhRVVxT01FSmc1bmhERktRd3AydW9BTWZzTUJJSzNFREtHVGhuaDRnSm9CV0ljdE9yc0VLQUt4QUF6VTR4UXpjTUFNV0FHQVYxYmdZSC9nUUJENk13RWFjWUlZc0JqRzRDQ25BQ3RONFJuVHE4SzhSdUNFT0lRRERKK0F3ckEvZ0lBSmZBb0FoMURDSFpsQkNSeTB3Z2lKdW9RZ2pXQ0FFUWtoRUo2UlJpMlIwQWdoZzBBSXBhS0VKUjJqaUR0TFFoRFFJMFlkSDFHSVJZOGdHTEdDaGlVNk1RUmRqa0JJY1B1RUliRmdDQ0VEd1FoVzIwSWkzQWVJR2FIcUNGMUJ4QkIwMXJnUlBVQUFYMURDRUhQQ1RKZkV4Q1pJc1lBVkJOR0ZZSFhDQkRXNEpnRGpFb1FkUXlNRVNCaUNETHdEaEJxNVRnektweEFRYlpHRUwvd2NKZ1FJNlVCK1RZb0FwSm9sQUNuQkFoUm1NQkVzdStNSFRrTkNESzJCQkNGQXdYQS8rNEFzYWtJRUdRUzFhRFlJMEFoMmNZYWN5S0VNWjNOQUVGeUFoWW5nd1E3VnVJQWNnNUNJU1lLaERGSmlGQkNaczdRWnFRQVVrOGlDbFRVVGlCaVpvUVJkeVFRVXR1Q0lUaTRoRUh1cUFoeTJJWWhqSVdNUFJaZ0FBVnV6Q0FqY2dRc20yWUlaR1FBZHVmTnRDSGZhMmhVaHNZVysrMlZzdTZpQUs3UnppR01Bd3d4YTBFSW5FU25ZTGpkMENITnJRQlRQd1RXOW1pQVp3d3NDTTBTb0hEeEpyUkJBQWdJUXlFRUVHWFVDRUdUaUJpSXNKcHcxMVFDd3l0Rk9NWXR4aEdMeEFteVRlRUlrMWdJaGhOeGhDQ0NLMmlVM2tJaGZRZ1AvdVZwOERoRE5zd1RTSjBFSVVJRkdLUmR5aXZKQVFoQ2xZQVR4Q1VHTVpnQ0JHZGRwMkNGN2d3Uks4d01VZDRMQ0dOVmdDRDNEQWhCbk1zQWtvdU9BSUxjaUJET0t3QkNua1FBZVpVNVFPa0pBNEcrUkF3emFvQVo4K2tJSUpmT0FFQ1VqQUNVdzg0aEpUd2hSek9FRUtVdEFFYlJ6REZMWWdWNG1pb0lVMzNFSVMwRGllRFp6UVk5WUE0SGhIQUVNaXZOQUdJVHdoQjFrZ2dobnVOZ2hPRUlFTFJOQndneDlVR1EzTTdBbCtlSUljbkpDSVp4amhHSW9naGZoVTRRaHE5Q0laMUdpR0p0Z1hCa1c0cndZc3lNbjhKR09Wbi93a0tCU2NJQUVWK0dkQUIxclFneWIwQk5Pd3dyNDh3QUYraHNFRDBnS1VaenpES29WSkFpSC9rb0JudnRnRWdCLzRnaEs2ZGFRT2xBUWxFZURVRW13UUJrSFlvRi84QXdvWmRvRkNML3B2QlUySUFVdWMwQXhiY0hBbEJkQjBvSHY5NS92eHVTc0c5UE5MU0dBTGJiQ2tDYTlvd2pSU0lhQlZqR0FLVTlEQUZEb2dBMnVVQVFsVjgwRUgzTUFIK0xCRUNwTFFBa0VjQ1dFaFZLRU9RTUNTRHFid3RBa1JnUXE1QUFMVGVxQmRTQ2hDQ0JaWWdrR0FVSVVvOUdHZFYxZ0RFUDZreERnY2dRdEo4SEVPR0FFTlV0d0JFSkRRZ2pUMktpVWpZRUlSYjZEWUU1UU1jR2wwQWhBYVZWWVdJSlVTa3lyQUJEM0l3WStNZElNbzZJRVJ1bmxKZk5KVXBBZnc0RThka05BSVpzQ0hsMkFBQ25CSWJkOXUwQ1FUQkVFSlFqQ0JGSFJRLytlY3NPQmVHRkFBQmpiZ1FzQlN3UXBjMEVFTFhDQ0VPRndoQjA1WFFCQmNVSVltWElJTWExOTdVT25BZ3ltUVFBTWtLQUVPZmlBRE4zemhCZHA0aGVsTW9Zd3ZkT0VNVU5DQkVKNERoaUVVNFFjS2tLb1F3SldJWHFCQ0MxaGd6WmU4TkFJcDNBQVR0RkFFRUo1Z0FTWUV3UVNJa0VVWE9qQ0NNdlNBQldvQ0FDbHZnSVFydE1BR2NYaENncURBQkIvZ0hnbFEyTVRJMnNDSmFYQ0JGUzVJd3pTc2NBTUNoWUVtVG1GSkIzSXpRWmJzZ0NrcEFFQVREQUdBRnBnbkRJMm9SSFhFTm9sS1hOOENjaThTVkhiRWdoVE12VmN5Q2tFa1JQR0o2dlFDR0o4QVJpTWE0WXdXbE1IeGlpZ0dLaGJSdFNlNEFpQ0FnZ0ZVbU9NQmdQOGlvSUpZU0lRcWVKOG5ZSTVJZ0tFNllaNHEwWUVTR0FGVFk1OHhHQU5xbUlSbVNBUlI2QVJIbVFOTWNKczYwQUpnQUlZMndBTkZvSVpPS0lJWG9KSWhXSjRRS0lNZmFJRW5HQUpXeUNVT3UwRkRhQ0lIbUFDV21BTmxhSUFKbUlBRW1BUFVZWUFHYUFBUkVJRUpFSUVBT0lGZXVRRHVZWVRXT1FKb2VBUXNnSVFxU0FRMXNDY0ZIQVpxbUFNbENJRVNHQUt1V1FJbW1CVWpjSVJQQUlKQkFBYlBxb00vYVlFaE1JRWVzUW9kT0JRbG9JSW84SUw0Q2dVbm1JTkpJSVNKZUFoSGtJWmsySU5hZUFSVVFBVTFjSUtWVW9BQzJJQUNxQW1neUROTUl6WlBMRFJRREVWUkhFVStHd0FVRWdvNk9JVU40b3VjY3d5aFdBRWVNSXovQzNxSlh5TkZRK2lGT1JpQ1Nmc2ZsbkEwRG9LK0JDSWdXK2lNeHlCRlFPTkZ2d0FNUDBNS29NQTZEd0FLSTdHS1RDeEdUU09nd3FpNUFSb2duYkFoMXJBYUpIQTNEVGlKQ1BBUjlKdXdKaG1DS3BuQjVmR0JKc0crRjFpNEpGQUNJeENDOXdHRjYxdWhISEFERzJDQ0lZQ1BBWGhHa3hvQUt4Q3MyakdGVVRnZEFaaUNGUmdCRmNBcU1JaUNCbXlCUjlDRlFzaUdSMkFKS0lDR09yaUNBSHdXUHhnQmo5RWlvVGlhTFZnRDZnRUFEQkFETVhBWkZsZ0JGdUFCRW9pUENDQUJIbGlCbWJ3QVB2aUFLVEFKRFFpY0s3QUJXekNGemhBbUtvQUVJQ2dCRGVHRUpwQUJLN2lFUzdnR3RSdXFvZnFEQjRpQUJ5Z29IMkdSQ1RHQi93dTh3QkJnS3kvUkVSeXdnQlJZcVFIWUZ3QklnK3ZyaXFzWWdBNWd2bDJrT3F0VGdQaXBPcFBBZ0JRZ2dSQzRnQkw0a3psUUF4dUlRY0RhaFJib09nd0JnTlFUQ2w3VHRBQW9nQXVnZ0YwY0lCTDRnSktBeVcwa2dRdEFFakVoS0tZNGtnR1lnUTJpUzd1a09nVlFsYzNzQUVkekF5NXdnMkhpQW1Xd0JndklDWlJUa1NKeHpCQkFPYXFUemRzYUJDM1Fna1l3U2lScEFhb1ppWkY0SGhlTEFCQW9TeGR6c1dHaUFpOWdCQ0I0c3gxU0JrcElneCt3QVJWSUFpb2dCa3hvaEdWNGhESElBeThBQXptb0FVVzVIQ3Z3Z2lKNEZUQkFCVUhnQWd1NGdCcElnU2NjZ0RTZ1RpZHNRaWVjZ0JOSWd4TjR3aWFVQUJSQWdRKzRnUDlQNFJRd0VJSWZHNElzbUlOZ0VBUkJTSUxCaWdKcHVBVUFzQUlxaUlNbXU0RTNPalVxU0lRb3NJRWpJQWdqQ0lNWG1BTldNTkFXc0Q0SlZZTXdxSUpBTUs4K0NBUkY2QVF0Q0lVK2tBUWpZQVJHT0FQcU9wNnhIS2hNSE5LVTBMUEJPRkpqVEZJbFhkSkJ1NEFOcWtVQVVJRXNxSUVic1FaUFFGTG8rd3RrWk5JQ0tqWlEzRVNnZ0ZJdUpUUmViTXUvZURSV1kwdE5qQXdGS05BZXdZQmlmRFRGQU1ZK1M5UEs4NEZROHBFODhvRVVhQkljMEFHa21xZ3J1SUkyaUFZenFBK29rWUUwMklFVFdKd1gyQVZENEFSRE1CMUNZSVVjREFNcTZBSFdZQUVYcW9FMG1JRUlHWUVnSUJJdjBZQS9HSUVCMEFFWjJKbzRRSVZZY0lUL1pJQW1SdFNFWkNnRlN3Q0VVcEFFU1FDRXVYbURPdkRWTnlnRlhxMER1eXFGdlJLRk83Q0VTTGliNkJvQlBkSkpxdk9BK2lnSnFtTVJKR0NZSHlpc0xjaURTTUFEZERrRHd4b0dNd2dCS2pBREk2QUNPT0FDdmh1RlVXQUxvYUlCUGpEUEFuVUJIU2hMbDBRSkVOQ01Fa2lCVUVQTmJSUk5uWWlNbXdpS1lNT3ptb2pNbzZpaEIxaFkwdFROQ0NpQmsyQ0pOTGlBU1h1SlZFaTJiQ3lBUE5QRW4xalRQdHRGYVZ5QmhVVUJ1dFJFWGpPS0RVRFpHanFKT2p1SnF3eFlwQ2dTbE9zWGNTeVN1MFNTR3ZnQUJSQzFEUmcvdThzQklUZ0R4TXNCTEtBQ296WGFITEFLQzZpQjBQa0FFUGd3RUFpQkQyQWUzUW1CRnNnTUVEdXgveE80aENZUUFRY1FBU1lFQU1VQmdqakFnWC94RkJkRGdRTzlUc29FQUJRQWdRVkFBUWVZMndDVmdLMTF5aWdVZ2Z3TTBBWXdnSlNObnhSQWdaYlNnYVZqQlc0WjBSOXJnU3VZQXMzUURSNUlBaUtRaFdDb0JGc1FCQ3JnQWk1NEFSZDRFYWF3QUpSTldiTHNFUk5ZZ3V1UkE1THFKMVpnaENpUUE1WUlnUnhBaE5DMHM3YnNpV0ViVTl1OVhkekYwcjQ0eFM2RmpHdjAwbVAwQzJhc0NRd29nSmJFdXQ3dEM5cmxDd2txSVB4cDNwVXdVZ0Q2aTB3Y1dFMmNVOSsxUnY5WmlZQUZnR3RRQnIzWUFBaVF6UUdBVXd6UVE1M29NeVA5bjRUbE5RRGdnVk5BQktBclh4WHhnU3d3MU9FeXNNTGlyVFJ3QVNmQUFpN2dHdzd0VHY5TXdJVC9Jb0pCQUFBV3dBQVU0QUdTalE4MmhSSGgxTU5WZzJDVWNFbVc4SUV1OEJnUEFCa1E2UUNVaTBaUzNGbHJJSUVyNkwwN3NOVk13SU5JcWpxVWtzdVU4eEtxU3lGRG1Ka3JxSnB0ZzcyUERJTGRJd0lvY0lhRzJZSkVFSUlsdUFSUVNBVlRhQXUxMjYwWElBSXNpQU1BVUpFQjRBRWVZSUVSQ0lGbUlJUUFjQUVsc0lFZWlJQ1dKUUdaaFZuK0tWanBEU0QyclZnelpRbHJtQXNibWt4OEdhQWpaUUdqaXMwd2JZbGQ4d21mRURZOW5yVHFyYUZMckFrSXpnbFJ5d25CWmRtY0FJQVRzQVpNeVUyVXUwb0d1MXJOSklHeTlCRXdEbUdDV3NvbFNBRUYrQUVxMVFFcFNBTGhvd1FyYURFTFFBRVN3TXpQaVFHbXZRRC9GV2dDV0NhREV5Q0R0T1BQdEV1RFN6aTBKbGlBUU03RUQwaUNpVTFiTVVHQmxGMkFEVmdBWkVabUZEQUFCOURQQmpBeEVwT0FKdFJiQ2FqbUJwQUF2elhtQVppQUdGaVN1aHdvSkVBRVE1Z0dRd2dDUFJvQUFpQUFNWjJBRmNMSkMxaTB4ZVMxSWgyZ2FheEx5YWhMTXA0Zk12YWY1VDNUM1AzbnRHaGVnQjdvUnl1QVo1U01hZVFmQ0tqZVFQTUFMMXJHbkZ1Qm5QQ0FUSVFBaTE0QUh2Q0VHQmhmM1IyQUIvQWlaYkFGRzVnZk9nM29aT3dMano3b3hHZ0MwUm0yZzA0SmpvNk1hZHhlR09DQkdpZ1dyZ0VDUmppQ0p4aUJKaGdCR1VBQ1lBN0h3dEFSZmZZQWs1QldydXlmcTd6ZWhDM0dQdVlER2JDWEdzSUFGdkFELzZhU2dSRXdpVFRRaGpUd2FVUGdBaUw4QWl1SWpkaXdnZGl4Q3FDT1JUTG14VVBKaWJLMElaWTlDUkpvTXV4b0JGSFFBbnE1QWk4UnRhYjQyMnpNaWFxMFNoYmd1UnFRQVNKQWhEQndBNnN3cVF5NWdpRVlCR2J3QWt6Z2d1dkxDZExVZ0IyQVpXRVFoaWI0QWxnZWdRaElneXZGQVJrNDdESTRCUUVSa0VHUWhYSUZCVXJ3aEQvd2d5VVlBZ3JoZ3hOd1d1WDhBZE54emlKWTBSTjRYeENJRDVyZ0E0WXJBVGxRQWJrMmlteFU0MlVFMmJaRTQrWTJETm4xM1U0RWlpbHdnVGd3Z1RnTmpNWnNDWUVXSU9mZVJSdUtuNTQxZ1J5WWd4aE1ITE1sQVRCV1dkMndvU1ZoaVM5NGhpSmdEZklsS01tSUQrYUcyZTNkSHh0Q1pmK1NIUURrVElHVW5jYUFOWXFFTG9DbWtPZE0zSUNXT3NMQUplYS9QZkFLUDJZRE1BRDlUQUJ0WU5kTFNBRDlyR1lSUitaMHZzVEZyQWtHdnpwMVJ0a0hqMmRNTlBGdEZHU0VUbWlFWlRYNk9kaHBsT2MxRmRqb1B1UGdMV2xqRE85UUZIS0N0dDBCNE9nNjNZbHFxSWFib0I5ZzlBQUk4UUV4ZVlEeFJRSXAyS25EUVFLSGx0TmszTkwrS1l3QjJBSFI4Y1UvQmtZeDNZc0g4SVNsMUFBNGhZRER3QUJwOVlBTmVFWU02QlU1L2tlUDV0U0RIU0FYd2dBWE91aVRZSUVQVUFKTTZJUnV1Y3Y2bUxUU1pBRkVBSVVnR01qR3JycFVtU1hxKzhGcEVBUWhHQUFOY0tHVW1QT3JXeWx0WUdUbkhnQmhxRFdybUlJWWdGTTVabzMvajY1ZHF5RHpCMWdBS2tlSnF0d0pJYkVBMDcyQk9KQ3dYa0dKVENRb2xIZ0pIaUNEQzdpTHdDQlNaR2ZUQnhod0NFY0owalJMQXNjQkVzQUIwYVpMR0pIclF4bEgwTlNSbUdTTnpzd0pDK2kybnNTakhqbUpQNUdCUFdrQ2E4Z1JCaG1CSGhBQ0tWaUNLVUFVc3VSdFU3aTBSSTd2d0RhTWdaTE5QVklNRWZaUzhrMkpGVUNCdEVBZ2dmZkZhT1R4eU94RkNCb0JLTmgxRFJBTU94MjJOSVlNTmQ1ZVRENEpFNml1NGhrSkh6a0pCczhKZkE3MkdkaTZ5emFpVTZaUEZhQ0NJb2pOcGpEWndINXFiUXhzL1Zid0pibHhrMldKbkdVSkNFZTVHc0w1SEpmR0lkMEFBbGlBREpkbUJpQXh2aDF4WkM0QVl6WnhUQVJrUzhSRS82dnY1YXUzZWtGZWNLZis3elRGbnoxT2pJNU5DYUt3OFk5RlJ1Q2Qza0VxY21GajNqMWpDU0puKzVkb2dVazloVUJEZ1FzQUljV0FBUHNZaXdJWVgyUlV5eWI0QWNqMmdaM1liT0hjSTRIL3hEUm1OU3RXSGpoTjNyMGdnelJZQUFDS3RjRW9BS0lRV1ZhRG9KZDRhT2d1NlpxT2FZRlY4eTl2Y3BYd1JWOWtEY0NINmVmdUNxT28yRWxiZ1JqZ2daeGNnZlFGODM5OGM3bTB1cFI0NllSV0FBaG9vZmpKQ1RjbkNpcmY4OGIrZ0J6NGdkdWtpZHozK293djAxM1UvTWIzNktZR2VnSXZDYURmV1pheTREb1RFekVoU3l1cExndm9TU2I0QWNZcEFRa2JnaXRZQWxnWlBEMHNFaFlSWXhtbU9rNkY4UGl4Z0I4QWlDWWplditRU0xFaFJaTW1GZ1l3ak5BakNKUTFWZnJrOFZJRVFKSXZOcmh3T1FJR0NCQTFGejlRc1lKRmlSSWhPbG9vYUNITFJRa2JKVnlrc0JCQ0FaUTZlYUFBQUxDQzFTVUFESWN5TkRWaEFBQkRwaXdvczZWQ2dZS2hCWWd5eEFDaEp3NG9jWExvNkRsVUtOS3dYcWtpOVFwVzdGbXFVYUZDdGREQ0F0dXZZUm4yQkt1Z1p3cW9TR3RjYVBGMTdJQ3BaQWN6TEpDV1lkUUJpZFVXS0xCaDZnYkFpUU1nemVFRnpKSzFnUVhUblV0VnNBTEhCQlpJS0YzYWdRRVVDMVkvMXN0MlE4TzhiRU52VUxEaGRnSGJqaDNmcnMwNU1GbXdRb2ZUTmZ2N04yRzBhQVBVYmU2OGJQT3lhSjFUcjI3OWV2WGcwSnN6RDBBWk8vanc0ckZ2RDEvLzRBR0U0c1BycGkvYnZ1Y0RHR1hKM0MwLzNpeUFCenkyVC9lcUFJTjY5OWxISFhRWUNITUtEM1VOV0pjd29FUmp4M05tTWRjVEdaeVlnWWdkTU53WElRQnpLS01nZU9WUmxkMWh4QkYxbUZncEhyWUJnSXNoVnRoNkJBcW5vb2xEVGFpaVo0amhoOWdERHlqMkFGc1lmREFGWExOdFlJRUZIV0F3MndCTEtwQmtCQ21VQUVZa1ZRQnh3eEUzM0xCR0pHQUlBVVlVUmhpUkVoUlErTUVDV3hHUUVBRmlINUNBUVFRUHNLQ21qMUUxUVlKaUE4QkcxRm9BYlBLSU5JN29VWVVOQS94UUF3QXBDSkVJSkZGZ1FZd2hBRVRBQkNzcTlLUVNraWtzSVFjVWlTaGhWaHBVa0xLSEYyRHhrRUtlaW1GUW13SWZKQlpDRGpiY0VNVU4vNXFWMWVNQVBwWTFRZzV4UUdGQkd0cDRraFp4WnlYbUlsS0dEWldERURmWjV0VnRiUlg1bG1zRHlKSEhFWkxpRUVJTFIwREJVazlnUEFKRVZMbTFsUUlPUGVtbDJFRW9QUGxqVkRoY0VNRzZTSkV3cjF3RDhJV3FZa2o2dTFBTDAzQmgxNGthZUNIRVcyLzVXeTl3aWtWQWIyaU5SWXNDZkx5eEZtMmVaajJwZ2dzMnhJcGtYQjZNcFVBRVJhWlpGNXVLMllic1laeEY1bFZqd09VV004dG1TU1h6QUpUbDNCbU5RazMxVzR6VndVWmVjNWRvUThhR01oSTMxWVRXOFZkVzArSXRlRjNVNFVHbndCUVBVRmVBeUdLWVVnMStLMmlZdE5URm1pMGRmbGJ2R0tKWDZhVjlIUVIveU5DRkJ2S2RUVGJaTUU0ZDlIVUR0UENFVnY4bVF3V1piWHNTZHZkUS95VW5GUUNHR1NhamlxRzFsK3NLdWlvNzQxa29JalliNTUzRFpVSEpFWmd3T3NqL1dZQkJCeDJNSGdJUTBPaVJpU1ZqeEI1SUg3UVdhUUlMR09pT0FReTdpeEZCYlJqWHV4WmJRcm5HTU05anJhZGVnTjl0M25saE45ZDFsN0VZQUpteHlvclY4TUhDY0VhMWdRYWpqOTVCVzB2SUFFVVFTM3dPNElpSloxL3RpRHBnSVVjTFJWaUJueUZoUkdHRERWRjBjc3NZak9DRlVCakJDWS9ZZ3lPT0lBUlNHTU1WWStoREh3TFJpVmlRWWd4amVBUVZhdENDRU5qQUNmd1RoQ0phWUlNaDJLQW5TRkxZd2t4UVFoR2FEREcxVVV3TFRCQ0NHZkxQZ3paSWdraEdDSklRT0F4SkN2S2JITTRnaENvUUFoWC9TR0lJRTB6d3BBNHdvWWxNR0VJSmNpQ1VDT2hBQ25Hd3dUT0lNY01hYk1zRU5iREJCM0NRZ3lTa0JBeEdZQVQvSUVHTFRrQXdDbUN3d1JPQTRJUVd5R0FFSWFoQkVtUmlBeE13TVE0MzBFSXZPZ0dFSTlnZ0JDWjR5d2FBcDRCMEphb205QUxTWFpJd2lVaFpJQVZnTEZsVVd0QVRFNVRPYnh3SmdlQ09oeXp0NkFrdy9SbVBYQUJBQnpLd0NVVFBpOHVBQm5NZVpWRXNhR1N3Qmg5NllvVTAxS1ZxMWdrQUdWQjFuOGNwcnpveG9FUVRRQVFBS3p4REZzNHh6SHQ2VW9EdW9NMW1VQU1BYzhMU21NTThDUzUvRVpCUXZPTzBjUmJ6YlQycmpuZVl3NW16UWFjNDdTeldPWE1rendoNVJsMGQ2RUVab0dBR1VkVGhEVzhvLzBVcHNQRUdiRHpDQ1RiaFZwRlVocnpPS0pOWWFWbkI1RTVabzNmS3N6aWpmQ1VBS0dHTG9MRGxjNkQ3RjF4QzE0RWtoVUFPakRqQ0U0WVFBaWFVQUFoY3lzTW1oaEJEQzVqZ2lVOE14QmlHUVlzN0ZHSVB0SEFFS2tLaGh6ZGs0ZzJXT0Nyc0xJRUhTMFFpRHgrNUFSS2V1SVFsREFFSFA1amhHa3F4Q0NlRUFBQWxCRUJVUTlvVDV1REtuUURRQVJLY281Zk1hZTVGVW1HWk96ZlhBZlYwUUtVcFNBRmVPc2tRQzlSQUJ5RW9BV0IxMElNZVFPRUhQWkNCRkhxUUpJYXQ1eFRXaUVHZUJ1Y2lzRmlnQ0VVSXdROWNwRFd2dG9BRU9ZQkVCYVB3Q0FnNm9SYXFNQVlwU0JHSUVCeGhFWHB3aFRFc3FBdGpxRUlQWTVCR0xQOGU4UWhOYUlJYXRLaEZJWFJSaTFva3d4R2RHSU5RUStHRUlSVEpDWVRvaEJPY2tBaE5LTUVKYUN4QkMwb3dnNnNLZ1FwS3NNRVNoSUFGTlNnQ0ZiRlFvQmVVc0JZTnBDQVhtYmpESVE1QkNGRndNQXFrK0FRa0dIR0RJbVJCQjB3UUxGcWJtRklieEdFT005aWtZS1ZnaENzSVFRZ3lYVmhVTHNBRkY3eUFDbHJJUXhVQVlkc3hRTUlMMEJEQ0VlcWdDV1Fzd3FsQUNJTWFiRUJURXp3aERsU3F3bEF0VVFVdzVHQWhVRGxTVXVaQW1WQXF3Sy9abmFFT2Z0QVZMcGpDQm9TWUJnQmFzTUcvbHVBUmlYQUNZTjJTcEpIcTVRS21HTmdBU0hDTkQ1VFRGcmFnNTFSbWxLekdXWk9ZRVhBU1EvZHFnaFNRenB2UDJXdkpMSkQvU0NTUm9BeExTTU11aUVNOXBMQ2lHWXB3SmQrYVk0cG1oQ0p6YzFsZTJnS3pXZkVFZ0pnOWdVQU14bWFZQjZSaFdQUjBUaHA0YVR3bnBVa0JySGlHRlVJUUJVSVF3Z3RPSU9SQ0FvMGRDYVNoQXI1VTlRQStrSU1jTElHUEkvakFDRWpnSXcrSURORVBHQUZnaHpDRUpGN2lFZ21RQUFNa0VDQ2tlT0lhS3dCQUV5enRGZWZaREo0M2F4OEpLTEJvNHNCSkF5WFFRUkJ5MEFNbVhBRUtRcnlCRFNJeFVGNncrdzU2V0lRZ25nRUFoSFp1TVdKKzNsK2FjSUViRDJBRkowaVYrNXFrT3gvNGdBV3BOcEd4b21LQ21iZ2dsQmdBYVpKWXdwVVQwalFGSER6MUhKR2tBU3Y4NEpDTWVFUXNZakdvS2pBQ0NIMFlReWRJOGU0ai96UXhLU2wyZ2lKNklRMVMxR0lNbWVpREU2cVFoMGlzQVErOGdBVXVZTEdIUFdRakcwU0h4U3h3b1lwRjRBRVBpNmhGYlBVdzlEMGdIUlpXaDRVcWtsRUxQQXh5RXpmd2dpRHdRQ3U3SkNFTFdYQUJBQ0N4QjFXb0FodVI2T3BRSGhEbXRDaEFBeml3QVJPV1VJSUk5T1RoZGk4QnQyU1NwRTRDb0FSUnVJVWVhcUdIUURpQkNqaWNneUVhSGxsZHFlVko5S0tMTFV3QmdMWHk3SEVGZ01EUVZBWUFMa1RLZVB5R0RmVVNjenE0TEtFS3FBaXFFMTR3TUN5QWdTVzdmSklJaFJDRmQ5T1c3UThjZ3lvczJJbG1vR0pVeG5pRTBCTnZET0krSWhCSHNBQUFFcEVJTENnaUQ0OFlBOVgzMEFlYTJ0dVZDMkpJSWdId2hXUmt3LzhScGZqaDV1OGlwNGQxZ0wwdC9JdGltQUNGTXNoZ3Jpb1QzSXU2djFhaFJJdDZqU3ZBQXNoZGo2ekFtaWdHRnlUVE0wMEg4K1NLOWZSSW5KQk1EY2pHY0R4SkNDeEJIUGdWVGtSQkh4QktFUWlDRWRnQVN5VEczT1VIZFBBYUFQQ2FWU1RaU2dtQklDU0JLVmxiNDhqRms5aEFNM3daOVBGTVdLaU9EN1JaVkJBSVZJeFVCN0RaNkh4Ylp2Qk5OWTBJWVB6UVpySEU0bEJIc1pHTk9qMlRBMXhGb3dIQUZGeUNHR0FUb20ySEF1ekE5enpBdHpIQmJGUlNzd0JBRGdDQkZ6eENGQWhCRHZpZmdDeUFvM0VJZ1F5QU41SEJCTWhoUTFrQUVPUUJocGtCTTZRQkdaVEc1ZkNIZ2tSQUNmVEFEeUNCbTRIRnorUUxDcmpMYktUL2dBN2t3SElWa2duZ1FBbHdVdXBvUU82d2dCaXdBQXNnd1JVZ0FjSDVBQkowQUNLd3doTWNBUjRFdzVOMUVCQzBBQlVJd25jSlFjZUp6c01ZVG5RTVFKU0VBQW1RVCtLb1MyZHN3QU9jV1p6TTFlNEF3Qzdzd2dENHdCT2N3Vk5kd1JDUXo4cU1JWVJCM0lweEVBaU8wQXpSa0EzSWdldlFBalhzVHdoMFFBc01RUTZrRkl5bGxqRkVFQkJVZ1RIQWdpTlVFRWdjd1JISWdST0FSQis4MnlKQUF4aHNnaHc4Z1FWcVNWUHhRakFVUXlQc3dTek1BaXdjUWpFY2dpTVFYZkJOaEN1b1FpRTRRaThVUXpITWdqRTRRa1E2Z2laSXd5SlVRU0F3UWg2OGdkTkZRaVRrUWk3SXdla2doUW40QUFDRVFUTWNBaVRNa1NFSVF1TnMvMVlhdUtCMElNWWtMZ0ZlcGNFWENJWEZTVmN6ekFFQXJObnBVQ01HcE1BVDJBQXFLQUlqUklFY2VKVVlKY0VQdEJVTzhzeG1mVk9LUUljS0NBRWg2Q1FBekFBVktFeUwyRVlIc0pZVHhCc0FUTUNkM044UWVFRVY4RUl0T0lFV1FCZE4yY0FnSkFJWVZBRWhIY0ZFOU1FaWJHQkpFcEkyeXBRMkJrSVZWTUZJa3B3OWp0QVNDS1FKMU1VWjhnOGNRZDlVME1IWVVBY01YRUlUdUtIUEJBWUFDQUFndUpzcE1WUnpRSVVKNklBTUJJRVBsSUFNRU1FZ3RNRU5iRUVibk1FTktCR2ZuRWorSVVrSVdOd1AyQURFSUlhYXNBQUsrRWh1dEJNT0FnQVBCRk1OR05JSWpJQ1E2Y0FTakVBTWZNREQ5R0JZYm82ODNOME1DWnNjU1A5UjRlMWhIOXlDSTBDQ2NrRWZXN0hWVmZRRXIwRUE2R25HdEtITjArU0tpbUJBMzRtSVY4VGtESkZPRHo1SE40M1VtczBRUzRtaGREd0FDWkRBQjF6QUJPREFnNjZBVzYzSE5CQkM3WFZBTVhLT1czMVRjMUJBZkZKSEJEU0JBL1FTZFpEQktvVG90TG1OZkpKSXRSRkxLdUVOTmlVQWpRcEFkckNvakViTjNyVEtYZFJTQVBTYXF0WEZBa0JpUFZVVW56eEE4SFNURFAzQU5MamdCazNWREIwQkhNaUNEK2hPMzJrQW10MkZDOWdDTDNVQkZxaVlBakNCRjNnQi93Q0JFSXdRSjBGZkV5aURmTEJtalB5bUFsd0FEN0FQTnRGSS9vMEZwNjBGajFtQlFuQ1FJZkdSQmlCQkRoaEJGRVRCWXhhcUpreUNJSENWSVhuYkVnRC9RUlFvUWlkMEFoaUEwa2lGUUJ5NGdCUHNYaWJvZ1RFY0poNVVBVFlFM3lKa2dpNjRBaWwwZ2pSMGdpdm9naXFrYWlma2d1NHBRaDA0d1EwRUFhNnVnU1ZVd2lFMGdpdmNRU05zQ1I1a0FyR09RWGtKQWdoMWdpSklnelRVQWltb2dpc01GeXd3SGhDY1ZDQVVLaUVKbTYwK0FqVjBnZzI4QzM4S0FTcEF3cmUrakhxMGlwc1phWE9RZ0MzbzJBeTFRQW9BNDJCc1VsNG9vNlhZVzFnOHhucE1oUUtrQUpxc1NwenNUWFFReDF6NUI4RDFpNHZkSENqQkVnQ1lRakE0UVUrMFFCUm9GUkNrMUJHQVJEME93YlZrQWpaWXlTRGR3QkNzenVqRTBDRWRITnVnQUFqVUMrVEFtb0kwamNBMnh4U2NnQVkwcUFMSWdCbHNnUVZjLzBFWFhBRVJJTUlWQU5yaE1NUUhOTUVQcEFCZjRBQU8xSURLNXNqQWhsT09RSVhGNGNEQ3pDSHpQSWtKYUFBVHJDTEdNb0lUaElJOUVoSXFhQjRZUUlObW5ob1FmTVFSckF0K2lBemJucURUL0dSVmtBOExmRUFkVFZFTnFFQU95SUVPZ0NDMUJJaUMrTUJLR1ZJTEFHTjJJSWs1eXBBTVBaRVNMYytBTnNmakhCb0FMQUJHYk9WcUhrdjdYRWV2OVJxOU9PNHZkY2ZBa2dFbzBBRTVTWlNNWHNjY21FSURKRURTV0VOUVdBY01TTzVZSlZwUGdJQTFJRTFkZUpuc1lvY3BnQUo1ME9GZExRUlpzRVVINElDbkZka041SUFNQ1dSbHlvRU5OTUlodEFJeC9FSWpWQUluZE1IbUtWUllLTUFETEluZndtZ3NEYXhiWFZURHVQOVNyejBBOUxHRkJtaEE2a3laNnF4WlRjbEJJRkJETXpCZVFBNWJEd2lCR1JoQkhEd0JZR0hYdkNWSmp3UXdDMmpBY1BKUk53RUFLTmdDS05oQUhweWNIdHhDYXBIQ0pQUkNMY0FDTGN4Q0tUeUNJM3dDTlpBYUlaRHJKaUNDRzNSQkhaakJMMndES0tSQ0NxZENLclFCc1VvQ0hKZ0JKN1RCSVB6Q0wyQUNKOEFCSmtSREp3QkRMR0JDTEh4Q01rZ0ROL1FDTGRCQ0xOQ0NKZ0JCSEJTQkZoekJBRmhWQ2NTQi90cEFFVVFCTk1qQlpRcEgrdVVMM1BySUx2TGl3NERBbnJ6Z09mMVFFM2J2amNRb0toSGo5YlFQZjBSQUNBamJTdWxBQ21nQW16eU9CY0R1a2J6Rlh5MEJFL1NFNkpDUEJTd0JTcW1VSWNIU1g3eWFmU1QvRDM2YXpUZ1IwNnVGeHhSOEFBdW9TZ2ZNVFNocVFET09nQWIwN2tTZFNOK1lzWC9HaUJ4L294ejRrUnlVZ0J4Y3dSRVkwdWVFZ081RkFqUU1Fa2pVQVRib1FXMUJ3eU9ZMWhoMEVOY0tRaTljRmdqNml3a013Ukwwd0Fna3h0cTJhSWlnbmd2a2dCaWhGV3pPZ0Fvb29FMGdyUTM4cnVWZEhrTXdFUWt4UWQ4V3J1b0VhRGZTc1pMTmtNVUpXMCtFd0ROOFdhQVZSNGp5ekVWQnNuVnNneW1RZ1RCTVFlbFdoNHJpSVhiRWdMUUpoazk4Wmo4N3gxZHVpRHg5cFk1Yzc3elNoUy9RQUVDWGhTbDh5Q1htUlpvbGprT2NRYmF3c2pqN0VBQnNpNUsxQks0R3dTWUVnWTB0VHNOMFpZNnMwenNaeXhSRVFBZXdRQWRBR3k5Ui93VVA4RUZpc01BRGZFQU5RQitwUllDUkVZS0sxUlFwaGdBU1ROVVRaRUVpQkVJZ3hLSTN0Wk1Ic0VnRW9BQzZJSzBHV0lBSERNQldBMGtIQUk5VThLUVZ4SUVWRklFTEpNRVQzQUFZZUFFa1BIR0REVUk2NWtBWFdFRTFhRU1sc1BBcU1NTXJwQUl6WEFNaXZBSmdCL1lXSEJVbXRNSXJ0RUlyVEVKZ3MvQWxCTUFsck1JcVhNSWZBQUFFMVBRM1JvQ2d5dVQwS05TYUtaa0x5SUVjaEd5OUZPTUxKUTVzSEFUcXlZV3VOUVR5dk5sQkgvVFU0QWc3UmNkbVBReEdQNmN5OEM1UjhHZWdrUUV2bFlBNFU0dGVoQmxEdUN6Q1hacHN2M1kvRDhBSXNJK0hLamQ4YUlBTHpJQU8zTVZrK2NjRzJZQUw2Tjd1T1RYL1hBRWp5UDhCSVlGQllGNEpFOEFGRjZqQklod1ZFTWhFYXpXUWFhbENSSTZCSHZUQmwzeHRMY3ZCd3JMRkEzdzFNN2N0a0ZMSHEzMUJFNVIxSWpkdWR1eVY0QjVTeVhhR2xNUkVFdm1tRDdidmVKS1FzQTNCUGJLQ01sQkNDRGhCSHJnQ0t2VENJNFNDVXpNQ0R3SGFKVmdEK0hZb2NEYUhCNXpDTnRDQkhWd0NLTmd1QUlpQktFSUJFL2dOQ3ppREdHVEllRUFBZWtCVEk3ZkpCWlNOYzNCRVQweUI2Q1pCTTN5SWliNDI1VkRvWFpDQktYQ0NaT0JNMDZLeGh3TGk1ZklKWHBFZ1dLNEhHUVFGQ1NTQkN4dzRWRUNiRlJCWlcxQVovQVN2ZGxSYm1qbDNLbm5Da2F2TVYzZUFENlFPSDNnQ0pzODBFb3dBRW5CaUVPaEF3Zm5BRlVUL1Z6L0owWlhjQUZYQjh1ZDhXNjZ4MTM5YytxV3J5bzA5akNMMWlQWEFDUXFRd0FxZ0FERVNJL3ZOZE9xQUlpaCs5Y05zNy9aR2lTbnFnSC9wd0JWY1FRaXNnUlNFd0JVRXdSVk1BMkNuUWlXMGdndVhRaU13UXpXa2dpeUFRcDdoVFZ3Rjc1T0VEeUd2aS9XSWI1cEJ0N1U3eHlSYkRWMXMxanhMQ0RZeFI0b25TZ200cDFmSXRNcjJoQzljUWd3TUxKQ3d5UVdRdDByWVFBQmNuckpVMDVaZk83N25PM2pJUUJLVXdSVnN3aFo0d1JvK3dSeTNGRFFVS3BoQUE0WTlkZTBzWGlpb0dCVVFnaEVBUUQ0dUF1MjRRaUJZM3hna0F4TGZRaXkyd0EzZ1FqSDgxaDRZZ3k0RWdvb1JubWE0Q0w1U1I0QmplN0hFSVhhUWdidDgvOFU1a2xBaVF5NzIwcm1DdElRTWpkQUlmUzJHN3hjWDdJSVR3Ty9KV2RBam9FSWlLQmRwYWpzcEZVczFnQTBBYkVNcXJNS01XNkVHWE1FWmFBRXhCQU1SVkVJbE1FTmQ5QnFrR1hSMDBDZDYrTzBBUUVEM3NVMXprRUdDMUFVeHZXelNRTURNWm5WL1N3ZnhYSGREbVVnUFdvTWcxSHVMYzJVcTFaTW5KTk9BSWdaTmhjQXE3dVVOU0NNVC9LbkpOT0MwQjhrSDFCSkxxN1JHUTR3Q2tJL3F0SUFWNkswT1BNRU8rZ0M1QmNHV1JQNFRNTmdWdEw3cU4xVWszSUJMNVFFMDFBRVcxMEVkYk1FbUVBRVVmQnNTSktJR0pEcWNCeWQ3a1FCNzBYVHFwQTZnOXZtbGZ6VUxsR0xXUGdIMVQxVXlDMVlQWUdjSjdPRG9NRUVSOFArbUxZVEJYMlh0TzRZQkp2d0NNOERCRzlUQkdzU0ZhNmlvZldUN09IbUdJb3V5dnQ4L0t0RmhDRFJCdlFJRWdBRURCQ293cUFDQUlVRTJXaUFFOEpCZ0FBQVNCVUljMGtmUG1DaE9MSVFJSVVRSURnVUVINVlVU0RMRkJ4SURTVDZrcE1hamhRZ3BJbXg0Q0lGZ1M1TTdlZmIwK1JOb1VLRkRpVUo4cUVEREV5RmJvbFJaYzJOSWxVV0xqalFFd0FXVkN4czI1RlI1MUVlT0JRc3RRb1RTVTB1VkkyNjA5Z1JhZEl2VU1GeWsrdGdBWUVISGpTcEFHRVdKQWkxS29oQVZkMHBzT2JEQWdBQUZBTkM1dEdxVm5aOGJhbzRrL0pObFRpNklBQmdrT0NPTG5CWVdXRjQyV2pKbjVvRUtUSlFZWXVOSWJFWTNHTm1JR2FJWklRRC9UaElsVXhYSXhoeE1mWTQ0OUFtREJRQU5wM2ljVkowNloxQ2RSYW4zbkU0OWVuVHJwcXNmakVDQ2hVRU1Jek1yaUJEQ1NwcWlqSzJuM2ptd0l2VG5xQWRnaU5DaGc0SU9ZM09BdVhFRENDQXN5UU9JL3dvODRva2hoZ2pCQkJOOGFCQy84Y1k3aU1MNk92QW9oeElzd0tBRERDellBSVB5T0xSZ1B4TXNrRUVHQ3docHhnallicmppaVNlQ0NHS05SbjdaUXBGRjFEaGtpeHRtcEJHUFNEYTVZWXMzakRTeWpremVBTVFNSW9MNHdJMVR5dWlpaXlzUUNXTUxLRGFSQWdnaElnRURqRWh5RWZNTU1ITEpCYVF3TjFuaktTWk1DT0dKRytTSUE0ci9zbmdHa3h0czhPR0tPT0xvWVlrV1NpQWhBZ3NvcEc4QWcwSkFaUkpCL3dib0lZNy9PaWl2dElkNFFJRWxCVENvcnFRQXJ1UFVwMDlCTFlvaWlvWWlTSWM4YW5FRWxpb1FqUURXUW0xUUpBd2IzT09KSUlOYUFBT1NVTVlJcGJheFdyQksxQWRxMEtGUTh1QzdkYUFOUUFEZ0Vrb3NPQTBpa3BTRnp5aFJSOTJXMitwV3E0R0lMUUI1NDQ0N1ZESEdDUVZrTXNnR3NUNk5vQVVxWXRFaUVEMkNJZVNXVUVKUlFnZjZqakl1aE5IVWpZQzhrMUFMOVNGaFFOa0dFVVNFOFFCWEYxN0FJUVZ0T3kwQWdnSVNPMnFERFVyNytHUHU0RE92b3hZS0txRUVPZVJ3d29sQUFobURsRWtJUWNnbUFEeFN3TGFHbmdBaUVEa081bW1GTkJBSjRRc1pUcnJXUGUxMm91TWFSRGJ0OWxTbzM3TVlLQWo0K0hrRk12L29LQW1DR0I1NElOTVFNeXNwZ2pUSWVLOG5Ud0dZWXhLU3RGUDY1OVFLb0hEQ2d4STF0S01ubUpCeERRSHYySU1YUFBEb2V3MDhNbGtrRUNkaWMySXJHeFEwWVQ5MTl5UFJCREZZOE9FSlJnanBwUW9uR1BSaEJBMEFzRVk5VGZGN0V3bTl6ekFRRUQxWWR1SUpHNFJvNWhsQVJGbUdtMlVNNStVT2JMQnhoUmRlZkxjRWtEb0dYNk1MVGxKSjVaVkpKbm5sRWdEKzRBTWhSR1E1QXdvckJpRWlsek0yQ1JDTUtBREpZNi9ZZ0tnaUQwc1d5WVFYWEE3cGhRb25xckFrRTBzaUNUQ0tQUElIb3NJQkZyakpiVW5MRE5oQ0VDaURtSUFKK2FGUWZrSWtFQTB3cUFRS2VKQnhwRlpCQ3diRlZFUkp6WVcyc29nKzFNWnRFWGovUU1GNDhnRXJxSUFuQlhoQUJITGdCV2lFNGhhOXlrUGl3Q0FFZ1FIZ0F0T0lBYlZXNHhuVlZJUXhpSEhid1paMUYxdE1Zd0FwMDVBUWwwVzFDejZ4S0FONHdBcFc4QkFOVkJFQXQzQWZMVWpScmhZb3NBaHFlSUVObG1BQ2FwbGtBQzlJUkN4dUVZaloyQ0FKYzJnQ1FYYmdDZVhNd0JhMmFKZWhQRU9ZSVFLRkpCakF3Qi8rWUowTlVGQW9BMGdNUWFwQkNSY01EQUJObUVQOHFwVW91MkVySndvZ2l3dEVZNUM3SEtFMks3ckZHQW9CaXowNG9TR3IrWUVMY0JDQ1pJWGdmSEpBSkFBV3NJTm5WV1FrU0h0T2RxRFl5NkpZNHhwblRPUkQrQUFLTXpqREpERzRtZ2E1ZzdiM2FDd0NBMkRGTkFBUWdmSDg4RHJ5U1ZRSy8zekFoQ0VreUp0UFFCQ0FDcGMrUEd5aURwR3doQ3Iya0kwOTdLRVFlSGlDRS9yZ2lqSG9vaERucWtVeWFBR0pRSURoQ0Vod2sxaldCWUJUcEtJU29FQkVHNkp3QXlOa0FRa21lTUlWYnRBQ0lmUkFYUTd5UVFpR1FORUFCYWdLcGJqRkxVcnhCajFBSXhhS2NJVXhjUEVKWE9CaUQ3Q1lCU3hlT293NzhDSVRrY0FESnlyQnZGRzhBcWpQZTU0c21KRUtMclNpRmNkb0JEZHNRWllyUERWR1J6aERIdDV3QzB4QVFnOVZRTVlkaHZHSlF4eWlHTnlZUkMrR0lZMVBmSUlRMHVqRUpvNEFsV3NwNEFFbDBRWWxuRE8yN0t4bUFCMTRrQStHc0lUOXBFQURPa2hCQjJqQ0FnOTBRQWM2Z0p4bGZObFlDMEpnQVJESUlDQUhRUDhaSEN4aERWRzRnelEwb1FrdERBWW9rd1dLQWx5QUJjQXdBZ3hWNkFNWUdDR0hFQ2lyV2lWSmczb3NrSUlmSkhacVRZeVBIK3NhVndEa0lBZERNTlJxVEVDQ2gwVFRzY2xkejBPMHNRdUJTRVFIdVFBQzR4SUZnQ1J3QVJLUWFCa1EydHFERlBRUlVkV3NBY3BLWUFNcVRLTUpxRkhYZWcvaUxzYUM2b2NJaTZKQTJHTXdBSHhnV3VyNllnc2ExRjhUREl1UFlrblpFTUFVTUFBUVloSkYwT1RyakJDL1VEQnV1QVNWTUhsbWlVWS83ckt1dkZUdXozb0pBUmhBekNTc01NVUVHZ3UzM1lwcU9peFJJUUJjWUlYTzFBZkdZN053b2pEUUlDYTBGUWhyaUVRVjhLQytSVGhGY0pZUWNpWXlnUTBpNjhJVitDekVrblZSakZIL2pNSjVoMWlHSkdDWURPTGM0QmVWQ0FJQVBKQW9nb1RBRkthZ3hEV3VzUW9aRENBQ0dnanNFanpLRnlmb1MxOWprTE14aktFS1ZkemhwYmd3NVN6NExBazgvdzBabVhDRm5lMzh6bExjb1JqRXFBT2I0TkRUYllEaUYyYUloakZsRVlZYjFBRUxZTkRDSlBWSGhTdlk0QVpEWXBrV0FJR0g5bjFpY0lEUVJDa0NFWW8rTEVJUG1qaUVOQUtoQlN3SUFTSWVDUUVma1paaDh5QWtVVFBKNVRVRndnSTU1TUFqR3BLY0Q0VzVZV2QzUzdUUHRpQkp2Z1lBQ0NnQVFFZGdBa01Bb0FSSWxFSVBRRmpRcExEVkxUUXJRQTJtY0FKUElNQkRhVHRiYldxcmlDRnMwWmtXQU9FUldSVkNIQ0lJMi9tdUJnY21HSWdGVENBSE1QaU0vNGpUTGlMVURoT0NFampoTlF2UzlWWkNBQnNncUl3UmZIa0VLcnpBc2pqclFWOU9VQVFxcE5IR1B1UmhDQUlaaXc1RVVpbGJnQ0xhMmRwbHlKejRib1pyMDdleGJhWXptU2t5MDJoTGtZeGRRaHc2WTZJT2FjQVBOeERDRGN3bmJoczd2QVFJYXVzUnp0Y0hSOUNpRDJQSWhESGFtUTFUdmxPbWZIN25IbFNCaDNZV1FzbUZNRVltcWdDTlBLZ2hESnRBQmk2UUVRUWYrQUFKUGlqQkNCb1VnUWNoWVFTZVVVQU5sdUFES0NpaUU1MVFoQ0JRMFFscGtNTE9lcWd6TzcrdWlrTHN3WDNGMEh3eERnRzRZa3lDRzRlZy9DekFXb3hXbEw0WU43MERNa1FSaGx5b0lRczVYb01YbG40RU1RSEJMMXFBQXpLcUVJdEdhRUlTbHYvQWhya0trWW1Ld3ZJSnU2WUNJYWdBR3dZdDRRbWpHUUlUUmpPV2d3alNNazNFcTM2WTROZjhWRW9nZzYyNXpjbGZmdlAvL0dpamNVSXpCRkh4eHUzYTM0cVVtb2tCTUExbG5BUnM4Um4vK2FPb1NKTGtJQXF3WVE5cUllTWVBUnBDb0lld2FTSWVZckllUUFWK0lBUndRQ1FlQXNCYTR6WEtiUWEwd1dRYUkrZXdnOW9XN29MeTZrMlNEZXB3UUE2aUxuT2NJQXFTb1JaZUpobEl3VmRxQWZMYXFSWnFBZVRHb0JiSURqaGtEbzNhemRxa1k4Wk9ZLytVYXdoRGhjYkVRendJZ2hJbTRYOE01anFtWVJLY3E5eXE0d0tzSUwwUUJaTm96RkR3QTdBc1NnOE81dzNZcmlvc1lBaU9BQnFNckErcVFBOFd3ZWtjUjJXT3dBYi9NcTdxeHNBWTVPd1JiRW9WM0NrYkx1OFE5T3dPM21BWStFelBEdUdzY0VFVE9rRVM4cUN0R0NFUm5JY1lsb0VZS3NFUFVNTUNOQ0J5UnNJSGxvQkNMR0FKTk1DTUFDQUZKb0FTUmtIZGJBQUlia0VhOHF5emVNRVZ5aVVRaVlFUVhTcnNhSUVXdm9vV0hNRVJYaXFtakdIUVlNR2wzb0JOL09BSnlPVVRIR0VXTkFFWDd1QVczZ0FTRkVFTGppQUVIQXBNb0NFTTVnQUtSOEVXSktFVUl1RUpUS0FIaEdBSmRtMXlEc0lFaGtBSTVHQUlicUFFVEtRRWxtQWRTWVBtakpELzVwRWU2ekZxV3VBR1RHb005aUFab29BS0dJUUpQTUpFU01nblBNd0hlVTQrZm1KamNJSStxSWdoN1hGYjNFYWlRaTBLZ0NBT2xnQSttc0FhLzJDZ3JuYk9KQURMQXJJdEN1QWlDZ1RGSFlsSUoyRGdJRG1GRXVpcVlJcXdnckNGQ3hLQkVVNU9EMGpoRG5DUkZCNmgwR0FoSThiQWpWN0w1eUF5SXBzTkFKcWhHVkR5VXpRc0FsREdCRktnQkRwRVAwVEhFRXhCUGVKcklNSURBRjdBeGM1b2lMREZCcHFoM2l4QUNjTEFCVHJqSUd5QUNYeWdCWmpnQ3BiQWNYU3NvaXlBcjRBZ0Q3U3VEL0l5Rkd6QTQvckExZXJuMVJhQmNkSlJDTkRuME82QUZKSUJGN0pxZlRLaEZBSk5GeUl6RXdEaHBuQUtENmlxZUFwSGNQQUFsRnpnQzFZaENCeHVNRUtBQ29SZ1dzcWpBNkt5SE4za0NxQ0FCZkNEdnhSTHdsckFCaEpCQ0w3cEJzNEFDeVNCMUtRckYrQ2dFVENoOUlBQkUvK0E0Uk40QVJpb2dSQys2aGoxb0JSeTBWeEtnUmN3N3hOS2dVMHM0UTE0Wi9WcVFjNkNwRytBSUhiS01EZUZBQXBBSWdRbTRjbEdJUlVDZ0E4NjRDanc2cEJ5YVFBSXJ1TDZpaVptb2dTK2F5QmlUdG9tcTFRWWtDZ0QxQjVOaFJ1SUFRRHc3Z29rRHRTcWdPb1VVU2g1QXNSNHdCYzQ4aWNXSUlpQ0FtTk9CU1lGZEpoMGdpQnFoait0eFpJVW9CMkhvQVVHNExKc2dBdHNvU3QvNGdHYWcxUEtMY1U2VkczR1Q3UkFVQ2pleXlqcDhUQ3dnN0lpNENFS3dGUnlZZ1dhTU9IMHo1TUFBRC93WTI5ZTRBa0FJRHhDQkFOS0lFWk13SWQwNEFkNjZFSUNrbzlnekNBc3dEWXNRQWh5QVE0VHhBTENnQlkrb1JNcU1zZktCd3IvcUVvUGlLY1VBQUU3aSt3T2trRVRnS0VUSUNFV0NDRVpEcUVWR2tFVU5BRVFJRUVhaGdFTWRvMmorZ0lTbW1LNnFPNThwRUxRbEFRUTRBQVFKS0VOdG9BSWJzQVBnaUFTbnFJMXoyQUwwZ0NvYUtBQ1NLQkJkR0FzaWdBSGhnQUQ3aTRJL2dNSnJpQlcvNE5OMHVrL1luVUozQkUzYlFBT3ppQk9vQ0FJbmdCenVyRURrTUFDbU9FUW5zTENkaUlFS0VxVGdFQVJnT0VaR3NFU1NrRVU3a0FTQU1GMmhrRVVBTUVZV0NVWmJtRUwyT1FHMWdCR29JS2pRdUJCUG1BblZ2TEVaQ3pvOWhOQUJaUS9PUlJmNTlIREh1TERORUJMempWSnNFRjRnTUFHS2l3b1BFQVlJSU1ITk1hSklvc29ZR0FCTmpSZkwrT1AvcWg1dUdYOC8rZ0FSZ3Z5WHRGb0FHcWdCcm8weFZKc0UvTmpLR3hoRkF5aEJkSWdtblNMdzNwcEFLeUJFcExBbVFMSUkxL1dKSktBRUZoQk9zQVBidmlnRmVocUNvSG91ZlRQWTNQRkFxNWdFdzRCRXhRZ3gvNWpMMklFcXVCRTZoYkV4aExrVGJ4SkRtTGpDRjZETFFjZ0dCU2hDTHpnQlJwa1RJL0F0UjdDd0RRcElQK3J2NFpydERoS0UwZUNDTmJBRDdZQURtNmdHeTFnRTZMZ0RZUnNLdGFnQmVKQUQxekJjSkhNY0kyQkZ1YmdJVENnREp6aEpRbENrRXdDQlFCQUFLNEJGTWpnRkdUaEd1YUFHT0JnMGZEZ0RZeU1mb3lCRjFSQkZJQkJGSUlIRzk2Z0RvcXVRZmdMVHA1QUNVcWdCbDVnRU1vZ1d3QUFBNGlnRG9oZ0VoOENZdjhHZ0FWV2dBUlc0THNNb2dUaW9BMnNBQWxLUWdGeWdHRGJTazlDSUJlYWdtVVlnbDB0WU51NlZtOEFUR1J4Tk9FOGxDYzYxdnpNbDF2UWQySVJSbUo1d2dHczRaWVE4bVpOUWd3MEFBWXdBTVI0Vnd3YTF3TWdKbjlIQmNVQW9BQWdOb01LT0FBT1dDSzZyRk1BYVg1OXRGbFJRMzI3eFFmaHRZSW9BZ2IrWUJWQVFSaCs0Z0JvQUFIUVZ3RndZQjFIMERXV0FBZzBaRDhpNXdjbVJrTmFvQWk0b0FnMnNHcnVRZ0crZ0JWT2xQd2s0aG9JQVJyc2ExdFVTRCtzcVNQMFFzNzA0Q3lBOGdhV0FBa3M4UUU4QUNjVWNBQnc0bWs4MUdJVVFHNEJCSDBja3hmMnNCQ3k0UlBRODhsYUFST0U1M0FXUVhET0owQUFKSTI1UzV6LzFIZ3ZHR0Z4WG9jdjM0d3ZjdXdJTElBTG1vRnhMU0FIaWlCQmV1QUtJQ1JDcm9WYVdHQUtwaGdBcktBUnlqVUlFRWtJT3VFc2VPRUlIdUlHa3NFUnl1VVJ4cUFQZ0FEOEt1Si9TMko0RXlVRXVxQU5VdUVaQnFBTWtNQVBtS0VTZmlFYW91RVh1QUdwbXVmSkpnRVVBR0FMZEJjaVZtQUVsb0FKZnBsTE8za254Q0FJeE9CcGVLNGp5VGVSREdVSmhDQVBTRUVST3NNR2VtQUlKZ2R1ZFc1M2Q5VG1DcmhlZlNLQ1FlV2IxL2VCdVlVeExtQU9pbUFvbzBPUWpua243TUFPaE1FT0NBa0dWQktCSWNBREFzQ0pGeEJqVWNNVG1vQVArS0NLRk9tVFMySUJxaWdWSnFFQlNtSUY0bmwvZlFJVWJubHJqUElBSG1BbDd4VUYvNVRoQ2hkWW5LbmpBU2owSjJDZ0FpNEJGQ29nQXpaV245RW1OVG9pSFYxcldFSkFCNUFOQjl6bFFvNGdDaVo1bytVTEFEcjZRdWtQbEQxTURQNEFmd0ZnQ2FMZ0xQSU5HdEF4QkRxa0ErNURiSFpwQTc1bUJiNkdCWGpnQTNoZ0NwaGxQanVpQkJnQk1BaDJDSUNneDVKc3lkd3BwZzRCakVlaEVqREJwa3JoY09UTXJSUFhGWWdzRGVjbkV5SXo3Y2dhRnZMYWxQSlE3UlpoTm9BQUdoZ2lOVDFpNkc2QVFmQUQyTFpEVkpDZ0M2Q2dZdThpUUU1VUFlYkdVQjZpQS9iR0J3eFdLQ0JHQVViZ2VUVUZBQzc0ZjkxZ0ZRQ0FFb2dCRVppQkdjNUc1OW8zZ29mV2dRZGdDbnBnTU5KTUNxRENTcDNEYUgvbUd1NHZRTVBac2YvYUYxOFRwUVc0d0JxUWVaZ0VJZ0kyeG1NdlF3WTR3UXphWUJCa3dRd2FaaEFHd1EyNkFCSGNRQXdHT29OQXJINDFZQVFhT2lnZzRDRkRtd3pJWUoxNWdBOGl1bW84bXNzYW94cW8rNVdoR3hHZ3dCbmkrU1lVdUNjd0ptT0VGRE9tNEFJSXBnUWdnUlRBNElzSWdqMkUrNlp2d2dISTRCcGVZUlRVb3o4YjNJSW93cDVQK2xSZ2dBU200QStzK2dQNFlBcFdZQ20xMUVGS0lBZWdBQTRTb1JFRUFSaTg0QWJFd2dTT1lINnFRTFhXeDNTREp4TUtSOGdFUjZjRUV4WDAyQUlXQVJ2U1RoZUV6QldXVE1tVlhCT2tRUlZxSVJTOFFBbENZR3R0WTlmK2hkZnM1a2h4WlNjb0lSVTRBQ0k2aENUNitTR3NnQXRPMC85dVJhUC9lMmw0Y1RvSXJVTWx6VzFTbnNZRFdDQ28xeHhYcG9BUGdtQUVac1FQcnNBSHlQc3IvUWl1K09obWFvN0JPUVY5RTEyQUsyS3lHTHlJSWlLNE1lTW9xUHdGeDhCelRzSmpjTGE4ZDNmUUFXQVZVc0VITUJlaEtpR2haSUVUWkdHOFphRzBUVUlpSkFLREVTRjRIdzBVV24wb1BNQVhtdUFhenVZU0tMd255TUNPNUd1ZXlYc0Ivd0FST0NFYXRrRVdFS0dRY2pxcUo1Z3gxRGRURkVDY0ZFUkhrWnNGUWtBUlB1RVdtcndpTFp3bkRnamNHL3dnUFdCVCtyZmNNYUNqNTFrRDNOa08vcGtIN0VBRzhsc01FdEJqSW9BUFpHQUVXQ0JSQ0VzSG1DQUlvS0FIc0djTGhDQU10QUJUaVFBZXY1UUp6aFdraEU5Z013RVAvR0JKLzNhOElSNXFBS3l3SkxJekQ5OUpGWFNCaTVkOHlWUmhER0FERmRUQWpJQ05aRDBHYm5nNmJnREFGNElkL1lSUS9rSkx3NTlvb0t0RlUzU0p3eUtBQlg2YWdqVW9IZmVpUUpMREEvUmRBOFRBY2dqQ2tCOUF6RmZqQVF5WkQ5eWdDZHdndTh0Z0JPUXJrM1RGY2E0Zzd6VGdtamlFQlVnZzUxcWl2bnFRd1R2Mk1FaEFBMWpBenMwdHR4bzR2cmU4a29EdENPWWdDWHhJbUFHNHNoSmxoT3lqQXpUZ0NvQWdMNU5NRjM2Rkk4UWlFb1pQRDQ1Z0NYVEFQV0Y3Snd6QkVFd0N4SElDQmpvd0F3REFFMUxobGtGOUcvekFEWlJxRUxxQXUwdkNEaEJoR3lyaEZaRHF5VHovQUxZbFdocGdCMXBoRW16L0ZYNkJHYmJoRkFhYW92OGZZQXJvUVBqcHdCZG9BQUJBWVJRK245MkEyenFZdXlTY2Y4WmtMQWNlSVJuMjRDejBnQkZNRk5MSG5mdHREZ01xb1JXdXdSZnNRQlprd1Jtc25xR1Z2bjcvUU0yVVB2UDcxOXdQdVZrc3FWV1ZZOS9oNmpWN29BTjZvQWNBQWtrUVAxMThER0syNVFZU0FBd1pEaGhnZ2NtVEsyc2lSWHJUWm9zZkRCR1pLQmdBZ0lXUGhnQkFBcmhTSjVOS1N5cGRaWEs1cUFxZUtqWkNoQ2hod3NKRGt3NUxsbnhJTXFqUW9VU0xCbjNBQThhZktRdGdRSUJnTktwVW9SNTZPbFNnQUVPSEZFeVdDSWxUb2tTUEpSaUFEdURqeHBrR0R6NjZFQ0VTWkNvQUUwQ3FBTWtEeEFraklIM3dMRm96UXNPSFB5VEs3aHdRZ2t1YW4wQWJZc0Qvd09MRGlxSThCeWpJSVFRTW1DcVIxcXpadENiSUU4TUtIb0JzTERlMWFnQVc0b0E1QThRand3SXlQdkJjelJBVUtDdTJmakEyV1JWQThLaW5kMkkxTVVSUHNtUlZuSVN3SUJSa0FKTFRoNW8wRG1IRGd3Y1JEb05VSUNjUE5sMnV4b3lwNVNnWklGSnY5UEJhbEtuS2swZzNoakF4MFdJSUVnc2RXSmlHZkpoUUxHalFnUWthWURWQUFRVUlaMVZEcC94U1RSZk8rT0NHTUc1d0VzUWxyVXp5U2l1dFhJTWJRdy80Z29FSEVQRHdody9IRk9OaEpjeHdVbzBzcHppRFNJd3lBQURCQTNSTU1RVWZucERoQ1E4QjJMRU5KNnM0WXdlUVNZWEk1R29LdE5EQ0VrQU04Y1FRSDZHRzIyMU5ic2xsbDE1K0NTWkp3cGpCaVJuYi95QVNqU3dZQk1ISEIyS3d3RUtKQTNqZzNYVSsrVFRBZEVsdzgweEozU25RUVFjK21MQ0VCbUw0Z0lFZll2Z3hDQ2ROQ0dQZEFCMGd3Y0lBQWhIUlJVNVgvdFNRblFESUFZMUtvcjQwVEExUlZlVkJjTU9scHVWcFJFRXdIVlRFOGNBSERERHdnT3NmdGlxMTY2MWlZR0RvWXd5bEdvQUhUaGtyQmd4eTBUbEFDaVBnMEFGV2srcFFud21WbVNYR0ZBODRCVUEweHpSQ1ppWEJZR0tHRzI2Z09FSUVESTBRUnhSNjRCRklIMlBrc1loZmVBQ2hBR05ZN1Z1Q0VJbTRFSlJabk1wbEhCTWxIQkhIRWs5QXdRUi9ZVTRWZ0paQlZYZUtOdmtOWVlGT0RBRnFRYjU0aHZoWUJ5V211dXF3cVQ2R2NxckNNYXRBQkJvc29jUEJSLzhjWVlNTk03ZWdCakhMakF2SERUdmhLYWdHR2hnb2RHRXRZM0NsQXN6K2JOS0NBUFJ3aXg3R3FLTExJazdZOEZFTGtmU1JSeFhRY0RPSEUwekVFUWNRUUlSZ1FnbE1ESEhERVRlOGZVTkZuUVVSQkJKaG1kQkJCRmRLZktjeXlsZ1ZnS3gwYlBNSFNjcWltdHEyeWdvM0JROGpnVElKS0EyUkhHbU9RWlhNRUF4SjJ1R0JyclppcmxwMVhCTDZoQTFWdHRBeGxnOFhKZnJxcnI4T081aHVJSUpwRUdKRXgvZWRsVFZvMmJBT1dSWm9WbUljR2dRVVJOd0FCeTJDM0VsU25jWUp6SHluREZrQXhoakc2RElHOW1NYzhidFJLb00rbEMrVXhBQkFBYmtiUllua0pLMFFwQ212WENJYzN5WTZOVEpEWFF5Q3FUTjBCL3NISFhULzhHQUhPeUJwQkJnQUFBWWdJRFFCL3VFeHNub0FDWEJBQWd1d3dHVTRLQUVTeHFJRGF4bXdNTkF6Q3BDa0VnYzltRWNQcFFoRUZlekNpSTRwSUdNc3hJOENiRUNLUFlpd0VLRUlSRjdzMDRIelJZOXBKQ25BQmpTQWhBNEloUkp6S09JQ1lnY1NIUzN1RmRwSVFFTXNjQVRuNUN0SFBoaENDZXl6aEJ5TXBDUVE0RmJBL3NBRE1jaktkNVJESEFaK1ZSVU5GTzhHVUFqQ0Rlam1CeDlvWUFSK1NJRUo4QllDSU5UaERaYm96QnFBb0FoZ1NFSVN4NmlFUTh6M2tBalVRQWJXUWxDQU9vV3FTRTVua2dDWWprbllCb1Q2ME8weFNJRGJGYlNRaXh1WUlGOGRpSmtGUXRDQ0pKaUNDemJZeXhyZWdBMlg0TUVQVE5CQkMxaVQvenFUUEVBeW5SckFBMFNFSlF6WVlZdERBVjhQblRhQXAwQmdBRHl5QXgvOGNBcEVCR0V0WjZ4ZmFtRHdJMkhZNFEvSUVzTWZ1dmdVWTA2c2FkRnJYWWdLWkFIOHRBQkIzL01kZzR4eUhSMEdwUVcySUlRNVk0ZlBmTUp6S21QRWphRTBBQU9WclM1QWgrbkJKcmF3aFRyVVlRdVJxRU1rZ2xBVGpVVXFla2FKd0FNMkJRQWIzQ0laZXRBRkxLaHhCeWR3S1FhKzBDZXJwQ0lMVGhCQkZoUVN3Nm9JSUFBQmFFNE1tUEtCN1FDd2pWVG9kQldkZWtBS05JQ0R3S1RnSXlWNWdMYWlROUV0OGVZRlVRb0JJL0xRQjBhc3MyTTF3SUlRbkhDRUhOekFCdExZZ3lyMnNBZGoxS0k4WTFqRUVlUnd3aU13NGdoZ0FNSVJET1JJaWYvbFNVRk9FOG9wVWhHR09YQUJkam84QUVNT3NJb3d3R0VUdDhNUitHQXdoUjFCd0ZpMm1zSWYvckJOTVBLQURrU0pKQUFlT3h6UWtZeHlHRURDRmE3UUFpWmM0VzEraU1wMldDZFBoZ1FnWWdYb0lxM0ljQW83MUdBS1BLbkVLTjRIQUdJU1pRQTR1VUlWamdDRU5kamdCbTh3Qmk5Y3NZYWNBRUFXdllISUFHUndoaWUwQURWbStWbERwdENGWXdDakVYSWt5YW9HQUFNNnJFQ2MvOU1TQ3hib2d4R013QTYyYTl6aXVoUzRvRnhpRXBlNEozVlVpMStUNG9ZTU1oakFCaFMwTHd0RUlBSWRzRUFMUWpDRW1Ua2hFTENZeFI3R0VBTHI2bmZDcTd1R0xjaVExSWFzWWhLbUFJREhvaUlBU2c3RnZxdlpIUUEwNElNQjh5VC9CbVY0Z3FZTWJJTWh5TmcrUHZqd2xvcnprSTlZd0FhQkdJTXJ5Rk9GWWRuS2M1NlR5bE4yQzRNVklKWVBBYlFHSlNwQTRZQUI0QlRNOE1Ua0huQmtBRkJpRXBRSXdqR09JWVNUK01FUEsxMEZwRXJpTkxyV2RiZmI2aURCcHBJeEd5eWlEelpJZ1FvQlVJVmE2SUhPTFFBQ05DRHhpQ2hVSVJDQmVJUTBIbUdEQWJRQUNrSTQ2OHpNTmdTMDNmR09PYWhnQlJGVWtvaVZUemkyV3F4M3VaUW5vVlFIQTM4WWdRellxOTRBM2c2MkRLRUJHVEp3S2hnOGdFN0dTcFZTSG91Qld4WHV2Wk83WENROXJiTDRSckprWmdHV0QyUlJEVHY0Z2dlZThBUU1VdHNRV0FuSDA1eE8xVEpQVXdERmVZQUZpd01LQnJheERZYllkQVRmL3hYS3BKYWdueDh3QVFCUWlNUWlKTEVGaHFDdUpFUTlReWxjNFlxWStCa2FrY2hrdzRpcUFCOG82ZysvR0FRQXVnQXBNbUQ0c1VwVzhwcDNXNVFISExGTEpvSktGNy9yS2s5SmpNU3g4OER3WENwUW9uQzhmTVlwTUtHQVlCRy9ERHA3MkpPcUNTSk1HZHdCSUEzS0NNRU9vNHh6MWpYa2wxSkJBQ2hHMFdGOGdxUUpnbmhCaHEzenBDWDBRQU9nN2lXT0UxbUNQT1RoQ0g2NGdoKzBHVUJoYU5NWmJvaHRsM3lwdUJnNHdNaTgvbExHa2NvUU82UlVGamVvd3gzNmdBMUEzS0FrcCs3aHBrY2VGQVhJR3RyV0tRb1hDQkdMV0NUakVZR0lzQUpRc0lJT2xBQU1VQTNFRVVxd2hCR0U0QWxQdUFFUWJBQUdMVGhIQjNHUVEvK2tVZmVSRmE1d3FpclVDUThiZzdpMG81R29UTm9PblphSkl3TTZRd1pqSGtFWHVrQzNnWXpnZGcveEFBYUVzUXBQMktIczNzVXlxbVJ0ck1laUNMTGNKSDVsbGVMTjRXSGdHdXJMWEVBYkJLYnEyT3B5cng3eGFpc0ova2xPQndhSU1JTXNCbEU4S0NncUtOY0FrYm5Md2dRbU1GMEJZSUNEM0g4emdCNUVZaE5QME1rUjNQMFNtVkJXZU1BU2VHQUNiclFGY01BSmlFQnVETkZQellOOSszUjJucUlhRC9FVVV3QnJ6ZU1xRVNocXNSTUFHVUFEVUdaQXRvZFFkaEFpbW1ZNGpEVWNOdlZHTGRnMlRJQTZHb1IwQjRNRlhoQUhRMkFEWWFFQVZCQUxWQ0JsT1FlRVd6SWRZbUNDUWljOUQrTThHZ2NTcGpBSkl0VjNBRUQvQWpuUUJXUG1CakVpREFXVU9TUGdEUGNERjlZVU96eEFCaVUxWVJRSUFJT2dCZlR4V1VIZ0JuL0FBdFN4Z1VXeEFKNHdjUU9BTkIwd0JTUmdHc1FCYlh6bkVEWWdCRVl3WGFuakVDU3dNWWNSVnowaE1HUm9GV01FQTk0ME1uUnloS2tGQVJSQUIwRHhBSjdBQlZ4Z0NIeFFCakp3S0JyZ0I5dmtUa2Q0Q1JoR0hMRHlhN2VDS3lnU1FEQ3dXZy9JSUtzaUJsdklkYlRqREF2a2dOL2tKUkF3Y1VQeEI2ZHdDaVN4Q3BVUU9TU0dkd3pCQjlLMENac0FCV3VnZnIyM0xKRG9kS3FqQUNrUUZqdVdCeW9SUzY2Z0NyTndDTGR3Q01GQURKWEFDYkxnREF3aEdoNmhPZ0ZqWW9pb081ekNoMTV5ZGtmbkpkVnhBS21nRFFGQS8ycHp4SFhPVUZoQzhYQkYwVC9YWjNhU0VpMG1ZUVNDRmhNMm9BWldVSUVaeG5QMEdJUVRDU2J4T0JXK2xEU21Oa3JHc1VKM1ZBSTJZUU0xRmhYbjFZWlIwWFhBSWs1SUZwQkd3UU1VWUdRT2lHV3JzUXUyc0F2dUtEM3hhSkU1NlJBdUlBWFEwWTRRbUY4TVlWRllrbkhQNHgxN1ExMGZzNEc1UXdhcG9CdGtsRXh2S0JkTllHVTc4UUcwMHdJbE9VVHVGeVpkcElyS3h3TTBjRnZWRVVtUFVSVVlNQUpCMEFWbThBdVY0SmFWZ0FoMmdJWEhLQmNIc0FJTzBBQVpZRTVkdEFyYndBT2orQ1VLMEFXYlFBVE1lQVU2VUJ4RmNRbXZVSDAvc1NucjJCQUtFQUkyQUNWUVlqTUVtQW1XZ0FjM1FBVFI4QXRyZ0FqSDBBWXYwZjgxZStGV1E5QUMwYkl2M3NFOEdpZVJSbEZYdWRNRDBHQTJaV00yakJCcGtaSTdPbVNSRGZGOTFjRnhyUVVCZEJBREZCQ1JFT0FMUUVKWllmSVFFUU1TSnFBRE9uQUVmYUFTZXlFSEQvbVQxdEFNRGttUjNlbWRVc0UwSGZRUXlMRUVPS0VBaElKUlRESS8rRVFEdzlja0QvRUFGeUFEUVpDV0tPWURpSElhbUVZRlVkQXlpRWhRZU1LYkhJaDlpWGlFdkVOdm80YzZ2Ymx6RWFtVStySUJrQW1VRjhrUWJFQUd2eEFOUkJpTUhtQkp5TVFrSU5GYUI3Q1NFUGN3ak9XVk1IQU5waWdjai9FcnBBWlpFcUlXdWdVN0JYQUFJUHA5M25WcmhwS1NjdUdjWnpHRjBTSXlDWEkrWWpBSXZ6Q09nM0E3R0xBQ0s2QTNJVkFES2REL0hVajFFRklpQkVDUUEwQ3dDU2NrRTNqQVVGdXdDVXlBWURPMlFreUFCUGRaUEVHd1daYXhBVmhSQWhKRlVOWFZvRlpoR1NqUUhTREJDdHVaWVdEQUM3cWdDN1dBUGNZZ1FpWjBCRkIwUXBUNUVVaWdBelh4SERZMlVRUXpqeDFLRXNtNW5DWkRGYjRKZnJpeFFwTTVCSXh3UXB1UVNUNXdHOWRDYjQvMG5hTktxaWVsQUxaZ0N6c0FBQjJ3QkVnZ2d3VTZGWm5sbFNXU1pWMENBU3N3QUIrd0NycUJBS3VqQUVzUUJEMXdCU3dnUVYwaEJ4NkJBMFBRU3dOREZCZHdBU0VnQ0dyd2d4QW9sVEdIWTJrNmVqWnhCSHFnQjVIQVBRRHdwR2EzUWhtREZia1VJZytSQTVoUkFsZ3hWQXhSQXlPQUJnNDRSa3Y1bnJVS3F5WWwvMEJ5NUFNclpRYWdrQXBuc2dwRlNKZjVORWtzUUFlUE5RVmlNQUtQcFl1NFVhTTQwaXIzRlIwUGdJVTl0UUVDbGdJcFVBTXVrQU0xRUFKemVwRUY4Z1J4MEl4ZWt3ZjNnbFUyZHprcld4VW1BUVdiUVFpRTRHSDdRck43OHpGS2VaU1ZtVXRhY2dPNUlBUkxFQVdvcWExNWNHKzFrQW1MY0RiNVVnS1lvUWRrTlFhRlVBaDlhZ3loUUxXQkVBcEhVQVY2a0FsOWNBU29wSk92R2FFTjBTRmlhRzNGOUNYVVV3cVJFR05qV2lLam1HTVpnMDdwV2FwelM3ZS9ZeGtwQUV3aXFrTjA0QWxRNFFGMG9CUzQ0azBBOUFjQ2tBQVZJQUJmRXBNRGxXTTVGSmt2SndkeTBHZDkwQWVFQmcxWTA2SFZLbUYrZ2pRUmtBTFIwaWtjYXY4U1VoQUZmVkFMWUJWV1k2QVh6VUFJVHFDb1hKSUNMdkFEQ2xBRFRacWVyaWtWcWJOQ0VYdUtYQklBTkpDQk4wdXZLUEFVZkhjYkhyQUtwOUE1cDdBTmI5a0ZOOUM4cVVBSmwrQ1NkQnM0ZWhrQWljc3FCU0JyUWtFRXl6QUtxVkNwRWdwUE9jYXVOcEVDTFpBQ0R2QzZvZ09oRFRFRWdLQUltekNwUlZFVlNzb2FER0ZISDRrZ29YZUlpWm1ZRENFeVByR2E5d3BuanVzVGVhQUtVTXZBamtBTFk1QU4yVkFJRWx3STVrSEJESnc5WXhBS2F4VnBJZUFENjFSaVBuRmF6T01CQVRRU3FkQUtyNkJUT2ZVS2xmQUxzaEFYQXNwWEdBQjVUekF6TmlCUlFLZ00wNkN5ZGV2RDA1aUV1QkZlalpNa3dpZDhyZWdUVFRBS2sxRC9TUVA3T3R0aFhkZWdESE13Q3VPd28yeXdIUmIxQUJZQURsWHdCbmNoRFpBQUNhaGdNMlpURjFZYkJYa0FEWDF3UW5vQUNWNEFCR0RRQjR0d3VUeEJBclViVkhsTUF0ZkJvS2toQjREQXdMb1FDbmtBQmd0MkI0RFFCSmVneUlxTW9xdnhBRDl3QXo0cE1HQklpREZISE16NmNMMlpPNzRIQUxvQmhxa0FQNmdTVDhJcklrdXp1YW54anptM0FIVFFpM0lCRldRd0NzcXdXaUdxR21wWFdrNE1uaitCclo0N1lHa3FjUTVBQnhUZ0k4cWlJSmZjSkRBUUE0M1RoZ3BBQWppUlRwS0dOeDJqUWtSRlhSSmpZeGx6UGc4N0ZDMFRya0lnQjJBUUJZK2dDWjF3QzQ5Z0hxSEFwd3lzQ3BWckRGQWJ3UXdjdFJyc1k1V3JCN2NBL3dZMnM2WTJ4bkc1Q2dLS09nRE9jQXF5QUc2L2tBcVYwTUxSNE1JR2xCYVdMTU0zZGhtTEJ3Yktpb1NyOFFPS0FBbE8yTkJJV0pTOTAzUnVxazhUeUpwR0FZdXU3SUJlOU5HWkV3TzRPZ0JzQUpRNjRCd3BFQUoyeGdac2dBWm9zQjNBVWdMNVVBN2lvQU5Gb0FpT01BdVBrRWRiSlFqTEE1Sk1ZQU5GSUEvQ01nUzFVQXJRQWFjUFV3TktVQmQ5d0F0N1lFTnhMQWxZY0oxZVVnQTZFQVU1Z0grV29ZalR1aG9zWFJUeGFzQ1JJa3h1MEFVb0hJemVKRUFiQVltamJJaWlaN05nKzhNVEU1VEpGRjZFQUEzTVdxbzdzUUVYK3dFZmtBSVB5amQ4eUJOaUVGdUg0Z2F5Y0g2ck1BaUlnQWhwY1R0RU9BVXFIUUY3VExOYk1mOUtTQ21xNEZrbjUzcFIzQ3dFcFZBTFFBQUFWRUFMdUlDNmZkQUNqN0RBcEJBTHFJQUZOaUFIbVRTWmZkRE84S3dLeGhBSWpBQUdrZ0FJcmlBdkZmeTA4R3dlaXhBVDliRTJhUE5oV3NJRDJ2Q1VuVkk0cFlvVnpCbVBFWEJGWUZBQ2E1MVBPN0ZMTitZZGhmMitGSm1jWXRna0pXb3J1TXdsVUN4WDNVUFdBTkFFRjNDenYwUExjdEVEVWxBKysvMTFKaEVDZDVBSVJZVUU2UjNDR3hOWC95bUJXY0lRMW1BSzhET3RleWlMcVR3VTJXWlVqeVVHaVhSSDBhblhleTNlMFFZN0IwQUcyc3NsZEhDaStJZGxwOHdsZHNBSnYzQU1xVkJJYmtuUWJsblFib2xoUU1FR1JOa1FjOHBDUHg1Z0FMRERMZkFBdDBSdkh2WjBPYmIvamlhUlE5ZVJiVDRrelVPUVNaWUhCQ1lVQ0JqRHhXT2dDYVRBQzk5NmhGQk5FdmtTQTZzd0E0dWdCNFZRSHR5NEJ4RWN3Vk9URGFwclFpbjB2cm1qWXdrV0J5SEFDVUZIWVQ5cGRrNHlCSnFpNVBsMERhWWdyV045cnBaeDJrajU0V0d5NDEwNXZvWVRYa2t4MHZMWUtUdW1ETGJBQ3VmcXFSS0RCczdKRUdxOUdpN1FCQmxONlR6eEVWanNPblFDQXhHZ0ZaQUJKeHNnTEpvTGRnaXVPOWN4cjRjeFlJNDBvVVdoc0lnaUJsMVFoS21CbHJ5M1FnVkdydjA3MmplMlQyRWJlMFhSV2toMGt4QWFYbVRnZkNTeEFFN2pBRTB3QmZKVmswRUJGZE54QUttbm5rSFJCZEhRQlVSUkRZcTg3VUtCMWlTeEFTUkFBcVdoTHMxei81NDVyQU85MEF4SmtIZG04UUJKT2dVcFlCcGFZZ0VWcTZBL3dRWVJFQVd1VUF0eG9KVnk0UXVYWUdVYjAyZDU2bFdaNEFSWDB3ZDZVQXZPUFFROG9RMkdJQlVZc0FTV0Z3VmZuRWxIa0FYY1FBeTBNQWNCa0MrN0FEOGFFRURaSFpSN3plTDBYdS9sT2xTMG5pVVFRVE1oUUFqTjBBdDBoc01zMVBPV1FjMkNEZUloOGlQVi9wQ3F3UVpXWUFVNVRMNFZLV1ZsUFZEK1dmRExna2F0ZmlXUEVhOThBeWg2ODV4UStxYVVBU2dGeHBvOEVhOFJvd0c0Wnl3VitTUVJNTTMvQzU0RHh1cXRlU2MrOVJnZ0t4UUVBQUNYWUFvOHhXWURzQUE1K3A0a2NRRTR3SHA4alJ0RzVURThZQTBSajMyVE1BcTJzRG9vREFyQ1FQT3FBZi9xMVBxRFNPOFRIUkRIVGpCdkZ6RHFFZ1k4d2ZPNmthbnNBTEFPaTBBcGZyVmF0Yy9YdGs4RGFVQUQ1Uk1BQzBJSjNPQ0RXWkFJYzh5dHlZRFZvaWNFT1JBQ1RqQUdyRzBVR0ZCNVp0dzJjV041Yy9ZSVFvRERHd01Bamgzc0RKRUtvMEFKM2pOdEd1cW9RZ2NSZG9RVmxlbG1pKzRZT2VCNVM2QldlckRBaFZBTHllQUlqM0R4TmlQUlM0OTJBQUZBNEVDQ0JRMGVMTGpDRng4eWJ0ekkycllOMURhRUZRc09HREF3WThhREE5Q3NHS0FEU0FnRkZrMmVSSG1SbzRlVUxWMitmSWxHSmhzZXZ6aXQrTVpDd3dBUEh1bVFBVENGaXhaSmJTd0FVSUNSeVlBdkFqZHFmTnB5Z0lLakdBZWlNZkZFbkFJRkxZWXNCY0FScGtIL2psWmZZZ2lya2FvRnJnYXA5c2loSVduSnRHRTV2bXBsSnkzR2pRTUs4QjN3NE1IWWsyS2RsbGhDbHpCQ3ZuYkpzaFFJWWZGa2kyaFNSclhMdFlVTkd5RXNzT1hLOVhPSVhMbEMyTVZnbUtEWnNRaklCbjVKNFJJTnFBUlo0TEJnUXVBd2FZelNDdEh5S0JCSndCcnJDdXhnSW1sWXJoMUFMeC9vaTh5MmF3VEpOVHFtMnFBSERCZ2dFeTRnbWJMRndCRlM1RFpSUXM1NkhUcEtPSjA4d0VLSUlaeVBCQnFqSzVRVGFhUUNMV0xrQ0NmR0k3QkFBd3Z5SUFZK2VPREJGMC9JMEN1K0FWaFk0U0FJdW1Hb2hpbHdjQ0VKTGJRNDZrREN0QnZMR3dCTXJBY21OZ0JnZ3czTEJscVJSWUZpTk1rREJXUklwUlVkWDZtRW1GUUkvMm94Tll6UWNGR2pITm93UXprVGxtQmlJQXNHNk1DeENDSmdiTFd5cHJJcUJUaWl5S1NVV2tqaHBSUkp0S2dpajAxQ0pKR2dBRXlpMGFJMUR3cmdUWUtxVWtBSEk0ckl3WWFrQmpCQkIrV0tzeW9xVTZ3QlFMSUJJUGpMS1JUWWFBdytGbHVFdEVVRGYvakIwWUhrTk9sRmdkRG9heW9BT3NobGtUeWdBVU1JRmd4S2REdE5VNEpBdkpRc2s3Uk5nOXBrYllVT1NqQWhCR2hLd2NNSko0NEFsaEZoaGRYampsb1dhY0dwdHNpQzRJQldXOFhNSkZjMW1oWWwyV2g3amE4SEl0QmdoQ2swaU9DQkR1U3o0YzlBTjFKQXlLZjRvaW9GRTJyNGdMV0JZQUNnbWg4bFF3TUROa2JBUURCOVl6UUxqWjVFUEVqV3NRQUxsS3V5anYrakxBVTVGbEZGbFRHY3NNR0pJZXBySVZuRzBtakNBWUkvQmhua3dCUjRJTTBFWVdEUVFUSzhXUmlBVlVQdXFMQ0NDa0NJanVNc2V4bG1qbko0aEpsVWZtbmxGWHRtUUFPQ0dGTGhBWUFDYVBiQU1zTklSTGNEQlRwbzRVa0ZTSURhT0tkTUdHRmNydm9WQWh0ZWVOR2piQ2ZRVVNTS0laNXN5V0NFM0k0UGdEUUV5UUVHZlRnaUFiNU9GZENBaEFoMitJRUpINnlPZ0VnRnBvZ2czV2paSkN4bkExL1dMSVNLUXdta2lqYzJtU3ROQkQzZ1RpYVpOVGN3STFac1FXU0FiOFNwSWhOZENqRW1tMndLZ2IwUVhYVEpiNHd4QUhsa2pkVVlYcXhhZzN3MzZWcVhIYzhXNFQwUlJwNnhkZGxrQXdadldJaUFCVVFhYWVTTExWai8rT1liRENBbzdpcktpQmNaOUJFRktrR0lQQUpoeElZV0VrZllJazRJMFJobStlZFB5WU1SUmtpS1p2cFJBaDdrRlZjZGdLekFSNzg5WVlBRkhYZ1JwbDdDS0hSaENUcFY0cDFkQnRPb2dqaE5mUHNMMlpVQWtKc1c2T0FIVXVOTHJzWTFnTlNrNElFb3VTQjhsdlFFRmo3QkI2R2hES2JZRUlGMWdLRUtUbEJFTHhKQkg0eU1zQ1VlWUFFVWJoQ0U3bURBRDNZUVEzZkVBQU8wd0MwbFJaSVpBQXhCRG5DTVFBZnVHQUlRRmpFR1Z4VGlkYkdESFJmSGdJYytWT0VHVDdDQURHUnhCZmNVcUgrUmVja0RLT0VKREM1bVZTMjZEUW51TVFoK2ZPTUtCR21hd05qUXFwbTBDaWI5UW92ZTZoZ3lDNVNnQkRZb2dXZGF0a2hLLzFieUlHQ0lRb2pzYU1tUERaQ1Qvb1BKd2xJSVFaZzVrWktOb1lvQ0lqQUZFOXdBQ0VnUXh4S2VvQU1XS0tZaUxVdVRZYWEwaEJ2MDhnWkhRT055VE5tUzFQaWdBMHdJQVNCZ3dZc3ErR0VBMFh0alpUWWxFeUQ2SUFoQmdFSVFiS20zQUF3Z0FKRHA1bFU4NTdLQmxBeUNOWkNCUWJ6aXlpcmtKeHQ3ZUowck1vRUhQQURoQmt4UWpGVzZzVW4rdmFRQTQ1akdKMUZpbVZlTW9oK0JZZ01HT3BBQ0Zqd2dvVENZd2gvczBBVTc4RUVNRVBER0ZKcEJDQUVnWUpnRnVZQWJndkFFSk5UU1VnSU5uWEZHaVZLV1VxWUhQOUJOU3o4WkFES3M0aFNyQU1VcXhGQU5VTWpVUUI4VktGQXRJbFJMVHNVQ3lSRUhGSUN3MUxXZGNQOHNFY0JCQ2pCaWdTWGtvSmNoV0lJY25qQ0VKOXdBSE1UNTNxYjZncFkyREFNUFFjQ0lPUnZIT1FBRUFGOEFnSUVZNUlXUXBYR09TTTNyUnROYU5VeHY3dVVJUUtoQ0ZXekFuRlMyUUhLLytpc2pRcUNhbFZKR0xBaW9BQTBxOENidVZlUkZzaW9BWktMVjJBSTlRQnNtNFFHRUJ1SUJNZkRnRDMrWVFsaE1zWXhSVEdJc0l4RGlGYUxrVTlyVzFyYTNUU2x1ZGJ0YjNoNE1NQmlRQXhOTXNMaUROYWQ4VWNqRERZWVFBaVFzWVFoeU9FSUlRdkNuOFRBcXN3VndXZ2MwQUk4cjlDUng5UU1BNTFqaUFRaUk0UThzdUFZb05OV05icnpNaWFjZ0F4TiswUVJmN05ON01SdElCRUtnQlZMQUFoYWtlSVFUZ0JBZ1J0UUhXSlgvSzJPQjUyb2c4VUJOZndCSXdDdEFrUUNCS0xBbER6aUEvclJEWElGNklMVUVnY0ZwWVFBWjhiek13Z2JCQUd5SkVJVGV0dGpGTHk2cVNRWXdnaStrazdQN096R01kNmZqUllybGVBdisyTlFpa0p6WjN2aHRBOWlBUndZU0RvRThJSzhIQ1NTVXd5c0dGampqRjVVSXh5L093UUxMUU9BUDBUeklOWGlFajFSTW9ocHZpbEdPSXdpQUdnaEJDUFpVTG1DckFJMlJ5R0VJVGtXaFJleDdrWXBJeGhjQ0VjQ2FYVklBR0JpcUkyb21DQ2hTZ1MxS1FvQnozcGxSTjhCc2tRNzRBQURNK0N5UE5iMXBTbnFTWUhlaGhOSU9vZ0Fyam9EVElpS3FUMU85VzdFQW1aSXJlckNNSzdLQlZLUktNaEJJbWtIMmZKQmZrTUVUYWVoQi94bk1jT1ZLNE9VVnAvakRkMkR5Sm10b1k1K1hQVkFFZW1ETFhFSVFseXFSbVdYMitRRHVHYm5DYllXckhlaTFnTUc4cEF1VnFFUlBDU0taRWJoQkRQSVRXSFRTQVlNRWdrY2dzYmJzcWZXOTd4ZmpXMnY4Qm5pQlZsMWJiNk9VaENUVEFCS1lJRFh1MFlnTlFIdUZNR0xHcVFBQ0tSemhtRUk4enZFTkh5U3lJSEZxQ2FKaDlHMENyVW5razVTMWVNeWhBVnpkc2pHV0tiZWd4d0lEZWcwRUFqVzloRW5zRUExTVlHSVE4MUkwR1dUQkNUL01Ed0l3RUVZbEp2R0tYN3pESCtGVnRxZi9IWENxVi8zVWh2RzMxYlUrcTYyUEordU1LK2RKTUJDQkFUQ2hCMTdwZ1FrWXBTazBtS2dEM1RpVnl6WWlBeXRNWVFVcmNDZ2c2ZitkRXBFdnNNZDF1ZkVEWURDRTJXWkxZZVNjNEpvTGJoQVlYQ1BuQktFRHpTMGlERTZzZ2hPcG9BajlhT0lMQjhsQ0x4QVl3VFdKcU96aHplU3VkMjBSNm1XeWVzK3R2dXV2aHozSVBQMzEyTmZlOWlqdGpnOXlzQVRlbDBNSDQzalBTV1ppalZSY0lnZ1VIVUVTUVNZbk9VRmdBVnczRU8ydnBNcFJUcHJQQklFVlM2dDFDbUtuWWdSLzhHa1JTWDk3OHBmZi9Kb2V1UHdrVmZMelZ6SmRlQmJJK0VGc0J6ZEVDR2FuU0JxWTZ6MldyMlBtU2pvd05SSEppS2t4QVJEaW5jVXpFQmlnQXp1d0EwU0lDS0J3Q2FsRENacnBPNUpydnd1a09rK1NRSUtoUFF5c3JmVHp3S0Nxa1lLUVBKall2NWZnQW02d0JlSDdtTDU0Z0VUL0tRdjRvNHc2dVlFNFlDSGVBNGZnTzd3ZGN3bEswQVpRRUFZZThEakM4SURReXJXeHFNQVFWTUlsdEtRazFDMG5mQnphQXNIOW1jSVdxOEpGZ2tJVnNjREZXSk9vTUl2bG9SOVBjUXB4T1NtWTJBVmxtSU5CRUlSbk1BTW1kTU0zOU1EWmc4TTVwTVBsMjhKTnk3RlcyNHM5bEIvTTZEYmVJZ01Jck1OQkpNU1pLc1JEbEVJUkhEbUNNVGxFSkJCTlFVRDZDY1RkMmtDRHlFSkh4TVE3ek1RM3ZFSkxxc1NUYUpGTHJLTXNGTVhWZ0NJQTBBQVpFQWNjU0lOSUJCS1VnS0lWa1VWWlBMM1VzMFVYU1QwaWtUODNBb0JkMDYxSkhJdFZLY1dXV0pVQmFwTk8zTVJrVk1abGxEMG1STWJMNkFtT1lBRWlpSVl3R0FSWkFJTFU0T2dBdk9NblR2ckVscEEwNnl1UURqd0pPckFaZUR1SWIyVEdkV1RIZG5USHJaTUJGcGlRR1hpQ0ZoaUVGeWdwRFVpTmQrVEhmdlRIZndUSWdCU1JZd2lESWVnQkFGaUJMWWlFTlhnQ0h4TEloNFRJaUpUSWlhUzZaM3lKQVFpMk1CQUZSWGdDbWFQSWp3VEprQlRKa1FRN2tqVEprMFJKSlJ6R2xJUTlnN0ZJbG9USm1KUkpsRnJKbWJUSm04VEpuTlRKbmVUSm52VEpud1RLb0JUS29TVEtvcVNrUzZ4Sm8xVEtwV1RLcHJURGszaVRxTlJFcDZUS3FyVEtxeHlQcE1US3JlVEtydlJLY1B2S3NCVExzU1RMc2pUTHMwVEx0RlRMdFdSTGZRc0lBQ0g1QkFVSEFQOEFMQTRBdmdDM0FGUUFRQWovQUFIOEcwaXdvTUdEQ0JNcVhNaXdvY09IRUNOS25PZ3dRRUdCQkMzK3M0aFI0MENCQlFBTUdEZ0FRSUFCSGd0eXRKaFNZQUNUQkR1YUZBZ0FJOFdiT0hQcVZQa1BvOHVCSEQ4dWZFblVaSUYvQlU3U2RDa3lnQWVXVElYK2hKcHg0NytSQTQvRzNNbTFxOWV2SDE4cUJCQ3k1MGFzSmdNUVBhbDI0OHVqUkhzRzBFcDJidG1SSXlFVUtQQmdid0c5ZTkyS3pkaTJvSUIvaHcrbjNDaUFwVlhIamhHRG5leFZvOWFOTlh1R1hHdTJ3TWdEL3g2RWpvQ0NOQXNTRVRTczBJQkRnNFlTR2tiRUpxRUI5WW9WTEJZODJBMWh3QURQZmd0czJIMTdCUWtTTENJOFdQQ1hBQVFDQkI0bkROQ1lwOWJvaHlWcnA4eDlJVTJvVk0xeS85d01jaTl4RWpoR2pQalFvNzM3SHYvYXJ4OHhFSFdFK3hGWURFeWVQQVVLRmluazk5OXVCQzVYQUhNSEZFQ0FnZ3dHZGhSYzEvMERtbUVCUkVjUWRnaDBwMkZYRmlYbFlWdDdBYlpCQkN2OHcwTjhOY1NuWW5zNnRDaWJhd1NwMThNSTd0WHczZzh5OUlBampqbjIyRU1RN2cwVXdXVUtFaURBa1JKR1p5RUJDV3pvcEladHpZVlVZQnZ3OE1FSE9yRDN6d2RiOXNDZURHQzZJQU9PTmRoWWd3d3VsT0hDUDJYa0lFTVFVSlJSaGhSUWRBRUZuZjlJOFE4VVFrQlJVSTRhS0xmQlB4QmtOZUdUaUNhcUV4dFdRUkJBb1pBZVZlZy9DaWpRZ1FZMTVGQkdGM21lOFkrbkJCSHh6eVk5SUJFQm9hZ3VvT2lxckZKR3dBUE8vZitEUVFjajVIQkdGNkNHZWtZWmZrU3dRYUhDL2NOY3E4UVdxNU1Db1dFd0tBYi8vSWRjQkIxMG9NQURDZ3g2R1VKQmlRZVVXZHdLdFJoVzRHb1cxcll6R1d2dXFqWlp0WlZCSGxtRUYxSy8vUVl2VzBTVkpGZFIyYW9FRTBGWVhYVHV2NVYxYTlCTWd4Rk1GbGs5UVVCVFdUV1poSkxCa1cyclVidENiVVhUVFN3bFJwREdIRk1IOE1kVnNWUVVabkU1aHRWSmdjRzYyd0xEN1liQmJpU3ljSnZNTXErQVFtZ1B4cXRXbEFNSjhDQlM2bGJIV0dUVXRhdllQd1FValpoSDJZR3NVNzRkeWJXdldUOEpoTkp2MDU1RzJ3Z2txRWNmZlRxQS9ROXJ0ZDFYNEFJb0VIaWZCaW5RMWhvSi82VGdBQXEzNmNiY2N3VUliVlZTU0x2L0pWbkdvRmxZa0pIL05ObTMwMTdaaEhCWmpCZmdBUXBUZkRCQ0RVakFGOFNaWUw2Sll3ODJlam5qQ0Vody9TeTArSlc0SlpkVFRDRXpDY1laeDhNSVZ2NGhPZGNhc1BCZjJnOXNFT0VCMlJrNUlYYi9aSmpBQVlZanp1cGN5RzlVd0FHL2RsM0Q1bERra0FNVWZwWXhrUFJ0dmpsOW5ISFNPYWNVMzBzaGZobDNFaVFERk9mTE1OQ2JBNVY1NVQ4R0tDbUFrWGtiYno5RUFiRHhLTi9KSiswWDhuL2h5M0tNd3dJZHlFQUlucnJWR1c2MUNWRU5CQXdPL01jTHBIQUJEY0RxQU0rNW53YTdvNWVDNk80QkE4REFDR1F3Z3pNb1FWUm5jR0F1aUZDRWZ3UkJBNVU2Q2dZWEpMZ04ybkF5akNJSUJBWjFLaG00WVlHYjJNU24vOHJ3QkFzd1N6aC9VUldzMk9XdnFsaEZKdXU2b1JTNWs2NldIR1F4RHhsTVZRdzJNTXdJYklxSXk5WlBubGd4ZmVFRlpVQjdVR1ptTWhXSWtZdU1GNU1LMWNCWUxDczZNVjhNb1ZkSVFuSzFtVHpNTFE4VHkxU2VPREYxSVNSZGRFVFhGUk1Dc1lPVkJTZ0tVeGhjNUlJU2VnMkdhRkVyek02NnlCV05hRXd5SEVza1JHQVNSNG1kaFMxN2JJcTlMa1pLNUxsa1lsSXlKQlpaU1pGQ2JnZVV0MXdrWkVTNWszYXBwWkp1U2N0M0h0TVVCd0Z0QUI3d0RWWWc4TElINEdaQW90SGRnallac1kzeDVKcVBPZG91cTlJMFhoNmtsY1JzU2IxU3doYWtMR2M0dWtuYlAvQnpId0RSaGpaVGVKdHlDQVFCRC9UR00ybHhUQUFoWVA4M1ZSM0ZRazJMRGhhQjBwakRMTWtpQWMwbEw4c2xHSklKVXlONVljNXVtaFV6RkxnbVBUajR4d2hLb0o0U2VEUTJ0UkVEY3BiekFNRDg0MWZEdWM5cWpvT0U0N0N1V1Fzd3dBSU9VTVBwYUljNlNabWZRaS9rVFkrTTBZbHlBY3BNa3ZLYkhTN2dOQnNkUVhwR0VEWWRhRlNqOU1FQmJWYWduQVhBb0dZa0tnMkFBT1NhQ0xET2RpdlFUWUVJa0NBRmJRc3VMT0ViUVFkeXFJMU5LREdFNituVTBrcktveUNNTElXQ1dkY2s1NTRnL0NBSU9malJEM1FFMWNKS05WQVJlRmxpazJNY0V2REFwVGJielhCK0pTeTZGUWNGdUN2cFNmOEhsSm9laVhkSSsyendSdXROaVV6TWNWY0o0S0IyZ3dLWFRrNEhOZEJCRDV6cVZLYi9Ja0VIb2F0TnRLRFZBWmxOWVQ1ZUs1TndyMlNqRHdqWFRETUttMng4dFpjRFdBWjRBekVTNFRMRWdOSjI4a09Qd2NweVdMQWV6c0VuRGtIWTA1Nysrb09CbEhjZzcrbHJEdndLV1BHdU53ZlhrMEVjY2dTRjgvNGdiRlRGN0FKVUZkM1FRZ2RweGJNdWg2NkN2S1FCYTRmT3hFRU5nZ0JlNnJGSmZEblEwNlk0MVFVOW5VRUtDRHpEQzRUUUJRUnkrTU1EOFo2YzVqU242TG13UFRYNEFBbFloaFRuUWxmQXEySVVvMTR5RW95TTVDK0R1c29EL21Nem0wVkFOeU9LWEEyOFJpTVpZUGdNSUI2SUVEZUJaQ0VJUVFvdWtCN1hOckFCbXNKNGlnQkVtbDBlUlNpMjNKTlpHakN5K0g2SUt5SG1LaGRuQU1PbmNqQ0NEbXhnLzFnSnVqSXZ6Ym8vdlhSd0lCakFBQW5PSkw1YmZlcUJLeHpJRlpDd3pyd3NqeTl5VG5SV2xQaUFEdFJBQ2w4UUZSRWNtTUlYbkNFSEdyZ0t6dkRXVmtVTEdEU1RmWUFGVXZCb0lsajZIMFJZNFJiT0lBTWt2Q3lBb2xrQUJFVGo2U3Z2c0ZBYllGYmMyUFNESy93alI0UWVEb1BNbWNOYWUzcWl5Rm90clNjaVJuVTEyOWpRNXVTMm9nalVhc2ZGa05HbW94Mm5uUzB4dG11dTJDNmpVTE50cm1ZWDBpZE5WQmRjcm5hU1V3YlZKMkpSQ3hjdkpraHlkNmVLNmE0MnU0SEdscXNST0NURFpLUGZERWx2aGg3eWkvWTJiYjdQWFpBSGRXaHY3dWJJSDlsNDdZWm54VjNoOWxkbUVxNXdkRE84V3l1NW9zUGVBcExma0tXUG12K0JXSlFRR1JlUUhKempEOEUzdGQ4NHNtK3lwUzZPL0ExTDJJMlNvUHIwM0tkZERMcDFvamNCYjl2WkNLK0lJME9HRW9hVnhUR0k5TnN1eXhWMWpCVTAyME9mRHNIMEpXOFBFZFVwNVJ6UDFxTU9tVEZXbllrUXVicmV1b24yV3BkTXFOZE9uaU1QZHZPem5ESXFOdUZaeUN2elNXdGlLeUZzTDYwdEwvSVdBdmY4NXVPME95bnZKWmpDZkJHTFA3djQzNnVKUzRNRXZtZTRET1dWRzFteVVnSXpTdkxlR2NrRnFSYitqUjA0R3hoQXkwaHFMYVNNWnpGOU4wdzJNNmEwVUFaMG9GUGtmRlErd3I5NFM2bmRzV3gzVWpxb3U5YWZkQUM1ZXdCcFNrTTMwK2pHNFUwbjUzYXVOWHRaYWljN2l0RWJkbXFhKzVwYmJETmUxR1QvMVpDQ1Z3bE50bVh6aEpsWFhWT2Iyc2pzVklTcTUxNU1Qc21VaEdqWUJMa005dytTbUtLcFhTdVhsMGp3RmhhaTF4YXRGQ0lFa0U3S3AzenRsQnF1UVFKSUFGSTRNQVdacGdFM1V5QVljRStWNUhWOHNRREZZVHZuWkV6OUJSUlk1RFBacHpUaHRuOVNsSGNTczBzakFVQjZjUUE3aGxtbTRTeGFFeHVodzFFYzlVNy93QUtuWVRzc3NCdkJZVTRFY2hxMVFZR3NnMW5DY2dBWWxDQzRoM25ZNFRHQkp6ZzFGSURHczNXZFYzYlU1RVhBTVMzS2R4b1VLQnV3b1ZSRWxsSHZwQm9SQUFNa3RVT2hzV01rUWlJa01BWEhVUnMzbzEvN2hUZHEwUmcvNHpNOVV5RlN5QmpBTXorSEFSb0cxVGRXZUlVK05UQnh0eThPOHhlaC8yRWN0WUVFNmRGVUl6Qm84UEVQc09FYVZGVWdkT09CLzVFZktXQ0V0SUVDL21Fem1iVUF6c0ZaYnpVeFRWTlFuaVFoc0FnODh0TWtLdWcwTFBoRk1ERkxtdVlCQXRSYWNhZ2VXUUlmczNXSlgvTVBjbWc3eXBGKytkRk9vUWdnS3hBZ3piY3lKTFVnQ1RJcEQvSlAyOUovbUNlSXZwTVl4UE9OQ1JCWFVnUjFaYlI0OWVaSS9LUjh4Z0dNd2dVa2wvZ1BnNlZjczlNYWlOVUI3RVFpS2JBYWpVVUNtRVVnd2pZc2JWZ2dkc1paYWxVZExoWUF6bVVSQkpBaHhITTQxc1ZLSmdNMC93WUF2VEZySzZBZU5rSWpRQUlrdndhUGZqVVFST1kxdEVFNnllaUR4ekVGUENDSEwwVWdBM0ViY2ZoWWNraFZacE03a3hJcjFBRUJBdi9BTytMSWtMUVlXbkxXYm9oRVZDUWhKVi9ZZnZIMFcweFZKaWpDT1JvVlcwd2xodlhZYUErZ0gwZ3BPWktqVVIrQWxPcGhYR1V5T2VyeFc2d1RLRG5XV2R3b0FOVWxBQWhnbHQwSWl6Qm5GTEdVTXgxSUlzWWhPYkZsWENzU0g3S0ZCQkdZQW9IaWc2OURsK3ZCSHNlRllqcVNJNE9WSSs2aEhoRUlmMWxSUDMwREhmTkRpTHlUa3pCbmNWUG5GNmpTV2hsbEkzL1ZBM0h3RDUrcElvTlZXUDlRSmpwU21JVTVYKzNoSm00Q1h2VEZrWllESDZpUmZLcXlKQVpGT0w1VGl3bVhaZDJTUkc5R0FvSUpXSCtGUHByeUQ5TGpKcjhXQkcreW5PampKNW9TUGRCWlBkRlRCdUVWWHBiRFBxVzVIandBQWlRZ09BTHdIRGtabnBYL09SU1hVUmVPTWhBV0NaeG5BaWZTd3liVTR6MGhsaWR6OG1SMUlqN2l3MkY1c2dsU29KL3lXWnpIMlNaaVlsNEVFVmJSWVdWeE5wNmp4RlBLZzJPNzhRR1pBeVp1MGliV1V3WXpBRDRVK2c4VTFtRnVVRUpkOEFJWUtnVm5VQ2Q1SWo3aXRTZWV3aWwrUWhBMU1BVnBzeUJJUTFPZGhxQVNNWHpMTXlndHMzbzFneHkvTlRzalFJRXNRSUVhOENWaTRvNDljRDdpY3lkQ01CQ2M4aWtWVnFLQnhUVjlnVFI0STZPVUFRQnNRSkVVV1U3QndSZC9BUmg5TVJ5UW1EcVRveWNZaWtCNmtxUktSbWxLQUdFZmtCdjVGNk5VQ2hiRnhwYjdneGlPNG5XOU1RQ3psaG85TUdZWjFnVk14bVFwQkNxZzBnVXV3QVBTQkIyVEVxZkUvK0lvMGVGMS9YSVZsOUlERjZBcFpJb3JBNUZtUktCbS85QW5KTkFCditFY0xzcW94S0kva2pLQTgwY3A2elFDYVhLbW1Db3F1ZkFQbk5vREphQXMrRWVxNXNJR2JKQVVFVE1wQ2hBQk5lQUNQMlJwZzBvRVJ2QVB1YkNtUzJBQzZHa29HWVNyLzdLclNHRm41aFFCSHlDc0tMUkFtcHBBNnBNVlFCTWQvQVd0VG9Ob0JCSm1IcnBBZmtJRVc1QnFSQkFFd1NhbGNDcXVBTU1YYkVndFB0Q25ua0lFUWpRUTYxb0dQWkNCYjNZZ1doR3U4Z295TEpObnRPSUNSRkNzcU9aQ0JKRnNCS0E3QllzNGZWR3gwNEplWlRCQmNESXFQV0FDek1JYkF4R2xjenF4NThJWFk1bGpYWU9KaEpZQ0tZQUJ5Q0ljaTBxeTk1Tmp5N1pPUWcweUxia21zNGswSEMrVEV3RUJBQ0g1QkFVSEFQOEFMQVFBdmdEQkFGUUFRQWovQVA4SkhFZ3dBTUdEQ0JNcVhNaXdvY09IRUNOS25FaXhvc0dDQWdNQStIY3hZOEdOQmpWcTVNZ1JnRWlUQWpkaS9JZFNaY2FXQmxHbUhDaXlZOFdiT0hQcWxOaFJwVXVTQkVHYUJEQkE0SUFBUjB1RzVIaVNwZE9SU29FNlhWakFKczJGUDdIdTNNcTE2ODJUWUVFcVJWbUFaVmtBWlFrVzJHaHl3RVkyLzhvK1dMQUN4WXE2RVNJODJBc0JRdHE0UndNZzlSaFhJSUhERUFqNEpVRFM0RitCQWdJSWdFelpxK1hMRTdNaUZWdzJRT2UxQlFwQStBZGh3d1BHS0NMOEk1R0NCSWwvU0Vob0dLRUJDUktCT1A2dDBMdTM5d1BTcGpmd250dGI0SUlGTU9qT1RSdzNzdlBIYWczVG5BeFVRR2ZHQWJBenhzeDlLOVNManVOQy8xQ3dWeThMMlZPbWpCaWhvMGFOZngvK3JaKy9uc1FVMXl4NGI4QmdXdUJkL0NrTXQxZGFMUHczQlE4azhBQUNmcW45RmxjQW8yWEVtQURPY1RTWlpBRWNJTkFCQW1qWUlYWGRoZGlkU1dzTlZGWnBLSkNBQTNzajlLQkRELy84TUpBT1N5eWhBeEpMc05lRGkxZTR1T00vUGNnb1F4QkI1REJrRVA4VUtWQVFQOGpRWkE4eXdQaVBEaG9JaE1JQ0JpeWczVDhFZE1TY0FOdUpLT2FZQncxUVZWRUZGSVhCUHdPZ2NGNkJyazJ4bWdZUmFHRGZDT25acDhFS2NZN3d3WXN5eUZDR0ZJTkNJWkFVLzBEUlJhSm5kQUdGRklwQ1VZYVJPa3pCd2dQTS9YTkFtR1IyNnFsbFZZa1dta0NoQ2ViWFB3OU13WWVnVWtqUnhSbi9uUDhCQlJFQ0VRRUdFV2VVMFVNSkVXQ1FGb1NjZmlyc3NOMnhzVUZwcUNxZ1FRNW40RXJyR2JrUXNjVVd0UGJ3Z0FlaWtSYlhBUnNRNisyM2xuV0xnWU1PSHNSZmYvMHRGRk5DV1QybDBsTHdvZ1JlU3V1T1pCVzQrQTdiYnJ0VGhRVHZWVU1KcHRGYW13WHNVMHdhRFVVdkFBRVRwaEowVWhXVzc4U1c4UnVVdTJBRmRsUlZCb2ZVc1V4VFdSeFhXYUdWYlBKZ0loK2ttVlQvM2t2eHkwR054QmFwYUxISnBtZU9oZlpBQVR2NzlkdGMvNlFXZ1d1dTJUbUZuVldlaCtvRE1HQWFtcGtDbDBWQUFjY2h0d0FFQi95YVZvV0VrUlRaUDErSExSbDFZVm9IODVneXk5eFlRV2FpQlVCNWVVVnczbXpyd1NZUUVqcjhvOEhlZThmLzdkc0FmZzJ3MXo4dzJQVlAzRERJdlpkcEJXeVFOUVFoa1J6YXFSeDlCcGxWRlVvR0dYVWFjaGpzMlZ6OWRGRmJUaFhWbStFa2pMQmkzUi8wMExwNzdibm5wK3F1eVIzM1B5d1l2ZmNJU0xRNCszbzdqdUFlSHozVXNLTjdBbzBnMjI0ckxDQlF0d1I0cUNFQmsyM0grV1RZZzU3dnpBUTl3T2Q2T2dndlF3NUZJb25rUHpJa1dnWVU3SGZocUt4ZGJQS1BvMTJVTVJEOUFqMzZqLzNyR3duRitKTXlra0F1RUI4VUZHQkNYTW9RbDdUSHdLMGN4UU9WTXdqa3FpSVliUlhtYVFCUWdBTDJoNmd1Q0tGUjhvdlZRSEExRUVKOVlDNWw2VkFEVi9pcGJCVmxBQW9Zd0xoS0lBTTNLRUVKSlB3SEdFVDREeUlRb1F4TFlNRUEvd0FIdWNSRWlJVkk3QlRsVUFYQkRveWdWdXlEd2hta2NJVU9kSUJjcExMZ1N0aWxsYW5NUkdGUVNhSVl2Ykl2TG5aa1hpSloyMUs2WnBNMXFneGhMSUdqeThZNE1UZ0N4VjRYd3lNYVhTSVl0bXhHalQ4NTJMdEVseFdRdFl5TzRDcGp4R2FDeDVRY3BXWXpZOWpBMnBJMmhaR2tZeEY3MTBBZXBwQTVPaVZsaU95VVMwQldHTGNSREl5aDZzeE03cWpKaXkxU0tpdFRXVVRhdGNaRGhuSW5LaW1LelJTQ2xzaWw4VitzRE9OVi9zR0drcG1wY1JBNFR0T2NOcXBWVHFTTmEzTU9oaXFVUFJEZGtpSWZnMG9rNCtLU1I0YUtUV2tLcDVrR2NLeHlQc0JOSkRqUENsakF6Z0t4azNDOThVdWFJbFk5TGxYdEFBODR3R2htMXY4UmEzckVud1VCNkRVaEVzYVpvY21VRVJTVlBvK0ZxWVpHWURjazRKT2U3Rk9DS1pTZ1NuWXFFRy82TXM1d0FtY3ZDeUFPMWlDQUthd1Z3RVBWTXdqMUx2S1l2MnluUzlqYlRtZk05c3FCYmpLTFJERkwxMm8yejlJTUxnSW9hSTFzY0tDZTVKWGdObnBpWjE1UTBEU3JOWlNrSUkxQVNDL0ZWTGt0UUtySlBLbFdXVm9BNnpBR1lvYVJURldvVThHeVZzYW1DT0VleG5EcUdMU1FORzRSYUUwSlZNZWk4T1VOUmlQd3c5SFNDVlNwN2dWYlBOc0xVM1Z6Rjc4dHJtZWk2dFp4cmhSUHFvME1iSy9FbmxVMHR4ME9hVXFnYUFVUEh5K1NGS084bFUvcGljOFR3ZWU3MGRMbkEzclNRSDRlb0pjcnlzMmRSenVQbkZhVG52VC9yT2NEdVBXVGVoRDBHdFVNS0VLaHlSNWtSbE5Cc0UzSXNpcEVhMDYyMmMyQjVPVTE4bm1QUU40VEpCZnBqVzhZM1p0czl0WTdJQjJ2QjB3S0ZKUit3SWNZL2VnZjd6RmVmQWFpQU9oUmozcGdHb2lHcFBNaDVYSW5LODVid2VwMDhLSWZ4U0ZKUUFKd0hKaEVKRU5Cb2NDU1l0LzZDQVdwTXZRdkIrdVR3ZitDTU9BZk1BbEdQd2dmYm5td0FzUEVseU9keXc2RjdDc2l0SlJzVzZaSmpYcGVaTHdoQlFwSk9UQVMvOUJuUDBKSnluOFNIcEtrSURWRlJBbkVmdjlvVlpDSFBDbnhrdUFCeHlMTjFLUkRZcGhaY21ieTVJeG4vRExCVXZrRkJ1bmNVM29HWXFoTlNFRittNEJWb25CMWhqSzNxZ3p2T2MyR1B0ZGtKQllULzBJaGdkeklwallxem1xZ0IvWnJGS3htTmFzdTRBcUhzZXBDRG5xZ2daMXQ2a0p0dGk5Y1J2T3JVeFZBQVJqUXdBY0cxUVUzd0VyTUFqbURFUTdsb2dnb2dMZ0hnQkJjRWszcWdjQkZjTC9wQUE1azhBSmF4U3FFdVlnV0VZVFFBeGFRUmxSR0xMV3VTZVdnMFhSQUF6S2dsYXQ3R0Nzb2pPQlNQQlBOc1E1NHhGMjNlWVAvOElCcG9GMGxnZ1JCQngyd3dBTSszYTF5T2Z2YkErRVBrbitqbXVWeVVaYkNCTGV6UlRZdlE5N3hLaDZiSXlqVkRiUEp2aVJpOFk0ankycWExbmwxY3Q3MHZzeTYwa3J3TktweGJTOEp5K2hnTXBiUktYeVRCZzk0VnhTSmJvLzQyK0pnTEFwejlYMUdlUVV5TEl2Y3ByNGxmaE5GbmxGZFkvL0o1aU01amtsM1ExeVhhZUVrUm9wTGNvaWtyQ2ZPVEVqQ1dHTEpmalc4WWJVRWloOUJCa2FMZVpMZ0FFODB2MXBwbFVLbUJEU2tHMlRCZmc2dmRRR2RYL2U2dUZZMjNyVjFzMUdXVW5ITExvK3k4cHU1YlRDamUwcE4wbjUxWGthUTN6ZmR1RnFCU1hLdGZ6S09qOVJsekhRSmtxUkU4dUUwb1dWQlNCWjNXY3JkNTI2RSs3Y1gva21aV1N5WEp6bGxVeGpHYzgzaUxEcWhLV2JKbHYyNFpvYnM3bk5mNU5GMS9tMlJRN3puYVhTNkpQa1lsTkFRUldkRWdTcHJVN05NVFAyalc5d3NuUmNaa3ZpdXo3d3gwcXo1NXhIaUdSTFY3R2JndEJsU2pobllwZTVHdGFvMWJMa2c4RUtCTVlVNkowM21jUkxUVEZVT2N6cHdweEQvbXpOcnNEalNrbVBvNXdpYVJwVllVUkhub1hYSnNuYmR1YzRWL0F6SnA2cmcxckovZ0hzNmJ2ZkRCQ0tJSmpaZ2t4MHFSUjBmUm1LVmRIcVRORENrTWhoK2tUVUx3RE1Fb0ZnYllCZDhzZ0pJWTFIM29RR3p4VTY3MFJzYkVFNmNkRkxFRVZJaFJWSVhkQkNhRXpaZ2xSSFNCQ0tDZ1dpNk5rcVJ0eEZwOFVMWjRsUC9FRktIb3hzcHdDZDJvanl4SVI4WXBSdnM1QnQ5RVU3S1JoeTk0WU5PR0ZKMDVqWGZsMFVzcURrR1NId1dSMm9wQTBrbFlqb3EyQzFBdFJwS013VXJraHNWaFYxME1od2hOUmVPQTFLbVVTNVQ1VDE2SVlVYm9CaFR3eUVDQUFHVDhZSmdNMVlkZ1IyWE00Z3FwVnhOc1c5dFF6TTRPR1dtb1JkeS95TWJTSUFET0hBYlIxVUNSc2czNi9SUVVzVWJQQk9IQTNGT2hWTTR0SGRPYzBFQUUrZ1hFQUpaOEZJVllUVmkwMFFRak9FNTJoS0xrSVZXOHJLRmdpUXpUOU9JckxWZHFUTlhPRElDVnpCYS8yQlJxcFVmK2NFYnZySW1lNEVYaFdWWWVyRUJFNWcxSmxNYXlYUWFCM1JpVlVnUTAvTWgxTk9Oa0NWYzE1UjRCVFZKREpNbWNkaU11ZU9CK3dVa3JSTWZIMEFiMkNVYnE3VVgvRUVRZDdFbkVjVmFpek9DeUhLTk1IQVhBc2tDS0xBNFdlTVpDa0dMRzdKQUhnSmZEbGxxTFhGNk5tTW1VQ1UzN0hoYk9yQmU4eUVmcEtVNmUwVW5yTFVmRWJBQkhRQURTck5PU3NWYUQ1VWk5akVGOFVnZjk1Rk9iUmdteldTQW9VYUxZUDhTR1o1REliS29kQ3luTmtaeFFZSWxVYk5WTi9QaElpMWlQRDB3V2poZ0ozeVZqTGlEVHVneEcvTHhCNmUxSGtyNWtrYVpUZ0xoVjBtMlFKcVNoWjNUSWZPVmt6M3BiRjlJTTZCQk1xWGhBVC96VUhEeUduL3lKMU5TbDlZMUFoZVZBblN5bDl1MU8wVzFsTVVUbURYQUpFcFpBOFRqWGNrakg5RDFHMGZrSEJ6eW1GenlqUU5CUGNMWGIveEVkbWJTTFNzd1Y4TFRIb0VwSS85UUk3WlJHN1BSTzdaeGxNVVRCRHNDSlQxZ0pFRVNJeGIySktwNVBnSDJpUXZnT05GeldmV1ZJVFJWbVE3QkZnUkRNbnVST2l5eUl3VDJta2dpSlFKaFhlREZta1FTQkFlbVlBa1dZeElHblUwU1h1a3pFRENpWFJIbEFBbGtIV0RTSlZ6L2tseVk1WnVyUkNLcGlBTHFVUU10c3BwRU1tRC9NR0E5Y0dEUUtXSHJrMkRyczJDUHNwOUNoaWdRSmltSmtqN1Z1U1FXQmlQU2RTV0ZFUjVaYUo0VUFXZTNod0lzS1R3L1VBT0I4ajlKOGw4QzlDaUl3bWZ1RTJTRk1pa0x0cUdMWWloY05oRHJvejQ1a0NSTHlXSE9FeHAwbG9vTTJxQVhORG1CQlZxM3haN0Y0eVE2cWw1TGFaak9XVHp1NFI2Q1lqK1JzaWlKRW1TR0ltU0tBaWt4eGdjNllIKzQ1eGQ3V0o0eE9oRm9JaDZBc3dFZTRDdlJKaHFZTWk3bGdVTGhWQm9hcUI0dFVsNkNrait5MG1WSTZrTm5JQVFlRkdST01nV3FFVDNSUTZWVnVoVlZBVGtqMFdpUk16SUtHbGpueEFKVEFDTlM4S2J4SXl0RU1DdWIvNUJET1ZRR0k3QXpMNFduZVhvWnJPaExFeFJuRUZKbmFUSUY2WE1HTDlBb0lwUkRtU1lRSGlRRHgzWkFXYU1wbFFvdUJoRnFmOUVaeEJVWHFmSURnM0tvSHZRcW8zcHBRYmFVTEtBQVpiRXBtOUtxK1lLUUo0WVVKeUk0S3pBQ3JPSUdINlNyalFvclpDWUZRWUFFL0FFNFNqWit4RG9zMmFJUXJLVUJOZUFHb2Fxcnp2SVB1WkJwUWxBR2Z0QUJYQnBxMjlwQWJEQnF6L01BVGlRRHVrcHN0SEt1UkdBRVJFQ3RIUUJCR1pGcjc5cEFQaU1RSGRBRGZ0WnFQWVJwdE5JRmZOQUJWTmF0QTh0QzFMZHRHTkFCU0NBRlBsUXI1dHBEWFVCb2VwRXRPK2lIRTRzdlVLVkJ2NkVEWmZBRnJpWS91WUlFN0xwc1ZJWXF6VmF5TUQ1ampmZW9OM21UQkdWd0F6a0FLVEFMckJka2piaG5zNkRqVS90eEVEandHdERWQWFSeUtnTWdyMGJiUU1FaEVHdUNFTDZWTGxNYlNsZGJ0QlVSRUFBaCtRUUZCd0QvQUN3RUFMNEF3UUJVQUVBSS93RC9DUnhJRUFEQmd3Z1RLbHpJc0tIRGh4QWpTcHhJc2FMQmdnSUJCUGgzMGFGR2d3RStoZ3c1VUNSSWtCei9iZFRJa2FUQ2tRSTNWcHhKczZiTm1SMWxIdXlJTWVPQWtBQjQ3aXhnY2lYTWZ3VUVKbVVKSUtsQ3B5VVo2cFI2czZyVnF4SmhGaFc1OGFqS0FVaWJEa3hhWUFDRUJ3ODJvSDJ3SU1LS0ZDeFFzQ0NSNGw4RUZnaWhjaVNyTWlrRXBCQ1NIdUJiSUlCZUFqb0RDRkNzZU9CaUFWZ2pTNTQ0TWdEWW53QitHdDVZOXQvZmYycmJ0bzJySVFJSkRmODBuRTc5VDh6ZENHc0RGeWdndXdBQmdRdlFMdmlYRzhLR3Y3Um56eVl3K3dBRUFnY0lITmZMVUlCZXB3UWdSLzhuQUhMMXlkZ3RkcjNJVXVDQXNuL1hvditBZ1dMRkNnMGFwdUFRaUdPRSt3L3UvNjNIY2JwMGhQc1BCTUpHRzRFODNoWC9uRmZmYVNTVW9JRjdVN2pIZzNzamZKRGFDckR4MWhkMXpCM3dEMklDZkhZaFpBZEFsdDJISUI0RWxtZHFzU0FnZ3ozODAwT0tLVjZSNGo5THFMamlqRDNJRUlTTlFRUUJSWTQyNXZBUEZHWHNtQU1VQXZVUVJBOXgyUGhpalFLTmdNUS9JMHhCQWdyL2RGaGRkTk5kT0pDRklYYnA1VmhJZFpiVWlBT1VXYVlDRCtEM1FKa1BCQVlCQmh0NEVLZHZFSnlWcGc1OENDVEZQM3YrMDRXZlVIUWhoUkI4bmlGRm9GSUVLUU1mSTFRNUVISmZSaXJwWk1RcDlaZGhTRzJ3d1FjeXVQSENHVVNjSVJDUlo0QktCQmloL3BORERVOHFFSmh4QmV6L051bXN0R1pYd0FPMGJmQlBCMGlVUWNRL29SS3hDUkZiRUVGRUZ6MmdwbXNCR3h6d1c3TzFSaXR0WkdyWmxhWkFwMFhRd1Q5cGtjZ1FTZ2hORlZOTEttMDFra2dFdWFRVlNleDJOKzI3SUlxclVrSXlmVlJ1WWt5UnRGVkxCakZWN2tzeGRjU1RXRWpCYTNDWFU4a2JWVUxtTm54dXdVN1p0c0FHRStONjYxb1llNWRSVWdvVGROc0JqUjBzTWtWRmpTc3VXRTU1VU5oc0F2MG0wRnAyUVVoZ0NmOU1VY0lVLzh6RndzNXBZdkNBeXQvOUJESExnajF3RzdTLzNWWVlkVjBkNU9GaVRFZjltRTZQcVFUMXlObUJlMjlHR3ROMjFsa0x4UFVQQ1FRaWdjT1RCcUtudGdZOCs3d0JCa201aW1aYStVV1FHOFlGS09DQkFoSFkvK1dXMm1TVEhSZHN1VVdzMG0zeVRtVmhVb2c1U3QzakhtS2Q5VC9mb1pRVW5QOVFTWGJOamJMM2p3NGoxTkFnbEIvZ2dBTjY5Mmw3Rndrc29KY2dsSTJ1V0VNUE5melF3dzhDeWRBREZMZ1AxTU1JUFRnNHdta0FVcG1mUUpBS01GMkhBbG5JdklXM1NUN3RSdUhKdFFJSjhOV2dmWW8vQk5HOWtTc0c4WS80T1pUQlo1QkIvaU1ERkRnRzRhUDVleDRLSkpCUytGaisvUU90TDhQKy8vQ1FYd0dEUVVxR0FzQWw2Um1RSm9ieEM4UWdrTUJMTGMwejNGckJDQzZRZ3o4TnBBdWJ3S0NvTExqQlEvR2hCeXlBM29VSUlLc0RtckJMZnNrVmFEcUFtak84SUZVQ0taV3gvcEVMWUpVQkNYQURqSEtpZDhJZWVrbERaeEdJQnY5K01BTkQzV0FnTVlyQWJ4YkFMR2Z4aGpsQ1NWZEYydVhES2tZbWNmUktpVkVpc2tVcTB1c2tKZG1pRlEwSXhwU1FpeWRpUkVpK2hCS1VoNFV4SXl2NTE4UHNKWk02N29Rai9lTGFHTCtFUlRPT1M0OXNQSWhsbFBJVlB5NGtNUnZiaTBzR1lrZkt6R3VQMDR1S3YxS3lyNmE0NjQ5YVZHUEJ3alNZMlh4R09FUmpEaVlkMGpGSVprZGVSRGxYU0ZJcE1JaUlCV1VRbU5qZGN0T1dDS0FBTnJpazBzczBOc3FERk1BNUdYS09LUTNZdEtOWXhqSmxXVmtETlhVeC9qemdlcXBaRFdvMGdBTDd3QUF0bmduTVQzNml6RmNCRUlBSDRCSUVCb080ZVVGR1h0WnhDQSsxTk15SHNBU1JSS0VjQk1EeVNjUEVNbGI1eWFkYlRsUC9BaExZYkNEbzJSa0wrdk1BdUFVbWdZUUJEUUhZVXFXdlJheVlLbUhNYllESnNZYzZKbHhRMjBnNnM5VE9jRFZsbTBTcEtGSUdjQkVQY0VzM3RtUUJYRlpUTXlTUWJXMG0yczhERkJBbnJ5M2dMeGJhVGNYUWNrOXR6dVlCQjFnQWVjeERWQlFBTlRCaGFreFNyaWFkalVUdk90ZUozam83eXNpcXNvdHlFd3FNV3RBQ0lOYWw0RFJPR3NIWjJ0TWUrVWpwTkFNdDZINFU0TGJqb1NBMy95RFBOZm16c3hXMHpuVTNpK2FVYkhuUy9HeWdLNUdycXBZc3BDRUxQVTBnZ2FYcXdCNkoxUkVWUUdWb0lRL1pFaFFmRW93TlNwaVZqM3pvUXdLN3Fna0RHTENMUUNkcjJmYUlsVUh1b1Yzd1BxaTkwVmxXQXlzNEhyY2VOVmlaL3p5d2VkUXhyUE1TUzFXS3pFWWozM25aTTE5NjJoSG80QU8vMDRGeVFTZFcxUHlEWnU3UndZcWtDN3daNWE1RzdGTVY3cGlVb3RrRjczZnVNUkFMT2tBNDVIbUlzQnN5N0lZYzExdXMxT21aVTZDc2NXazBrQ01kaVVnLzBoOFVnUFNqSVAycERFSDRFNUVFSlpBdXpHOThQaHFmcWtZVmhEaUlqM2JhK3dBSW1JaFlMQ2xQQU14cmI3d0lvcW5qMlJKN0ROS2VpTDBMdkJvRWdjU3FSZTNOY0pDZ0h1VGdmZno5Qi96S1o3NkJFQWtLUHZyQkZDS0FKdHNBY0NNRjFIQ3QyQ0JGemdTQWdmTTZza0FZdURLT0tTV0JhWnBDRFdTUWcvaEI0UXlCeW1BRy8xRXFQd25CZ2puNEFBdEVLZVE5Rm1aeGxWSks5TWI1QUNuTFFQOEtibkNob1RBb0JSbUtxc3RTMEIwTHVvVVVwWldacWdWZ0EyMkc1aTBXakNBSG5vS2hud1lTcWhxK29BczVHQUd1UExORDJmNzUwaHVnalFLMk5RSXAvQXBVWEQ1RExvZ1Z3MFlwWUNETENmS2xNVzBjWEdHQUJUKzRNeEdJdEFWRFhhRmJCSGpXWU5wazZWVUxXVmVlT2ZVRE9wQ2ZFYmhnUlZSTzFqL1FwSngvaE5ZM3ZvNzJRYkJKdDRMV1JHRllqS0swbzExSzd2enIyeExaMTdaOUdNZ3pxckZkcWpUSlRoNkdibTJQdTFaYWs2SWcrV1dVa3EzYlhuQTh0NzN2cFcxM3Z4dUI0Y3BpR1QycXI1VU1iSkVVU1RlLzZIMnZVdjRiSW4yTVlyNFdnbTk2TzZ3N0ZaOVhZWm9pUm9jL1BDdmZFaXpGUmI0VW0vVHJ0cmIvWFRkRHlCeHdqMThhMjRCc1pNS3E2bTJDZ0VVczZVYTQxdFFWVW9pSnBTbS81U1ZWSU9yeU10ZnJqZDJKbzJBL1lzbEI0dnptT2UrWFRvUlNjcktBY2pZRFVGbGdDSGJJSkh1OUsxUDllRThFMXJSeXBaTGZPWWVqdTUweW9rMTY4dTJDRGxNK1IycEp3MzM5N2ltUEhzc0p3dHN5SnozSjZQcFcxTk85RktoWTNUZHAyU3JHRm85TnJCTE1qa1RITFdJRktIYVB1Tkh5YlZUM3ZBMVBOOFhYMGp6M0FWRHhmTmx3amdtTjc5U0JBRy83RHZHcWliMlAzamxtUEVNNm05K3NwVVJ1K2ZCWDZSS2d2cDEwTjc0UmprWUd5WmVKS2lXY2c3RVFwcWFTMkVaS2hmWHRMRm5hWS9MWUk4TnkwQmZxdkROTjlOVm9wc2F5YjRGUS8yVHpjOUROdE4ycEJLd1U4aGVnbkFDay9ISHpsZ25VNXEvUjFmKzVqdWlDaVZsZ0NSakc1ZWNBK1hFM3oyUWFwVVVnQjhJMnJMTm5hT0VxM0pSUW54RVlOeFdCeWhGQVhSRUFFOFV4OUtjdzBKRXVVb1U4MGpZU21GRVlRWk5NYmhJYytmUUFjaUVYZ2RNa3JxTWFPME5zYUxFQlpoRWNUdkVYZ2NFV0FRaEIzOVJKN3VkK2g4Tll6ZGNjaG5GWThHY2RZVGRNK0RkN2U4RVVZK0pzNFJFMmNqRTIwelFDL2VSU0xyZ3phdUlxaEtFV3Q3SWIxWEpUL1hkMTcwVkxzZlFxRjVKUWdtUi9rYU04a3dkOXBxUjAzRkVZeDBRNVA4VVdjYUZTYndGV0JqSUNHbkE2YXNNekJUVlRkUElzb0NFaEpYUTNXcVZwZHRGN1JBVmI1ditCZzZDa0V4dklkektoWHVsME5hbzJUSXVWTGg5VmgyeHhGeW53RmdKUkFsVFlYQzdsVWxQZ2d2amhNd3FRTjdxeVZiS3lGbk9GRmxDeE05R1VIdEcwTTdja1V3UmhlRTZqSlpjNEhjTDBNZXdGU2Q1MkVRaUhNaDRBTm0wUmZxdGhJRWp3SkdHRkE2QURKYW9oRUJDaUpnTGhNOGRESHYzUk4zaHhGM1oxR2xLU2lvR1RJRlBnSUpZMUVFYURVU0VET2ZEM09CMUNqQnpWVVdqVUVxZlhmNzZSR3l1Z2dsQlNXcWdsVnZJaFZxVXpUV3l6SDhzMk56QUFHeWFDR2k5RmprZ2dYeWp5RHpYd0Q4S1RHa2ExUzRMMVM5VHhOQmdHWkpFemoyNW9qRWZSZEIrUlRBVUFKL2xoSHV1b1dhYWpXWjhUT2cwaVZ1ckJPcW16Rm5YL3RRSlN3Z09tTlpNMUlGMFE1ajIzc3owRUVTWHI0Vnh2ZFR4T1VSMVdJcElaZG1IQ3VHMG11VXFWUXhEWVZCNkJRd0tuSlRyU0pUd0kway9va1FKOWd4cU53aUJJVUpZcWtwYmlJd1BxVXlOTFVwRU1RaENXaFJmY1FqRUVBQ2tnRXgwV21DWEl3U0dWbDBVaDVSc2JBQVBYNDArbXBRTndtVnlmbzF4b1kxeEFTU1BXcFdBMlVnWUFKaERpczJBeVFwRnAyU1JJUUROajA0OVZVaWthWlZqRWFGNS9lVWdReUJhVHBSNk5vZ011Y2dYLzRDSnhrSll2TWo0NW9pUHI4eVBqZ3o1K1VtUG9nMS9xa3lNLzhBTzZJeEM5RTVQSDlRRU84aWhQUlpvWXhvYW51UkJzWUJBRE1GeVU5Wk1yVWwvWnVTSlE4Q0pEa2o0Rk5qOEcveVpqbE9sZk1xWW5RVElrYkNrUU9YQWo2cU5nM2ZNRFViSkpaNWdoMGZGTG1SaWRUOUVVY2dJYmVWZ3pBbEdSczdOZE50STl0a2xsWlpBRGJHa2p1bk1rMVpVbkNFcVo4d09lNVFPY0E1R2d1ak1DU3JRQkgzTWJkMWwwK2tsNkJLRlZvZVY3blVVQ1BBQUNQSUE5Q3pJOEI0a0JkN0V6NUJoVHozUWdmRkErZkNJRmljSW5NdFluTmZZUFFxQ2pDUm9sbmNVV0hicDNJVm9SbHlFY3NqRjh3S1ZNM1dRWVMxb1dNQm82TWdBL2ZFSWtRbkJsZ1ZJcWY5SUZYeVlRWlNBRFl2WVhKSFNYU2JwaEliVVpqS1JNUGhnVFNEVXhLR0NsNW1Nb1dIYW5YV0JudjhKbGlYSWtMUms5K1ptbUlVSTlnclFjd2RFeUVqUmxaZkFDZnY4aUJSbFVaeGJFWlo4V0pLeVNrUmNpUW9KYUswZDJaSDdCUTFpSGdsTndBWXNLS245eUJubjZwUUt4cDNuR2g2NHlRcmFScWZCQ1pMMDRMN0lSQWNhV2FKOWlRVkNnYUVyd0syWEFLQmJqWTdBcU1rUTJhRWpsR3hqUUFTTWdBeThFTERHMENYYzJhc1p5QmpMZ0I2ZDJITW1IcE1OS0t4clNHUVBnTXlYZ0FpOEVLcUl5TEwreUJUVWtLaXdRV3MwRFFNQzJyWkpEWkpubWJCckFyUDlnQkl4R1Exc2dwaVBBcmx5eVE5b0tyOUZ5SE5VR0pWM3dCY0JTcnNSeUJrSGdBMnhGRzdMU0xDVWtzRml6QUJYek5wZkZxR2V3Q2FrS0JScVFGc3h5SExORllSUXJPYmZDaFFLaHJHOG1wZ1FHR3JnQ2JKTkdzaVU3TWg1QU54b2xPVGF0V1FPV2hTYXRhREViSUtzemEwQnpCMnkrUjVmT3BoYnZHclJqZEdxelJSTUJBUUFoK1FRRkJ3RC9BQ3dYQUw4QXJnQlRBRUFJL3dEL0JmaEhVR0RCZ3dnVEtseklzS0hEaHhBalNweElrU0lBZ2hmL1hjeW8wV0RCQUJ3MURnUUFFcVJDa2dsSm9teDQwV1RJaWpCanlweUpVV0RHbFJoVml1eW9zYVZJblE4SEZDandnT2kvQnd1UWJuakFkTU9HZ2dVSUNnVVo5YVhFZ1RTemF0MUtjZVJDQUFQK0NZVndsT20vQlJGZ3NDQkI0cCtHRlFRanlJM3dZT25RQWdId0JnZ3dZSy9ZdkFISUZoQ0E5d0FFQVhzUko4YWFVRUJEeGdnUmM1MU1rMlJmc1IvREZnQUFvUUNFcGY5UXdFQ2hnZlNLRlc5WnFFNUJ0NmhRendVMmRKYjlUN1puQWtzWHhPNThZT21EMFE5T3MxakJsc1JwdUNzV0xDQkFjQ0RlZ3dFY1IvMDNPQzlCNWdVZFI2Yk12U0JLbk0zRER2OGdXNXZwQ2hUL2pLZHZxMEVERWh3YTNLWWZnWVBFRkJJUk5NaGxtdlpvMmhWcjJVZkNDQVNPME1NSU5mU1FZQThNL3FQRFB5TkFDT0Y5SzBSdzFvV2ZIVURkUDh3RlFBQUJBeEgyajJNSGVEamlBU1IycCtKTWJBUjNHbHNGam5BRlFRVWUyQU9FUVJBVUJCUTVsQUdGRkZCMDRhTU1PUVNSQTBKbFNPRWpRVEw4SXdNVVFlU29ZdzQvL0NCREhGSXkrRU1OTlV5eHdsQ09DVUNBbUdOcVdKQ1pLNlk1R1JzaTZUWFFteERrRmRWbWVEM1hYSjJ2ZWZhUFhBZ1NLWVVVQi9uWWhSUmRDUEZQRjJjVU9tZ1pCeFZGSFFIVHFTbnBwRFM5K1E5NUd6WTFoUXd6RVBIRlFVQ2VjUVpCdWZ4anhEOUV2TkJGRFJiK2MwQUJCR0QvU3Vtc3RHbzFGQVFMSE9RR1FXY1FBYW9PQ2d5MUFheTJNWVZkcmNnbUs1TnZHQlFVQVFzRUtWQlhwQXk5eE5HMUpubkhXRXZmbGJSVHQ4cUdXeXRra0dsclUzTkFhV3NWdWdidHhTMUczb2IxVTBjaFpTdnV2Ukc5VzFOTjlzSzdVVWtxQVZ6U1ZLOTVzTUVDQjdPQUFnclBSZ0FnZ0swZU5GUkhmam1VSW5NYXZsbXVRbUhpTzJuQXpUVzBXVUdkZFZiVVp3UTlrQmJESkVDYjNscHoxZVhCWm5FQ1lHZWNCSkZWOG9adUl2WWNwSVlaRml0QmRtNzhVWE1nQ2lUWmlBUnA1M0ZYQi9sa2tIZ0JlSEJVYUNqQXBZSEM4YmtGSHhMRnBWZmhYRmMvVUp2QlpKbWRWSzRGbVUyUWFteTlGNk1PQmVJd2hRWWtvQWN0ckVSai83VjBkTTZKU1pDWktUcjk5RXg4Q1J4ZVdDaWpNTnlBVTlCWEVBNFEwbGRmZTVpWE1BSVNCTkt0SUlNTDlpQ0Q2RUhJVUhxT1FmUlE1RUVFRXRUREIvOU1VVGtKcVRsdzRXRFZqZW5xUVFKb0tQamhhZ28xQUFabVczamNpeVNBd05ZSEJUSS9BdDB4am5DM2FreGhJSmNHQmpaSkVCVC8rTWdvUVQyNndPajRQWGIvenc4ZndGVVVjN0FXZ0NidzhFZEVzODJCeVVuZHJkUTlnTUlVSC96Z3dneGRlRUdpUmdXa0xpeEVDa0VZQVYyR3hUWlp4ZStCbEltS3pncGdQUTNVUUFxK0lzS29DTEtKZitTQ0NGczQxQkwrb1lEZFFXQm9FRXhoZHlCUWxMbzh4V3drcU1FL2p2U1BST2tnQlc0N0ZrRTJ3S1o5M1lRblFJVFh2UC9BbzhJaVVpWWtHOWxYMUx6VnJYcGg2MTNlZ2c0UmpYaTRqR1RyTytiNjFyWUV0cTRwQW1Va0xxRVhFTmRGeFZuOThGdEhBNDlPZEdJMGcxanhmcmVDbGFNK0E1c0I5T1dPQWdrTEZzdElLNlBoNUNaUDdKZEQrRklBQlF5cktXdGpDbElVcWNpci9XTm1mWm5PWlNKeW1CRU5KR21ENU9Oai92VVRlNTN4angvQlNWVHlkTEFJTUt4Q0x3SlExdmJFRklSMTVqbCt3WW9zZWVjcUFSd21BTy96U0dPWTloaE5Jb1NMM3RvWW5lZzB5WUljOG1xcVlRSGUya0tDRkp4blB3OElsbWYyQWhpYllRWi9ROGtMemhDakdHNDJUWlpPMjFpSXhqbWlwUDNNbHdxaHlrM21kQ21lbGV3cEM0REJQeXFFSDlUQWhRWDd3Y0JRNkZmL1B3OTFSaW9sazJBYzVaUzJwT2h2T0N3d2FGSHUwc1lOUmVjamlPbVFEbWxaeG41aFJTaVhLcWpESEFlWDlDd3pQbHVqaTBFN2t5ZWhSQk1DNHlGS0l0OFpsMmV4Qlc4YXVNOFU2a01mRVBBZ2I0dE15RGdmR3JJVDlZNURSeE9BNGVJblM1eFFSU3g2UXNvQ3NyYUNGSUNBSUNsUUp1MUdnRGVQMHU0K2xHdVoyWnBTbXdnc0ZRYnh6QnBDMTBNQ0hFVHZlZEZiejFzY2ljS0pjdk9udS9NZFVJY0sxeFFDTENHYXNhYkpRdk9zeVpVMVFwUDdCdzQrSUNEOHlPV2UrR3dQVzZZUU9lWjlBSFExK0FFZmVtQWwwVFVvUWJEN1IyWWh4SmEraGtZNUQ0QVUzd1kza0JJZEJFVzdTeTA2SGNJR29qQkZZUkd3ajFrMVJ5TUMvM0VPQ2JoRndqK1FvS1hVUGVsME9UQmRjRXNIQlJtVTRYc0krY0dOYm5RUUx2MGpRUWFxM0FoSW9CdUJqSWs1MTcxT2RuSzVXb2dva2pnamVLenpDdlFndWlYb3VUbHFVcE55VUNRc21hNEhRZUJERUdwd3VpWWRGd3BEd2krUENoSmM5aExwdjBIWUVrSGcwajRPSFVhQzNlVks0Z3BDdFFMWWNTakJhVXVGSG1ESENndnZNek9EZ0xRS1dZQm5UYUVHTWlEU2tyYjNQZTc5QTFBb05xRHJXcGVyQWlkWVhCZVpwR0NzQTVXSjRlV2Z4UG13QzZUZ0JpRVU2c1FuSnBTUGEwamtQK1dnQmhvd1pLU285ZUlIMWttV1VjR095a2p3Z1JyTUlBbEU4QlVCZ3pTcVhwa0tWWVpDMzVjMnBMTW1hNUk4N095TUFsandBUmtBQ3Y5Vkd6eFVCd3NTUWlKMG9RZk5jdDhKQ2NCZE02TlRUeHRRd0FqS2tFRmVkWEFMdnBMQ0ZWaGd5SVM0ejg4dkRpMkhLS2dBQlhTZ0I0U2Fzd2ZMTUFJR1RrYzJ1bmtLcEY5TXdhMm03Qjh1MDBIL0ltUUJnN1h6SHowY3RhekxnZ0ZSWjRWY29RVGpySGNkdFNGMjhpVW1hV093eWNocmovMHdpZjlLRjd2UUJjWW10aEVveEM2MmlwQ0lrRDhxYm9yczBuVW5VNkxyYUV1Yks1eTh5UlpCUnU2RzNsV0tYdkdPVGxjeXkyOVhaQ1B3N3NsTy9IVlhja210V3NOT1owTzk3ZTZIM0Z1WFRId1R1Mzh0U0NWaVpNbHp1a3V2clpLUmtmVTdJcmlHamhzRlR2R0FCWktORXFPT2htUmptM2ZDeHNFVzVnbS9IKzZRTityYVVsei9WRmZLRVNJc3p4ek1ONHRNNUNJZmdMSy81TlhnRnVzM0VZUGRMcHRjMGVMQXRMaURDVG1BdWlneUtRd3JXOFFPc2dGNWtRUXYvSTVLaWhBeTBZVzhhYWdxWkF6SzB3WDBycGRMTTVxNTMyZUtWNkdzeFhZNEZxSkxXV3d6c29aQ3haWndMMUhWR1dLcFdXTzcxMFdsRGxqNGdwRE9JQ3cwOHp3NzNxSTZsd1VXcGVtYjhZcTdXQjRZRUoxUUx5QUNYTk9ZOXJlY1M3eko0cjRUV0RnakVIWnVRRU5tTWFXRjF2SVBaNllBUDZ4cHlyQWlTVCtmZDk0NWdXbFhkUmJqTjUxNmM1ZS9YSnJTc201eG5IY2VMQTRXakRGUnFzOW03WWtncFNrOWFwelpHclpYclpwN1lUTGozUVNZdXRONDk3ZTNwUGFYcGgybmpjbEVSVXkzLzdxaFlqV0hjMllBSEhlV3cwcFBPeFMwckdIUkZBb0FTQUtCcHcvRWdVUjdKV0hrQkRSY0pYSnRyNlFYejJFbjZmUjIyYUZkdmpReTE2SVJ6L0ZQTklkTTZFRVFTYWMxei9JQWtIUkhFNU16UkNGOHR6RVVRT01aTVhjZUlqZ2NZTFZJZlVZMEJpRWlTdE51UTNVc2MyZHNrSUZIWUlGVTQxRVcvd0FEeGhOYitYRjZNUFYraW9SaHRxRlBaa0VkdzZJekVOQWJ2ZUZ5NXZFd3FMRlk5Y0ZNZ2NkQzJGRjNCOWdjSGNNeHpDRTRMd2hqMlpKMzMzRXJvTEVBWE9OUnNkV0RiTEVuZEFGTkJ1TTJKZlFaUy9GQ0ZtSVduNEVCMXFNYW1OTWVPQ0EzQkdJM1o0Z0NkVEZqVWZGUUhkSXgzVWRPdmVNWVcvZzBXTFJHMXVHQVpQL25mcVhuTWlVd0JTVndWY1Z4Ti9xQlQycG5GcjV4TlF3alQyVWhGOE1SVTVPSVZwMkRJSUJWVlJrSEptOFhIVUxWTkVrVFVaSnhndkNERmVDQ2dpaWpOc2RUSEM4bFdERVZVL0J4aDIvVEdtWVJnWnI0TUtoR093TkNYZ1ppSTNSREl3U1JQS2RoRnE5Q0h0VEVUa29qVklCVElpVHlVM1ZWUkQ2UlJBeVlZYUJ4SG0xQkVIWmpOL1FoT1pSak4xREZNSExCTnFJNEhJd0ZJL3hESUkrMUlNclZJTXVsSVBpb0EyM2hUSHVTS3czRU02OW9oWU1SSmxtSVhiN2tFbnFFR1F3NEZpbmpNaER5QVpSVFcyWmxWb1hGR3V4Qk85aVRWcytEWHNxVkE4eDFJM0hnT3Y3NGpKVlRFRzJCSHZ2UllwQnlJajJWaGI1VEpyTG1GK1Avd1I5Wk15QXJDVmdaS1ZoN0tEYzZNSlNVVlpST0FsOVdVbDlHSWlVb2FWa0ZjU0FTd2x3RmNsVXBvQndoQTNmWDFUczA2VzRzcERKcmdUY0ZVaEIrOEE5THdJejg5UU5HOGlUR3hUMzQxVDJNWWx4bElDVGZzeU5SRW1CR2NqN0tSVi8vTUYvbnN5Q085U1hTbDFxQzh6dmYxaUlBWWg4RUlrUC9jQ0N0WTE2dU16bzhJbUxIUlJDTW9wUndlVnozMVFYY1kxL0ZCU1hxNVNTZkdXQ2pJeUVOb1R1SnlHc3pveklXZ3BqcWFGWlZ4aVhQTTVRNm9DQ21ZenFsSXdNMXdBY0UwaDVJRUZPY0UySnRPVDc2aFZ3RjRRTC9JRDQ5d2w3UDFSWlAwVDRnb2lHbitXMGM4UnBFeUVoSkVWc2d3RHpGOFN5RUIxdE1ZVWlWNWdFSy8rQlNmVkpjbEtra1FKWWtRRllRVXBBRGIrWXNmeGNyV0VkeW1iUmtla2NTMUNROERHVmpEalowQlRBelVkRlg4TlVqMy9NblFZWmkvMkFvQ1lxZU1tQ2NzSk1yWlBFcTlGa1JBeEZyRzdJUUVxUk5zUFJrUkVFYUNOSWpQQ1lFU2ZJalArSmpYZ1lxWllDYkpCQVd1bkVBS0RTaFhNRUdnREZqMUtGTlVERnBTVUZsTlhBQlNUSURQVFlvZzNJR1VCQm5CU0VFVWhBSEk0QkRUL0VVNUVHTE1Mb1ZXREZOY1dLTmFiTUNQREFDeHZVQ0wwQUVTakFxUVZvUW8rSXJCT0VDTlRBQ0tJQUI2UGQ0Si9Ta3RMSXpJVE1uRzVBZmJwWmxMOENlQkdGQW8xSXFTaUJBVWlBREkzQjQveFNkYktvaUNIYWpFYUFETWlBRVdYWVFYY1dnYVY2V1pVUWdCSXBKSFFFMXFPS3lwdmN6bmdoU0JsdnFaUjBFQldLS2FLZGlRQnQyUW01cXFmY3lNVTJIYWo5d0JwOUNaSkNhQzZWeUJrSGdBMmpxTnE4aW9haUtMNjFWRzUvQkFpT1FBNjlhYUUvWkFXZ0tBV21ETVVheHEvZHlBTXJoY2hEUUFTTWdCWW15Q1hObVp6STBNWjl4UXJiQnJQamlLRWd4ZHBlMll6NnlDUnFVQXhyQUZFUnhTRkh4Z041NnFXLzRBTTN5QUIxZ0lUOEFQaWxhQXMyU2ZqdUVmKythTEk0Q0d2NXhmRE9sSHlWVVF2K3FRZ2hMUW1aRFBERVJFQUFoK1FRRkJ3RC9BQ3dKQUw0QXZBQlVBRUFJL3dELy9RTWdzS0RCZ3dnVEtseklzS0hEaHhBalNweElNU0xCZ2dFR0pzeDRVV0RIaEFBQ2hOVG9rYVBJZnlJemxnejU4YUJKa2hWanlweEpzMkZMZ3g5dllpVElNaVZMZ1NwVkR2ZzNkRUFCQ0VZSFFIaXdnQ25UQ0E5UVJFRHhvT3FDRFI0RUZ2Z0hJU1hLb1FXM0poUmJzNnpac3pHRGpnUzYxbU1CZ2tiWHR0M3c0Qi9kZnhIK3dmajNZQVBkQWdNMkZDZ1FnSENBd3hrVEh4WW9nTEZHdy84SUxQNDMrT2hnbEpnUENsQ0pjck5uem83UmloNWRrT1hieEVrektoMWM5OEhTRFUyaFJvREs5d0dCeWtmQkZ0NEtnYXpkbzVRcGIxWFFOeXFMRlN0SWtBQXg1Y09JRHpoNGtFQ093aTVRaEtBTEp4WkFlRE1CZ1FRYS8vOFRQNTYwZVlnWFQycWwzSnZ2Z1g4THF2OVQvZy9IUHlRNGtKRFFzSjhGQ1JZc1ZDV2dnQVZOZFp3Ry9QRTN4UWdNanRCRER6VThLS0ZBUGZ3emdrQWZrREFGQ2ZNSnRBSUtUUW0yRlFFSExMREFBZUVWNEYwQTcwRWdRR011Um1iUWQrZlZpQlliRC9pbndZTDdKYWdnRGxQWXAwT0VQUVFCUlE1bEpGbEdEditVOFk4TVNmNlRnd3hOT3ZtUEZGMU1DY1UvUHp5WVF3OHk5QkNIREVIOFlHYVlVM0lwVUlUL0FVWGpQeWcyOXA1QWM5cG81NTJZTFJiQUFJbGRobHRoTHVWcEZBUVJBRWlDZ3pVZ0tjV2lVdndEeFpKV0ZpUkVGMUs4SUVVWkxsQlp3d2NPUkthaWloRGdLZXFvYUIzR1czQjhLY0RDQ0Q5MDhZSkFSSnovWWRDV0JZSHhqeEZiZkVIRUREWGs5ZDEzb1pJcTdMQ2tBY2NYQmhvMFdaQ3MvMnhCeEJaZFhNRUNaUTlzdFVGdkMzQkY3TGJjMHJTVVFNSHlwUkFHWVRta2trNGU0WlRaUkNQOTVCVzYzY1pMR2tjR2dSYm91Z3U1cXk5T2lZWDBWbSs5V1JhWFQwUnBKQkpQR0dtRXNMd01WNlJlUkVIVjI5UEVJb20xZ1FKMHpXYWd4aWxVbDFkbGU2WjBtcDZvTWtUZVFWdXAxTmpLNVcxV2I4UGRSbnlTYWFmNXE5SzFsQ2xGMXdZQ2JTRFZBMUJoQlpoMmxmR1VjbWIyQnRBVlpRY2NkWUJWcmhXd1FBRk5ROURiZDRUbDJWbEdMbmR0TDNmaW5ReXpXZjN5V3hDZm9UYVZMZENGcHFCQkJNbitvOEVLLzZ3d04zSjAxOFdWWmIyVi93akJBZCtLaTlkc2R2UFhvQTVJaktERENFQW1pQUp5VVRGVndKdS9CZ0MyWitWaEpzQjdraDNRV0hpL2puMWVSbThONWdGZ1NPR013dHpKVGxIQ0ZCc2VwekVMY0ZlbkFRNkhRNmk3aEJLV0tZTU1VeTVKSlpjUS9sUEQ0aFlhditrL0gvd1Q1QWdhS3JjQ1V6eERJTmwzTERMMm5nRGZmUzc2dGdEc1hJQUNBeEMzQVZSQTAvM0Ira0JDajBTUUcycEFld1FZRkxDelh4MUV3T0UvRlpieDZLT1hPbEpCWElBa0FqWUpTVk9TUVEybUl4Z0MzT1kyQndpQVpMNUh3YlJvaTJncVdScWdZSUFjLzlUQUJXVjR3UXZPNEFaR1hRa0tYUkJDby81QmhHVjlpUVFSNE5sdHhoTXFzVlh3aHVkcDJsRXk5Z0VYdklBSXNUS0NyUC9PMElWTkNDUVh6NHFWRERSZ2xBMDhqV3Erd2FFVWJRUUJuckdtQUJqQWdBNll0Q1ZtdVdFRUVUZ0FiRHhWRnpHVzVtVTZvZGNacDhoR1VxbnhPZ3FKbUUzZU5UT1R0T1VuRzRGWEc4ZDJybnlwNnpvOWdjbEIycEt3a0lBRlg0QlVEeDRSUmpDUzZIR1BaZm5JRzlGb05wZDBoSkE3VWNscGxESW92bmtxV3p5elRhZ0dZNVNDSFpJZ1d3bUp2YUlJU1ZISmtTRVVjeGRiZkZLNmdtMWxLMUdoeWxTU001MFZSTUNYZGJrV0oxUHBGVUFoc2x3R3lWcG9FTUl5bHJWeUpyR1VvMCttV1pxVUdBVXdnUGtIeGpBV2xWK2lRQ3JvcXd5ZlRJVVl4VHhFZ3B4NTBkZENZME90Y2NaeXo1UkkwclQyRXdDSWhYVDJMTWhmK2xML3hhb0lCSnhWQ1l4UnRFTlFWZllKbmxrYmlhbUMwN1NuV1kwQTFydWxKdDFKbWM4d1V6UHhkQWhCRHVZV1ErNHBtOEc2WWxWNGRwY0ZvSzlhSUNOTUFiSVNIR1ZXeGpvb2c4RFVtc0tVQmNBQUJUQnd3QXAwU2dLZGdzZzZnM21sdmE2am9veE0wREhoeVNoSVJNSW5lMjYwTWxXMFRyYWFJcFYvc0VBcVZ4VVFUZUV6eXZab2l6M1hDbFhUN05LYnFoQnVQKzFyRUlPQWhBUC8vT3lseUVSbm5zU3pGZTRnSktuaDhaeFNMWm1ZZ3JXbkt0UDY1VDlTSUpBRTdjOCtRZnFIR094MkhISDFaU3RYbWFwQVlKQVg1Q2huUDJwbGtBNlM5NzRMU1c4MmEvdE50c1pqdWRKaUR5TmNlNCtLNkNRbmc5UXBuZzhiU01Yc2FabHEvd2xFTm5STG50ejJFN3ZaREloQUhQVFBocWJ3UHVjWVYzZG0ra0dZS0FTRkdoakVPUlZ5TG9NeTlOa1BQZTZiSnhLT1hlRkVIcjNDNmJ1YjJ5dEYySENVcC9nU1FmdEpMNEpZd0IvMnhvMS9FaUxUbElLUUEvcVM2Ui8yVlpKKzY1dmNnbFRvQjJ1Q1VBMEdMR0FDT3dlRzJ2MlY1NUk2bnRDOVNid3p5ZEdPb0tlY0JJMkFCOHhybm5OL29BTUFBODlKWmZpZERINVFBd1pOQVVFSUdrRU5maWVsK2daQklQYUY4Wlk4TEpBd2hhbElKWjVDWHFaR0k5Q0poM01RUGcrZk1LUFN3Z3dBQUVlMm41SUZzNEZyQmt5SHVGbEtqcWJRQXo0Z0tVa212RlFPbU9RQ0tiamdJSmZpMGdpU2xhMFpYbStvUVhiamVwS0pFbVcyV2Y4N1EvRkFqalNrQVFjQkQwdVRXdFNqSE5Vb0tRakJEYkpLNGFMKzRZSWVrRUFCSStvY210Tk1RZDhvVFR0YUNVd0VWTnhsS2JqaEh5S2tGSllhMVFWWUlaRUlTdkR5cGlMZ203RXllcThRcFF5dzZMS0NHcFFoQ1MzOGh4TCtrY0ovVE9vZlp5QUNFcmNna0RLTWdGeGloUk1iVGszc2Z3eTdMZ3BJd1FqS0FFUVcvc05XUnVSMUY2Q0FCQTBvSUpsVGUyMnhnMnkva0dMZzJrZ29neEJrUlFRallyb0hMRWpiVVFnZ21LaHRtOWo5REZ4ZDlpZVFSakhCTHJiUlNtOTQ5dTUrdXdZREd3QjRXZnFva0p6MCsrQ0FmRmtjNFdndzJiWUxKUnNWSk1KeEtFbUpKL3lNOVBMS1FxaXBMNEpQbkZzZVI0akJGNjNRam1nY00vdi84c2xGWkZtU2o4OUxrSXRHR3NZZFB0U1lyd1RpSzk5NFd3aDJjcGRiaEpMWXNmaEdSTTZaUUU3c0t6d1ppa1RickRXSnhYWmhQamRYdWdyK3g0TDM2eVE4WjNoU2NHT1pybk45TUU2bHpORmhjc2lTUmIzcXgwell1aUp1OG5hOUpKTmFNWExBQUhZdDEyaTFOUU1hUUZiZUFvQytVNVBwRG1IbE1rK2RSa0hLNVNVYUo2VEdyYWthNFNDbFdsSDVoMVNrOGlHTjVTV1luQ1RLbmxEUzg0YjR4cG5Oek56QlRXNHdXYklkNGltWjVzUnEyY1M3Z0xOdEtQZ1BWY0t5MHFHNWszUVNNUXpYdUNaNmhiU3oyT3BScEd5dm8vcXhDR1NiQXByS0wxZHdIS2VRTXFoRlZvek53OUluR0JYRW1RL0JQcVBsQW5HWUw1NzBiTTVtL3lrZEN6VEtBdTJ4ZjlJOVl1UTVIcFhlQnZTRHYyanZHVFA5dmFvKzhRUUwrL09kd3BWUURrNUFmNEZOdXFkN01NRVpaSkY2ZlRKM0RqUjNLT015Wm1jUW4yRlJ2NWRSSEJjV2dUUmIyRlJGZEZGRkNrQXVmS0V4SWRKMWg5RVZXWE9BbkZka0EyRVlLaFVxMVNKVE1vVitsMEVaMCtjMXBOVXkzUk5raVZkMUhuVkk5cU5OTEhncVQyRlNmZkVYSVVPQ0VaY1pvd1FjU2xjWW9WSjNEL0EwZDJjaVVtZ2kxck1lZ3FjWkV2UWlwT1V5RW5ScU0xTkxnQUlBWGZWVkd5Z1FWbEViVmZGMUtmTXZxbVpxLzBBdVIxTldkeGNWZUhOWjBMTWgwMEVWT0hPRlJIWjlmamgvNENGZUYzRWFRK05VZ3pGS1QxaFNUa0Y1dnRXQ08vK0VGT3hCSTlaU1JhUGtlQVZnZHdLQ0FzTFZIRGpnSEd0MVlza1NBVTF4RzlIbmU1SmhVZkJVRUEvR2JjSmhTeGRoUFMvNEFIdXhpSVVDUTc0a0c3NFZJR1lZTEtFU1ZiZ2hHSlFSU29DVkF2NHhYWXN6QW9relp1bDFWU3pRRkZjRFIwWmxPZDR4SGl4alZLSjNNaE00UmJGRkVueGpGZGx5VTNVRE4yN0RJU1JRQXZ0aFZYUURJSm9vaTN2REY3Q2hONDYxRndEaVhuV21PQTN5RHpwQVhQWnhXUnFnUzMyeEhvZHhnelBTR0gwbGV0NVZIZ0s1VittQk52QmhJcEtuRi9PaEhLNWpZUVV4QmZQQmZDZWxOdnpHZjFqRmZNcHhPQ3JXQTV1MVdRVnhJUVZ4am9VaUgrQWlpYW9tSTlqVE5abURWK1BoT2R1amJXMkVkZFgvZEV0NzAwK0RreGNwUUcrdDR6em1pSVpTZG5sbVZUZ0pzaURQOFJ3OThBRkVBbDlkWWp4cmNpRVZnaUdlUlZnL1JWTlNDQVBab2xMcTVETGQ4UjRMTnBNNHVHWUl3VWxnTVViVkVTUjFGamR6UXpzbWhZdlQ0aCs0WTJJTjBnT0lVZ1BLaFY5RlFpWmhVaVpWaVk4bEZtRE5renpUOFIrOUZEU2s2RUF2NGlKNXRUbmNRNWI5MWhIL3NodVh5R3BKbVN6bWlGNEFBamZ1bFl3NjhDQmRJcHBCUUNhbGVacjdKUkFBQm1Ed2hZOElvV0lXc2o0RGRtRkFNajJUb3lKSmxRQXlVcFBjYzVCbkJ4K2FhRGU4Vlczb2hXTG5HSnBlQWp3SWhDUlB3aVJSVWdaZG9GOHJoRjg1OEFOUThBTkJVSlZCb0pjR0FTRjhRR0o4b0Rzbi8xWVhXZWhqZVRXVHY3S0t2L2tBSHdra2NpTUdDbElmQlRFa1hLSmNTTEpuVHlJOFQ4SS9BN1ppdndOaU5ZWmYrR1VrVDBLYS9ET2FURUk4K0loZ2tSR1oydk1pUHZhYkMxRW84OGc2dk9RQUc2SmlBeWFZeGFPWE5jQUhtd0k5czRFQkQ1QkZIWEFvc0VsZlVDQUQveU1sVmdJOE1Hb1FWQktWMDFFWEVIUVFFY1JnRXRvUVJZRVVsaUVpZEZnM0FJVStNVFJTOTNNVkFUTm5IUElEVE5KblYrSWtqVkpBT2VCbExsQ2xLeFFtMENNNS9NWndPeG9SY2FFMVlrRktPWU5TWExjYndnRjlnREZuR2dBbTkxa0dldmFrVzRaQUJ0Rm5JU2FTSFJJWkRkV0ZYV3BCQllrUldSTVVLS2hTVEFjQmoyTTRkdWFtMCtrby91TS9WLytTUW00Z0JQWG1KQzVRQXpvbU5WVGpvSHRxSG11SVFXbzNHUS9BU3lUZ2xESWdCVE53QmpOd0pWS1FBL2lKSldmd0tnTFJhU0VHUmdQd2hPQ1ZxVzVFR0pYNFp2MlVNU0RnYWpQZ0JwWkNSQ3EwTExVR0s4eFNJVzhUYkN2RGg3WmFJOE5XRUNTNFVGRkJBaXZtUTE4d2E3S3lRc3dpRU5zcVFsSWdBeU5nby9mVXJQSGlWZUJpSGY0aEF6UHdBcm9pYTFjaUVFSmdSTEZTRUxyaWF4NElVWk5Ecmd6REJyMW9ocC9hYWpOQUJPMUticE95Q1dlUWF3SmhCRFZtYmVEQ0crcXByL0p5U3hqUUFSb2dBOERLclFZUmF5eDBCa0dBQkFJWEtoQ1ZhaEJiUVFQd2JSWlFBNVhDclMyVVJMa1FMVDVBUDd4aGFnNDBzcUxEQnQ5dzRSb0JWMi9rOWcrYmtFUVd3Z0pXQkIrWEdMS2pSYk13MHpRRTRCclg5ZzhtUUdzRjBVS3RxZ09TMHpNeUJVVkdLenBoeFJmQmdnR1Q1aWpkT1JzTkMzbFVjN1hmUTRuUStvRUNzUVFDTVFVbVFCeUJRVllQU0xaakV5eER3WUo2UXpjZHdHOWJLcmQ3eElJZUdCTUJBUUFoK1FRRkJ3RC9BQ3dFQUw0QXdRQlVBRUFJL3dEL0NSeElNQURCZ3dnVEtseklzS0hEaHhBalNweEljYUpCaEFZQkdOd284R0xIZ1J3MUFraW9VV0RKa1FGUWlrenBVV0NCQUFNQUZKQUpZS1RJZ1NNcjZ0ekpzNmZQZnkwTC9sdUo4dUJLa0FJSHZDeFFZTU9EcHlnaXJHQ3hBc1dDZ1J2K0ZZQ2dsQ2pMbEVDUmlzWDRzNnpac3p4enFqVlpjbWhRalFOY0RvaGJRQ0FCclhObkJsZ2FvTy9ldmkvL3hkV2FzcTdRdmtBUmQ5ektkSUZqeHhEcUdnNGdRS0NBb0J5RG90M01XV0ZoQUVxMXVwUmM0TUhWcXcvK1BkaXdnRFhyZndzZ0xEZ0E0Y0FEQ1A4MmJDZ3dJQUNFdjM2RC80UGdORUlFRFJxUWpOQXdSUU1KcWhGTWI1MU40TUFCQWdUK0RqUThlSEhsdTVZRFpQOEhlbG0wK0xDZDAwdjA2SEVBN3FlcEYwaU5nT0ZCaHdnc1dQeGo4VHlDQjcwQVRvY0NDU1Jvd0VJRUhhUlFJQWtqTkZoRER6LzBFQVNFUWZ6VHcwQU5qcUREQ0ZQZ01NVVVKUHdUb2dZRDZSZUJhZ3FzOWdBTUs0RDR3RmFXWFVhQUFKSUpjTmNCL3h3Z2dJN3E5ZGhaWGJkdElOc0NNRGl3d2dvalBOaURoRkRra0FNVVpVQlpoZ3c5TklnY2NqNGtsOXdJVmNxUWd3eFFYQmhFSEZUS1lLR0ZEZmJ3UVE4UDF2QlBnMGdnZ1p4eEN4U1FYV1U1em5nQVJ4QmtoNk9QZ0FicTFsQ0VNVlhRYjBEaEZ0WmZTMmxGSEFrMXlCQkVEbEtjVVlZVVFnZ0U1VDlSUnBsREdXVUlKSVVVLzNUeHo1Zi83UEFCQzNYaW1CMEJoZ24vS3V1c1ovWHBrbUNDYmREQkNHVjg4UVVSQXAxUktxbWFEa1JFTHNBUzRZWU1MR1JWd0FGYmdVZnJ0TlIyeGtZQkhpaFFsd0krOUhDR3NNQnU4YzhXUkJBQmhSOHNLT0RlY0hWQkVGbTE4TWI3VTJwT3BTWVFCZ09GU0VJSEdDaUFMMFE1bWNUZVIwaHhOS2hDTjdYMEZjRU15K3V3ZWtVZFpQQkZCbmVrVWNWdEFhVVNXRVpwdkpXUXBvWDgxQUpQc2NzVVl5ZjFkUk9obVQzc01rOGNTNlFXU3dFTEZWZHZBaEdYV2xQRThlYXpVaStoZ1ZobW1tbEdWc1ZBeGRxeVI1VTEvZkxETllXMU1Wd3dTVGJYYURsajYvUEpUREc2bDBhQmhSWllRc0xCRnQwS0JEYkhJSUVrVkhWVmRuMlY5dytlbFZGTU1HVVlYU1R0MDV6bC82UndSMHJCUjVWekM1SUFvZ2JHd2JlYXo4QjEvUzV2N3RYTG4zTWFaTGloRGtqb2dPRUliM3BJWUZYdzFRa2pieXlGeFZkMmRSbFVkMlVGMkNpZTAzanlmZFpJVjg4RkdtZzZLLzRVZmlnb3ZsdFRENkRBWCtaTFBoaGhEMThHQVVVUVpRVFJCZk5sZE5FcEZBSlZ1T1NGWityZ3g0YllDN1JtbFZVKytFR0dFVUN3STJVNzduamRqUUx4aUdQc3NzTmJOVzd1Rm9DQlVnTTRWZHdEMFVVbTA4bEFpMHpxQlBnQUZuQkpVam5vQVpTb0J5VkpLUzhJRTRKZ2hZS0FRRFBWWUFvdmloVnUrcktuK0hud0o0M2F6a1pvcDRBSWZFQUdEMXBPRDJRd0tpRklBVlJPQWhVVXBOQ0ZMcnpnQmNCU1FobDZZQUlGYUlzcHVMR1RyZjgrU01SQStRWkdLV0xCQ1dmd0JZR1VTeUJkMklTd3h2VVBJdVRBQno3TURSQ0x5TVZxdVdjQUR4aEFpaFR3RHhQMElGUURVVUlRZkdDQjFFUUdOMEtDRVVNeVlqZjAxQXdoUjdsakYvZFlsb2hKN0dBZm9lUEJOSE1Ta0JRbFpVZEpUTUdLWWpRK3ZxeG1iYkZiNlNScE1ZMFZKR0dGeE1sQWFyYzFydGt1Smg0eERGR1FrakpIOGkxaUY0RWtXRXAzU1VtU3hqUVJrTStSWnJtQTNybVJNWEdweVNnSGhiU3hFTVF3c1RJbHhFeUNIczhjaFpXTDZvMHlmY1lWeFQxR05hWEpZRzllMHB2Z0NHZGdjL3dqU09oMm1FVUpzeWVZcEJuTlpvYWVsOGlFSUxrVURETTNrTCtlUlFaL00yRkQyWXBKVDRkc1pKNWlxZVBjOXNuL3o3bnA4NXNUV1F1aGlDbk9uSEFIQUlneWxNK281Z0d2YVNkcHcvR01OOHNKUEtuTUVnUlRBRUhiVnJNM3ZGbW1JNzMwWnovckNWQ0lBRk1tOE54T2JnaHdHNU14cGlsMjJrMUVSY01iWnhVS3BJbGhTVno0TjdrR0dZNUFMT2hkYkFqUUp6dmRVekdpVktsV1dDY2p1WDJrZFkwczZYYkVSaGZSRE9jeEM5Q1Bha2dHR3hTc2dFaU95Ukc5Qk1nWFJhcHNMMERpM3dxdWhJUU9JUWNIbE9NUGY5QkcxeFhBSURZZDJhQWx3OUsweS9pVmFJa3BqOU9rU2hhR3RhdGVhT3ZRRkVaZ09BOE5aQ3FKeXlCTWp0aW55TmhyZHhwUUVITXNsOEllNkdCSlo5TFFQM0JRSUExRWhYKzZhVXB1MkpVMHJyMFVNUUtJTFZCbVZKY1ovNUdOc0gva21ESmhvcG9YaVJHTUhZQVBmdmpuVy9jd3hUUUxJRkFKa0lDRE9PRkFRem80bm9Rb1NOMHY1UUNDUC9pSG0ycVFvU1NKTmtrZjJPNC9OdFRkOFgxZ2ZDT0lBUHJDOGlyUnNPOGc4TU10Uk5nd0FEYkE1Z0ZWWVFGOFhMTWJNTEpndVV1YTBKUEExSVhseVhCS29FcHdsTUEwa09WSktBNFhBdTJiT05kZDhmMER2VDRsZ1ZXdTQ5Y2NXVVpIZlBLVGZORnlyYVk0NXE3NEhjRnphMUFESFR6SVFpeG1yQzBma0tMVjFDZU9KUnVJQWlWRnBncjlnMG9UQ3JDUVFkdURLM0JwQ2p4NEVYYStNemNlMFloMUkrNVJTbnFUTXRMc3hUeUowczRBTjRLYkFaRmdTV0NpNGFpb043MS9NSzlKb09LVW1uUHc0K1hFY3Y4NDEvbU4rZXdiNWZncGFqaFhIa3FqREJVQkV2ekFCWmZxZ2hDaTlBOHB6SkI2LzJqU3AwSkZMSUtVd1FVeTBBQTdJL3FzODlUWmxKSWhxMmpFcUpyNjhNb05TbmpCUDg3Z0JsSlJDdEdaT2dNUndIWERLWkZBcGpuYjI2VkwrbEJzRFVDSlpXaUNyeEJSaENxS0NncFNyT0lVUllVRUMrU1BNVU9jdGJMcE94Y1BkRUFEWmhLV0VvUzFpU29pcTF4dThMR2oybFVuWlhzN2EzTzVHcmRtdUlsa2pZc0lYV0RXL2Q3WUxqbCtlOVpPVVkxRFN2QVBETVJSbmV0NnQ3NEZVcktTK1NzdEJDbEpIWkc1NzRMN01aQ0duR2h1SlpxeHFCYjhaVWJEcHQwaXVhaERJak5tQmRVWXhWWVNzNGZQU3BYbzJUZ2xGYll4aWVuUmtHZi83WGpIYXpKQ2o2UGw0TjRzWmNQdWxqR0I0WVRnbGl4ZFcyWW1rcDZuUk9ZdTEwbkVoZEt3aVpQODVzYmNPTEtqQ1lHbk5KMDAwN1JKd25YdThLRGowU0wyVklrbXhTa3dJRWFUWkNUemFnUlFJTlRWRUFlT09Oc3JUckU1YzZ2clpDMUZXMWtyRDlJMTFkUnI3UGdoUVFxcWNsZUJaS1cvZXRIbDBDWko5SVlZemFsQlJ5VXhjMzZUaHVQUklGc0wzQWFpRTlTcWZIVmt1MkhuVEtqYzg0VDVjaUhCTE5qcVd1WjJscm5sNUJhakdVWHhWOVcwdGs5L1BHT25NZ1YvelhwV1hadDNJK2xBNHZ0d2p2ays1QTFyUytyd3NqV2I3dVpGMnVJS0JBQWdUNzlNOVBhRkh4cnVFY0w3ajM0YjQ0eXNwRWNvdmhIZTRNb2xxVkhSLzliK1UwMXI2aDc2SVBIYThJRy96Ny9LdHYzV2Q3bFhNcmxKWEhYbG5VdjNBRW9EMEZDdkplWXVzVElZUTBjeG1mWXNLekpMUnhKTER3QXJoaUUzRHJod0E0Tit3alJLZEVSbHdPUUJnckVYZEVFYmtBTWFNL0VTZ0hGUExzRW8zUUdCZ0dFbnB1RlZoRE1GSDNBNEt4QkwwTkpQc1FNL0F4ZGI1MkVqdDFKbnFVUkhLN0ZNNTNRUnNsRWFtNlpPcm5VeWFMVVVLZFZOaFFGNVlOUm5oTE0yelZFVko2SVZzRkkzZDlGOU9CRjY1RkUzNUVFUWlLZHMwNlJNclhVUmRVSXlENEFqSCtOMXRSRk03L0VQR0dnb09UVkNCbkUxUElVREh2SmNKVkFnUWZVVVRBRXQwTkkxSVBnV0VrTVpjY00wVmtVeFgwaFkxRFFUV3ZHRGR2OEJkaU96VlZieEdLYVJNNURZVXI4UkdJeENUWk8xT3l4QU9jeDFKVUJsSEN4eUpDeENKQ2p3RDdDaWNDTXhHWmV4RVE1b0VEamlVWkNuZTZhVU1WSEhpV2xsRld2MWlYUFZOaWNTT2sybmZCOUlFNUdoZ2Q2WE8xTkJPRGhRQWlQZ2pGUHdEeHBBV2lSZ2h6LzFEMnNsVkNkalZiOEVlZDc0RjNmaE5LNmlpdVQ0WGxKMVJ6VmpXVUZGQWlEQUljOUZJSnhESXNJemRqQWdXY3NIZ2kveE9IY25GWTMxWERod09VaFFKUVNoQTB2d0praEFBaVdRQWdkQ01wVzFqUVIxTVpTR1ZvUGxZVE95aW4vU1BvUmxFeDJuRkUyM0lpVEFBLzVJQXNkeEpabTFBdjhRRlZ5aEViOVJUUWVRRmRob0hNYnhpZFBvakRxd0pqWHdBemovR1FRNGFTSFljeUVIaVJ3b2dEalJvVGlyOVE4S0lIc2VvRDljMFNpeDR5bzRDRit5QmxBQm94YWJwelc5ZFJVKzFDL0drWUNKRTI1Vkl4T3l3UUp1TlFJcGdCd2hvQ0Vhd2lZUXNrSVNJaWxta2wxb3dpV1c4eVlYOWx4djhnRWVvZ0V2T0JWcGMxNGs4QURpQVl2bTB6clNVaGwvRXBVWjZSWlROb2U4VlMvMjFsdFJFUlV3RUFGYmtSZXJRWGFWd3lGcHlTWFg4d1BVSlNrTEprTXlJQ25YRTJHWlEyRU5vbVBoZFdFWDFsM2VOUUlZQUZXeEZVUlBaajVOWnBnMlVuMnp4b1NXNVV3bmtqZzZ3eFVwa2dJVDlsa0JCa0ZNSWlWUXNFRFNBd1hTazJaTklnTnhFR1NnOVFNYjRnZDBLUkFXNWliZFpUaEtSaGw3Z2pxeC8rVmtCS0VqV21oMXVpTWtyUkV5d3ZNbTF3TUZZQklsemdrbDFGV2F4eU1EVnhBcERmWkFreUloMTZOZGE3SW1uRE5oM2VVY0tRQ0RyL09VOFdjWnRGVjZDbEVhcFNFYlJzSWlJeEJlTGVaaUNJUXFQOEJkSXNrdkhjQXZNQms4QmRJRGZQQWt5bU1tQXlGZEVTSVF4VE1oQWpFQ2NWSUNJR0lWRldrakNXQ1kvTVJoRittZ1pBT1dSR1dHL0hNY3BZVWNDeEpHSE9rVTlwTjU1TGNYQ3BBY1N3SUZQd0NmaVJZbEUwU2FaNEk4bmdrbWJzSW1IN0FDc0thS2dhZzZ0Y0dqSmxWV3VPSjlRT05hdm5HRStPZ1hKek41WDFZREVMUkE4MmxvOE9sallKS25uK0lrUDZaZEtiQXpxMmhVVDBhbUZER0FTZU9OOWFTSjVlUVV5Zi94QTU4eUttSkdRNXlpYUQ5V0JwU1NacVlTS2xUaVV6UXFxQ05GcUdhUlo5eVlqNkxxRXJJQktWN1NCZC95TGFiU1lKWjZYUUxCYUYwd0E0WDJRb1ZXQmhQd0lyYlNMcm9KcXFGNm5udW1aNm94QWpMd2FLUTVLWmY2UXA5eUtteFdhQzl3QnFJbUVBbWtBUjBBTkJzQUxVOUdaNzRLS0VHRU5ScTBBWEpsSWlaUUExTHdyRzdnUXFaV2FJSUdMditBTEVyQUtUSndBU1J3RmUxR1ZOdGFMZlJEVSs4RUdtSTBCVEtnYXI0bWFxMWFLdFUyRUxud0QwWlFMaTlRQmhvd0FMQVNnM2Qyci9CeUxaazRIRmZqQXpwUUJpL2dLOEF5YW9sR1BUVTBhZ2NyTHIwbUE5VnFyODlTQU5vcXNRNXpSQUp4SEh3d0E2ZndCVm1BQ0ViQjRHdG5ZR2hSbEN3SkN3Vk00RU54OFRneHlMTHhjek56TVFJNThFUytGa1ZUdEFYaUlnVTlvQUhxc20wcFM3UkVsQlZUaXdReU1MQytOaTdrY2daUk83VmU5N0JXNjBHOElaeGlaRWFWWWlxUklDN2tJZ1ZYd0FLRG9TaVZoWmhsS3k4djRvYVFjejhkRUFTR05oRGtZa1VHTWh3eXhSZzdlcmN2QTZIdWtScjQwZ0ZuOUxHbWNnVWRRRWFxb1h3WStDNkl5emQwOWdDUEdhUmE1V0xjNVhmSGh5My9zTEtaR3orcGtTSzk5UThua2grc3F5S25DMUQxNFMvMm9oTUJBUUFoK1FRRkJ3RC9BQ3dKQUw4QXZBQlRBRUFJL3dBRC9Qc0hnT0MvQUFVSkloeDRrS0hEaHhBalNweElzYUxGaXhnemF0ekljV0RDaEI0UGdneko4S1BCaVFJTEZJQ3c0Y0dHbGc5Y1BsaFpZQU1FbFFVQ0RHQVlBR0ZQQUQ5TExoVFlzYWpSbzBpTEZpUjY4cUhQaUUvL0RSQUlvQURCQWg2dzNsdzVvRURYZ2psN0N1eDVrQ3pSaERzZGp1UTVrS2xEb2dHc0pwMUx0KzVFb0NPcHVuMDdVR1ZYRHdyK1dRVUFvYXJobkVBYk5od3JzbW5CcWdNZ3hJUVJZVVhsRkJGWVJJajVZTUhOcldIN3NoVzhWOEEvMDZZRG1MYkx1alhicXY4Zy9Kdkp1ZmFDenJNWmNvWkFBSFFBQ0hGemhrVjhzellMRmhwSWtOQ0FoTVFJRWxPZVQyR29JWUx1elo0aDNOeWdjbTlieFEwSm5QK1dYVmFBNmdMbUQ1bzNmY0MxZTRzSWQwWldtUlVyemM5K1pSZGZ5VjNsN2VWVGxLREJDRWlNWUdBUC80eHd4UWc5Tk5oZ0VEOEVJY00vQ1BiQVI0TTFJR2lnRGd6MThNRUlHa3lCeEhUVDhURENkTSt4Z01JREVjREF3Z294YmZWUGU0S1ZGOXVNcDlINDNvNnV4YlhBYmYrZzhBOXl6bjFnNG9jZlJLZmNpekVxOE1Cc0VVU0F3b3M0MUZBRGhGRElFTWVFL3dUaFpZUlhHcGhnRUFQMTRJY09CZjd6Z1hJcm9MQ0FZT0tOUllCcVJCMGdnRnc4NXFsblNUVmFKZGR2Y1FXYUUzQTVUUVVCQzFOOFlPVVBNa0RoYUJsbFFOSEZKZ05KK2c4VWtWNmFLUlJTZENIRkdmK2NrWU1NUGJEZ1pBSHRBVGZubnF5MnlocFZWblgvTldRTk03aVJ4QmVJRUJIcVAxSkFRZW1rWitoS0JCaEVuQ0VERWhvb29OSkFONG5uNnJQUTdtalZBd3Awc0lTa20raTZoVU5sREtRQWViMmgybHUwNUpZN2wyd1BrRGNRQmtGcU1KQjE3R0swMEdNa21XUVF2UkRoRlJWRDhna0dRRm9KeVpXWXVRUy9SeFZmK1lMMzBHUGVNZVdWWDh1NjFONEJHeHp3SkVzWTQxVG9XRDV4clBEQ2ZLNVY4TWdZaVN6U1dQcmUrOTFpZU1WcTFrSENwU1RXVkdJZHBiSEZrcVViWTdvSDRDa1JZM1NtUnpLMEFDUTBsTDZHNlJlYlZSamZPSUI4NnI0VjZHSWNEMVVBWlA5Z0VGT1VVYWFnUVFyL2FEQ2xsTmlsdTZ4c1ArRTVjRmtRcFhhYWF1cWR0OXJRcnRGVUd3d3JyS0NpaXBSWi83YkNBaXIrblc3Rk9CMGtZd0djWmFiQjRnVWlnWVFPWityZ0lJVUdqc0NRY3NsbHh2Vm1zOTMyWTJjV0wvMlpkazk2bHROQmNiWTNKMm9CMkNtZTZuUzM1cGRnZnVKM1UyeFBzc2pDY2tnNG1DR1pYQ0pJb1lNWEJsR0REQkwrZzN3T0Vqclk0RDgvL0NPNW1OUlRicm1CVTVCd1hHZnBNa1Fvb0hpMnpwTjRVY2RPOUVreHg2VXdZM0pOSlZWZm5VWGdYSVk5TkpycFFGNDI2bVg5VzJicGY2UmxrRUh3UHZBQklmMURQSGVha1hmTXgwQ09zQUY4M3dsQWJ6WXdBQXhZNTBCU2VNRUxpUENDTTBqaFVrR0FBcGtzRmFwaW5jRUlMMUJDRjF3Z0dKc0lwbGtOaktHcklMQVRCV0JBQXozNDFEOWVNQkFpK0RBWFd5Q0NFZi8rMFFXSHlHWmlCWENXREplb0ovMndaQ0F1K1VjSmd0Q0RHMGhCVnpud0FRWXc4QkxCek9RbWJPQ1RZeFJ5cjRPRkxDTW1ZNklhTjNJV2d5eEVJUitabDFyMGdoZUVDZVpwa2VsS1YyYUhHS2E4c1NGTFNlTWF6U1hITWFyc0pDWlptMU0wdGdDWTNDWW1iN3BOVFdhQ0U3TjBER2w0eWVSUUdrT1NRZTdJakU0WkRVZ0U2Uk9rb2V4OWNkblBCand3dUszUWNHTTZxZHJLUUZrdmppelFrM2JKQ3htUFpzZU8rV1FxN3R2WXc0VFR4N0tReFdhbThaTXlhVmNqZWVHeUl3UGJGMHFlUWkrZ1hDMG82cU5KV2FhU1NURmFKR0FxU2RjakxiTUFLVDNBVGJjekdkRE1BeGZGM1BLWkZCSFp3UkJ5emJSSVJVWlo4WUI4WWxYL2tLbjh5WjJMT1JuSW5vWTRyYkdJYTlWUlVXVVdzQ0xPRUlBQXAvTWpUL0MwbW9wS1VBQVZYUms4SzlLeXZueW1OeGlMeWRLV0pab2FIYUFucXpJTHpRQnBGVlkrQUFQSGVaRUdXQUNpRUpFZ2JOb2Iyd05XTUJ1UjRxbFFUZEhvUUZKRFZJWllaU3hGOVJrOEY5S1Y0a2dHSnBEOHh5TWYrUUFZY005c0R5UE0xRklTR2FnZUowUUR3a0dCY0ZBNUhWd1BCOGtaMG5HbWRGV1gzRVJIQnp6bUFYbGpsZDVBZEZVRE9XbEo0U1lBQXZSMWJyanNwMDRnOEMyYjZJeHB0VWxzSzIzU245N2NKak42VTl4eVNyQWhCam52ZUYwYUhnRjdZS0FQMVFBSEh4ckJoMEF3QWhCTWdRY2c0SUZxbFVPQ05rRnlNakc2RVk2VTZMYUovN0ZIQUhiYUtFL2tBNVovMFhBZ2U1eUpUVlRDa3R0c0FBVVJTTTRJek5vZ0JsRW9zOGlEd3BVWU1pRlM1ZUJTeUd2UWhIUmdWdVplYjNHTG0wS2lSUHVCZ1R5bk9sRmlRVXcyTUtQVHZjV3Z0cDNSWDNXTGxBZldCQUlNYmRNS0JsUUR5ZW1nQnYvZ0E1bW8yTndwSkdkM3lERlFEWDZ3WUQ1TUNBbzlnSEFPb3BlREh2eEFRNVhMY0lJczE1emsvTzFIQndoWFR3YWxQb0hjRmowaHBxOWRQTUFzcmd6QUExQXRaMks3ODVkWTFhNGxBK3JCbFppWEEvL2xqNG9FQnJDRkVYUmgvRkdJZ0dyNkd3SlA0OWVoOGlhTUt0NFJ6UVNWRXUrVlJUaHNTd2xMWWdJZHlja2dCem5JRkFBeHhhdnJqc3AvWVliQ3BicWc1bitVWWY5VU5makFDcmp6a1BKRmVXaFFqaG1oWXZNU2w3Q2dBNzBUb0tUSzhLa3plT3BTamdvQ0FBZFN4Q0tHU2dwU2NJRU1SaENCbHF4TXFYZGVZNU85b2hOOWJuRUVaWENEc0VMbEtVZXBHUXBFeUZhMkJySXQ1V2xnSnN4cWI2Wm4vV0k4UGlCUk1wakJGM3k0SzJDdE9oZi93Q0lTck1PUTF5Vngxc2graUZYWXBRQWZCRUVJRHRsQ0VCa2loU3V3Z0YxSDFDYW1rNjFpRjZJck1JSHBRYmRBNVJBcCtHRXpLMkhJQVhqRGJXN3ZSRHVXN21sbXlQcURDK2hBQXgxd2tsSHQzTzUrZSs5SlNYbWp2UVFwVkg4anU0MGc4NmJSQ0s2V2hCbUV0d1lubWNsR1FuRk95bk1wWmR5dFRuREMyNktGQk9QNGlyaWVCSDVJZkkyU2pOLy9VU1JZUm9xVGpQR0hKc3VTSmNwS0tVMlJId1hoaVdFWXZlVDRSKzlndkN1L2NVa2oxMnRjdHlwUklXSlJaRHVGV2tlYm8xRW9Iay9rd2JvNUdqanFSVGlmWVN4bkxQMGs5dDVYWTJUUjF6SGJ5YkdRTTl6cGltRzRTZHppYzRuMGt6VHErbm9yaVZ0Snc0amxaVXMvWkZBaGtuZVJMNURnN3d3a05mdkNWZHAxVlFFYitCWk5mbk5Ob09EZG5jbnM1Tm5SanBKUTVpWG44L3BqdzF0Mm1LODhyRDQzS2Z1SUdjTlJ2VThFUFgxSnBublE4ODZxUnhra2NNRjgwOG00dHFjTS9wcFg0M2hLWWg0WHg1UCtqTldrQ0tvMFJ2ekNWU1Jvdjc4ek5mOUk4RHJTSENqQTNMaFVpQi9Rdm45Y1pXbGNTU005eHozdWUrYjQ2OGs3Lzl4TzArNUFDalFrZXVIbVlLNG1tcDE0SlRLQmlxVlJTVFBMQ0hyRVQvT0I1SXJhdExlR2dxWTc3cVVlQXVnUXFFRitCTmg2dUZSenRFZHpiYkY3NytjdDhrRlBoQUV6UmdOUU12TXZSWk43Z3BFVlZZVUNlak1sWThNQ0MyQlZ1N0Y0ZkhGVURGR0FvZlF4S3JZMklGZEtma0lXTlNFVmdmRVBxelIvOWdSY1ZFTTFTUmNTVGNVZnVwTVptcUVaWXFNWk1FQlZYL1JURTlVUUdXV0EzK0VzVU9pRTlPVWQ2aGNYYm1WWUJiQUFNK2dRUHRNZFdUWVc3ak12L2VRQk9mTUFYNFVjaXpNUTJ1TTNtM0V4STZVK2VpZCtQR0VlQ0lRZUdHVmlFa1FuTFJoTFlMRmxMZUZJdWNOblVWTVRMVGNXeENSNDl5RVpsTEU3aXdNZHkvL3hEemlnSFA5QUFpbUFBaVNRR1QxRmd2aUJncU94RnhKRWZrR0RVVFd5SGtzMmhVQ25IMFVIU1N5UUcrY2tWZHd6R3l3UkxvTVNjNDN4ZzF1ek93WVdJQUV5QWlWUUFtUkZWZ054WUlIVFZyZUJYMkZCSjBSQmlnY0VnSXFoSTAxSWh4NlRnTEJoSHpGaFVKVWhKVEN3SWtNWUpRc2dPQzRCY3lSR1BqVjBVRkVDWGtoQVZnVUNPUnhpWG1ZMUFwRjRZTWlsV0M0QlVUanpKaEJGT3lzQlVnU3diam5STTJPaFZ3SXhNUWpJUkdueEZ4dkFSVnNESkZCaWhtVHpPZXRsTytJelNSc1FKWmJvTll4RFdReGlXVlIwWVQzQUlSbDVQWk1ZaVRmbGdmK1FOeVFBQWl2QUppVGdBT2lVV0o3RGJoSEZoRVJCVVFUNFRKMUhXQVgvZ0FFNXFZTURzRjdwY2lveHdsZzBWQnhUb2ozTHNUZ1lPUUord0NCK3dGa1hnaUgxVXlFYWtpRGxwU1lmNENHZFpTQW1FaDBnUUFJOHdDWkRXRHFlYzFUSVdCYmxnMXZ6UlY5Rk13RFFGeCt4MUZSNmRFZGV3UkwzOFI4aGttSDA0endQMGdNUW9qdzljRjJrSWdNY3laRWJKanhxVWxPTDh3Y25FbHFXSTE0SnhTSlVSWmJBTVJZUUlEUm9tU000b21JU2VGUXJ3WGphWVZlQ29ZWGZLRldNZUNBNlJtQmxBbVJkZ2lCQXhwZktJeUZCTUNvOUVBZFJPUkR0bUdFZ3FTYUsyVms0WUdDYUFaa0xJQ2NBWlI1MmdwYnRnVnMyOTBCb2dCQnNnRGlJODBSdklsT21pU0FYMGlVLzhKUUdVaUNWbzJNQ2xEeGxNbUZVTkNIUi93TmdCa0ltYW5LZWpQa2NPZFVaSU1aNjFkY1RkcUlhbGRremdFVjViYUY5SXdnREplbFpBNkVvVnFKalZvSTlMNkplbkRHSnBuVWd5Qk1oMVBWZ1paSWdEc3BabkVVZ3ZNZ2NyZVdOdFFNMzQ3Y2U4NGxYOXNsM1Q5SXpnL01QVXFJaUt0bGFDelU0K3FRUzNORlZYRFlDR2NJb28xSXB5RE04UXNZSERmcGMvd0JnY1haYWsvaGhmdUkyT05JNmZkV2h4MmNRTWZjd2U2UXhvY2QrOHlFUVQ3Tmx0OFlneFJObXlUT2pVUms5RldLZU1TcHBwTktmY3ZZbW5IZ25DVVNrR2lHRE1CTkJNVWtRL3hJeVZuRmNLMEJXOWVNL1hRQkFrTklsWnhhYi93Qm0zYUptVXZCbTFaV2pKeklURDVWYmVVaW1OdU1SUGVGUEpTVVJOUCtFQVZOZ0pjZ1RtMkVXS1llMnAyeldZN0dwYUczR0VHMG1CZGVsQTNNbUc4ZUdIdnhtcUVnUktOOXpPdVN4RXpDMlU5RUJxV1hnYUpEV0tiemlFQ0VrcDBRRWJkUTJZVG9RQVlpbkVxWXhMcWFhSitDRHFxTHpoN3RqT1FLVUE1L1NRUzlRYXBIU1kyNzJENXR3QnRiNkQ3bGdyWDFhQXlUQVhoQmxuTVBxS25mM0c3SWxIeGpRQVJvZ0ExY1VMTVh5QXIwU1FtVENacnBTUWoya1BFakFYdTExZE9FYUxjMUpGWWxSUVFNaUE2QXlyNVZpYWdOeEJxZ0dLa1BFUVRLUUxQaDFRTEsycndSek5ZVkJVQTh3QXJubUJnd0JiT1FHQlFpYmFzRm1RajJBQkJpZ0xNTVhzUkk3TW9ieWZnTmdRenBRQmp6MEVOVUtFVkxRQXhxZXNFZmgwak9sbXJJVEN4ai9VQzFJd0NYc0Ntei9zQzFiNEs1SXNJcnR4VzdDeXJQbWswY0tBTFRxU2lsbnNHclV0Z1R2azQrODhVVk8rN1JQb2dDQWNVTTVoR3FVMG1vREVUMDlhUlVVQTZKdzFiVWpRNWV6SVJjVzRDN1g1V2hFVUFaSWtEVXpvWlBDQld0dVN6ZlA2VUo0c2dMOTVSQTlZQUpPNGtJUE1BRDQrcmZtb3pSeUFSTU1ZVG1hd1VVRDBiaU91MFRZQm5BSENYQWNFUkFBSWZrRUJRY0Evd0FzRGdDK0FMY0FWQUJBQ1A4QUFmd2JTTENnd1lNSUV5cGN5TENodzRjUUkwcWN5RERBUVlzRU1XSThLUEJmZ1g4RC9sa3NBS0JBeUFFUUNINEVhVEpBZ0FFQkFNUXNHTE9tVElvNGMrcmM2YkNqUlo4TE93NjBLWktnVEtFaUJXTHNXSUJrVTVremF4WVVpclNveG93cW0ycUYwSlRyeXBBOHc0b2RpOUNpVkpwSC84a2NVSkl0ektFRlluNDBHeUF1U1kxQTFSNTArcURBZzc4UkhrU0FFWUhGZ3hVUi92MWQ3RlhnVFpFZlB3cXdPSG1vQUlNYkw1UGR6Sm1seDRFUTZoNG9zQUZDNmRKZC8zbGQvZGJselFFZklXRDRTNWhGNGNJc05KQ1lvbUVLRHQrNi95RkdFU0V3WTQ4ZUNuajk3REd5U284Q1ZoYVlUQ0RBWlFLZktZdThMRUN6NXM3Zzk2Ny9OUm5TQThqekJaS2pOS2tjTnRlL0dGanNIa0ZpeElnUEkzVFkxOUdqeDcvK1Fmd1RZQTgxL1BQRGYvOFVxTU0vK1RHSTN6ODQyQmNoRHJxUnNJS0Z1NjJnb1lZb3JQRFhBbjRWY0FCMjNFSEFIWGYvWEhiQVB3Y0kwT0kvMklVblkxZ0QvSVZDaHhHUW9DTUpMR2k0VzQ4cnNJRENBMXdOc0FGc0EzVklRb0k5SERnUUZBY0c4WU9VL1EzMFFZRURqY0RnUC9xVm9NRS90aFVubndNTGJFREFkTmlsbWRKQUs1cTQ0b3h3ZHZiUlVZK1pCVmNBb2FXazNBSVgzc2VIREVIa0FJVVVoQkw2anhUL1FORkZEbVZBMFVNUS9nRTRaYU5sbEhGb3BRblM5OEFDQkVGUTNVcHhoaXJxVG5hVkJJRmc5OVZReGd3dkVER1FHeTkwLzlHRkZMTjJJY1EvWjV5QnF4QlNsUEVEQ1gwOVFFQktKbzVxN0xGeWtnYmZQMStXb1NzUlcyemg2a0JFeUtDQllRT0p5TlZveUhicnJVNGVFSW5CQnJNcGtOZy9VM3p3VHdmL0tJQkJjdzBCSmU5VVJZRWtFRnNpZ1FYU1RBTTVacFJhRzMwcmNLaEs5VXZ2dnorcDVhOWVRaUVaVWxPd1JRd0JUTEMxVmROWnJpV3NGMEkzWWRRVXZLQU9MSEpaL3dJODFGRWJuWldXd2YzZTFXL0dkcnFrYjhJZCtSdXpWZGlKdUFGcEcyemE4MThYRmZWZGlnZE5WdG5JM3NwMTcwdE11MVdRbm1CeE5iRzlKSmtjTUZJUis3WFliQjNFVjlnS3VxWHd6MjJLYlVva2FzcUpwSFRBMXFWSTJkdmZZUmNBaWRNTkZDUFNQTVUxRUVxcUxmOEFBWWlMYlhBQWtRczhNUGhvVXB0MFhvMnpQY0JDYmxPVVlCOFM5bFcrSDRNOVZGNFFmVHArR1FGaVFhSWc1SVlMTEFBRHA0VWZBTUhxQkJGd2dPQWZFU0M3QURFZTBQWkEzWFZIUUFJRDhZNDNUbEFsNVZSSlRNYzE4ZW9QL05QaEZPbU9VSU1PTmRRUVlJSDRUVTQ1RWxPTVFDQWZBbGJaUXc0eWZJK2dmcFg3VjlBVTZHcWdQZ202OVZqY1gxcWRPZUtMM1ZtSFlrRUkvTzV0U2NSRFlEUC9JZ21OMnV4U0Y0bzlJRDRhc0kvMHdBY0ZHVUFCQ3VBTFFvQUVaQ0JJOVFCS2dmS1BrMlFnb0I5NDhCODhRRUVCWkRmQzZaaHdhUHBMNFVQWVVCZURRQ3drN3FvUDVuSkFxMFB4cWd5TWFpQVVMTldGTW5UaEh6OEU0ZzMvZnpDQ0NKQ0dSV2hTb1JKbHBCemxLT0FCN2twZ0Q3cndBb0lvNFI5RVVJSVJ0dkFQSXdBeEIxT0lnQUpTTXByUjlHV0phSVNUZVpMWHM3RXBvQU5JNkE4VXBuV0dNdlNBQmYvWVFPcys4cVo2MGVTUGZvUUt5dnlZeGtKMnBtQWJZNW5COExJeGdWUXRNZzhMaVVEODU1S1lkR3dvSlNPa0laVTRyNklnQlpFTEE4dExQSksxdmhoSmF1NXBDY00wOWhPejNFUXBlVEZJVlRiWm1ZQmhFaXVlbkVwVUhxUElUSDRFU2VSeHlrd0VtUlNhOWZLUEthUGxxS3FDeUpmeHNwZ0ErT1JaaGdLVHRWeU1tUHk2WmRVYW1jaWJOVWNyT3dPUm51YlNTclVSYlNFb1ZHWkNVRGJOWkdiU21meXlXU1huR1pXNGdNVmZRTGxaWFhUMi80Q2VCV1pJRDREQmtEcDFKay9aVWlFSHZVemJEcXJPaFJCbGJ5MmtXTDRZbHEySEFSQW1kVkhLUm1iNXNBSmdRR3VBd2NCZ3ZwYVk0aENHTVNDcTVEUC9XTGZxSEExMzU0UVJSdTdXMElOa3JXTHM4VWppbXFnYTVtRHlKYTN4aUZ3R0VESDRDQVlEU08wQWJ0aTNwTWlOclRqR0lkSnF0RUt4dXJTUW9VV0R6blRtSnRQS0dPMTJEYlduOGR5am1vLzA1VzhRVUowNHU2S1ZqSkpTTmFYNVM0OGV4eHZlN0NaQ2x0TVNoZGdITmpBVlpqRkVPaXRCT0xVcDFRM3JUQit6QzVxcUF5T3RVc2M3dU90T2k5SzVSUDVKWjNYS0lSSktUck02VkthSFBlbnBtVWdMbzc0UlVBNEhsQ09mOXJRWHFZR1lMMHV3SmNpUzFNY3NIZit0WUNBcmNJQndicnNDR0NSdlV5d0tyb2pxMWpiSjRFNDdOSzNweVd5aWthb09UeldBZ1VHUFJvRFgvSHlnU1RXb0VwYTBoTG4vY0s4RzRXc1NsWUxBSC9zUWhMczRZTjlBNUpNYkhwRkFERHJxVVQ5TjA1UXpDU0FsQkREYWljNlozd1B3emtXK1V5NUNOOFllVDlsSVI5bHIwQWlXNER6VlVvZzNVTTNOUUJaVUlBNkdsMG9HSXBCL3pKczUySTVnQ3V5N2xnYmVsendSQWRkMUs4a1o3YlpqTzVlK1NNQTVZVU5zUGdPYllKM3F4bWl6S2t3VU56Rnk2U2FPa0FwVW9vSVFoKzdsb0FlQVFqS0NwbFNRR2pncGMvZFJsMGRreDFYTnpPMHlkWVB4V0Y0Q1FKdDFLaU54aWFoSm5sZzU4QWJCZ1FOWmxCUjJtQ2p3L1NQL2ZGTGk0QThhQ0Q0M1E0RWc1TFZRSG1NWHUySnBlWDhFRkNCb1drZ3N3Y2huUVRJb0E2SU1ncWhHVVZCQWdxS1VvdThNUkJmOHd3VXkrSUFSMmFTZFA2TlJLMjFWM0JOWk1JSWZ5RUFLTDlEVkdXYTFhRXN0ZXRVRVNiVVVaTUFISkp6eHNBSGdscWNiQ2hNUE9JeFpxbW9DRnIvZ3FsakJXbGRnS01pc05iQ0IwaEFFY2J1T05nVFlFSkozTWFzTVNjRGlQM0xoS21saDBWVkYzS3l1UnhqdGFNLzNaeDZLUUJ4OWVCQWl1TUVOU3pLTm50WlU3bDAvSUZ4L2VlSzRSQ3BsVS9jQUNldzZqVWZPV08rQ0YyVGY3VHFnVGpxcE1ZTTduR1AxK2lTOU5wcVV2Y0Z5Y1E5WDVrSFpka3VqcEt5cUZGT1ByMXVpTDQrdkxPUGYvMko0SWhOWmtzL01oV0xrbVZoeW1HT1N0TXh5dVJkSGVYaEFlYkJGRnFTYUxuT080ckxWbE9Uc0RDVzlacHJDS0o1TlhsSmM1empaT0NBWm1rMm1BVUNTZWpIUGUxalRucVk5eGpGVmQzcWRvbGtWckVLOVpLeGNPU0FkeWo4N2ZSTmk3S2txVkhZWkZZcFdCQ3NqT1R2Q2VrbVZqbDhObXV1RUN5eGRZMCtiWUJTZlR3L2ExRjJvRlplZm5lcmRkQ2JnQVhaeWd3MlN1UnE5NWpEVnZyQ3JzTFNKWmtRc1Y5Uit5L3RsZkNtN3ZJak5XZjZ2ZkFLKzZSeGhpSFJlOXplLy9JeFQ1OUdvSDAyL2RrOHZSUy9EREQ0ektVLzVxdFdNb2hvVjVqc1ZFaG11OUd3RFpiTFJiN1BTUkwzRk5DR1UvZk1yaVc5eXU2dmw1VmFOcVAvVmdSOFN0L2YrK0E4enpXSUs5N25pM05ac1JPS1czaEpmRUs4dXRQNzFUdGxSN2pJOHB3QjlsRTN6RS8xSFBCWFhkdzBUV3U4aEdJWUdKaXNnT3FMREdLQ1dNVGRIRUFwbEVGOVZML21WWlEyRmVTWnpkVnpXRXVZSFF4K0RVNTRYVGF3bkZBZ29XaEhBTlk4elY4d3lOaDhDUHpzRGR3ZGxYS1gzTnJmRVZkVkJJc2xsU01GM0VoWWpWR0FCS29rMWNLUkVGNGNIZk9pUkhGelJPSUVoVWdnRU9ScVFBbUVpSkl2eE91bFJNYUhoRW1BbVZBd1JIWFBqRWp1WUxVVVJNbUgxTUpCQmRKOHhMREN5SnM2UkVlWFVRbkRsQWFmeUZ4MVFoWSt6UGwvQ1BpQm1JWjlqTnF1REdzdmhkZ1NFWmVrVUhXQUlob3lWSnRhUll0Zi90MGx2Y1I1dVNGK0lBeUlFTUlQRDBsWmM2QmpwOFEvdlltaWZJMks1b1Q1ZlFpSFVOUUlsZ0FQL3dDTkJRbUovc1J3Zjh3OSt3eW5TNFZNbWxDSno4U25YWVRSRTR5Syt1Q0xabDBLV3BWUFlzVE02QlR2OUZDSTc0eFZ0OVJwNU5CdWhLQitrcUFGSWtFRFhzeVgvZ0FSSWtJMTdTRnUyQVZBUGdBS0tNUkNtVXpvclVEcUdnMWxiY1NZd1FtNWdsU0s3bUY5cDhvaHBWQkt4Q0ZkNUJGaWJvb3p6MVVRVEV3Qys5aGYrbENNSmRJclhNd0pYZ0pEL2tKQ1IwZ01Mb2prUWtsN3FoVWRqSXgvQzBTRWJBZ013UUk2eXFCaXE0eEZsRkdhaGtWL24xQ0lyTWxtdHMwa1pCWGNBQUl2K2t5OHZZVHhVUlI1eUJUWTZrbGY1LzJFZlBYQUYvVUVnQThFOUF4STlVRVkrc0xVYkNJWmdEa0FDZERBRkRwQmJKTkNVRFpnOGZxTWNJOElWTGdHTUtZa2RLUUZnLzhBQUFvQUFBaEJnaFNRWHhRTkxBMmhWVGJFcGhJRUN1bkVmT1BBQi9LRmhEdmtmSXpBOUd6WkIwdU1rRXphWEVKbVRxNGcrd3ZFbDhyRUNVOEJlSFNLUW5wSldUYUVkTHRKVHQzZ1orZU03K2ROUXhPT0JIUk44YXJFYTVraVlIeEFoMEtOaEI4SkI1a00rY2VROGt2SmtWSElnT2tBK3o2TWxXc0liQmFFK2RnVWtmNFUyV2pFWmpaaHI5M1ZmS2RJaXZJTWRrN2xyR3ZWS1ZZTWtpbkVoQlhrbFBwbGQxMlU1MDhnODBKTWczRk5CQjlLVEIyRTVCZ0ZpMHhoaGdRRnFKY1NPZGlOVGFmL1NtTDhZalBVV0cxckRLUmVTTHRuVEcvYVJQY3h6TFlZUkFUK1RJN3N4RUJVV0tWSlNuZjlSSUZEMmFGSTJFTHdobjFBRkdId0NqQ1lTRnp1NFlyYlRXTjJoZHdUQkJ0QlZhSURSZ0FLMUFLSlRPb2xqais3UlJqbWlQUVlpQTZJNUpWT2laUDN4QTlrbGx3bUNJQUw2WWZCcElTQUNJdzlLTzQzcFVwb0VvVEltUUxBaEYxMlJTbTMxZlZmM1NJQ1JQZjBCWGxEU1FBRnlaZ1BoUWVGallTSDZRWkR5SHlnYVBRaGhaU0tTYS9RSW9RVlJlT2NSazZQVUd2WUVrNS9oQVJzZ0g2ejFLRGtRQkR0RUtRVEJRYTZGWk9ielBRNEVLQkhVUVFYaUljWTRJajJvcFEzaE1TMW5pODRCRm14aEY4YzVCWklDUVpNMks0Y3lFRGovTktkUWNtUm5GZ2R1NnFpSklwcGhsSXl1STZOOXhLY1RZU2RNZ1NjcWdTZGRBUUdmVXgvWEphS0taaXUxUWlnUGRHZVFJcWtYSkVIL1lDbU5vcWhDWUNtWnNtZU5wV3VjeWhrcndWVlN3eVlENEM3c2dnTklSbW1LZGlpOXdpaVBGZ1MwbWlpTHFxcXorZy9xMGxiRHdsVzlHaDRTeWh5aXVrOEpSMXFRcG1wdW9LcU4rbWFLWWlpNDhpcVhGZ1NhVmxaWlpwN1pDaDdlYWtBUFFBSi9rZ09wOWc4dlVFVkJ0R2lJc21xNWdpdXpFajVoTkdPWElXangyaTB0bHh5RXdhaE5JR3hFOEFWWTFBVUFTN0c2WWtWbklBVTlvQUVLb0Vjc0locjNtTERkZ2dZaEFRRUtVQUJSTkt1d1VoQkVjQWF1NGlwR1FBUzVvSzlsTUFJZnRyVVNhNUtwSW9zM0tHc2U2eklDTXZDeTJzWkZXK0JGdUlJb0VXQWt5cEdKdkxxemVITXFUOVFCSTVBRFhYQkZNanNRM2daRXpCSXNmYk1uVHZzN3NVRWtGZWtEUFdBcEY4dXlYU0FEVXdBL0JZQTZiZnUxU05OUEFsazJncUVCVnlBb1Y3c0ZXZUJ1TXNBQ2VpUTRpbkdKY0tzL0hpVzIwQmdCL2hFb094UUVKcUFBVDNRU0ExRmlnNHMzL2RRdW5rZ3Vub2d1WFBJQlg5S3haR29hSGlCams2dEMvWVJ3ZXBROFFWSTI0emk2eW9Sd09oRVFBQ0g1QkFVSEFQOEFMQ1FBd0FDaEFGSUFRQWovQUFNQUVCamduOEdEQ0JNcVhNaXdvY09IRUNOS25FaXhZc09DQUFvTUtMaHg0MEFBSHdtRy9GZlFZTWwvQXcxK1JIalNwTVdYTUdQS25FbFJJRW1VTFE4R0tNbXpRSUFDQmlFYzJGQ2d3QU1DRC80OTJQQmc2WU1GR3hibXpFbXpxbFdIQlFaMkROQXhLOG10R1FjQURla1R3RCtQWHMwT2dDRDJBUVlGR0poMmFOb2hRZ1FXR2lMOFkvRXZ3Z01XYmpkNEtEQlliRmF2Qlg4ZUJHcFFRRWtCTjFsR0xnQ1pBTldybU1YK0xKb3g0MW1nUlVPYnhjaDF3RDhQVFZtc1lFRkN3eFFOR2tiRUhqRUNDVzNidEdIcjFrMUNkWVFWd0ZtZ2dQRnZnVklVVGZzYWY1cDBNWVIvQndnWXRQeVBNdU4vQWlnVGdQeFB1dmVEM0RISC95VG9FU1BPanYrZVEyZ0tuTVNVS1NOMHhOZnhiMFFOSGZkcjZCOHhCY2xzSlBUWjkwOFBQZFR3VHcwOWpGQWZiZi9nb09BL1NCZ0VId2trR01UQ1hSaTQ1VmRUQlVCUWxHTUJnQmpBQVNQZVJHSkNCL3lUZ0FBSElDQkFlT0xGeUZBQUVHVEVWV0paQmVEQlR3TVZSWkpQb0Qxd2wydTBCZEdEREZEOEUwUU9RUVFoZzVJL3lIQkZEd2NhWktCQkJBWmhJSUlKQmpFZ2d2OU1zVUpqMjAwblhYU1Z5YWhtakRzQmVWMTFLVUlRVlhPdzJSWmxHVG44SThVL1NVS1JRNUovUGduRmsvK1VvZWVoVWlScUtCOVRHSmNpQVFjSUlOMmFsRlpxa1ZvYUdhUUFDeVBJVUFZUmJpQmlFQkdrS2tHRUV2K2dtZ3VxWjJncXA0Y1FuUDlwNmF5MHdtUlVjZ3M4QU1OZlB2UUFSYXRFR0xURkZrUWdVc1lJR1I2MHdRSE4xZXJzc3hFeDFWU0d5ZEowNHdDZEVWYVNhUjZoUk5KS05rRXI3cmd2L1NTU1NDWU5kQmxPa1ZFRlduWFZnZWFqandneDlpYTUrRTUwcnJjS3BhUVRTWW1sWkc4QlVDMlZhd1FMWFBqYlh2K3NzT0VDb2Uwa2NXTVVZL2RRZUk3Qm1DOUZHV25FbFVaam5iV1lRWXlaNVlGWklXVTdtSnk2TmhWQkJ6Q3owQUVMTkxQZ3cxNnRhYUFhelhZMTlVQm9BMkQ3WTBFZUhqQ3ZkeG96NUZNQWxtSE1kSGVTSnIweHlmRnVkTmpIV0h1N0ZsMURrb0FFRHJZQm1LQjhJeVQ0enhVSGVYbVFnZkV4K0hVSkdyUzJHczF6QXpmY0FzUEJrT3V1RDBEL0lGU3NQZ0ZzV1lqZEZSNHBpWk5hUEYwQ1UxLzZYRlBMcVJiM2E3MlJzSUxsRGsrN2dWNWpVbmdnbFFjYVNPVVBCUDRBSnVpZmYvQUJRcTI5SEFGVFN0M0ZOMThRU3hmMWRwQytHS2xsaURlTzJZM1pIa2IxYzUrdGRaZDdaZmZBeDZCUWxGR0dGTTVEajJjT1RQYVFBNEVEWWorZzJnWXQ2ZVNYS3pSSHZBQVFwT243K1FxeFFSTHhpajJnUUFRZklDaEREaSswK3NJL0wzUmgwSjU3ZHJFblF2NjduZ2FpMHAwQ0hDQlc2RXRnVlFZQWx3RmdBQU1tdUVBWjNDQ3NmeEJyQ3djNVF4bUNBSmkrRVFDQkNneWhURjdGRkF6NHBRTU5pZytDUnVBREN5Z0ZLTS9Cd0QvVU42T3pjS1U2SUVGUFpPQWx3aDZLQnloaUFZQnAvNFI0SStDSkpFY1BRUmU2ZkNqQ25JRGtpUUxCRnJwU3NoTi90UVJjTHBHS1FzeUZFTE13OFh4YUVRZ1NDWUtUMFpoeGgrNktWM28rU0JRZlBXY0RjdW9RRDgxeUw2bDlrVllyS2FPM0FuY1QwdHhFWG5Ga3lnWVc0QmU3K0NWelZFdk1UdnJZa25XQjU0NFBNUTI4RHVORm9DakdJS2E1Vmg5TFZoMXVWZWNuYk9sYkFUS2tsN3RFQUFXZTAwdFMvQUpIa09WSVlseE1DRS9BRXlMS0ZDUThpYkhqeGpieXljN0FhNUdZb2xvUUUvT3RKUjVtWlNYRXdGeVV1WmU2NU9WQ2ZObkxhZ3FwZ0tWMHFDaThsTmhvMm9RZHloUnVsbjBFVCtJVzQ1anpnY3hHMklSaGFPamxzYTNZQkliclNjMWQ1clliM2J3bVRCV0tHODE2cy8raHB2Z05Wa1ZoMWdNeWg3QUZQTWRvSitHSlloemprK3lJc3pJSmtBNERDa2NBeG8wTFpaeTVabzJBNXFhT2NjVURBM0NMVy9EU21pbkFyVDl0QXgzbzZET2dDUFVnUWdpSm13YitNZE5UL2dNRlk4SXBUdjhCZytFMGhUaEpJVTUxbm1PdUUyWHNsaWt5U0lxQWtsVHNDSUJ4NDZ4VlNhZ1l4b0JkQzQ0K2cyWkphUk1nS3ZWQUIxNXRtdzRBcEtBSEZZaEtvZ3ViZnpTQWhOYmtUS2E5V2MxTldaQXd2alhsQUxWajJvaDJ3anVLVWsycE1HSWNBaExvcnoyS1pUQXVZODBIYUtPZ3hUSTJONi81VFFRcXhGVURhZWtnWHYxQkVBTDBJQ3gxMWlBajRDZk1JaENYTm5vSWh2QWlnSFZ1TXM1SjJlNEFFWVhrUWpva0xaLy9yUWNDS3dPb1lZU0l5UTI4anpXMG9WS1RyaWVESXhHb3VHaXRUNEs0aEJBRnVhYys4Qm1CZzNpd2d0cHBKMnJSa1cxRnpMV2pqV0RFSjd5c1Z5ZWJRZ0xHMXNCSVNFSlNHWnJYdkJ4czhFa0U4bXFCbEdTUUgveWp1RUd3ci9XcTlBOFFORXUxQk9EZDA3UmJMZ2dvSnFNbzhZcThHTE9VeVU2aFFFOTYwbnJYNjk3L3JiZTRoS3B2OXdaRjMwSU5pbnZoTXc1MFdPUklBdit3Uko4TW5JZWtGUUg3SUNrSFVqaERxeEMxSitmdFQwOUM2TUlaOUpjb0dlZ2dMM0FFTUlzVVorS05TVWNqelptQ0RtVGdodnQ5QVNIQjByR09nNVdxRzd0QUlSL01jcEZGZUUwUHdFVUJZYXJCQkpQd2p5OFF3UWovSU1JRmlkQXFLQ0JCLzRiL0NIS3M0TGpsTDdJQmRySGpWQS8rSnl3MVk1QUlaWkRCQjFod3pROGFzTTVNRkdTdURpS2ttVDVKeWtvS2dnYmVvZ0FJUU94bnpVSzBEekc5Z2JqNDVTQTg0S2UwakJJUmo2VGsxT0hTdEtxN21CVmZmaXRIUXVPWFRmYTFhaVoyWnRZMnd0Wm9lSmxIeWZTcnhMVjJWcmRFMHEwdyt0S01peXdqYVFxN2twUUZ1MUplUkVsSXlsTkZQWTZrMldUTTRoSzcrR3g4YVJONGV1UzJTcWF5US9IK2xZZWZoQmNOdS8yN2NYdnhYT3FLZHJyK3BSQjd4Y3RvMFRrdHZYUlMySXF4ZTRIejdyVkorUGd2ZTRmRzBGQjVIRktXUXBTMXlCc28zSWw0aUFpbnkzOG5STjc4bHVXOUN2S3VkZjRNWWt6SlZWSkdicENrOElncUd2K0RqTW90THNucjNQQmY2eXJKbTVvNnlRTEFjWkErSzZRaGV4Ym5WeTBObGhZam5PS1NOdkZ5SS9ya0NqNkp2RGtPcjlFa3VPbHNLUXFtWGZZWHlXb0FsUkhnVzFDS1lxNWsreG9oR2FQMzErOUlrS3lFOTBZazY1Z2t5eFB0aEo1RlpRV29kS2VGSkNRTTBDd0YwY3g2eTViaUliRU1FZVlKV1RsMXJnT1ppYSs4aCtDOWlXZVlia21FU0RJeDJDTDR5RURtQVVHNkpVUEx2QXNMVXFDemh1MmxuM3puNkU2RUJpU0tGUjdzdEZ3NWpKaFdjYW1HMXlRNzBnclhEK0toZyt6NnU4dnVFV0xqT2EwSHpLVXVNSnNaYkF4Q0FrUDZqQ21FdVNaSXNCWWFsM0JSOVJaVCtTMjlhUjNIMkU1RitVTERqWFlrTWxCT0p6Mmd1YjMvTmozcElaLzlCWm8xMDVuT2JEWjhtckptL1J1Q283NDFZNUJjaVp6T1BMUWR4YVZ2R2UvVWttb3ZFbjJ0VnlsZVVUeEVNMVEwa21BR1pra1NZeldJSlNUN2hCY3lCUnNvQlNFS1VnTC9VRjRHSVZNMGd3TEZFVDVKSVdKS01WQ1FNMUNPQWppcFZSM2treDJzQng3dmtuTFk5eDNQd2lNSkpocmdkU055OUJ4WHd4SFNJam52QVJ1MUVZU1BKUi8xVVlSRktGMXVCUnVzSVJ3T1l4REUwVk42d3h6Rm9SUUdaVFQxZ2liZUJCbFplQkxROTMwR1lWR3pja1U0QkRRL0lSYTExM2Vnd1VBUUNJU3hVUUs0TVNESkF5QitRQjllOVE5RVNEWUc4VGIzUkRjTkkxZXJNUndlR0lYVnBSVEVzd0ZJRXlzQjZGQVlFMzNwVVRqKy8wWXJpWmN0WHFRV1pYZ2RRRkZiK3pRYmpBVldBeklnOGdFNm5kVURYakk2b01oU09HQlNVMEFodmFFQkt3QWJyUWdjd0xFQXUxSmQ5bGVGUGhFck94RjI1YlJJS25jaTJ6RlJ0ek9BNHZGNDE2WnRhOEY3Q2NNQ3FTaGRJL0FCUGZBQitFR0V5bldFZG9oWmZQQWw4MVZXWkZNQ3J3RlhyVUZURmJJenhtZCswZUVqUHdFaUlBSXd0cFFka0FGYkFzQUFFZWR0WkdSc1gxRWRIdkE0ZjNFNTd4RS9ZcVVEMEVnMmk2V0tNMVVDOFFFNkNBSW0yVk0yakFWYW44VWZPQkNPUFpNaFBsTVVSTkVkQVJZZENuVWlJekprQXVBaXNGVW1nNFUrTjhRdEJRRlNJOWd3cmxFaDhIR0tvYVdLWW5JaDV4Y213V1VReFlXUVBXQmZCLzhSSHd0aUpmeEZmSFpSRjB0QmFUREVGSExpS05peEhYcUZPeW5Da1hWR2Fpd0dpeHRTU0JNSk1peXpPWHdCSHdxUko2SklpbXVqSDh0bE5zUlhVKzVuT2F4eE9TaXdBQXRBSFdWU0dTc0ljVFJuWWpyaUl5dmpkK3VrR1luWFR2OVFUUkVnQm94MWt3TkNQVXNpQTBFUUIwZVNQVHg1V2ZXeFFqdFpWbHN5QWg2WU9MZ2pOZXRXWnpSSUd0bEVUSWxoWUZ6Uk4zL2hHdkVsaW54Q1BlNFZLSjBZWHdlWlhKOURJRFdnV2FUREI4cHpKU21ZTzkwVVZhdUdkdWl4U0pZRUpPWnlHQml3QXZDUklGbWlYdTRGQlZLUUpGS1FBK2wxazlwalg2ZEpPZ2FSSkh5aVdRYnhPb3loV3ROeEwreUdUb3UwU0FhMkdMdTVIcitoakdYL1V3UEQrVHcxQmoyRjBqMmswd09FNlpjRG9sbE1raWMwaVNVL1Zod0JaaDFBUVpzV1YyNkJjNHNKU0R4eEFqc3pWWTFVNGlubW1TUkNZQ2hhQ1FYbkJRVk44Zy9JQ1oySFVpaFhkbzBrVUR1TmNXajdPUjRld2gxRE9Vb0VoQVJpdGovNjg1ekZtU2Q1Z2lSOFVpais4dzlDb0NkU0lBTXlFRnJOWVRTOXVLRXlVUkRxNHlaREJTOFJNQVg2TVQ5OGRnWlM0RC9TWTJQRjJRVXZtaWhTNEFJeVVBTXJvQUJBOFFCSlJSbHZpYU5WMFhqVk1WRGxaU0QzOHdJdkFDcGhhaEJLV3FiL01HTm44QUlKK2dPeXNRSExvaDBEaHFWcmNoMGg5UUF6NVFJejRBWkpZR2I0UXlwaCtnS293bVpnY0tZME9RSjZZWWdncEo5eUtoNXN3cEI4YkpHWExjWUhlL0prZkJvc1NwQUxCOEZtWi9BRFNLQUFCTlFkc1FKQ2l5cHNqMHBUSXlBRmJvQXFCb0ZtRnZRUHVSQXNrdllXaTNGQW95b3V0ZGRwR1BCZ012QS9WR1pCd1VJRVhUQ2pVeEJuUmlPQ3Rmb3N0Y2NZTDZNQmV6WXFDVUVxWmNBSGdCRVVKWGVzdFhKekNJRXcvOUFCR3JDclowQXFyNXBteCtJWGNnSWRCR090enNLWkkxZENCckU2bUxVRUtKU1hVWWNRazRtdWxuSXJJNWNjQTVWQ2hqb1hvZmN6OWtvdWZDZFMwMmtoZmdGbnhCT3c1ek4zTXhFUUFDSDVCQVVIQVA4QUxDRUF3QUNrQUZJQVFBai9BUDhCR1BpdklNR0NDQk1xWE1pd29jT0hFQ05LbkVpeG9zV0VBQlFHeVBodkk0Q05BZzBHRUxpeDVNZUZIREdPWFBsdkFNU1JGMlBLbkVtelprZURDRlBxekFseVlZR2ZIZ3BBRUxyaHdJTUYveDVzK0JjaHFkTi9FSVlXQ0RBQXBrSUJFYkhhM01xVllWVUFCY0IrckJxZ1FFR3pZWE1pZExseHdNOEhRZ3RnZ0xBQnc0TzdMQ0pFNk5BQlEwRU1MUDVwYUZydzdzK3ZKa3Qyck9yMjMxU3pBa1ppRFJCNW9kWi9seVZUdnR5MXMwcVhiRjBhVER1UWFnQUlUdS91emN0Q3d4UWNJMkwvazQwRTRZaUN0M0ZNbWZLUHhEOFd3Rm1zUVBFYkJ2RVZLeEltRHh6aEFkUUZCUTQ4TGtCZ0pBRUJxTFZHeG9xMVFHWE00TGw3L3g3dk1pUG9zbENEb2s3NkFFWmcyN0JoazBCQ1FrUDlLU1NtZk1DdndYYVBFZi9wY0Z1QXQ5MzJEeEpUSUtHZ0JneHFNSUpydjkzMXdBQVV1dlZUWEFkRUJjRUJSYUVGVlVHVTNRVEJaUUpjSjhBQjQ2VW9FVmdCZUJUV1FHR1oxYUpaRUF6d2dIQU9PZ2hnRDBIMENJVU1VQVFod3o4Ly90TkRIRDhFSVNBU0krQWc0SCt6eFNZZ2dEVVkyY00vTmZUd1FVRU9GSFFkQWY5Y2h5SUIxSEdtNHBtZVBYYWFZMldoMTlLSEdFVFFHZ2tqMUpCRFFsSVVCTVUvVXV3SlJSbEVsZ0ZGRndVUktrUVpaYmp3endVay9BUUJtSTRkWUNhYWxGWktrVkFKYmZDQWd6S1VrUVFSWC95RHlEOUdFUEhQR2JtWStvK3FlNzRablZBRXJQOW42YXkweWxUQUJrVTVGUUdETW5SeHhqKzVKRVFFRVh4MDRKaVhjTldxN0xJVFFZQkJYVnlkZEpOQko0MzAwYlVtSVFUU1NkSjJ4QzJ6NElZclVXTFlsbHNSV2dKZ2locGFFQ2hsMUxISG1qV3RWZUxXMnhWSDE0S283N0ZzQUxWQkFVbzkwSlJlZ2JHQVFtQUhOd1hYVkMyMnlCQk1FSU0zYlVHVDJtdFRBR2lVWmE2OGJrTEFVa2xWRFVXWHBnLzBGUUZnd0RFWVhNRUphWURqQ2l4SUNJRUhGTDVJVWtZQmVIQ2FVUXNzZ0NLSTNzbjdFbWJlUVh3ZHhSSmJuRkJWM3Q1czJtSTVGK0FCWGFvQlY1OXJKVWc1Z2c3L0NMaEVRVi9meG1UWFN4UW9vQTY4OGZCYWZmVWwvQTl5dkpHUUhIdDNMWEJYVWtJMWpKMWttSVgvU0Jsa0I2ejBuYXlZbmFqMFRBTkVGWmNIRHd4VjgyRWlyNmRYZnZIcGNHVkJWMTZPVUJBOS9CZWJiQi9VWUdCQmNnLzhqMTgzb2lBM3pNTVY5TE9IbUlGNW9nQVZINzZWWWxXbDliVEdVcE1NWEd3MS9DREQ4UC9rVU1hZFplUjVadzdEQi9HRGtWMXpYZEFWUFZoK3BaOUJXQ2s2VS8rQ0NidnQ0RHNFazR4VC9lTUJRaks0a0VPZVg1ajZRaGZ2bjlHRkZMLyswNFVROWY4anhEOHVES25BUDdraWdIUStGTDRDMWtRb0ExQ0FTeFRRQVEwRTRWZEUyRUlFQzdLRlZSR2hEQ05JZ1VLR1lzQU96bVFwY0ZGS1VrN1dtNFFnd1ZoTHdadklVcWlXa1BTa05QT3FsclNza2hJUDJwQWlHYWtoUzdpMWtueVZKaVV0cWlGRC83QkZrb25kOElZZWlaZ1BlMUxFZk9IRWFTRnBDSTNPSWk4UEZZQXRSd3dmVERoQ0w1RmNLaTZvUVkxMDdJYVVveXdGTFQ4SnlVY2NacFhhWlJGTlhkUldFUk1TUjdOa0JGTUEwNVZ6SWdBRGhEaUhLYzRaQ2hzcndoMldkTVNOYjBSSVdKNTJFNVk4NW80NzhXSkxwT1lvQ3QzRkxzMXBEZ3M2RUxPQ3JDQUNjNXZRSXRjWXhDMCtzWkdXb2VOVmtIWkVibzN5SnVhQnlRQUFRQ0dyYkFTTmRISFdBekRRZ1YwS2JKT2IvQWRmaEVtd0ZMQkdMNGE1b21sK09DT09qT2hWc3VzSWVycFl1ODBja2pJaDBxSzBjS2FSODVVeUxFT1Jqb1FJSmljV1RNRStEZW9QNmY0Uk45L1VoM1V3a0JETjFIT3NNSkx4UFFwVFNxd2c1ZitoYVNha01wR3BEbFlJa0FEYUZmUWZDU2hjdlQ2R0dLWnRDeXpuMjBDN0pOU2ExbWdnYTB6NlhHeVlwSVBhUUdrMlhOdG9iSFJEQWhJQXA1eWdKR043M3ZZMkdOaE5RMUdCemxESTFLYnRhQ1l6aHdTUElTRTFPM0dWQzJTM1pKRjY3bkl3dGswaE5uVENUVzFxbzZPeGJXbWoveWlCZ0tJMGdnOVVWVFk0c0U5ditxTk93VXloTmMyUlVBaWxNaFVURlk2RDFBbEE0SW9tVGV2OFUzWS9VNXBZcHBJN3Q5Q3lSaEQ0SDBKU0FBTCs2T1ZrQXJQTEFwQ3pBdnZvSUhTZFMyem5zSVNRSG1SSmVyY0pxVUx3bzVlZ0tNQURKQ09xaE96MkFPblFGQ2FvRVJ5S1NKUkk4YmxGWTZZQjZyWWNNMUZRb2pNMi8rbUJESVFFaFIvL0pLa0h0bldlWTdHMHRhN041cmZTbTBJSmpsb2czR2dFVWdnNUdrSjZXbHFJVEFVc2ltd1QweDVUSXhqa1p6NTFvbTBPdGxzUTQwSGhUdjhZa2d3U3U0UWwrS0dqc2dIUTU2NWdKTTZGOTBxaTR3RlNZQktyZE1HcnVUT2hxOGFreWFaWmdsWXBJR1NLQnBoVUplTVZMd2RCK0c0Ty92U1BJQ0E0ZXcxdXNKQVNJcWdoL1lNUEF1TEJDam9MelpFSURiK1dLb3ZIbHNaYW9VM2hlVko0d1JueXBEOUNFWXJGZlpyZi9BcHlodjJWNFQ4c1VBQUh3UlNyZjhRVnhCYkRqbU1vcEFBTTNHWUdidmpIQzBJMXJETVFBWUxBVXNLcXBHeUVNNXpCQlNQQWxWbWtjNEFlQS9tSWlTTXlDM3JBQnhra3VTREJBaFpDbnZ5UEt3UUcvd1BSQ1djZXY1eEZSMG1VWkIzd0FYZ1JVc0VKRG10SXlYb1VCK21jUmRUOGNZVC9TRUdCK3dTRlBmVUFDZi9EZ0kzb1FnQVdFanFMU3JGTHlRckR6citjWlNoc2lNZ1d1d1VTSmw3NjFObFNqTFd5eFVPZW5EcUxINXZYelhEQ3hYd3BSbHM1N0lsaXV2VnFaWlY2MXQ1YXJkTzRpYTlWTjJUVlJOUlhISHM5SGhuMmtGcmJZcUs1Vk0zcllxK3hmQ3V4Q21nZ0lFUm1kK2FuUXVRaVJuQzliSi9FeXpIcWN0UlBEaUFhRDN0YlhLWldaVUxZbGNZOFFtQUJ1QXFZUk0xWElUVzZTWTd2OWd3UVNXMXJSYUtiT2h5OGQxSTBGWUVOY05ZcDZ4TElHbEVKc2NtZ011QXp5YlVRSTNhV2ppZU9LSGNUbU4yYXcybEZZbnZac2YrV055THBMTzRXdWx3akYvOUh2eW9VNW9rZUpRSUxhRXBlbk9QU3UzbXNZU2pmbHh3TGFmRlRnM3VMMWdMUlNhYUx5aXZLcUYwdHFSSEFuSE1qcHZ4RzU3MkpBQW9heHpDZzUwNGlaaXEzME44SVhTZVdwSHlMRVlzTFAyS1dvUHhrQTVoTmlxYWJZNWU4OUJHWXUvcmtYZWh5MnErUTVOWlRqUGgzWkEzemZSVmRpMFYwcUVqS0p5TVFJVVlnN0xvenJqQmdGd3pBUUpQa0JBNG5TV2N3cHNUVDZZbHBHTnVoTWhMVVFFcHdySlQzTlV2azRZRW1yVjV0RDZwSjBxSkswekNObGlJdUFHYzFmZmtPeUlsZ3dQeU5ZRmhneklJQXg1Y2VVTUFWY1c4YWNGN29ROTQ3Vm5YWVpOT0gxYjV2Q0dHQVhDRWZ5eUdmcHQ3TnY2UC9veHJueTh0YmJVN3BaSkJnQktQKzN0amRsNUt1R1hRN0xyUStGZ1E2UHlzTDdiSTViL0ZnMDIvSkZTWUNhQzlVUVd2UFJVV0xOQ05Va1VzU2dqSXNjRFc3TVFMRHhTUUowaVQvQUJzWHlGVXU0ekl4SXlGOXRGSkk4US8zNUVjOUF4WGVrMjFoVkJiVHR4MlRVVWhlSW9BOGhoQS90aXhpa1JoUXczYm9nU2xpbFJmb1JGeGJBeUJJd0RXWG96bExoUVFEaGg4bHBRRXc4MWYvUUJ4YTF4NkVrUm9GSVJVUzVTRWpGZ0RUaDAwQUZTS3VCeVlvRWxjOXRYSXFRa1RrY25ib01SUWVLQ2RLT0dDd05RSlhNQUpmSXoyNGNUbGlNeHRsazFFWHlEYjJRWHhNS0h4dnd4c0wwSUVhMGxtS1Uzb3RZbFA2aDRVSXNSNW1VUjJCL3hNN1dERmFOTGhJVUJOczh4ZDVEL0JKNlBjNUgzQWxIZlZiWVJNOXM1RlJPakJWV3BOZVc4VWdNQU1jTVBOVlN4Z3o4ZFF1c3FodWg0aDlGSU5OT1NWR2poRVpYeGdta1JnK05FSlhIL0pMcWxNZnNmRUJsSE5VRG9JREI4S010M0UxVlBVa1Z1VTVJY1VrSldDRUExWWY3T2RWVitkTEMrTVdRU0ZpWkVJZEhMTVFaOWdSUnhOWE0yZ3YxMktGVUpFNG1zSVVNTk1iUElCVVYyTWZLYUFCcXFOaGhYVlUwTE5iV1ZJbEJSRlNaMk5DQjRJUVNBaEl6MUpKSWtOK0I3QUFHeEpHMFRWaWdPTmpxU2VHNEJKVU1ESVdRZkVzY3JLRVl2VUFDakFoZC9aTEswQmNqcVVsanZVOG1aTTV6OU0xSDNVNVcvSUJXNElmeE5FQmV2OGxWbnlFQXBmSFdkQXhmY3ZsaTJIa2lKaXhqb24wY1ZMQklqL1JKazUzR0FEMEFDbXdBdm1Ca2xiU09ibkZrdi93QTd0VkVETkprMVdsSlZ0bFVsNTFWSDh3QWtmRkF5OW9KdXM0SWhaSmFEbDBMUVF4Y1V6cEdIalJqMHpDSkZicFlBbVdZQ3lKVzBHUUpWRlNOanN5VlYxVFhBalJpVFQ1QVdoNUxPbFNJb2JqaFRKaWxDRFdGbzZ4a1UrakptanhBUGxobHJEVk9UTEFQSDhDS1A5UUJwODVXMXFwbFNQQVViMWxPVm1pVVhVaVc0eWxKVHpnQUJ2QU55VVNKcFNCSW9UVGExOUJHdmRsY0ZNbkhLMVJKNldaWU5zMUpNZVRuQVptSktYWW5EcHdCYzJwWGxmQ09UMVFXL0MxSHlpQUZHUXlnRWFFY1VyWEVVSmpGcUwvZ1RPZ3dYQW4yWW1PSlNUTVl6eUlJZ1dLd2p5Q29wVXdpVG5PNHlON0NWNUM0bGhUUUhMUlFRRDE5V0hlS1VWRHhpYnd3bmgwc1hERTVCcGJZNVhEMDU1OTBsMTNBaVJBTXBvTUppaWltU2g4c0Nna29FK3VnNXNCU2hOdVlsOXY0aFlEUURLN1FtWTU0Q3NxVmhCU0lBUlM4S0tJOGlmek15ajBZejk1VWdZL01BSU5GeDJSUWpRWSthRVNRVDRPSXpJbHVnSWowQ2xTNEFabjhBSkU4QUtuSWo5OEVxV244cVF0MmdYcTB6VWtrRUp5NXA4QUNxUmNFV281S0JvR2NnRUlJV1hEb21UdzR5dFd0aW9JWVdVdldpWEtCNWxrZ2x4ZVdpbDJOUUFzTUFKOG9DaE9LaXFxWWlwUHhtWUo4UUtBZ2dISzl5aXZVcWUxSW1LZ3dwRkFlVllEbnRLbnBMSXFxRUlFYWRaZ1Q5QUJObklzWEthbzRtSWpBdk1iT2lBRGtscEJGR1FxWnhBa0hZQlptUEtibnJvc0E1QjhTZEVCRnFBQlBmQXJFcFFRZlVZRWRuQWJjUEVvRDBDbnI2b3NEa2QrQXBOblFWQ2piRnBCRllRSVplQURlQk9BdzZvc2dZUnZJcGhKQlFFb2hQSXJ2eUlGUWFBQnozSnZSREd0eTNLZzhuSm9Ec0kxMy9VUDBGb1FjS2RYVTlpbDVEb3JzcEpDVFpFZk9rQUNHdlNVQUZNQThEcXY0Q0pSQVFOQXlsRVFDaE9QQUFzK2QyRnBNaEVRQUNINUJBVUhBUDhBTEFrQXZnQzhBRlFBUUFqL0FQLzlDeUN3b01HRENCTXFYTWl3b2NPSEVDTktuRWd4SWtFQUFqRVNMS2pSWUlDT0d3Y2VCQkJ5NU1lQkpBMm1GSGp5bjhhVkZXUEtuRWx6WXNtT0xqMXlSTmtTSWN5TUxGTVMvRWlVSjhhTUp6OFd3QWlnd0FBSUQvNUZmVUMxNm9ZSEhhNyt1em9nWjRDdkpYV0dyVW0yck5tTVN3TU1JRXJ5Nk1DMUI5UENYVnJBWmRNQkJTQVUyUHZnd0lNRlZSOWc2QkNCUllSL0d2NGRGaXlWcXRNQUJZaldMUm15YnVTOW1QL1ZMU2hncU1pTm5qK2ZIVTFhNVVtbUFBQU1TSDMzbjRlbkJhZ3VpSUNDQlFrTnVITlBRYUpoU2dtRHRnV1NJSUZZUTRvVkVaSS9PT3phc29lNkVLUUtQQUJZcjk2OWtFbHVIanJaTXNzQW5jRVgvK2hNUUFCNUFRTFJpeXpOM2lGYmdwc2Y1MTF3ZFlGQUZpazAzQjVSVUwrRzVJYXhzSUoreFAzRG53NEdHc2diZ1NSTVVaQ0RIMHd4d29RaklER2hnNGcxcGhkc1JRVndBQUgvRUZBQUFTS0NlRmw1blJrRTRqOENIQkRpUWVxMUorTlpIbVMzbVdhYTdhVVhWWWF0UUFLRk5mVFFRdzR5L0pOREVEMUE4Y00vTWdnWlpBOFVUb2pEY0I5VStjOEhWOWFBUTI0a1lQbmdsQ3NzUU1BQk1aWkhRQUFnSGpEWm1ETzI2V1pUYWtFRzMxdVFiVGJBQUZRVlJod0wrazFSZ3d0RmxsR0dGSU9Xa2NNL1VNaVE2RDlCRkZta1FVR1VBVVVRUk1wUUF3a1JMRkNBbWlWNkdLT2JvSVk2R21RQzFiVkJDbjdLVU1ZTVFyeFFFQkZHRVA5QlJDNUVnR0dFUUdEOEE0WVNYZlNRV0ZkMWZZaWpxTVFXS3lNYlYwR2cxVCtEK1NIRlA3RUtSTVFXMC82RHlEOGRZUENQWGdkczRLS3g0SVpyVm5SUlhaV1ZnTUp0RU1GVkcwREZrRnZyQVVYWmVwN0JKRlJiS0prVTFGZmk5bXZzVFN3Vk5KUm5IYm9IYjBLZ3ZYUmFVajk1QjkySTEwV0hJN2xiN2VYdnhSRGhwSkpKYmIySEwwOENoM3lSU0UzaFdCZEdtYkhCUm16L0tLQ3R0bmsyOXNBRzdUNEZGcjhRZlJvYWVwOWkvRzlia1IyY2IxZHhLbldYV2hBb0VGdWVEeGhXbUFaODRwYkNQMU1IV0ZoaEtDZ21zMU5PYVZieVFQRnRTd0FFWTVQSWFVaGp4YXVpUUdmMjdETjdRM1VNZG81NEtVdFZiU2dNUndJT1VZNy93RGNPLy93R09IOFRYbWxRaFluaHRvS0FoZ1VXMkQrMXJmQVBjU1NzSVBrREZrZDJNM2hveC9pVkFPTUpBT0tuQnhDVTRwbHZrNmFXWmh0QmdOYy9yenZsdXV0M3JsYjdVMVQ5TThVSEkvQU9aUTlZMXZDUERzTC84RU1Qd2d2VWc0RTlJR2hnQ2JpUklLRGxDOEFRbUx1V055aGdCQ3Vnc01EM200YnVJWXRrSGxUZVA5K21IdTVYY0s2MUZyelFYZldBbnpYdzBVT1RpajZhZjZKRUJuSDg4VHJnRFJJc05DSGhmUUJLQlVGZ0RYNVFneHBNcUhJR2lNcjVOdldWeUtqdmdtU1JrMXFhb3BvQ1BNY0RreE9lcTE1d2huKzhvQXRuUU9FL3VpQ0ZMaFFFQ2tSZ29ReUY4QTlBaldBRHNhbExpM2FJd1I2R3lqcDdVWUJBL3hUUWdRNk1RQVp1VUVKQmFGV1FMYXdRQ2o1b21WNE1JakVmV2pGVU15dlhRU0l3QXVHVjRSOVN1SUZBbHBBdEJTaExVNW9LMlZFMGxwT2RlRVZrQWJ1aUhOc0VzSGlCUm0wWEdRdGJqTEt3Zlcza1l5NjU0eHg5Q0MrQXpVdVFEK25KU3c1U0ZMbWx4QzJQSEJhcHZEUEZyZzJTam0xazQxRkc5a2FFOUtRb0N4RUt5RURwazhtVXJDNndVWk5mNU1ldXFXaHhJSngwNHlWTFUwZU81WkdOakJSbGgrVG1TYS9CYmluYmtrcTNNSmU3NVdpdFhLN2pHbGpVcGhPRTZJeVpzNVNJMERwR3paYWdEWnAvaE0rY1NwVVhIUlVUQXhnUVRGUmc1cmpyMU9obU9XTWtaOUl6bEJTeHhHM1JsRWhYTUxLV09PRXJOVGxKeVdvRWd2K1hBclJMZmxGaHdRTnFVNWdPOE9rd3hna1FCZ1JhVHJ5UWhIMXhJMGpzd29jK0VhbkpkTnVKbzBiVDlxSjROa1E3UUZzakIxbXpsS2VZTkRZUW1BMzNVaEMxM09SR0lMZzV5RzJRZzdVSVJLVlVzRmtMQkpCbUhXOUJURWNzMFJ5cEdFS1FNMzJ1TStnUmowaFc1RkdmZklRMTd5bklqbEtxMHNXdFlBb2FRQUlPZHNPZmZ3Qk9BeVc0elJSd0FMaXlUaWw2LzhDUFFDSmdQY3gxRXlwUXNVOWJwNUxEeXdSZ3B3UFpLY0hXS1RIVGlTNk9hQklORzVwS0dhSkZwblo1K2N2ZEJEU2NFa2pvYjBnb2dWYVJrQ0cvRlc1d0NKcFFDZnlHVmVsVnJuTC9HRkJ0N2pNRkJ4RnVPR0hTakY0MjV5SVhNWFZZb0Fzc2kySlVPaGIvRWFTMjBJd25XN2pXVFpUK1U0akpDVzV3dzBrVkJRUW1PVCthMEFFTGNxQUVkVEZCQm9HU0R2Z1QyYlhhOUFGMXk4dER0N1dBbENwV3NkMFYwYzQ4QlI3WFRpZEVMV3FxVE83VXdUdkJicWhkaTQ0L202WTNDZWxBU0QxWTB2MlNwRHovTGE5NS9QbHFsM2pBQXhBVUdMVW9zTnhhQ2VPanlTSG1PQ0VxajNoRTF5TExnRzViU1ZXdldSYTJTN29zalhFa0lGNFAvSGNrSlVGaFNJZGlFcEtPMXp3ZFROZWxHaGpCZEwyRW9Da1ppSGRSbWtMbHduUys4NGt1T2k0Q0hUdzFiQllPQm0wOTNzRkxuaUp3bXdMOUkzbEdrZ0dScG93b0dTRHB2LzlZMHYrVTk0L2xNU3JGVGRMZEZNS2tLYVl1YzhoRU5oWkljZlE2akZpSC81OEM2UUR6Vk5WQ0dwWlFDbmlHZ2tDa29PY3VRSUhQZk42elFHUWdQVytoajJ4b1NtK2FCOG1HMXRnMU5ncUl3QVZtOElJa0VLRWdLQ1RDR1RSdFp5R2M0UXcwRkFpb0RZV0VEU2h0Uko1Qjg2SXZhY0U2dldZQUN0REFuOHJnaGhkODRkTFEwaFd1WjdWblAwUkFpR29pMnhSWFRXeUVZRzRESHBoS0IzcFFoaEl5cEFjczJBcTNXRmJzYWd2RWJ0SXBTQWQ4TUlJeXVFcFcvNmdXSXNvQXpnY1F3TkRwcy9hcVp3YVZwYldNS2lrZ3dmSitrSmlDbUJ1SU4xVzN2aHNqbGF1RVUxc1ZLZVRHL3JqdmdpK2tqdGVrMXh2eHRUQ0ZHZnlTbk5Sa2JoUEdzRDRpeFNOdWllckR4U1h3bmN6TGpvQlV5Q01qdWhKU0Ntd2xJZi9mT0MwM1prZkE2a1JvSERINWU0aVNzSmlQM0N2YUFkWkdCcXR5aWtSY2JUaTVlVzZkZXZLWi84U3BtOVNPMXpBelNjMklDRE9ZR1N6UGV5NUxvSytuNDBpL1pTajNKVXFOeGp5UU9ZSjYvUEt5RlZabWtWM0E3QXJWRWQ1TGorT2NaQld2cGtKMm1VZVJmYzNEMjlyQVZySzQ5K0lLUkZ2c0ZVM0lOczcyTldKejVQYUtLaTVEQTNld0I0MVV3SEpOc3Z4TmxYRGF0REY2NTVwRFRUNzM5TERJNjhYbWFFL3lOWHFNUnhSa1NKR2JaeXh6eWcxNXdMZ1kyRUE0RFZKTVpETWRuUTNoV2NCQzRzNTkxeXNzSGlNbDhQTjFjNGZCN3BmV0tlNERqR3RjZTFlK01hZSs2eklkOGt4MWJrVFZSQWFKd3FxWmNNRmJNNURZMlF2L1hrQUlBYnU1OHZsYVl5dlRIQ1A5ZXZZeUxEZnlwRHQ3cGg3c3B6bitkSUVUU2Q2M1I2YkFwNS9pSjNuSHRSeFhFd0ZRVXhqM3NSd3djRjNZZFNkN1JDcjhZbGV3b1JtYzhsZTlwMDZEVnhDdnBXRWVReGN1a1JZY0pDZno1SGdBc0NGNVlWeC9RUnNGYUlCUEUyMXBWUkJYczRCVlVUditCekx6OUREL1lCOWlRaVptNW5JSkJ4cEk1WGtiR0UwbkFTeEg5eEh1WTA4ZmFCbktja1lQZ0J5R1lSeTU0UU5VcUFFK2NCaFlDSVUwUlJ1NW95TnFWeEJyRVJrN2dqN2wwbHAyQlNmZUp4cElCUjZsTWhBWlpuK0R4RXZ2aFJUdW94bFBZVVliQUJoUUtDQXc1aHRpOVlJdTZHUW9jRFVDOFFEVzh4cXNwem5YdGkzeWRSMXAveUdHUWdWTHNCUWVCaUZrYmhnd2EwZ1FVK2RSRmxSUFIzWWEvZFNFZndFRFZuVWJNUVk5cDlVYmllRlkwSU5WVTdKVmxCTnRWNU52T2xLTExqSVZnS0ZhVU1jZEVHaFhzalVaU1pXSlNEVWU1NU51UkRoS2JUZ3hzS0ZZaFRFZ3VhRlpPRUJaa3JWVkk3QWJmT05WWGlJbE1hVTR5a0VWN1RaVnN5RVFsdE05M1BRd0FxQlhkclNHNjJFaTExYytuamNkY0doRkJGTXlkUklkM3JVQXBTZ2hGTUkzbEhWYWxuV05DREpkempNQ3Z3RlcwY000M21OVHlaR0QwZFprdTROYU1OQ0dlWUZYQStNNVFoWi82SU0rRkdZZWFhSWVRemhIeXpRVWM2R0xlYmRZRFJJbGdPTlZuUlU5WWJVZlhaUlp5K00zU0VBQ005a2JEWEtUT3Y4Mk9Yd2lWb0JUSUNnUUZjK1JJeG9CRnNNV1RPSDNlV2ZDZ3p6RGcrU2phSVNGZWhaa0hjbkhHRnJqSU1QUk9BcTVITXZCQWlpUUdMN1RWY05EWFlRakVNdEZPQlZDT0pTVlZvVFJBY3ZuaUVNcGxmWllmbzVoTVJtWmxFZzFPaHJwanRXbU9lVVhIeUNrQUI0Z2U0RmhYSGZpRkI4RUFlSEVBaUF3SVZDU1BBN0VQRjNtWmN2ekpDT0FaZjlRa3dlSUFsQVJGUk5aS25rQ0F5eFFQWWI0UFF1Z0p1amhXcWVaYUREU1d1cjJHTURTRlVSekhTV0lOSGl4RnMvUkZGVGhJeEpTSmNSVEE4R1RaY3NUQndmaFpSTXlYWWh4a3lBQUFuUmdPUkZaRmYrd2dHbmxJK01ZV3QvVGtkRnhKcWhUSGgvQ2c2aERkUVV4V0RXU1QzVC93VWxUeVQyMjBUdkk0ei81WXlSQm9EeEM4bVREd3p0aDVUYzgwRlVmb0RleFdHOEdJaUdVUXdLbHlTSnBvb0VVbENiUThaRlVKNGZ2NDRIbGg0L1pzenZJWTJWTk1pbEd3aWhDRWdjOVlLRUNNVjBFR1QwRjBrWDhnU1VrQUQxcEtUd1VFbG9Pc0lQQlVsRmpBem9FR284UDF4RmRSeGRQMFJpRmtTcjljeVE0aWlRNGFtVkh3bUk5c0NDNEVZM08xVHRnK1dUSWd6d0dRZ0lPc0FJd2NENFJwbkRqNDUySk5CbHhrblpETlVUYzB5V00yV1g2UlNSUmRpaEJrQ2o0MVFOTDRDUkNVcGxuYXB3SXNpVCs5VUNWVTJZandoSTdWVVZTT2hGR3hoUVdCRXhxVVlzWThEUUcwa0JkVmdORlFpbDZCZ1dHOGtXSlltVmJKaEFTLzVvb2ppcGxUUUk4YjlwUjQ1R0JkVG9UY05JZGVVVVEwWUZZekNLWUJqZ0Z5Nk1xZzRKbi95QW9lU1lRWDlTZWlvSW9mT1pDZ3ZJUE8zQ2ZNeE1mMm5tcGJ2SXdlTkYwZDRVamgwRWNNdkFzQlVGQ0xpUVFMdlJuZmNaQ0FpRUV3am9EbHRKdklESTJUbWVNdURvamJDQW44ZEZQWFhGQWxFWUViaUJxcm9KQ0x0UkNVaEJxb25ZR2VJWm5NdkFCUWtSRkZGaXQvUUlTZDhJQ2dqb0QvL0FGYm9CclNxUUVtblpwdGZLdjBxSUVaMUFHME5ZVkcxQWl3Z2F2R05PcmVXRTdDc0FDUi9TdDl5b1F0M0lybHdZR3VCWnVaeUFESllCZElWSVgwcnFKQ2lzdWc5VmJtSU1Cc0dZQ0ZSS3NSUEFGMFJKdVJyQUZUblJwSitZREtLdzdIV1ZqSHlON1FTNmlGeDZBQVM3VEFSckFiSzVDTFU1a0VFVHdMQnFnTGROR05qdHJSWnJTTGx0QkdEcndSZFh5RDFsZ3RJUFdNb1c0TFp2eXRCaUVMT3cyTS8xUnRabVdDd0pCTGVIV0JYS1dGMUtMa1dEck14TGpqYmtqRUNPUUF5aTBhYzdXQlRrd0JXeEpkamdVdHhqMEFOZ21lOUxCWkVod1AxQndCUWZCYnQwa3VENkViZThtZXh2UWtINnprSGtuWC9rR3VWZWtMYzFIdG1sMWVkbkd1ZkgwTWxzeEV3RUJBQ0g1QkFVSEFQOEFMQWtBdmdDOEFGUUFRQWovQVAvOUF5Q3dvTUdEQ0JNcVhNaXdvY09IRUNOS25FZ3hJc0VBQ1RFS0pEaXdZMEdPQVRnV0RHa1FBRW1GSmswT3hKanlvMGFNQlFJVXFFaXpwczJiTkVYKzA0aVM1Y2lMT25mcUpCajBvbENZL3dvb0xRQ2hnQUlJR3dwZ21KbTA2a3ltQlFZb05SbWc2ODZQREFYZ0hFdTJiTWFVSWRPaUpZclFLMHlOQlRaQWVMRGh3WU1JZHZGR2lMQWlBZ2tVTEFDditQZUFoZDBIVFFjRVVFd1NvMk9FQUs3S25CeEFRT1d2WW5lSzNmeVBzK2ZPWmtPTHpsaDFNVXltQytheVlMRWloUVlOSkVob21GTGk0T3QvdDBlVWtQMlBSQVFVdncvYjlmQlVhMlNaVFFuOE8vRGczd29ZQzU2blhtRFFyZWZMbkF0a3B0bzFNNEVFWWhNSS94U2ZlYlQ1aGltM05vWHdyNm1IRFFNd0tNQ3c0Vi9kdkhTRjF5MlFsOFNVRHpnVTlNRUlIeFEwUWcwNklGaEREeC8wOE04SS81VHdXZ29kc0JDQlZsZ2RvSlNHa3duVTFBRUhMQUJkYWhBYzBKUkFNZTFFZ0dVQ1FNQmlBQ3V1ZUVCbk01NW40MmdFS1JaVWV3dEVONFVPUGZRUVJBMUI5QUNGa1A4Z1dlUS9WK2d3d3BNbGpJQURnUUxoTU9VSUNmWUE0WllqVFBGUEJCMW9BR0Z2c3JGR3dJcVcxU2lBaG11bVdabDJOOFlwWjFlSy9UTkFVcEV0eGQ2ZVRBMEFGUVlkZE9DRERqTElVRVlaVWlRcVVCbi9TQUZGR1ZEa0VHa09sSlpSYVE3L1RKcUREQUpkTU1VQ0JSQlFRSTFzdWlqbnFhaU9OcU55U1RsRmdnd3V6UDhnUlJlSm52SEZQMFFZOGM4Vy94aEJCQkZnNUtKRXJtZEljWUVHRzFCSFFBQVFCRkJqcXRCR2V4NVQ5YlZYclFJS21CREVDNzBTOFU4dXVMN1F4UlIyRmRRVVZkS21xKzVZOVRWSFdGMkU5ZVlsQm5iSmhhNUNQS0cwa1VzZEFRVlpXdit1QkFCSE82NXJzSndGRzVVU1d3dzdwTkpKUCszYmtrQWh6WFJuaXUwcGRlWS95djVEd0FFRVVFY2RlMGwxWlhLK0I2ZE1rVXBvSGJRV3dBS0RKVEZZVnkyWEZGMVEzUWR2dmZFSzlBQ0dKNnNrODBMb29semRWeXFyck5iU0Q2OVVNMVFMM0xVWEN5bFFUWFZ2R2tUQVF0WVdkaDJCYy84QVo1aGRXRzNnd1ZFWFBkYXF4eW5HRkZObFBHWDIyZHlWc1NqQVRIZVhsN1JvUktYL2RUR1BjeTNBMXdwVDRDRG1rLzhVaUlPWEpJemduK0ZUT1A1UGdBRksrSnFGWUs2bTlUOFdhdEQ1MXJBOUdYbHNLNkFRdFluT2VsV1FaT3hScFpSTUhyOEoybGNIMUkyUjNYdWJCOEFBdk8vT1VWYkFhL1YzVmhuZnRZSi9BMzZnd3o4MTFNRDhENXpLMElQMEFqbm9wT095QWZkQTFOeVB5RDNIMFltbzF3b3N3TUJYYzRNdHQ2TE5ZaDJRWm5scjBwajd1aUtacEpqcmRpb2dkVitnUCtra2tVVDZRWkdDRUlSL0ZGQUdCQlJJRFo0VXBDVDlZM21JK3djU0hxUWw1aVhPTjFFNzAyVTY0eUx0M0d0K0lLUUpHMUIwdjUzTXhDNHNHSUVMdnNDdGdyemdER2Y0Und4bjhBOGh6RW9JTXBUQ0dXWndoaTRJUVZZeXVNQmcveDR3cXBtdzUyTWhUT0twVXJjNk85RUhkRDBvd3d1OFpZUXRiQ0ZYdjNwQkdaRHdzd2NvaHdEc29ZNFN4NWlxUFZYcmhQK2dGd3NJSlFXQlhPRWZmaEFJZmZoREFMbUF4V2hJc3dnWjk1aXFoSDJGWlI1aHl4MEw1aEdYN1l0aVFnTUxJZm1ZTkR5VzVKQXI2WmNqUytLVFNnNHRrWDk4REV4T3RKU3FLRWRERUZET0NCa1pKNk8wNVpIb2FVejlKa21TdnJrU2JTWkVrVkxpRlpYbUZBQlUvSW5MdWJMQ3RJMzR4SlNrSk10TENwbVFSTEpza3I1a1dDdno1WmlsekZLWEc3QWpZbktKTTUvMTZXMWQ0VXI5RnFJM2lpR2ttOEY4Q013T29wYXp4TXlWSVJuWVFHcW1GQWlBcWk3YzZ4RjFqSGUrSVFyRVhzektKaklYd3Y5S2ltMW1nNTNaWnpqUm8waW1kU1ZGTXJtS2NQU2lOYTJ4QURlNENRelhmQllCR05qRm9rblJVY1c4TWhQWW1iQlpIRlJPWlZ3RU43RjBCelJ6UTJsbnRCTzNnVUxrWlR2Ulo4bVdNNWU3U0pScXI4bHBReHZLdWRXUUwzdDd3Y3YyRUVQRXBqek1iUi9hVUtzYzA1MlltQlEwMkZIcGRaUmpHVmJCaWFyZ2NTbHB2SmtXUFVVTkJTaFl3ZkZtZ3dNa1JHNXhqblBjRkdhakFUTGhJRFk4aUkwR1V0QlFDeDJHWG5HSjVqOFVjSjhIaUpWd0h3QUJEMEN3QWdla1prYXJrdXBCQkZCVnRWbG1zUjVqckdKZGVxZXFaRFNVMUpSYVF5K1hVOCt0cG11Z2pVMUJJQmlnTHNrR05sNzZRT1FHOUNRZWRJa0hhMjByWFhFR3hvUC9tbFE1MnNFc2JsdEZsYnRwcG4xZldSWmpieWUvMldtVm1JNnhIKytXeXpzUE1IY0F6bjJ1VmpEd2p5bEVEa0k2YU5DQ21wZWc3ZlpnUVQ5b1lBa3NWelc4UUtCRTV3Vmw2eEo2WGhHVlRxek5pVnJQT1BqUHh5NUhBT3R6bjgxWWRWeUthREl5QUQ0a2h1elN1QkY4OTd0QkVLQUFEZWlnQmw3aFNTT0FEV3hRa0RXK2tBQUVWaEt0dkFoRWdnNElCQVVrS0JDWndqYWpsK3cyVktBcHNmdWUxVitjbUNZeU0vVlRYR0RRdU9iWitBZmhUVktRQnRqZ0lEVllJQWJtRW9NWXRLQUhZUzFySkhpUWlNTVdBWkMxNkxIT1dsT1VXZVdzRnArblRnZTVVMlcxN0FIK2JPK3ZVM0F0aEtBUWhFMDlLZ2VRZ3RRL29DZWs4QzdKLzBFSXFRRUNNZFdsd0N6QXlTdGRVU2hoWkdXbDJTbWZkZElJUWVpVGw4aE5EMUZkZ0tFUGNaaXBHaW9xVVlteVlhUGFLQkFYL0lNSFg5dUFoamJOeEQ3ejBUVE50Tk1ERkdEa01qVGhCUzlRd2hTNUZjTXV5RkFnTVh5MVFKVFFLQm5vZ0M0TEFPT3lPdWpwRmlQbGJ3cUl3QlJrZ3dRWnVPRWZYMGkydHdvQ0xsLzlvd3MvUUJaL2toSktrdlg2MnVacXp3RG1NeDhNK0tBSFoxajJRYnJRZ3c3UTVTRFd4bmF2M2NXZWF0VUZBeEd3QUJKeTRHcGNYUkVSTDVDQnVlTkNUWFZqV3k1eWNWZGRJa0F2TVgyM0JOVGxLMVNhOHg3cSt2dmhCc2xQWGZUbnJvbnNVeWZEaExqR2gvWklsdmlFbU5VQkpyODJ6a2VSajBSbUJQK2pKQ1l6Q1JTVTlUSm1KSmZXeFNIcHNuSGlhK1hKaEdSTEFNYnptSi9Iang0UHBOQVpzclJpb3J6b0dlZU9MSGxMbFZINi9LVjVQSnJPZlFueW15K0VZRFp2SXV4T0pLcWVnWkhhb1pwMmN6UWE5YWVYSFRKUzUrZk9qVmwwa0w5U2FCaTUyQ3l0MVI2TzJTZU1kWWNLTCszSGxZNUFiT05BOStZaXg2bEtnL3BMNVRCSHBOS2ZXUitvNkoxUFJZVlA3OTcybFo1L2MrUDVXbVRFRURseWNycTlrQXFEWFVMNWZkbXI1SEk5dGV5VGNmU1o4WVNBVTIzcVJtWmorSVh6bkxka1lsbTJ5Z0hhWlJYNzJDY3VoQ2xYUWVBamw1TmxzK3I0T3JzL05mNTNRQm9lWWtXSjVFWnFCckpvNXJLdnBxdEtjKzVpa0tlOExtaC9EOHYvUGptai9GNkhYMTlURjRsUGxqS2pCZFFsV1hhSlduTUFRLysrOUdYNzAzVGJZbUNKa0dmVzNXMitOVXVYc1VFdTUwM01wM0xRVjNsZllURk13VEh3ZEJoVHN4ZEpaalVUK0RYL1lEN2w4ak1Ec0RzRjBCS1ZWVEt3NHpZY1Vqc3dZaGt3NGhqZzlCQXAyR2ZKOVh3TGFEL0IxeU40NFRVNDFWWko1aHRkMHh6bUl4QkNSVGE4aERZZWhUK1laVEl2WW9MR1JSSExZaEFyeUVnd0pUQW4wVkVkbUNKUVV4aUFFUUd2Y1ZwVkl4QVBaWVYxMVJ1c3dUa2NVeS9PdElFbXhCVjZraFF6OGpaT2RUc25HRkFRc1lZQ3dTSXE4Zy9pZ1cwdmt5ZlVFalY4SVZHZGxWTUdzUnFlZ3h1eHdSdFRjeGVIa1JqR0VSTXdoaFhXUmtTZy93S0NYbkUzQUhWS2VWUlNTaWdRWDRSZlMxaHk1MFJDZVdnWFlpVmhyeUVsMWZWV2N1VTRFcFpraFpOa0dzQS9RWVdCOVBJenUrTW50UFJsWWpXSUpGQTZHYlFxdnFVMnZrZ3hjQk03dVBORm5VR014NVVqNndSamZrSUFRd1VEdHlnYm83TTQwc2c0R2dBNU4vZ2tpMk01YytWUWRvVVg4b0VCMUdXSWUzRTh5UE1mSk9BQUs5QWpJQkk3eXlJWklpVlNHTk9MSGlRUUt3WWEvR1dNV2tVVXIxTThoTEVBWVFVYmd6ZzV1RGlJQUhtRC9rR0tVaUlsY3VVMXVXaVFBQW1RVHhLUTVKTkJTekVadFpOYmViTWNIWUkwTXVGYjYwTlZOdk1zVk1WaVROZ1JXa0Z0WUpSWkQ5QUJlOEdTUWJVWFVuTVg4TGFTclBFNHBKaGRRUC9XRzFLU1BCREdXdGpJT1JVQ0puV3hTNlBTSVk3eFNlNWtJa1UwZHhTREpuTGpNVkFaUDVvb0l5N1ZOMUZvR3RMVlhGbmhKOUFsUEYzbUFWODVFNFRUSlEvaUpOWlRQZHNGWHQ4bEVFaGdPVUdWSDJHbmF3alZGTXp5TWRGQlBzSmhkeWdpV1FHbFo1S2xYd1hCWDhmMWdUdlJPOHRsSjh2bE94N2dPeEJBRkYyV0ZSYjJKQitBSUFleWx1RjFtV3RtUWM0RFliRHhHL0VFSWlIaVRqUWxFUElFSFRBQUhlblRJekJRRU8wVFpid29rdkVqbUhhNFRsUzNVY2R4UHhlaEZlYzFmeXd3SU15VElEajJBNWtwRURrQVp3L21KSE1WR0Nod0YrSHpWNE14UGlDbVBSTFlHN2lCQW1HalBtM1NIaGtwWlJweVg1dW9jUjE0RW1yL1l4SUtGVllGMWp6U3d5bEZjaVFKVmlUV2d5WFlHSkd3VVYwOHFXUUU4Z0VEUWxjQ0FTQ2kxVllyTUNQL3BKMSt1U3p1TTVKbTl4QWQrR2ZVOGdBaGhwN1FnMERVSXlSeElBTVQyZ052OUE5TEFHRVFCbVFhYW1NRXNrQ0c4elZ0NVp0WTg1K2h4Rmd6c21jclJTUGtkNkQ0OGpkNE1oa0w2aGNRNWlSQXNpQUgxbUJ4NEdNODJnUENpYU1IY2lETlE2SUtXWTM0V1NCSG1vNG5DbHlZa1ZzYjQ2SVBnWnNZVXpJV00zeUV4aHJYbFRoODBKNXhJQkFGOUErWWttRENDV2NLUktZVjlDQUd4anpOTXdVcFFFUWFzajV5QXlkUXVqS2FWREtWOVJhMHVGQS94UWN5Z0dhUGdtaFN3Q2dDQVFXY0FnWFE4dzhJOUFOOE1EMk0vOXFuMGNNOHc5WWpzL1NrUmlTYmMxb1JVeG9UZElrVnpKSWk4cUVBRlNJbTBITW9pbElRYlFRRmtRSUZCWUZtbEJLb2s1WW9OTVE4S0tCcFhkZVVLSGFwNTJFYUhyQVl4TE5jVXVGWGtTTURVb0JxWi9CQ2lRWnJ6MlpEUHVSRE5kUkRRdUJETTlBRkxsQURINUNPWCtSQlNZaXJxQkpnVXFjQUkzQUJVdEFFLzBDc3JEWkZQdVFHUXZBQ1FuQUc2eW9RM01Lc1phQURMT0J1S0pJeDJwb3V6ZUkyMW5JWEVPSUN4MFlFU1dBUTNqS3d3OUlyWitBclNtQUVMeUFGT1RBQ1g3TWhSVVNTOTRxdlJtUXhDZ0FiUGlvRGoxS3NYNEFJdnFJcjM0SXJ1VUFFWjZBRVVpQURiWVdHOWZwQkU1c3VGWHRlWm9NdHkyVUNOZUFHakx0Q0JMY2lFTG1Dckdld1JaWjFYaC9Ec2kyYk1rNVhBR2V6YllCU0FqSVFiZ0toSzFSVVBTemdmVW1WYmtNN1A2Um5OdkNoQUQ2d0xiaXlLd1A3RDJYZ09mUnhJbUpVdFNDMG9NbUNGYVBtYlQrUWFFUUFMa1N3QmNYU0F5eUFBWE14S25wcHRybVRTM1IzVDRHaUFUL1FSa3dyUTJYZ1BJVHhkWmFxdDBtREdQQ3lBZlR4SlJwQUpBVmtBdmVFUmxGeElvbzdQMnpBTTQ3YnVjYWpBYjVKYUFhQkFXemdkSmtMUXVmMmdmU2hSczk1dWkxR0wvUmlFd0VCQUNINUJBVUhBUDhBTEJjQXZ3Q3VBRk1BUUFqL0FBUDhHemdRQU1HRENCTXFYTWl3b2NPSEVDTktuRWl4SWdDQi96Qm1aSGl4bzhLT0FrRXVMQUNnd0QrREJRS1lIRUR5NUlDVEFRSVkxRml4cHMyYk9EY2lOS2hUcDB5TUlUOHFmRWx3Z01vQ0cxZ3FHRERBdzhBQ0F6WkEyUEJnQTRZSEQvNVYvVmNnWlFDakYyTU9CRXFRWmtJQk9kT3FYVXZ4WmRjQ1dDUElaUkZCUXdRV0tQQkdXSUUxYTl5L2ZRZEFZT2tCYXNxTVJqZXFIRHR6b0lBQWp3OEVJUER2OGRqS0JORnFac3U1YzhLZkxGbENnS3Yxd2QyN0tWajhZNkY2aFliVUpQYW16cHQzQlF2YnR2ZmVMYzBDSzRhQkd5SmdwZG9CTlc0U0ExY3NXUEFBd29LVUJkQ0tSWWoyb1BUclBhazcvbmNBczJmUElBY1kvd1FnZnJ6Sjh3QlFadXc2Y1BUb0FROVdrTkF3WmNRL0hUVjY5UGp4VDcvKy92K01vTU1JQkdvd24xMFBvRkRWQm05eHhSVjdTRG0zZ0hQTllRWERBdHhCTU5vR2xBRWx3R01DU0NZQVpRUWRNR0psM1gybjRrMXVQVVdWYkNTazhNOTg4eUV4Z244QXhxRmZFUHYxTUJDT09oRGs0NDhFalRERmdhMU5jYVNTdDZFQXdRSFJXU2JRWXlSQ3dKVUFKdjFENG9wY2VyYllXQkJvRkFBRUpTMDJWUVE5eUZCR0dUTzQ4UVVSTHhEUnhSbi9DUEdQRkhqbXFhY1VYZnpUcHhzei9MT21DeGZZOTBDV0J4QlFBQUVRYk5ubG81RG1OT1kvUkNtZ1ZRY3NhS0FCRWpXbzJVV2MvOUNaQ3hHaEd2RVBFV2U4SUlVT3dyVVg2YXV3ZnYvbmxIc3NZV0JTQnhyMElBV3BwMjRoNXhJc1lNQ2dsY1RHYXV5eE5WRmwxVCsvL2FOQVZpdTA2dXBEWk5FVTBrOGVJWVR0UnpJaDYrMjNCUEhVMkVGaU10WXR0dDFtVk5KRllLbjBFa3Nsd1llVVU0V0ZSaWxYTEEzMDBsY3hKVFpXdWRtQjY2MjFZVjFHMFhsY0hUWFZCZ3kvK01BQ3dzbUZnbHgza2FCZ0JPMFJJQlc4SnBrbGtGa01nVXl1ZHRVSjdLMWJWWm5XcEFZb3hCWWJhM2M5VU54cGNxMW1HZ3g5TWRjY1hBME85bkdaWXk1SzBJUVlQbmlaU2lCYTV4QUJrRVVYc0hRbVZ5U1RTY1FXTU5VREN2ejJ3RlY5cWJ6WENpaUFQVEVNdDAwUklBNENqb0REakNTUVFHRGFBL1pBSUJMLzJDVlgxOHc5VjlWb1hvbi9kUlNqQkJ5d25PQ01QbVVTMHdpbFdMSm1rSGxYY3RRVy9lUjNSa0JCOTlVL1U0WHQ5bzBmK1BkZkVQK0E3cU1mQTc2dE5nNXR0NjJCZkFhaTNuWUtxYmROTVZZbzRCekJBaE16SjNpaUlHcUVwV1ZhaWd3NWwwQXQ1cS9CRU1SMUd3c2pkQ3BERGpKQW9XWU9aVUJCdmZSQnlKQTlRVC9JQU9CQS9QblhhZlo4L0RQRkNqQTRCc0h2MGFXSStQRHdUOFFHVjFaMlhJQUNHelJmaGhzdnZIbnFxUzhnaUJMT1FLY0NFdVFNQTB5VkZGeFFBeEkwcHp1Tk9sejhKcWlpK3RXdkFFNFppSDM2ZENwZWplcFVYVUJDdnFaRndSSitCejZsc2RwVkNvQUJGa3pCUjFEb2dROHNnSUZuUGNWS0lmTkpRaTRTTG5YNTBJUkE3QXpCL3dLMmtIU0ZDMTB3NGFHNnNHV1NkVjJPS0VFRUlzZ3d3cE1qVmhGZFYxUmlRWXdIRmFPeGgwSC9xTmZseGtPNWowMHVpbDBhbDBhMHFDM0doQXdrY01TSVlaSVNGUXhpVUYrVUdneGgzT0lVa3BBa0psNHhHQkhSYUJOeCtVU0pBUHZoUW9pU0pUK1dwQ3NNVXNEOVVqYWMwbUJGWjMxeDFsdThJcDdEdEZGNFVuc2NJVWRHbGkzRzhaU09QRTl6SEVZeHV1eWxObmVKVmdSZ2NEZWNUY2lPZ21uTVQ0NVdSTXg4ckl5VUc4dmlNTE1aeDQzU2lsaE1KcnVRMHBlNTFFVXVzVm5CUDJMV0FkTjByV3M0YXc2dHV1SUJkSGxTa1ZxcVRPTks5c3RoRmhNaWtDR1JvNDRaTHNOYzdRRXdzSTFkVW5NYTFyaVNaaXhJUWJUQVJ2OFh2UFFHS3hDd0ZiSDBLRWUrV1dnRkNKWFBrY0MyZ081RXgybUtFZVZaTXZPeHBKRUZSRmt5NFZ1Q0poVy9yS1l1bXZxSE5PZVRtMmpwVTUrM1VTZ09lRUFDSEdoS0EvbGtqWHhTWjZDWHd0UXVkTEZrenFvQ0phdXBaREZWMU5KR1RZS2xoSGxuT3VmY3pEbEw2SkgwTUFVcTVQRUFVeFFBZ1dkVmhUQjJmQmhDU1RBRnRLSHRIelVJVUpCcW9JTWVkRTV1Y3Z0SENXb2FyYjRrN3oxLzlKdEdFa1hYQ1FGT3FDa0M1R1JPNUIxaWNnY3RCRUJMZDlaSndYWnR4SkdBTkVySEVOT1ZxaTVBb1NQNEFIN0ttaVlmV1JaQWFDVVFqVFNsR3dWbFpXS1pqSURtRW5wTnJlRHNIN3ByYUVhNkE1bmZtY2hFV2dvUmlpVEtUb2YvVE8waWphV0syejZRTmdIcFFBZEx1TUtOTU5zZi9ZekFSdmI1eHdjQ1pMNjNmWUMzTmFqQkI2UWIyUlNnd0c0cldDaENSZnVBUkRVdEl4OHFtV1FJc3I3QjFyWWk5dE1YMVRiZ29CZkp4ejdKRFdzUFFCYzY3K1hnSC96Qjd3OTgxTHppMW9BUFBnSndmZ0pVSHdLQmpyZFR3RXAwd2xUTzZEQU5TbWlaMzNuVElyekZVQTFDZzhHQWhqVTFYWUtVUVFvREFUR2V5aUNvTlYwdkJ5aXVYdlJVRElVU2c1VzMwbHhVaDdSRTJBa2pxMHc4WE8vcTVETmRGL0FQSWJ6NlJ3QkQxUVVodUlHQXFSTHlHWTdjaFJsSW9WQW8wQXAzdUtLb1JObTRoQWlieWdBVVFJTGxDa29LSHliZ0N4QTRFRk9kd1FoMElrSXVRaFVxSlN6dy93TlpHUTJVQ25kbE5FcllpMVpqbUxOWU1KOGU1SUJPb1JxVnFZaWdCRlJKWVFyTm9wL1Y2bHpucXNGbnl4am9BQks2UUNvakVHRUxBOG1GRlB6d3JBdG5oZEUyZm9BSHBrTHEwWGdBS3lsQWdvODRTT1FlaUFGalZzc3pxRzBjRllKZ0lLQmJHMGpia2lzY3VKQmFLaG1kdGJBOVlLdEUxNlNVQkZzaktJVnRZMUE2TzFzN3VkWVNtUjNFYWwyR2pVWWtseExaZU1RaytuR1ExSDdVTHhYRHc2QTBSTm9QOGNqVTdzV3hrcHlFVE9GZTBYU21iYTAyOG5EYlB6dUlTQWl5a3E4WUpqVDliaGUvek1QdGVFdEVjc0VjZDBTNHJjVW5HazRnWFhsWHhOVmJyNGhQM0k4eFdiYkJGUUl5bmtndUxBMC9KUld4K01lT2JESmZ0ZjlPeXIzY2VTOTJteEdKeUFZM3N3MVpiOFZvZTlsWmdxS0RIbVJIcWtZbEtiWUt6YnMyQkhDdUFJM2JOZS9sbGRYSThYMXJuQ083Zk1zREJDTVY5aXJyQVFRb0xWYTB3ck13WVREakkrdUp5TEFqN0tDVzh1WVN5UksvQk5NVlcvVmxBenBEZ1lJbTlzcmRZQzdXby9ucHZBT21jWTJMOHVtUTIzY1JSUTZXUHpZeU5KUzhKc1ZhR1FGOXl2S1MybnlMVWM0SWVJbjgzZWFWajUvSU40OHV4SGR0OGEzODZEUlZBNFBhaWZSaE8vTUFnMWdTRTBUcU95RmQrYW5sQkFrMVh2N3k5amFQSXVkRjNzWGs2WXd1ZHFITksxR3JVNjZWOXRFc3NWcTVzME1XdFo4bmtIc3ZWMFZ4ZjN1bThaWFI1M0ZQWEdqSlo1aldqV2FtdVVyL3hCN3d6MHk2ZFdOZG5FbGlJRzVoOS9CYjcrQmx2dTB4SC8vRzJWOUs1NFVLcWVPQ0doS3docDdUeEhqVEpGSlJGaTMvY0RIV3BHQ05GWEZob2xpRmdUa1NnZ0s0QXpZT3NCd0xRQm1MTlVYMGQzdVdFVmdqOGwwQ0VWaVpKekR2NGhkVVlScnlrU25QaERIT1pEY0JHRk4wQVRiV05UdVpaR3RkUkZWVUZSZGIxVFlnMERiSzBWRFJNVzhZU0gyS0VZUWRZMzJMRllUZlJWdUJKeE9pd1NBcEV4elhWVk9ieFdldkV3SFJOQnRXT0JBYXNCcXhNUmRTbGo3MmRCY3lsU2w1WVJmU2RJQjU4eVJRNG5XTFFZVEFneEVTZFNJNGhFTXlSaGtwQWorUHhIYnVjWUpieDMrMzRYLzlWQnZMSTNjSUJRSnFBMTg0VUFMelFSRDEvMUZnOWVFMjh5RWowNFEzZlhFQTd2RlRMK0Z4OUlPSm1PaFRIVE5PUWJnbDdSTUFEblVpZURobHc0TmgvQ1lZVEFFZnFxZGh6WlNBWFJNMjczVTI5ckUyWHhVZ3ZQVTJRVElDYXdWVGR3TlBEME5xSjljdFpTSm56bkVBek5nb2VlYzNEdVlUZ1ZXS3J6VVFnYVdLVE9VdVgvR0tLekVZVXRVVStzZUhWcE1WV0ZoZ2IzTWZuVU5aUFZCV053SmZTUEJTL3FjZ3pMR0FUMkVVNzZKb295RlVCWkFvemVFZ0JNQW9nUFFoeFVKVVFmaGFnaVZZRkFRYVgwRWU0aEYxSHFjU1ljRWVHWVFWOU9HTCtWRUQ0Vk1Eb29OWmFlTlNiWk03ZUlOYXprRjhKbUdCRmxpU0MxQjZEOU1lbjZnNEQ5VTc0WFNRc1FWYkpvU01MN2NSRGYrWkhqL2hkVTRoRUNqb1FnUVNYUmVKSS9vaFgvK3dCQVN5QkVpUU9tWnpHN3FSVUdIek5XM0RVbnp4RjZXQk14ZGlTOEhUSGQwQldBSlJqVk9HaDB4NFhzczNGdjdpSEs2Qk5qb2dXZmVoYWpmaU9UMXdCVDVpSXpwZ0k4cmxOa2ZDTnJ5MWw4LzFYQ3MxZWpHVFVBZ1ZOcnJUUGxSQ0phWW9YbDY1Y1hqMGJhU1dYU093VzIrRFhIUnpXY1FWSUVQQ1hMK29RY2tGWDJGVk4zWmpoVWRDVXVqekhDYVNtQWR4alk3eElhdkZtUHB5VzhSQ0ZSYjRJcXpoTmowd1lPUERIM0dnUGZoVlB2d1JCUG5WT1FUeEFhQVRWZ05pUGdOUkgzL3dBZlZoUHNyeGo3OFRXRFRaV3E4VldEamttazh4Y0s5NVdCaEVGYU9sSk5NVlBmLy9BRDNZTTU3WkE1dzlzbDg5VUQ3OXNWL3FXU1FEQVdES2RTUlY4VkRwOURHS01obW1pSjBMNFc2Sm9WaXlweExPaUhnUmdDa2xNQUl5b0QzUXN5WlNRRDA1NEFMam1RTXRaajNXb3oyOHFUM2RFd1RROHc4SkdsWU01U0RwZEJsRnhaL3A1aUNXYzN1S1phSkhvUUFwZ0tEVTgyRjl3a0Y1QWdWU01LRTFDbVlrdGlkNDRnSThDbFl4UUFMc0pXT0xzajRMUnFJVVpqbXpOeVpjeGdmUkpRTXpVQVl2OEFJRE5HUjBVbVJDMENkMjhnSkZSaWRqZGdhczlnK0JBZ0xUWkdWYklnRFhhYVJlc21pdlNCNFJVQUp0a2dSSlVFQmpSaXA5TW1aMmlpcXBRbWdJbENwZTZnSjhVQUtTeENGYUFpVm8raWhzRUd4YWdUOGswQ2xSLzBvcXZISUdSQkNwaFRZUWp2by9SQUFHcURKQURBU2tZQ1JuaFhvc1hjUVV4ZEU4TnRJREREb24vV05waFRaQVJtQUVtSFlxWjFBR1BiQVZRb09vbnhvcGkxWlZVZ1VWQXlBY0NsQVhDTG9tbjhKbS8vQ3FscFlxWlRBRmtuUkRkSGFyeHNJR2pMS1BUM0VvYnBjcFBkQW5oYVptdlhJcWJqWUNOU1JuKzJpcnp2b3RjZFlVcTlFQlZ5QUZvb0lRWnlBRkd2QVM0RXFvNHlvd2JBQnNUZEVVVmhGcE10QUZoYlptbUVaQVZ4QUJWSVdOZVRpdjNsSjE3dUZyejZJQkl4QUVRa0FudnVJblBZQm9BNHV3QmhzMThuSW8vL0FpWFRpZS93QUZvaE1iVzdjQVVIaXg0SUlWcXVjc0t2c3NHQU5XLzRBRUhXQXA1SFYzWjJxeTN4b1NVRlpSVlZQM2FjbkJzMWtocmphTHNTbzNBTGRtYkJNUkVBQWgrUVFGQndEL0FDd0pBTDhBdkFCVEFFQUkvd0FCL0F2d3I2REJnLzhFSGlTSXNLSERoeEFqU3B4SXNhTEZpeGd6SW1RNE1ZQkNoUWtiQ3VRSWdHREprd05CRnZSWTRHU0FBUjRKeHR3b00yRUFreHcxNnR6SnMrZEVsUVpOR3Z3WUUyUlJqd2NMREZCUUFNTy9BZ1VnUk4zd29DcFZGQThpUEZoUjFlcURBVW9MTUZWNlUyRk5qUUVFR0ZUN2o2MWF0ajdqeW8wTHRHQUJnM2ZEUnUxYThNRy9ySDh4UktDcTFhOENDQTh3UUlDd29NQURxV0JiRmkwUWsvS0FoQzN4UWkxQVlPQkF5Z01KRUlSYnN6VEZ0RG5ucWw0ZHRxQ0NCNFFmb0lqd0R3V0xGUkZ5LzRYUkZYRFdDTGRaa0xpdGdmYndmOEZYM0Y3QmRjRUFDQW84L0x2Yys4RUM2MVdsUXJncElPM0t1NTN2L3Y4VFBUN29Tb1RkeFhzUEVMNzhnZFh3ZFpZcytERWtnUHN2a2Y2REFMWnFCQklsNEREQ0NEclVVTU1QUDlUUXd3ai85RkREUHpvZ01ZS0VHbFNvZ1hJTHNNQVhkcngxVlZoMlVrVUZGUUVoSHJBQUJDUjJSZ0JVQVJRZ2dJc0VRVERRQVMwZUpNQUJBblNXV253OHhpZWVqRkw5MVJVS0swd2g0UWc5ZlBEUENFSFVFRVNEL3dUUnd3ODlJT1NIRGt4R0NlVS9mcENnQVpJRDRyQmtEM3lNOE1FVUpKQlFsV2dDZEZlZWFEaTJDVUYzUUhhM1k0OTQ1dGtRUVpjOUpaQkNqbVhGd2hRNnlHQm9HUVVsUWNRTFo1enhBaEZ1T0hwR0Ywb3cyc1UvTHp3NnFSQ09kaUVGRVYyY1VkQU1mUEJ4d1JRTExOQVpqZ1RBcGVlcnNPTC9TWlowQ2d6Z1ZIU0NDWWZFbEtJVzlLaEJST1JpQkJHTmRpRURDeTJtZUZPc3pEWUw2d1lIK0JYdFA5Yzl3RUlQVUlpYXl4WmJCQnVsQnB5aEtHNW56cFpyTG53eWVyQ0J1ckFKaHB4VysyMGczazhTMWFmU1NDaXROQjlLK3lJMTMzbnpuaXN3ckNOVnhCQk9CNEYwRWtwSC9RdUFVbUE5NVc5SUwwRTEzYnhoalFRVFREYjllL0RBSVBjazFGQWVMVHl5UTFDQlZlc0ExV21Gd25XNmFUVllWb2wxdGNCcjhrYlc0azA4THp2UlcyMFY1T3BhUVMva1djZ2hOL3pVZmdONHNCZFZmOUdXMjlSY2ZmalZQK291QmdGVlZlMVh3QWIvYkNEMkFKZVJCVk5VWU1uTEdJb0wvTE1DQ2dmRVRTN1BOcHAyTkVRdmh0WVd1WHQ3LzRjMGF3L25KeFZCVTIyZDExT0tzV3hkQkN2ODQvSUtKQXk0eEpKWTZsQmxoQ05vVUpDUlUweFJnaGdzNUliQkJoaUV4VklBMisyODNWMUJVcmJkUHpqRzNSWmxBWGpBMEh0dHB0V3FqSjNKdUxSYWZQK05aMDRDOVhuWnd3SjFFSUh5RVZpb2VRa2FUREVnZ2Y5OHNPQ0NJL2d4NFlUL2tJQUVEczZQd01JL1gwcDQ1SUFGM2RaYjI0L0JEbTBCQjNDRzQ0enMxVGhuVzZqUm1QZlF3Z3Q4ZkVGT2s4cDF1QWFidnpodUNqV1FRVUdDVUFZcFFPR0JseXBERUhMd3BJTGtRQVlUbEVFWmNzREJIR3pRVUlmNkJ4U2l0Q0FTNE9ZcG5GbFJld3BDbnY2NWNDNm9ZODkzWk5TQkwzMGdnV1c0MUtPVUFLb1hTTUZUb2ZvSEVmOEt3c012RU1FSXVTQ1dFczVRaGdzd0NIWTNvdEVMcDJpdUZLM3FLWWlaZ3BLa1VKQkdpY3BiL3ppREZHVHdsUlNpaUlwb0xKZU04dklBeHpSRkFSRkFncFRLQUlVZStNQUNCV1JNWG54M0hvdjhpVDU3TW9wTjBrakkrQlFzSXZjYVdWMVNvaC82NE1RbEJlbFRTSUlpazJXZHJKQXZYT1JERkxhUmh6UnlJU2paNDNUc1F6R094ZkNSTnVHWklESFpQMFdleHlXSjFPUkJ5RWJMdS96cEx2M3BFK3NNeUJldy9XbHdNT2xaSHpGeUoxYnU1R1A5dW84ajhjTXdXTVlrYlpkaENzdTJSak9zVkFVRk1NQW1iYXhURUxEQmhqOFBBODFBRHVZemlyZ2xhUHdEbXRHTUtaK1NBYktZS0V5WlVoQmpNeUhSQm14Z0s0dytxNFAvR0JGdFptY2xLU2M4Z1RhYWdBbXRhT2E1MDhmdXhzN1RRQkloRzNQYVhoRHpEeGowUldvV2xabFZzbllZRWNVVE1xQlI1a3VRSnhuSlBDVkZiR3ZNMHVaRkdzL0l4RTBTSVJlYmhCYThoa1lrUDA0YkFGVzRoZ0szb2FDbnN5bE1ZTGkyMDZqNXBUcGRvMVpWTUlDQjEzUUZMSXVCSHdSTXRBQVlYT2M2VmwzVGR1dzBUUFFjRkg5SE15aHE1dFlkL3RsMEpXVmI2WHVFNUordVlNQS90UW5kK0V4SUF1bHBEZ2tWNmw3M1JvQ202RTNoSDFOZ2dXQ1JXcFhuNkl4Mk82dlJRVm9WQUJyaGJqd3hpaUZZMjFRUUdUVjJhYnhqNFZueE1rck0xQ1FzRzBzSUxTc1dtTWRZSjNJNmlKRGxrTlFnQi9YZ3RRTXlIeEs4cElIUS8xVmxNd1Z3MmsxZWh6clp4Vzg3d0wzZjdsN1VJZ0hjN3kxdGF0VmErVWFlVlFIUHJEWTF5NzVFbTUvaUFlQnNrWGxBQ255Z2dSSkFMN1U2bUZ6bGtQU2dmOGpXUXNQQkRYQUVXeHprUUE0SFU4QUJDY0Jud3JjMTV3Ry9sZEZqRGpEVk05NWxyV25aNVM1aDF4YmNyWFd6UGpHSlhuYmpGeFNZVUFOMWpSeVlwRlRlaHVpZ0lIaEZ3aFFxSkQwL1ZBbDlmeGhCWFN1VW13NTBRRGpCcWRZRzVuUWp0VGlXSU85NVQvN3FWMVlFcStZa0VIdVlZYXV5QU9Xa3lVd0dNbENWdFBRa0dVQkJTaE1rNFlLZTlPSHFGZVMxVWZwQkVHVFFBeWJ6b1FjOENDenNWR2lYQTNUR1RjWWxRRTF0M0tOYll0RnJBUTJ0UXJJeW9BUnFzUCtCUC95SEZNcUFxSUw4VUFwNDVtSURHOWlGUFV2QmczUFdzd3d1VUlNUFlNVmlMbkxSVjhrOFJUWkVqRHJUVVFBTFlFQUNITDdnQy8vb2doQ0UrQUloOGxBSXhCcmlESG9saEV1NXdTQm5XQ0tleXlDRER6aUFNemRpRDNRWlRVaU9XSXhsa1J2eUJXZkFhaVBuNEZObldKUVFpMENzTUJaaEN6NHNndzRlSUdZVVNaSFcwS1lNZjEwbkw2aWt5Z0U4NElNTHV0RHBNQVpiVzFzSW83RWFKK1l3US92Y0RUbkErK0ozSXIrTVFBWkQvRWN1Q2hKdUlVTEJCeDJGSC96UXplOXVSbXNCSnZvTEFmd0NPV3c5c0NCZHFDTUxNSEFpZ3h5NDMraG13MzRpZWJVK3JZQkJIOUJBQjNDR0Y3OUEvT01Pd2FmSGVTSkxRRTR5bGtIL0tUbklXWGxJaU1peUx2NmF5Yjg4TS9QT3JoeHA4SFNJdlJ3NVNKalhYRjh6UVFqeVluTEptK2RKNVgrMHp5ZFQ4L09VTS9KZlpjdFhkU1VUVUQvbDNPZ1lhZmttRmRiSStpUU1ZVTQzMnVFaytVZUd0V2drbVVGWVViQitrYXN2ODA5bHZ5bStVdUlRMWJGSVBIK2F6R2NZU1ptQUVwM29iUGNqdmZZMEZKUG5xMk5yVDBsWWF1VlN6OUJ5bEJiYm11OEdVQkxRNUFjcCtqbUxSR2JOZG1RZWpTaktYR2JER0hLWlI1TVdMTlFSbTVDdWlsVFVqL0xzZ0cvOHo5QVplSnFiWENaQVdaalFqeExKZVpKdEwyNkVUVTlkRm9FRlJLQ25SN1dMUHlVYXpFcGFSSjFxK2RnNWJmUngzT2NMbHM3TXZsSys0aGVkd2tac3NyRUsvMUJsNDdpdVlZZjFMVUdzSlorUE45cFQvNkRxUFBmaE1ZSjZzZXdVTnJuWndHRENKalhYbUw4M3RaSVhVZEV6NVJRUjZVUTA4YmRvUUxPQWIrRTM2UFpKb0dRZlllRUJ6OEUxQ1BGV2I5VUJwS01WVGdFYkQvQWFCTEJ1SHJVc2dLSllTY0VRNGhGOWlwYUFNRVY3QytpQzduZHVTdk1ubEpkK2hrVk4yTkVYTktOUlhRRTFZZ01WcmNNZi9FRVdsdlFTZm1JWmRuRlNuSkZDNDFSVEhQR0NyZ0tGNkZSV3dDTi9sQmRKOVNjVnZhR0QvcEViZ01HQlZLRUFZYk1BME5KOUdHQXIvUEY3cG1jOFJ0Z25iZk9HTUdBQTR5SkZBWE5PZGdpRERRaFdDQ2gvWm1NMld3aFV0ZUdGOE5LRG96TTZDbkFZQkpRWXZCUTJXS09HVmYvaE5BRUVQL2hWQUx6Uk5qQ0FHTkhDSXBQMU80b0ZmWXYyTWQ0aFRyUERlYXhVZW5maE5BWlVmQ3pRVStwVmZrTHlWcThSTmhvb0dJMlRQc2VuRlJrQ0hPOHlQa0lTSWl2MUY2bnlBTHlCRmRleEl1a0JWdmRUSTNrakh1QnhFNkl4R3BDRkd1ZTBVSnYxRWxuSUdIMVJFTE9SQXVybGhUc1lPbzdUT0N2Z1BBYmhKYlMxWVNRZ0JzckJWa3RWTTBnbGhJbkZWZERJV2IrWUY2WEJKcFRoaWJUbmdBMDFFekdrSFZHQkVMMUJGVzkxSGJXQkc1QURZUUt5SkJpV1llYjFWMyt3T2VrVk9qQlFHT3NDaFBseE5wcDNGblBTV0kzVmtUSW1OS2h4V1VmelV0RTNjYVNZUnBqSE1TVDFIRXlqaG1FQkpBZXhBRVR5QVFLaUExZi8wQ0NUVXlVOHFTUklnZ1RmVXlHRDFSVmZFeUxoVkJyZ01YSG40WkgwODJ4Qzh5TEdaU2RTaVRwdTRqdlBSV0JudFhicThURGZRWFBIRTN4VklXRUVRaUN2VlpZOWNDVTljQVhhY3dWSVlGN29aUzBnRWhXTUFYQUdZQ0w0OVJpUUFYbmlNaDRlMVI3eFkxdzlrem83VTJNRlZwZzI1a3dKY1gybVpJb1B3eTRwMEYzZHRTczgrVnFXVXlWU01nSkxFRnVkVTFzbXRCVlpZWHlPdzRwZUVqcTV3UUxYRVZXTFlVVmVBenY2cG9SMDg1b0ZFV01IOFhCazVqQ0ptWGVRcEpGS2tSc2E4SmdCZ2dRNmdBUG1nd05MY0dFRk1RSlhFRnZRVXlIRGNZNFNBbDhwWUNUVE16M2RzeHpXOFliY0pIa25FaTF4SXhYRzFYajNzeEswLzBtU3RaZVlUNkU0K3NjNERpWWNGNEltMHNNZ0JzSWc4b2s5RXdJOUpXQlhHN1poQTFLV3UrSTVYb0liaVNFenZMRVlqMEVBWHRhUm5rRlpiUko5VWxRbmZGU2VDZE1TVUpXSXE4ZzRrRU0rUFBsRUIvRURCbkVGQzdJRWJRbVVEREprZnFBa0JjRmh0YlU4TEJBOW1aTTV6TEVtdWlPU3ZlTlMzVUVqY0RKbUVKb1VJUUpTTWhJdGFTS2REeUVEY1VCbC8wQWxPWm1oeDZtaDhva0VOeVJrMXRPa0RNSUR3OUZHUzJPTXJVSWUyK0ZsOVRNL09lcEoxOVVpOGxSWndvZ1ZQaFpoMWFNZy8wQkhNdUJCVTBaa0dBUWxaSUprQmNFSElBUkNVM2FuR0ZRRGZBVXZlYUZDTVBKbFhOcWxIZkZINmJjZkRXZVBVSFVYRldJNUUvOUVSNTV5Y0ZEZ1FIUUVCWHRHWjNUbVFYdkdRUTlFUjV6YUlJWFdPT0pob0cvaFpVb3BxTVJVZUhheE14TUhBZGRsTFcyMnBuU1daNHdpS1plU2FUOVVhbWZnQmtMQUtDOXdhcGRTcTEwd0E2dW1BcWJ5QVNEUU9HZmtaZnhGbTZicUU0SFRkMEZTRlZ3eEtPWFZCVzd3S0ViRWFVTTBxMTZVcTdzS0twdkNLSkhpQnByR2F6THdBeDlnUWx1bXJNMmFKMnlBZ2lzU1R3TVFBU1BBb1dQVVFGOFViLyt3YVdFVVJyNHFLVUpFQkVUQVE0NHlBeTVRQXl1d2IrUGhsTzBLS3p2ak9uZnhHaGVYUUo4aVJOZmFCVGtBQlI3VVJaMDJzRVl3TEdmd3NRTjdCak53QVkxem9DM1VzT2JpTzlkVkVFMTFZalgwSlFyQ0pEblFLSXptRWthaE5tOERHMFpsOEFNYXdCN0s2bllxK3lxZ3NhT2JzVFZVd1FMdkptZSs0bTBCRzdBdlVBWTFrQ3F3MDFnU043UWhVN1R6SXBOdTh3Y0s1QWJDZGdhYklHLy9nRVJFSUFUSG9pb3RpTFZUTkM2TUFRUFNJd09uaHJOa20wUmJJQVZYUURiN3NTSVB5cmJDSXk3eDh4aU8wVDA1MEs5RVVHL2hGZ1FsQUJYeDA3Z0c1YmNnNDA5MjRUc2JvTFJHeGtWa0swSSt3SEN0MmJpUTJ6OGk0anRSNVJlYVkzQnlCZ1ZBcVJYeTByZ2s4cm45QXgxQVVqb1BvQzdrZ3dPVzh3TTZZQUlkOEJjZTVicHB0R0lHc1M0ZU4xY2t3SWo3TVhLK1MwaGJrelVZaUx3WEVSQUFJZmtFQlFjQS93QXNHQUMvQUswQVV3QkFDUDhBQS93RDhHOWd3WU1JRXlwY3lMQ2h3NGNRSTBxY1NMSGlSSUlIQlRMVWlCQWpnQUFmQnhRRVdlQmZTWkVJU1dJcytQR2Z4bzhmT1hLMFNMT216WnNKWjI0a1dCSkFnWlVpUlhyNEIySEFBQVViTUF4NFVPREJndzFPQzBhQSt1OUIxYWtGU3pJdEVLQXIxNjRqYVFyNE4zWnNScGRoMGVyRXliYXRRNEVsLzZFOFdNQW8wYmtRL25rNHVjSERoZ0VGRkF6NCs3ZHVBUXdGdUpZTThCTXMzSlpaZWZyc3lqaGhTYk1DeHhZd3U3QnNRYytneVdZVjdiWTB6UUY1U3hZWSttL0JCdGNQRnNSMktwdnFQd3dSL3JGZ29Wc0RDdzFUZlA4andYdkZGT01yRHNhdVdoZUNUd0FRRW5lTlNUbG0yQUFFTXB0MHVkZ2szSVJqc1dmLzFXaFdnT2ZQcHRObmhBbFNvSHVYQXdTS2JBcjRnUUlXSkRUazE0QUR5UWdjQmZYUVF3MDE5RERDUHpxTW9DQVNHdmpHd2dNWXNBQ0RiRERrZFFBTUV3WVhISEVyckxCQVFkR054TlVCak1HVkdBVGwvWFBBUHdTNGRJQUFBUWl3bVhrQ3ZmZ1BBbU1sUUpwNlBONlVsMXdsUWRBaWZzQXBLT0FJTmZ3allCQTVIQ1JERVA4RThjTS9DZ1poNUFoV0tzaUhnUVltS2FDQU5VRFpBNVVmakRCRkJBOUE0QlFCTFJKUUFKcy9CckNpQUNHaTJPT2RlSHJublpBUUJKQ2FBditzUUFLUy81UWhSUmN2RVBFQ292OFEwV2lqTDV4eHhrRkNkQ0dwcFYzOE02bWtCWjNSaFJDTHp1RENEeCtRUU5ZQkJheVk1NnFzdG1XWVhzMFYveVdTQ1NVVWRJVVVtMlRLNkJsRWRFRkVMZ2N0K2tNTlBLQ1FxcHV0SnF1c1d3VXM4S0ZWRUd6d1R3UWo1T0Ryby85c1FRUVJaZml4d1d1cHFoalhzdVNXUzVGVGg5RlhrRlVzNUZZUVZOSkdOTk5LRDRFRW4zVm9MZFNldWZ3cUs1Qkgrc0xVRVV1TnhSY2ZBQ0pGQjVpYUJVU1g1Z09vNXFVQUJJQ0t4TmhrSmoybkZrUGo5dXR4UWkyeHQ5NTNDSjBVZ01FYlVHeWZmYmxaOEErZy8wZ2IxUUhmRnZYQVhxZ1I4QUFBQzB6bjgyamJQY1RaZTJoeGR0MUJvU0g5TVkvc2ZmUlRZdHVwZGxETnIxSGQ4QVluQXJiWFNYSVJCVzFCZGxWc0VFOWdtOFNubTg1aTEzQytRSC9Yb3RKSll3WWVqQzZOOWZiU0UybjBOTWJRMWY5RmxFL3ZRaERCNEFVTk9nVU9DaUw0ang4Nk1HNGdFZ1VoTWNVVVlxekF3Z29SUEpqWTFoNWdyRnBkQ1V2WFozVGZVZVlWaTJHVlJUZWRvYVdvb2dBTW9INDMzaEVSSlBKY0JBRm0xQUR1U3FXYmJpVGs5ODhVVkNvNGduOEZhY0FnZ3cwMk9JVi9rQ3NQK1Q4TS9nT2NCdFpQR3dFTUVYUzRBZ3dZUVBWbWRBS1FTS0o1b3NGWVBucWZvVWpBajdTdmVsSjAwVnExZ05RUDREZUNnVEtVVVFZVVVDaVVGQW9TUUNoMEFRcjk4MThaY3FEQWYwakJVRko0NFArNmtDa28vSzhNUWNoZ0RUN3dBUjZzd0NvcmtoTjI1R1MwK0psUUlua2huVndVa0lKMmFhQUhtSnJCQ3hZbGd5ZEJJUWVIMnNTa0lPV29iZTNRZ2YvNFFBVC8zSVFxTnAzd2lEMXExcmhrczRJUHlNQ0FtdnJISmh5VnJYOEE2d3hsNkFDSXhJWEVMcW9uU0NrTEkxTWVRQUlkOUNBSUNGekNQem9BbGVpOHJ5QUVZTU5CNk1VUmdyVEhqaUx6b2g3eDlDK1dzTzJPZ0lSTWZBYkNsYURORVdSK0RCcEcxckpIRXpMeWtDbXhIVXNDU1JLaUpTWXhDL3VjSnRuR3lVYzJjbFYwOUNNZ0VZbXdzcGtrS0FlQjJXRHE5NjJueEN3eDMycEt3MmJac0JJTmtwTkE2MWhEa3ZaSmlBQXNJWU1jMXgwbitSeVV3UEkyMy9KTFZkNkZwdHk0eGxsUENaSkpFb01xRXJuRVBaNFVXa28ybGhPMm5hZVhPV25Kdm9CeXNuS2lVakJSQ1YvTXNLYUFhRzV0TUlCQkRGTVVOcC9xT0NaZmtxU1gwb2gyLzgwU3VpZEY1d0dOZWRDSFBuQU9wSnlBSzVuVTZKY3l4TVRNTDZpWm1BSUNrNWlKQXVhVXM1U1ZYVExHTlpjOFp5MUNnaHBSZEJJampoZ3RQT2xMYWRJMmc1QVNmdEp2c2t4VGExN3pGTms0UldZeHc0QUNNT0MxaVcwZ2N3ZEJBZmZheFQwWVZBVkNSSWxPWFFUU0o1ZEFnSHltaXlyYk9xWWQ5UlVOTHVFUmo1N21kTDRkNmRGa2dQSFRMS09tbktDeW9JVU5Lc0dnRHFRZ1B4aHZldEc3bklTY3dqQ3VQRlV4MkhUUFdFZGF5THlBQmFVaDlHdmR1am9hMWFsVWo0eUppOEZPdHJmR3Jzc3BzWWxBOElJM2dnOGtTRWtCaWx6eGp0Y2dGdmlBQlIySUFBWXdRTmZGcE5Ba0Q4QVFaRlBZSFQweGhrNGxjdEY3NkVhQWdQK3FxcUFGMFZIc2ROVEZRQ0pTTHJvTHpBUFFORnlFYUtBRXlxUGVnWkJRZ2hJb2FITDYwVURtZGpPNDdWMHVVUGxCQWhJUTU1L2ptZXA3RTRKWXFtVERuRXNlb0UvbUkwOTM1bFRidGRUV29CYTVLRXFzMHByY3NHQUtpZU1TVy84eHBZT01vSEU2ME1FUy9LT0JFZnlCclg3QTN2Q0MwNkRrQlErL3oyM1FDb3lGMWFxV2ozVjNZMTBLWndkZmVZVUVrMFFwd0dza2kxL0VFVWhKWnd4Q0R4REk0b05BS1lQL2VOS1lrdlNrR2dlaGhqTElRZjkwbk9NbjhVSEZJeWl3QmpyRUZCYWhpa1hZUVNuOE9ueVRWOWt4VHQ1cDJBTldvQUVPL3FDR0RDekRHZHpncVVzZHFsS1pFZ0tYdWZ5cFNMMEFpQVBzd2dBTktBVnJsYUgvaGdRcUV3b1dzQ0pWTFpuSkhwTW13b1piNEI4dzhGQmxlQlFSbEtDcEx1QlFDbENJb0JBSTZLZ3pKRW9KUkRBQ0VTVDFnakpjZ0FRTEVFQnRENkFxUEhzeEwzT0JTZ2RJY09VeThhRUdTMWpDRlZaOEJoMU9LbEVJOGVFWnBDQURJVG9yMDU0R1oxeWlzNkw2b1FVR1BPREJCZnAza0FvV0pCZVNMb2lpK0RDRk5CR0Facm5POVYwLzlBOFlVRmtEWlhCRHB6WnhrQzFzd1Zid0ZCSlJPQnh0ZzdvR0FyTFJ5clJlQ0NVcEVtR0tRVUNDQWdDd2dVNHZnTnpsQnVkU1FKUXlud0x2SHpVWVFRcVdXUldHeWpIZkNGZU92M0V5TDdUZ01lRVE3eWJBc2ptd0FkanVaUERSbXo0akhyOVF2dVhoaVRRSVhVeVpFYjBaaE9JYy83OVR3d2VXeUtiNThaZUFqSS9VRWdtV1NZSmw0eWx2U3g5UDduR1Jod3drSXZFSVNoQ20xNU1GaFN2em9RdGxybm55czlRODV4YnBlVU5XVWs2REJKMHVvUXR4aUpvMXhyVVJwV3Y4VEFzdTJRZDFpSGh5WDJBTHlVam1ZL0cvZ1U0QlE2bVlSSnZ5bEszOGlKNnZBbnZHUE1wM2lxQzh3enRmWkI0ZHduYS9vWVJpU0FsZjNXbEQwNWhSR3lwdisxeEk3S1VSZTFua1BTYjF0TlJISXJLVlBPY2toZ0ZjVVJDelU2b010KzRSY00xUFVmQ0FPY2RNcVYxYkRIVXNBN1MzNFBLYlZpM0wzM3M3ZU00ak5HaFBpNVpFb2JMNGQ4VnNPZllUWHhqZENBQUNBR0JGT004YmVrQ2prMi9pV2JFTW1memtnUlF6ZU1aclhVZUZsLytJWDErWVMxS3pBR3dBQUhWMjM4MlVvcWY2b2ltcCt1U1B6YkUzOG1DTkVWalU1ak5SNGhjRW9pOVRGMzFoR01FbFM1Z1VWVjl4VUY0Uld6bWhHbXJUSnZreUxpaWxMeHVEZWR6VVNFMkRlVDV4VWZMVUZIbmhBZEdCTXhRRE9zMVJnQmJ6SGZtWFVJVUVPUGhYR1FxQktvVzBPaTFWVWs2SFVoWVlkdmFIUk84eExqZmpnU2xFUDV1RFNRTTRNU2VTVVNjaUxhcUJHbU56U3dtb0dGRHpQbENZQVhSV0ZuY2pURU5ERmpkWWdTMFNJd2Z4TmkzaVV2R0RjVjhYWW1tU01qTzFlTkdVRi9WbUdDZGlVWWVCRUZiQlU3ZGhGVXpoQWZPaE1FOEZJcU16VCtjVlZSeXhHSFN6SW05RE5GeDRkbFkxRXByR2Z1UnlTWHJSRjl2L1lWT3lBUnRVRVM5MXB4dURnd0Vkd0J1bUlsZmVjem5Ka1J2RFpWUjNWWCtKNVNjTFdDTC9sQkFrc2hrTUNFY2xFaDVVbFNJbEZTTmNBWVpMa3pWRm9SVlBKVWFRMVl2VFFsLy9rQUlya0FMUjlSL1BNendITWp3a01BWExlRGt3VUZwTDlSUE9VVXVLNFRUNW9oTS9Jb2dtRVVLYm9SZ3R4WFJwSVNmYjRTYWFka1JDRVRTTTBTZEJxREFiMkU3VEVpaUNnamdLZ2dNNmtGbFVRajNVMDFuNDBTSFArRlJkc1RDbUV4WjdNVklXWXhrd2dpS3NpSVY2NFIwdzhpSzFaUjR0a2hmWjBXdW9neDY4dFRUUVFSRE84WStWTjVBL29UVk5rUnVEUXlUeitGOUtzai83OHc5cXBGMlg1UnUrMFFGME5RQmI4NUVXVnhScUVpMVAvN1VpbCtRbmFPRlhBelVXcDVXSUU2a1JPcmsrNWZoZVNsT1JlRU41NHJSWWcyUTdXbkVZVUVGbHdwZ0NCeEpnSXpCZ3lhZ0RTTUNWME1NZ3YvRWd2bmhYV3pSbEhiSUFRclVBNkdZMjNLRlhkcFdPN2tFaTJaRWRZOEZlV0dnK0xIS1JMMklqalNRVEJ3TVlKZEZPRVJCYW9VV01JZkFQeUZVQ1N4Qmc5WmdneHFNZ3lKVWY3YkliMWJZOThHZ2N5bE1rMGNVYlI2V1RjS0VxNXpWTDJZRmt0ZldGWkdFbk1rSWFDSkJiQllFaitIWkNPM2d2MDJRVUcxQXh0YmxHQTJjQ3gzVmM5L2lZOVhnZ3hNT00yTU1ia3FWZ3dyTUVJK0JXQjRJOWt1TWdkUFVqUnNVOTAvUW01d2NuSTZjaUlsUVFlMW1YWGhWeDZrUmF3eFVCS1A4d25weFpXUWZ4QVh4UUVCOVFFTXZsWENTQVhPeUpQY3o1bFZUQ1BNSHhHODNEakx1QlBWYVJrSnEyUGx2SUp2S0hJclE0bHlrbmhuS0JrMFN4QUhJMU9jVVRCQVVDY0ZBeUpXTnlCVXFpUm03Rm5uNlFFQ201V1JDbUlCOGdKZ3RHQXRLQkdYTjVHU0F5ZnkveUpvcllZVDZoR3ZEVEZKWkRXZisxUDBueUQra3BBejN3SkRsd1l6R21ZdXdacENnMklEV3dKUU9DWXpoMll5cjJBUUUzQXUxeUpzdkJpRzhqSXhmR0pycVVjekN4R2lHMkZMU0JBcE5wS3Y4eEFqS3dKV2gwRUFEVVAwOGtBMDZTUVV5U3BqcTJRQkRrUDEwUUJCajBQeksyUC9qRmpFV21uUVlxYm1YWEVDRDVkVnUzUlZXaFAxanlSSFI2S0drV1FXai81a0NHb21ZT0ZFR0hnaWdSRkVEL1lFQ1lTbXM1NEFJeWNBRVRFR3pKOFNidmhaUi9HaEdGdEJoNE5ZNm9kVitZNVVDSTBnVktjR2Jib2lpZU1tYU81Z1l6eEtpVElnUUQ1Q21MaGloY05nTlNJQ281Y0dyRmNnRFBWbzZseWhaMkZaRnJBeitTRldQOUUwR0lraWl3MWtObjVxb1IxR1dUNWlrOGxDaU81bWlXOWdFYjhHeGs4WnJMNmhhQ0pSOXJOQVVEMGdOWDBHNW5GaWxkOEVRNThHZVdFa1hlcWluSWxndmI4Z0lEaEJEUFJxcnAyaU1sNG9RSVkzRUR3QUpqUXFkZE1BTXlNQU0xY0FWTDBBTTVVQ24va0NtOE1tai9BR3VVOW1Za2dCM0llbVFGcXl3bndSb2UwRTVIOFZNUElEMFZtMmhBbENuZzJtaitxZ1N6MlZZRHgrRXNiMVN5eThJR2NnUjcwYUljdzRVa04vb1B2NXF0bTNKc2sxWUdBZWNoTzh1ejVzSUdxZEl4VjdNQUt4QURkdUEvWnlZcGx2b3Ivc29ydE5ac3lBcTE4U05IenpaTHhsR2tVdEJvNzVZdFU2UXRaOUFEQkxFMTkwTzJlSk1xRDZBekIvQWg5ekVDV3NZcnVmQnRDSEVER2tDRTFYUnZkcnMwWmZoNmRFZ3RRWUFybThCdFZJU1B2WGEySkp1NC9iS1dFT05LdUdFcThSb0hScXNrUHRBQkUvVWhpSHU1bU1zdkhYZ3pEWFViZzJKY01GTnZJWmE2SnpRVUVJQVlHSEM3M1RNODBqVzdUVUc3WGNSVEtnTWhTRVVUQVFFQUlma0VCUWNBL3dBc0lRREFBS1FBVWdCQUNQOEFBZndMOEsrZ3dZTUlFeXBjeUxDaHc0Y1FJMHFjU1BHaFFJWUFCZ2djRU1BRHdYOERJSUNFTU1CRGdYOEZMaFk0R2FDbFFBQW5MdzZzU0xPbXpac1ZCNkFFR1lEakFKMGlJUlNBc09HZmdnSVlUcDc4dHdFRFNxRTZCNnhjeWJIbHdBSldDWDc4ZDFIZ1ZvZ0Mvb1g5cUhWbTJiSTQwNnBGK0pMclFwOG5PWHFBU2JkbFNnQUI4TGEwV3ZCbjNLZzZCd0pveTdFdVRLMVlFNk1sZTNCeDJJSWZ3MG9XaXpEQVk4cHJNNy9kdVhUcXlxY0lJNnhnOFMrRkJnMDRSbWhBa25yRXZ4R3dwL3lUUFdXRmJSWXdIa2o5UEZDclhic29zemJzckZqcFFBSXp4UzVGdnZPeFpPUUNvR3RlbTdjNlhydytVVXBWWVBSZmhJSXBJblQvK05laFF3UU4vMGhvZ1AxNmhIb1N0MjB2eUkxaXhiOFY5YWRNd1RHRkJ3blgvMmxnbTIwUG9GRFFBL1RCZ0Y5dUQraTJsMWdFaFFWQldOS0pKTUJrQWlCd29ZYVRUZWNoUkZ2cHRFRUJEeXlBQWdra2xDQ2JEalg4SUVNUE1zUVJSQTcvMFBoUEdUbVVVUVlVTWdUaG80ODk4TkZERUM3S2tFTU9McFRoZ2d2L01Lbmprenp5R0VRUFZQYXdoR3J3UFdCUUFRZFlSb0FBSHpIMzRaaGs3Z1FCQVVJTkpCUlNFWXpBaHdzdVFnRkZHV2VjUWNRL0wvd2pSQmxTU0FIRkRWRGtLTVFaLzV6UnhUOTNGdnFQRWdVcDhZS2hCUzBRd0pkaWxtbnBwUk4xOW85SUJ3eTFnUUlZc0VCQ0RRVUZNYWVoZ3hwa1o1MUVyQ3BERFNSby8wa2lwclRXU3RNREd6VFlsSmIvckdmcUdWQWsrczhXTi9yUndRWkNkVW9BbDdZMjYyeEVEeVQxZ0FkR1ljRHJkSGh4eGRKaFBsbTMxYmR1RVNUVHMrVFdxaEZLTUQwVm1GVFMvb09CVkNCaGtPc0FUaFZFRkVtOEZsYmNWWkNKeTloUzVRWk1VVStEY2RXVGRwd2hWWUFDSGd5d2dVWXBGVkFWUjFoNXhSZExtWUZwVm5JYkw3WXhaQWRKOXBYQU5zbWswMG9tZWFieVNMTVc0SUVDRUVUYllJUGZmWWNDRE44VmhBRUUxT3FVVWNXL1pYdWRTd3dGb0trQVdHSG0zTWdKYVR5UXlCZVNuTkRCSDNGazhIVkRIVVV6aWdKcThKOXJyNlgyMnRpcW5lWURDNk5Gc09hYWlaWDAwOHdSbFBoQXpGck83WlZJTUEzVkdYQXNnZjlwbWRGRy8zTUEwZ0lNZm9CWVVSdUVnRUdYU1UxVFhpQkovTUJKRDZCTmduN3M5VkFRYkpyL1Erby9QZWdBRzM5SXNQZmFId1hwaDhUWHM4RTJ3Z2V2MS9EQjdEMjR6cHA2b2kyQTFaZUJZM1VBQVgrRENXYW5qcE41VVFCcGlrVHpiU1BVVUlNTU9Pb0l4WTJFcW5xb0cxSjBJWVVRZW01LzZBdHVQTm9GRk5VWDFPY1pmR292eFF4OHlIREJCd3ZzcE5YZ3hkZmZFQnRjbnJuUlFROW9VQU1mN3BsZDZVcndoQ3RNRHdwQ0lCK2hERVdFTHRUcERFTG9nZ3R5OElNUmJHQUJ5MEtUL1RhNGxnTG9ibE9WK3djU2NsUytneEJoQzNmaVhsL21Wb0NpY1BDRk55R0tCNUMxZ1JrcXJ5Q2ZRMElFSXJBVWtRemxIMnl3aUZiL3ZESVRUYVhrYXBDRG9SSnBNcTZFdEdVcDNRcU1VbnBDeFNOQzdqcEliQXZUbGdoRExJSWtZVi84Qnd0RnNxa2ZYdXRBQlltSlcwREdSUmllTENOVVJBbk0yRFdyZDlVUVpnYmhUb05rU0NLSlJTeGJ2a2thd05nNEVRdzFwbzAzQWRoR0RxWWQzVXhPTjhqNklzUldzb0hmWUlWaWZOdEw0MVJTU0FoMURHUm42Wmp3dG9oSXQ3eUVpakNKU3VRa0ZzY2pjbXN2RjV0SkV3Tm5rSEUxTVRoZ0tzQllrRVlXdm53bGxBb3haT00yMkphRWtBUjVVdWtKQkE2R2xhd01aakRDNmNzQUZMQ0JUK1VxV2dvcjR0Q08xeHVDckFReGZndm4wOFlaUERZS00yUi9ZNDV6WGhpWXlKR2tqQ3RaRTY1NEZRR2M3ZkE4S3ppTjE5TGovelhabkVZMkJXSFEzSVJTSFk4QjBtQnNCQnd2ZVhrY2hRQ3VpRnZSNVVNcEU3WEVrVXdncmlSSVlhZ29GUWpBVEFFN2ZJL1gxak1DSGZ4REI3WHJRZW1RVUpBUytNQUhKbUFCQzJZV3o2U2xFU1dlaXBsUTB0UVg1RTNOTjc0Y3k5UCt0cW5tZktrZzBjRk1RUmIzRDZaS3JTMTBVWXBVSG5EUENLRGdSQ01vZ1hwd29JRVM0Q0Jzb3NNQlY5WERBdEdzWUZvRERVbTlhQ1lnK0lnS1BmVVU0d0ZJa3JmOFFlQ3V3UUhBTWpVbW1iMnE4MHZSdVZEVURyQzR4WFhvaFY5UlpieDA5aWxxMGt5bS81bkM3UDd4QWNxaWpnU3orUWQvdURxQ0tjQUdzK241eHhWV2lwNWVzVUFEb3ZxSHFGRFVIOC9XSm00elEycExMaFNBdy8vTlZyQmlvZDg2TFZOS2g1REVaYk02a1djNTk0RWVGRmNHQmZuQmtBeWkzSUwwNEFwZzY0RWZYT09hNmZhZ0JsWHF3UTljQkNNWmVKZEl0YXRCWnpVd0JiSkdZRVQvSUFEd0NEQTRvZ3FQb0wxMWlFWVBwbGVBYVdrRlh4c0JsWUtnb3hueDZVWTNLZ09BNS9Ra0tlakl3SDNxMHoreTl3L3RqVTlPNDRzd0ZFd1ZCQm44UUhieVFjbmdSSExVK0NaeWk3UTh3QUVHRUw4SXNNQ3p4NVdDRzRUd0FpSVE0UXQ0Y25HTEgwV0VQZlVKQ2ozWUhxRzZzSW1DUExDQmo0cmdnbWxVV2VoSXg4UFBlbEJmK3JJQkFGaEFBNXJMUWZabThGMGtXUGtLUFNBZlFvUkZoRndrNmd3eTRNRUcxQ3VXTHgwT3ljVmp3MDlBWXBLU0NPWC9rZi93UVFtVzBJTTQvRU5PWjlqRUF2L2hoam9ocWxCRWVJRUxaR2NnM3FBWmhyTkNJN0lXRUFISjhrSEFEclJUc0FpVkMySVpwQXRkR0lHMWhPTENRNWV5bXJwckVBYWdUQ2NYLzltRWNlNEFkODdFYWs5L3VrSGR3WlZNUjRDRUxFL3Z6a2pvQUdrTWdxWkt1YnFVMHBxaEJ4NmdnQWZnRndUcHFkdTlPdTJRYkJWa20ySDh0YlJsV1oxYVd1ZlpHTTIyZFk1NHRXbDd1Tm9Gb3k4dHJRM0tMNHE3bU40TzJDbWR2UlRzTVBNZ3hFR1h4SjU5eFRVT01kM1BhcUpTb2lwRnFmaDdrQUFqbzBId0pwZ2s0dHRXSEIzSXVvUU5HdTA4akNsN3pOVS80cWVsZTBuRkt6YmQyQ0NuZHZDMHNLUXdVbW1ZeXg3bTBaMVFLMWNrL3hyQTVBUzNFMlE1YktPd0ZLUkN1Q21Sc3d3ejNYblo2TWxNWWhTU3FGeU0vNWloeE1WSUZNbnBEU1Z0cG1LMWR6S2NtcHZsTXVjOHJLdXpBeGQvLy9Zb0tqOUtVaDRtc1owZTVwVVBDa3U3MDFLV3FGUDA3RXFONzN6ZGpkT0lBUVpaanZYalQ5WUV1THI3cGpkQlBDUWhIMUwyc3d2UDc0QWY1ZDdkaUM2RnI4eVBUeG5SNVB5OW03clRoU2VZTkRSQ3QyU1Fhb01ZcVppSDBEa3hqeUZnYXNWcGlOV1h1MTl5VERMbVBDK3Y3TTAyWFlLWW9TRmtYWXNzYU8vcTNodGVLd2YwZ0M5bnVUOGZQRkk2S3k4cFFXVjFyTVlUZ25JRUFsR0ZJelQxa2hpRS9RUmVuSWtLSElsdmxiWjFzemQ4alJCQ2RsbDVrWDJ5OThnWm1mK3ZpM2Z4Z1ZBTEpoN3AxREtiYVJlQVVhN1lvcTZiR0xXRWdaY0ZIVjdBejMrL1lKa1ZKVmNlWUdnaFZLRTBTa24xR0NlUlZKbjNWQkdEVEViakVkKzBMTFVWU1JNblJya1NOMVdGTnFJaFU2TmhIN3hTSW5mRlNxTW5ISHR4U3c1RlN1N0ZhN09GRXR3SEpzQXpLZEVVTUZpQk42V1hHUEhrUWlWaVlqaG9PVjIxR3V2eFZTTjFHbWp6RHpDd0FIdkVlb01SRXlNNGVaV1hkak9oTVpGeGdBbTRoSlJoR1RlSEhPTlhMbDNCYlJSVE1ESGpIVHVVVC9wMEdpT0FBMGhnVWlhMU9RWWhVNmUxUXczeVRZQURQTTJVSmlTeUxFb2hjRXdITXNQMElENWxla1BsU1FxQkhJWWxNRDZqU0FVWE9YdlVJR0I0V3Y5eFVpVmxFSzcva3hwSW9BRm40d1AxdEFBTG9DemZwQ1pHTVhJTlFvUkU2QUh2cEM5clZFUjNTRXVjZ2t0b1VSbklBWVdHMUN4V2t5N2FJWHdaUVJJZVJWVXJrQUw0aFJyN1FWMDRSRjJ3VVFLb0JZUXp0VE1NNHhjaFVSUzRBZ05sVlZZbVpoOHdrRWFadUNrRXNTWUtseHkrZ3p5enhSZDR5SEtISXhsaFVWZzNKelVRRXhWVVJUTVJrQUlJRVlhYkpUcGppQ0lrb0lFcmdET3dab3MzWXpudXVBS3V3VklCOVl4bHBEeWVXQ0pNOXh1MHAzbkRReG5JMFkxSVpWaE9wVzdlZ2pYcGNqSWpVazNmY1N4VWhRRTdWRmE5QWh0aDFVKzNRUm81RTRZcFFBSmNwUityVVJDczRUVnFPQm96cFpLMm9SOHlGUzFCc1JLcnlJTHBsRnNmZ1pCby85ZGJjUkVYejlZZ005UWd1elpjdkhnUVlITVFYV1VRS0RLVXJ1VTE3cmlJbmVVNlVDa0crb1EyYUZNaWxiUmVWdWlDMjFjUWg5TWxoOFpKOEFJQkY1bFBVN0FleGhVRW5nTTZhb2tRVnZKY0pUVUMwUFVhbXJOU3prVWx6a01selZNbFUxSTdyK01lYUhOV1o4SWxnTE03alZOYlhCbU9hdGRPbmlJM0s0QTVlZmtQZS9rUE1pQWxQZ0taUFJJa29GTmN4YVZmRnpZbFBlSmQzd1dhT1dBa24xbGg0QVViLzNSVldxSTd3SE43TEVkbUJ4ZURSQUZ4VnRXRGpWZ3FNekpoT1FLWk95SmdQQUthL0dXYU9mSWt4SmxnQmdZRlhiQWpmakpoT0JZRVdPWWVHaEEzSndFZDA0aVkwd1lUUHZSbUpGSjB4a1plelJNblBYSnBEUCtXWUh5U1lPclRKOWpUQlhraUJRMVdLT3g1WjRkeVFPUGpKMlhnWFJjQUg1ZW9TNGhqaHgxbkVQakRFM2RYVkRlMEhwNkRYS05aRU9IakJrRDJBZzdrQm4yR2FRektvS2hpUHNqSlBWS1FaK056QmhlcVBVcmlYVFV3QlNqd0FGYkljdjFwRXpFNEZrWURsS01pQTB5Q0p6dkdLQVh4S0ExMlk2TTVKKzlaRUhvV28yNVFLQS9VQlRNQUp6eUFRWUYxWmlWYUUwR1VOUE96VXdiUkpqcFFhMlhnUU9xcEJCd2FCRXR3QlV0d0F6VHlucTF5S0Q2R0VGS1FBNVhGS3gxV3BKa3hJWkFoaHo0akZlTWhBOWt6YU41VmhrK3dCSFoyWjNkeUoyZndvSkRpbmk3UUEvQWhPT3BWT0dSNktWWWpGQXJBSFYvSWFLZkZCS0lsSXd2LzFwNkhvcDZtNW1kQzRBWmxBQ3Yya1Y2QlNpdHNnQ3duTVp2YWNSSWRVQUsxaG1WeWNtZVFjaWlFWWdSZXBnUm44QUpLVWdNcmdFRkVtcW1ZSW5BdHhCc1hoRm5PUXlPR2NpZzU2bVVHd2FvTk5nSXpoVUh4UTZ2UHdnYkxjaUM1Z284OUlHQjVhaEFvZEJBeXdBTHYwa0lUaUt3a016T2pVUU5CWUNjNHVnVW9GQWtHY1FNcjFFS2VxcTNrRWpNa1VoUVdDV1hac3dtYklLNy8wR01GMFFVOUFDcklRZ0R4YzRYcVdxdmNBWGZ1d2dJNE1KbC9ZcTgzVUVLYlFnQWlDZ0hIK3EvTzRrTmF3aDN5RWlvNG9Ea1lXd0txQmpNZWxDeGxCTEhKMm1rQk8yejNVUkFmOEZYeVlpL3dCcklrUTBNelJEbk5tQkFieDdMMVUyd0tCWkIzTlJFUUFDSDVCQVVIQVA4QUxCZ0F2d0N0QUZNQVFBai9BQUg4Qy9CdllNR0RDQk1xWE1pd29jT0hFQ05LbkVpeDRrU0NCd1VpSk1oeElJQUFId2NFR1BDUDVNR1JJMGtPZ0VCU0Fjc0NIdzBXRElBeFlVMkxPSFBxM09sUW84S1BRRUhDZkFtZ3dFRUZCUWE0TEZqQWFGS1lNQWNFblFxeTZreUROeGRtZlNqZ1g5ZU9ZTEhLNUVtMnJFUUFSZitGVEZ0MHJkcVNWcXNDZGZxdndFaVpLZ2ZvbGFwU0lFMlNNRDFlN1NpVEpsYkRZUWx2Wk1oUlFJR3VaaVBuSEJtejdqOElCUjVBMkxBNVFnUVduelZvbUNLNnRJWVMvNUNNR0lGakNnNGNHbng0ZnZEZ0kwMlFnMjgzaFFCQnNjMkNrTDFpZEZ3M2dOMnJqR2NTV0R6V3N1VG5CYW5PQmFCU2dZSU5HeUw4ODF3d3dvTUlLTUJ6L3ljeDRzUHFmMU9tL0dOQis4R0dCeXhZcklDeGdzVjJEU2hXYUdDTkJMWUdGaW1zRU1FQ0JkVzN3b0VJc2tEQ2dkNDlzQUFNRDNoQW0yVUI5RWJjWXdmOFE0QUFCd1NuSVdRWlFpZWlUaDk1VU1CbTMwV3dBZ25ramFCRERRWDlBRVVPUWZ5VFF4bFF5SkJqRURMd0dFUVAvOGpRdzQvL0JQRkREamZlV0VZWlVraXg1SkpOT2dsRkYxSk15U1NPUGZiUUF3NGtSTERCVEFVc2QwQ1lITmExM0lob2psZ1Via3d0MXhRQkJXUm8xR2ZsOVZDRERGSCtjMFlYWjd6UVJSazArc0FFRWt0Y2tZTVVRcHloNXo5UUVQSFBDNG9LMFdRWkxzaFF3d2NMbnBuaG1XbDI2bWxabUYwMlpsMERKUFhlZnFzaDhZOFVaMnpTaFJEL0VQL1JaMEZHbkVHRUVmOTAwVjFCbkg3cTY2K1NiWkRoQXhobzBBT2VSQ1FiaWFQSk9xb29qTy9GU1FBRXdGWnJMVS9VQXViQmw5dXhnTUoyQkM3QUxVUStHZVRYVk5HOVZkSkpKS1dsRmxRRm1YVHR2TmI2aGR4TTBzRlVsRWg2UGZWQVFlNnhoTlEvSnBacU1GcHlvVlJaVFdCdFJlL0RGNTJic0VoVEJmV1dTUVRGcExDK0lBVkY4YnZJR1RXV1J1VTJ4MUJYWDRtVm1NcFlRU1pBQUI1Q0xKbFExTUVsVlhRdzBWUlVVM1U1ZFdKbS83UTM0Yi8vb0JEZVB3dGdFQUVHUWZObWwyMkNJY2JtUXVXS1BCREtYbVVOYzNJd3cveHl5aWJMVEZIQ2xSVkViV2FaeFpjZml5T1ExeHFYSkdqQUlnbFR4TTBDaEhvVlhHRlRNR2YveTV1RVFqOFFJQW41bFpTelVkUmF0dHZQVEJuWDFRRmRCMGFTY1pZUkVNQ21sNE40bVlaaVc3UVZSekVKaERobjd5Mnd3aFNxOWZBQmtBaTlxT1UvUUs1V3cybzlwS3BCYXYrUVVOQis1dFdnZWhDK0IxOERIejhRYnlmd1BlaFErd2dhcFBCQVU0L1pGVDJjSEVIKzhrQndkdTRwWVU3OXV3QnQ1TlZ3cHd3NS9MT2tESlV1dWFxdUJiRjZrQlJkekxEbi9IdTJyNnVpcmtLeFNVRjh1dHJGSmpsd3dROXF3QU1VUE1WbGJOQ2VBaWZDaGdaU0xpc0dTMUY5MnFNQkpqd0JDVDJBd2tFMkFZVXp3RThJZk9JVC8xN3dqeDl3YVFFTDJOUUNWNWltYVFIc0h6Q1lRZy80b01IN0VXRVRqdHBDTHJaUUVFZjlvd01LMkZiMi8xaEl4QkdOaTJBdXdjQjNOS0NER3ZYZ0NocXdBSGJjMDVRTmhPazNHZGxJMmJKSXNpSjZFVTMyTWhlKzVQSVd0S2pySkVFQmlVcWVVaXJqTEd3c0R2dmlBa3NXbmJBVUpsNkpFd2xMQ01ZVXpHUnJYUlJMMkcxT0VqWTUwdXNtR29ualFjNW1HQXdVQUNrRllOb0dQTUNVZUJsT0toeVR6dFFVa3BWT1JnUnJoVFNrVnU2VkVhUGNCU0dsSWhVYlM4S1NqS2xGTGtDSlpWdmc0cTZaRE5Jd1pJSE15bFpHU0ZFeVpJdGx4RWhNSm1lYjIxUkZaeDNEalVEV05MbTNQUEE0bFVta1R4U1p0WVowN1NUWFk1bE5ya2xLVVlha0tvQjVsMXNDYVJ1ZzFLVm0xT0haaVFxeUFReTh4ejFXL05mQlNqVkxaWExrSmhqSkozTDBpZitRbUhGTkFDOWJUZ0FzNXh4ZjB2S2dwVG9idGI2WG9tNWh3RDd4K1lkbzVwWTdpZjZqUGpEUVMyOXVvekdzTEJPTFZRTk9OWU1ETm4wMjVtcTRyQW5LQmlwSzBJR1RZQ2NxRlcwK2t3SUZ0V2cxT0VDQ0R2aURneEg4STBBclFBRm1tcktteC9UR0szYng0MlhFNVI0VVJ1QnNKMUdwU0oxQ09aRlJpeUNtZElyb3VFa1F5M1ZvUS8rQVhLODZ0MHl5MmNWZ0EzQ1BPejB6TjkzRjdhMXllOXZjMkVNYnpyaHpBSTRjQUNVdkF6ajJlRXNEY05QQWdTQVVxZ1ZBd0xDMGVSQkRxVFZVNkhFRUFtM0I2dVV5SnlZQmdEV3NtTTJRWmVVNG5hU01oR2VxVENobmdrWWJCRTNCcC84WVFkMFdwRHU1eGEwMGJpVUJEblk2Z2hMLytQUS84a0hRZ1Vhekd0V3VSZ2NmdU5ScXBxQ2czS0pnQVhaNWJJVllDZ0hpWUNSRTBEWG9SVXhpSXMwOGdEUzlwVjN3U2hna2hBU2hmQVVCa3BaR1VEdllGU2w1V3ZvQmozcVVBeG00OTcwNjZwR1JmcVFsNVgxQUE5NzVoeFVWaDlLWGRjaVVZNVZ1Uk5oZ25MMXRRRndMWU1GL2REY0NQclEzQ0RPQ1FnM0xZRDRwMk1oOFYzb1NocG5VcEZYbHFTQWQxT0EvOWlkaVhYVUJDbFhxd1FDbmdJSXZQWWFsbDZ1bWdNbUNFYnBZcGxUWGVWNk93eFBENExyWEJXNllBYVQwNUlZUktxcEpLT2J3cTRRZ0tUM0I2bFZVMnBPRkx6eTdMcjJKUTVlZDhiV3NkaEFCK05Fb0M0aEEzVmlBR2hua3lsTHVYVTBKa1BDRUsyUVEvNFQ3YzVXaXpyQW5KZEM1U1RuQTFBTU9jTmtBYTNtQng5R3JYcDUzSXVPUXhBY2xLRlFQY3FCQkZNczVoQ1JNU0pNc3BUczUvZG1nRGNUTUFVSUZzUHlNd0hkUUtJT2lHQ1dySEJwaEM3YUtsUnZLOEFHa3hlblNzRDdJT2xFZ0JpMkp1aUM1aUZWQnRzQXNSaTNoSHdwSUNKZGpMZUJvSFlScEd2aEJrMjZnd1J0SytBbytPQWljcHVWQ1lzYzZXeDVZeW5wNGdJTkw1VGRvM0hwQUFxMU43b1JRYTY4N0tWZE56Rm51ZGlja2pLNU0xeG5SU0xhT3RFVXExSFQzd3hENTduVEZwYU5HK1NoYW9GSXpwcmlMVGZuV054aVpNOHA3d21WZEIvRkFxU1NleXFiMHhaUU1Sd2dkRlY0V2VMK1NhNVZVSENWSllxSUNTRWdCYWY4RkREMnRvaTZPS3BQajBPRzNRd3lET0ZubjhiRUFpNVk4RVNiSVlwcHo0OWFFK1ZtbzlwT2tSQnd6N3FTa0FpYVVGQWhzcStRSGc2VmNjbVl2ZmhKeW1rSW4xeDFmcVVtVm9BUXpBNWhrSkxFVHRKV3M1Q1VHU3laYXZobFpzV3c5NFVFL3FZeTFMUE9HN0FzcUFUQlIyZXNDQVVoU0VnQ1lhWXZnMVU2MndSU0hrMkhzNWoremhyWEdNeDdXVkdFNFNzSkp6NEhnVzVZdUxXdmtSVnFRY2ZNVDdvVGNtdU5IUDFMaFpOT1FrU1VubThvMjhWa3VFL05WMXp4S3BvYkx5R3l0OUxoMzJlTlBEeHk1KzNMeWQrSFhRTEs2Sm9XMW5ONGtTKzd3bHkvcnhwMnp3Rm5wNkMxQjcvaCtzZ3owMmpPS1NpelRsc0NvNWZJY3dYZi91d0krZnVyMGErVDZOZm1YNkdsS3FBN0U0WWIzemNubTNrOWUyZ1JzUk5UTE9Vc3l6cnVnazkxckpESW5NaVlRSURUZWtWOGJvQUFZRUd5cGhCZ2R0UkdJOFg3NzFFM3laMytjdzNsdzlFWFVRVE9XRjN5TXRUbWFVWUJEMHg0dzRCa0E4aG5ySVNBb09CT3FWM2dzUnhpYjFIdUhjVFVUYURJQ09IeFl4U3MwaUgzV0VoWDNCQldiRVlUL29oMmZzU0x4b1dBV2xScitFUUc0VlI5MFJYVWNsVVdLY3h5OTVCUFhReE12UXhENFYyREZNV3dVOG1LTE5JRTgrQ3NvVVJpTTlTVVRvaUx5b1NBU0pWdW9rVm8rcFFQL0lJY1NwVFlPWWt6VFJ4T0w4d0JuWWxYcVZGQXlwa3RjeUlYREZ4d1JHRXFXTlZBc3BVQWlRekh3L3dKVGx6RlRLSUFmY2dPSHR1VlRxcEZhcXNJOG9FRWIyNUoyVGZFVjByTWI3NkZFbnFFZGRXVkwxQUowVm9OeG0wTVhCWlpjWUFGS3p1RXkvaVF6a2NVV1E2RUFzN0VkREpaYXFTVWFOVFZScXpVRks1QnRCZk16bUlGVmUvRWVwNmdpK3JFZzRLRVpPM01aRUpBaG0yWlkweElxZkVPRmpOUWJLN0UxRGZOK2tJT0JpVU5XTVNndkpqRkZURWdDeGRVbG5oRWV6WE1hQjRFREtSQUJDL0k5U3ZROEVnSkREMUNDbitFWksyQmJPcUFEWE9KYUs0QkNwR1U2RDRJQzlERWZ0R0V3ZlBjVWdBY0FIbUFZS1hON3ZMSlpCSUdOUkNRZFVyRXpwb0lkN3RST1UvUk90Q0VmNllGYVBrVmM5YkU1NkVFM0I1SUNwcEVxckNFYUF2OHlXQWVoSUZQQUEzVHpBYWVWSHFSeGhCRENIakRBTngyaFN4NkNqZGV6SEg2MlFEVmhFbWNGU0FqeEZOU1NXQWRDTjVsWU95dXBIbDRaTi85UUFtK1RXaDlBaDZQQklpeFFOd2NpbEo5bUozWXlQT3FsWHJNakJxUXhHaWpnSUZmQmV3YlJGWWtUWTVyVmJseTJMWWYxQUN2U1crVmxKLy93QVVZaVh1YmxPakRTV3dtQkJLZjFhVFV3UUQvUUk1ZkpJOGNpSkVJQ08rbTFtS3RCQXBEMGg2T0lFQmtDQWROeWk5YW1UZ2Z3SFNnZ1czWHlEekNTbVRxU21kL0ZYajNDWFQrZ0pVQVNQRDdpWG9DaUk1U3lKQzZBWVRjQ0JSQW1YMEZBWHpxQVh3am1NNVFqSEtqNWFrTFhMcHZ4UFVHak96M1ZsajJBSTNIQUtNSVphdTMvbFNNWGxpT0E4aVJQNGlTVFFpVk9zaVRzV1NXcm9pY1N4a0hJR1FRN05RVmUwbzBFc0NHb09ZYXhoamg3czA1RXVDSTZrSmsvQUNXclFtRlE4cDVVUW1FejBHRk4wZ1ZEbGl0VHRpcDBwaEFjZEdLTVVnYnVkU240V1VtVWxYVU1RV0FTV0pYYnNTSjBVeDQrZFNtVktRTlE0ajUrTWdQL0FFS1FRbWREVmlWUWRtUUY0VUdiSUFYN3N3WWN0QW41czVpNXN3R2xrcHJVS2FJUUlTL0xWMVhHQVQwbXB5S2Y1Z0pQb2l1eTBpZG40QWFRd2lSUWNBVkxRQ2lHWW1KRTBBV3kwa05ud0dFNThBTS9zRlA1dUFDYnRWbEthaEhuaUJsZTlqSlVlQkRnc3dMY0tRUHNlYVl1d0FjOTRBTStZQUpyZGdVenlqNkxncWlRb2l0Uy96QURlVlkzZkhZUUlSS25rU0VuVnpTQW9DVVFMT0JUb1ZrZXJzRUVTeENxY1hBb3JxSnJ1YklxaVVKQ2ZTSkF1aU50ZkthYWxGb1dIV0Z4V0dWMFE0VjBFVEFvYlFZa2piWW5UN1lva2FZblRtSm1LWUEwWWhLcnZ6S0tYMlpGWWFlQUNxWThQMktvRkdxbGJrQUVMK0JEUnFBRTdYTUJTRk1RazRxc3dESlF2Y0dObVVHWVBBQ1pFVnFxeVJJclJ1QkQvNkFFc0RJQ0NYa0FDekJ1NExwbHJ4ZzBCVUVDSDhBSE5hSW9JclkvTzRRclJKQnJIb1FlLzBJQWZIaXZZak51NzlFaVFlQStaTHByQmJFL3FMWUpOVklYSGtBZ1hzaXc4MUlBNHFJMCs4R255WUkvUFBRUGtYQ3lxYUdBa3RxdEhnc3hCOEF0aVdNc09lQ3UvMW5BUXpqVUJUS0FCRXdUTkFvTGt5LzdNQ0pET3Y4Z3NoalVwU1IyQlV4Z0FUMTdqU0d5c0VFTE1RVzRHU2FTYmZDaEhTWFVBN2NEVHhsQ091Y1l0VElETkpieEhpbklBNjNXTkNleVgyRExRdU9HQVZSTExEa1JFQUFoK1FRRkJ3RC9BQ3dPQUw0QXR3QlVBRUFJL3dBRC9CdElzS0RCZ3dnVEtseklzS0hEaHhBalNwem9FTUJBaXdML0NkeW9jUUJIZ3hiL0RRQlFZTUMva2dYK1FTaUpFVUFBQUM1aHluejVFdVRHbUJrcDZ0ekpzMmRCakFOemF2d1hNbVROZ3lrSEZpQUp3S1BUbHg0RDBKUXExU1ZOZ2hreFNvMFlVcUtBZjE4SENoRHFzNnpac2t3SnhpUktOR3RObDBPVkJpVm9zaTVScHdQc3dvd0tWNlBBcm16am1pVkwxbURZczRnVDMweVo5d0dFQnl3aVBJakFvdklLRFNNMElNazhZa3JseWhFd1BIaXdvWUJwbkZUVkR0MG9JR1VCeHdlU0Z2ejZOY0RoakdQQkZnZ2dlemRCQXI4MUVwQmFZT3lCc01qQkpsNytrR1pkMDBsTktoaUFRZlRvMFJzZW9GaXhBZ1NKRlpFalNQK1cvQzlDaHdqbEYwUlFYMW5EbENtZDNXdUk3SGpCQWhpakk2QWc4ZjdQaC85ODhQREhlL3g5aDhKbzdiR2dIUUVMRENjQUFWOGRCK0VCL3pBd1VBTC9JSkRoaGhveTV5RmlKVDAyMmo4czhEZkNCelhrSUFNVVAwQVJoSXMzUUZHR0RBUGw4RThQUGZ3amd3eEIxQkJFR1dWQUlRT1FSQUw1anhSU2ROR0ZGRFlDMllXTVVEd1o1Sk5RL0JQRVB6VjhRTUpKQVFBSG5BQVFnRVdoaExaOWFPYVp2T1dVRW0rcnpRWFRhOXF4VUFNVVNVcFJSaEE1Qk5HRERqV1VVWU1HZ0NMUlF3NWRDSEVHRVlnT0JFV1VVWmJ4andzeTlEQUNDUkZBc0VHYXNRbEE0Wm1jZHNvY0d3TmxLaHh2QlR4R0FndFR5Q0FGRVdkMGNjYXJCQkgvOFFJUlN2eHpSaTVuS0NHckRCYzhjTUFCd0hrcTdMQ2NCZ0NCQWplVzBRVVJSdnhqQkJGYmJFSFFKb2lXNFFNR3BSSlFRR3l4RWV2dHQyZU5tTjAvQ3p5UTBnUHUvZlBCU1J0WWF1bENRQWttMUZVYm1TVFNSVFM1WkpKcnZBMndKbENBZ1Nzd3NZVzF0TkdhYlJaVWw3Rmh0anN1c2lpTkZOUEVNRjFrMGNXQ3FYWFV3QnlmMlpkZStYS2tsVlZWK1lWVlJvVmhKZTlXV3ZWRW0yMGNmYVJ5UW9kMVRHekZidlZsTUV4YnBSVG1pQmdNNE1GazVUNEFBd3dyd0hEZkNndThORk5xRjI4OEVXMWdsZW1WV1A5OG1WSnJKOVZzYzA4NHhYVHVkVVl2c0FJSk9Qd3p4VUFha0pDQ0JpbFE2dllLS1lRMkFBVCs3dWFTYTdzWi85dXYwQmg4OWgwTEJ6NUFybFJqcFFSY2JDdXB0Tkp1ZVd2TGIyNHZRUUFBQkFJbDlhV1gvMUFvUUljYll2ZzFUd0hVbFplOWZFUFg3Z0laZU5kMjIvQ2RDTjgvSTR4QSs0bi85ZkJmWm9ENmtFTGRFWERIdzM4QTFzQkhEelVreitQeVFlem8vSTQ5TFA5RGxpc3NOVlJZWGg2bUtWaFVqejR3WEhpSHVVSU5PbnpBNXcvUTF3RGVGSHpTS01XUjhBLzBQcEpuL0ZPby9ZYmkvNCtqU1FxeHFQMy8yRVFYQkRpUUx1aElCc2tEUWQ2eXhrRHZPZEFuR3dsQXR3NndnWDAxUlNTbE1rMzRKak9DNkQwQkNWZFlGS09DRkFRcDBJbCtTeXJEQng2d2dESE43SUV3NUJRRUZwQ1NBeGhPUEVqSUFSUmdCYXN0RU1GVy85akNKdjk4U0swZ2ZNQStCQURXcG1MSVJFL2REU1VQOEVCZVBLQ0FEdnpvQnYrNEFSTk1vSURwbE9Za3BiSWhTQzZTc1RFR0JXQXBhNklhbVZNd2pRQWxjeDBSaUwxR1loT25nSEZoSW5QYXhOb1NzRFUyTVY0NXVVbnB6aWl6aXl6RldQL3dRRXFROVVXVzZERmZNMWtMWFA3aXhxdjRjWFJGeVZnYVEwYVNwM2lTTjJHamlpaEpacENRYlFVaWFXU0kxeTVKa1V5K2tJL09pVmhKN3NXVVVFNHlabFN4U2lnVHNzbkFRS1I3S29zWjVRaVNHMVkreENNS2lkbEo5cFpMVWM0bExweTBKTXFlS1RXSzFLWTIxTHdtTkduMndsUWE4eUNVZkdQWW5sbVFyZlFya1hXeFZIWmU4dzhXa3MxeXFCR1pRNUxEVFhDV2NpRVAra3F3Z3ZYL1RZU3NaVFdkVkluaHNuT2Q0SlZvUGo0QTFIdW1jS3I1L0tNRDJNSGJJUXZabG9TbEVqZkt3ZG85R3pLYzRpZ2xjMTNLalVqN3FURi9rV1FsK1JGUEJHREFnck9OQUFlMTA4QS81a01aRklSbkF4dFFBRXBDUmhEWkZLUUFWS1FNQzVTMktWRlNEam1CTkNTYmZQUFI0dXltY2FZNVNVS3lKNEJWcWpHYVRWbUpwU2FESGhhWXdEemlRWUYrVkpvQ3VrV0FCQmp3UU5Ba1JoS1YrSVU0RjhSQUIxQlZPeHkwalFRb3NBK3BlUE9yZnh6dHJ3NUlXdEZJbzVRQkxBQnZvSlJxUmhhWE5RbTJwcXBWM2RDR3JMckd2TFRwZEpiTml5eGZzeDBIT0tDaGExUGJRdGZXbWRMQ3h6OGo0RU5uU0VRaTdkaUhoZjh3MGU0K3dJZmoveGt2ZVRYQUhmRk9WTHZhOWVBN1VvM3NQanRIek1raTRDc2FBaDFKSWZJY1M5VjBCU2lRNlVCUUZLbEkvUUJIS3NwQkhQN3hBeXZsNkFwSUFHRVBCTFdFSy9UZ0NpOWFrUWpWKzZJeVpIZC9UR3JlajVwSG8vUE9KNjhiR0U2WEpHZ2JweEtBQUJDb3pSS1gyeE4vS2RKdzBlMWdEL1Frd2lwVmFVanoyNStqSnV5b1JmRnZTVXVLSDVMZ3V5UVROc3ArSmpUZ2tvWWtneGp3b0dtUUxVNllqdE8xQVJQNExCZGJpbVgvVWNHbWJHQUJKSG5BQUNhemdtU2xVRmt6Nk1JTDNKQ2tJQWZaVGxBd2J4bnE5QTlXaWZoVkl0NEVvNUFVQkIzTXA0SW5HUTZ3dlBsaVRvRnFMbkI4Sm5Bd01BSUV0bFk4b3lrWG5FWkRBaC9GSWY4SDd3UHhvcWhVcFJSS1FRWS9HQUZwL25zQXgvS3p5MnBrdzFJd2dqa0lHRG9BSHBES0FjcjFIaE93UUFOWFFsS2hUbGhBL0Jsd0lDN0lRVzU3SEpzL0E3cWZHc3pnQVg0R25rZjNRRm10Z25LaW1ud3JIMHJyREg3S3F3cy9UZXVmRmtBMEd2Q0REQkMxaFMrNEdsby9IT0lQMXhDRUt5QkxwOER5ZEswL2ZiZlR5WFVKUEZMV3FxVGxReWo0d0FUK0FsYVlCbUs0Wlh2YlhLTWhBR20yK29BdEVRUlpLdUZidDd6TjdvS1F4akdqT2RaT0FIa1FWN2I3M3ZZY1kwMVFoa3pyTWNRMStGNXVKcWM1VFRmeDFDQXlMbDFVQWQ0bW5BU2NZL1FtWnpuZHVORzUrQXVESklGT1NxTEdNMHZhaEl3UDkxQWI5NjNZT0Y1UXFvYi9sSXNIRWluTGtVQnlLcnNrSXlYWjBzZVE4MlRnd2V4M1IvUlZrNldFTHlWQisva2NPWW1hTjFJY1lLcGhTTTF0cm0rSno3d2hLSEdOSXNPMDhrNDJKWnBWY1diTS9sa1JwamVuM2lCL3BpM1BpWEtTbEs1MEZNdDYwVVdwVEU3aVMrSkwvenFYU1lyelY5cGRKR2N2YWRnNjNzeG10bW5yUndsWVR1THVrRUltUjNzWmZiRzkzWGpJc2Y4RmFxQ01JTUdETXBYVW9JendZYWVJVUtnR3pJek8zWmg5S2FjdGsySzlySXU5a3FjMHAwWHIzcFhIKzdMd2d1Rjg0alc2U29xKzJOOG5BN05mNGhVWXd0RExMNE91S043aG9yT2tGbDZiWWltVDhyVUhzN0dFcGZsVlEveXkrejNKU3Q0eWtodkRMSFV5ZTdxVlQ5MDNUbnVMLyt1VFBodU5HaWFqTlh1Wjg1VWorOE1vbThDTi93aGNyRWY4TlpWa3gxR3NJTm4yRHdOeTlabW5sVWRJVTRNUVZuTis3ZmNiMktOUGxMVkdnbFI5em5GeERrTmo3VFJVb1lFQndhTUJaOE1kNEFFZUxMUVMvcUoybWlSNENlRWJ6emR4QjdGK0J6Z1F3TkVsY3VGUkt2aGlVaE1pQklWbTU3R0JnSEtEOFVGVGtZRUI3V0lhSHdpQ2Q2Y2JHdmRUTllNeTYwZE1BbkdBTC9ObmlxTVJoN0VieGZSTjg1Y1g1S1pTbE5GT0x2VVBtNkdGM0JZWkhZQXRqL09EemRSNlNQRVl3ZE5DMnpaN3F4U0Z4QkZJOXFkUEdVVjY2VWQ3RU1KS1RKRXZCQUVCb3NFQ0MyQlRsekVGbUFGVE9EQTNjVk5XS3RWRnBwRW1WUUZ3Yk5JUmVmOVJIUzJWTk8xa0xvbVlTeG8xZVVDUlBld25nSDF4ZUpHVkFGOFNXWDQwZXRneUdqdEdJcGZ4T2hvZ1ZtT0ZBbVgxaXRDbFU0clVGQmF4TGREUlUwMmhBSHZZTnBPeWl1dlJJSllIQVFDbU5QaWhOQXZRVHZjQ1lCdHdFdDNpTnhleGNsUmpHN1JSVlpzaWUvMWtFZlppYUk4aFYraUJBZitnQUZZNEh0dXhIU3VnVXFiNGlQc3loQ0lCaVkrbUE3eGpJQzBFSnEveFd0M3hIblR3SGp6QVVFbmpUb1ExR2dlV1pVYW9oTUZpalF2b1FHOXhGMXhpTHlLUkZ6bzFBS1hoa0N6VVdZQTRIK0JSVmcwRk41Y0JIdC9oSHJYekFaTENVUFRSZ2ZkaE9LZ3lCUjlRTzBHUVdzbXpPLzZSanlBNUJRTUNLQ0FnR2RyU1g5aEVOWnovWTM0RjJVU1dsRmxza1JlRGhFRXpSSTRrQURza3NDNy9NVjI5dFpTcXBWcVp3Vm9ZeUlkSXN3THdVVHc5d0FkR0ZBUzFKUU44d0pVL3dBY1hVQU5oaVpWZFdRTXlvQ1dVK0NCbElsSVNSRnlTMVNHaTJHVWhvWE1XbEc2ak1aVVp5WXNEa1R3NDBwYzkwRjNUdzExNzBrRmNLRk8yb3dNNnNDZklzMkRvRXdUb015TkNzanpSMHlOODhBOVlpVUNWNlJrSzBDRC94WG0yNFNDYUVsSmhzcFBzRmlJSXdsSWtZRHNvNGlNNTBGMHYwZ05Rc0dCQmNpTTBvZ01GY1FXMnFTZEJzaUpGa2dOQUlrSkE0cHR3VmlReTBBWHp4U005Z0FNZndEVEhLSTIyc1NrVVVnRERJWXlmMTI1VU9CcmVXQ0xzZ3ljV05tZENjaVg3STE5US82QWl3Yms4UE5Jb1N3WkFSeklsOHFNb0JoUWwrek5DUWdLV0U4QTBIbFdIdmlHZHBWS2QrSVl4aHROdEduQmQ2T09iU0hKbk5ZQWpxZ0pFZHJKaERJcGhrdlkrWi9BQzllT2VsalpBQUxRazliTUovNkFpdkJJRDFXTWEvMVUxQStsMUZTRVVBeUFlR0NrZWNiTUNBS0NMRVFBZktjSS9Nd0EvOTNOcElDWUVya0puQlFSbFFtQS9qR0tqTWdJa3VrTUNPcVk0ZlVhaU9nRXErd0pHandjZHhsSXFqM0VaSjNLZ1ArQ2JSSFlrU2VJa084SUhUT0FETm1KQWg0SW9Za29FVDFLbUpoUWtmemtwQjNLTUxHWWNTRW82U2RpRWpRZ21ZREdhajRFQ3FqS2VNdEJiN3BHYWtiRUNrekVGUDBBL1pDcG5WQklFSFRZamtyS2NwZjhSVlZrekhHOTZKbUhTTjY0QkdYem9neEJaT284QkoyMTJYaytBWGg3bVlYTldvRW55S012cEdNRGhWQzRXcVdiQ09GSmxFaGlUaUQ1NGpHcGpaVDRBUWpIeUR3NG1RdjhnQktVcUJXZXdZYmFqSHpURWdxejZMYUN5RzhxYUdnd0NBU1JRbEkvbW13T1VhZ0dVSkdmZ0JnUHhRN1ppUURhaWd0dHlyQndqRlpOYUt1bG1ReENBS3FkbVFrUWdRS3d5b2RyNlE2ekNLbTZRQXl2RUlLc0tydDhDY0k3NkQ5c1JBUXFBQk1DNkxFSW1LMXRnQkxtUUM0bWlvYXlpUXB6NVgybUlyMS96QUlMbUdDdzFCVDJ3S21QS0xHY3dSRUVFTGRMaUlqamdMMG1VUkJETFJBaWlBVmV3TEs3bVF3WWhMUVNCQkJiZ2pTdXhhTzlYc2gxOEExVFVZV3JMTXFGWkVDMGNheVZJRURUbVFxdlMrYkEyYXpORjZnRk4wVzBkMEFFK0VEMzJReTAzOG9YdEJHRHA1bE5IT3pvVTlDNnZVU3FsRVFFamtBTlhBRjRkMEVXa2NZd3p1NjlaT3pvN1pvdU9NWS8vUUpYclVnTmw2eTVKOFM1cnkwVEw2TFdOMDA0d0lGUW9NRVBzbExmOVJGRGRwaE1CQVFBaCtRUUZCd0QvQUN3T0FMNEF0d0JVQUVBSS93QUIvQnRJc0tEQmd3Z1RLbHpJc0tIRGh4QWpTcHpvTUVCQmdRa3hEaXp3TDhBQWkvOEFBUEFZUU9ESWppZEZsclI0MHVMS2tTOVJob3hKc2FiTm16Z05zaHdvRUtUR2pnVkw2aHpaRXVYS2dVS0pocHo1azZETGdRT1cvdU00dGVwQmtCS2ZQczNKdGF0WHBBZE5NaXhna3VyVUFRVWdETmpBdHNBR0NBVWV3QzNBRVdNQWtGZ1JLbTJLVThBL3Y0QUxCdmFiOTZ0aHJnQUtvSVVMNGNHL0NCRXcvR1BCWXNXS2dTd2lQR0R4NEFHTXpuSFRGZ2d3Mm1WZXUwRC9RUmdJb1hVQUQyVHZYbVU5bFM3SDIwaEo2eDQ5Vld0cHF5QUZyQzU4dURqREFZbFpSbDArOElHQ3hyQlZiMWp3ai9xQ0JROHNvL2luWVhMQkRoRTBUUCtaTW1JS0NSTGRJYS9vdkpuRlpBMS9Sc1FmUWIvR2h4NGpldndMVXFOR2p3LzI5ZGVEZi83Ujk4RUhKQ3hBVndCK0VTUUFBUThDUnNCZkVQNHo0UUVVR3FkaFZ3OUV3QUlKNU9YWGd3eHh5QkJFRUhFRWNVVVEvL1FBUlE4b0JnSGpRQ2FhV0FZVVVOd29oUlE0UXJHamp6eis0eU1VUWc2RVl4QTVRaUdEa2ljT1dNTjQxeDFBQUFRQ0hCQUFBUVVJSUp1RnhHM281V0ZValFZQmFSMVJsUnhIYUhXb0FRbjA2VERDZ1JwUWxobGxKTGhYQW94UUJKSERpWHZtOEdJUFBlelp3dzl1bHZmUEIxTThRSmVGQlJCZzBXcGZSaXFwVnh5Uk9kY0JjYTN3Z1F3L3lOREZHV2Qwc2NrL1JQelRCUkV2RExRRnFVUVFjY1kvWjBqLzhjTUlLMEN3UUd1VDVxcnJoaXdnMFFNU0hXaFF3Z2d5d0NoRnFRTVJzZW9tUVhSQWtHaFRRYnJydE5UZUJBRUdjWG53bG1TU1hUWUNDZis4RlpwakN1MjBsTGttdlhUVXV1a1dSZEpKMWNZckwwOUJFZFF1U3pRQkJRQmFpU25tRVZFZnFkUVV2RUJwSlJSUFJ3RVZwbDd6Tmx6VHdTWVJGWk5HSXRHN2w3M1BPbVdVVkZhWjFaVldEVFg0RjRNa08reHdZbWdwRnRjQUVFelgyUWFkcmNBQ0NwVmxsaDI1Mk0wMWwybGJJaXd4WHd6clZMQ1dBZ0JtdEdCL0pXMlJsaU0zcmVXRUpuOVZnTGJYRWtUWlpKMXhoa0ZuVzIrQUxiYUtMcmJCYlpVZUJETjdNR1BISG1ob0xVYUFaeXlJSi9jVUdzVFpnYzNPUFRCQWRwL0ovMFdXVkhjeFdHVmdEaElFSVlhSFIxMVR4VE9WZVZaekxxUHdBQW9vZ0FzaUR1UjlNSkRtT3ZqM1F3ODZ1S25Ec0NNc3NRUVNTNVNPeEJVOXNGN3NENTBHVVNPU1B3aVpnd3c1bEhIalAyVVV5V0tOQTQ2Z1FXZFRUaVhjeUk2bVJwQ1ZpbE9ybUlmbnJRQlpCSldyaDhJSzU5MW40bzcvU0RGUUZ3UGRpT01OUFhZQlJheWJmSG8rRkVJUVNXVDRRdXFacDVMNEpSaUJnZ1E0V25TV0ZtSFkvUDhTWVFOY1dFS1hNWFhFSW1hQkFBd2NNSjRhbU9nZmZ1cWQ3cFJFSkIxOXozdHVrSUlMcENDREQ5elBOdjREb0FnMVJCWHNqZUFLdXZ0VXFiWmdoRmJsQWxhallsWDNha0FDNHNGRlFTUE00WmNhOHcrNVdPZ0J0M29BQnY5R2NLUWVMS0VESFZqTEFUWXdwUTFFUzJnWVU1N0c2aVZGSFZxeE9EL0JDa2J1OVRPdGlFVmRqZXRJVk1LSUZKaEk3SXBXUkplK21LSXVwV3hsSk1pQmdFZ0Uxa1o5Q2NVbFp6UVh3dENvdU5PQUJXZ0htMkppeEpJdWd4QXlpaHY3STFnVVlpWjZSYVJMZkh5WUk4dDRrVHE2U3lFL015Ulc4SVVSM0hnTWloQUJHU1FIQWhpU2lTeVNDNkZZRjdkb01iRlliRGJLZTBwVEZnYTByQ3d5WktRMEpZTUtKN0pUb2pJaGdRekx1NFN5S05IUVJWdHIwOHg2V0lBZEdDZ29jR095MGxic05URmdLaEtXcGt4YTBaTEdTMjR5cUd5Ny9HVkNCZ0FiQlNobUE3QnBqR1lpOEJqS2JHY3k3R1RQZXB5cEtHeU5walNsb2RnbUR6TC9Sc1loUkpTZlBFaURUbW1hZ1Rwb2x5VVQ1MVJVTWtaeS9jTXlLN2llaDlhNXRhMDlRRnh3UVl0dTdpaVQzdGhHTlFWY3dBRVV4Wmk3YUlRanJXbk1SU0V3SmJla3pKTlRtbER5RHRnYm12b1NhZzJTYVNTWkl4b1BPQWNENkt6bzJyWVdGNVcyVEZFWGxZc0NQSUFRbUswZ0JkS0w2T1E2RXdFWTNLOURXYk1NaUQ1UW5oSDR3YXZrSVE4UHhtTWVEYXhnUFBLaGxXWWtVN2FpSFFBd2IzMXJodndIdFJCR0VpVDlIT1JUT0hLMkJkeHZCUTVJd1Q5SXNBS3pnZ3NFNFBySENCUjdLTVhHcVc1VGdHaGxRdlFtcm80Z0NQbnhEeDlHQktNZXhHRkVuZnJjRHp5M1dUN0lnRlAyV2NFQVB0SW9Vb2JRTHlHRVdsMjVxZENHLzdDaE9jeVVtUW5mTktCT0RZcEY3Mk5SaTRyVm91SzJDRkNCUXBMOGR1Y2ozamtYZ2plS0xnV1hKQ1RxQ3ZjUE9GakJBdkluZ0N6OWhVcXFLUmp6ZkZuYmliREJhK0VaUVExZ2Q5cC95S0FHTFRxaGYweVVBK2U2NzBjOEVrTDNOc0dqOVVHaEMrMFRrcWlLNUQ0alVmQkVKeHJ0Z1NJcTB2d0ZnSG1xY1pTVVJsbmV4VmtrS2lCa0ZHa0tpSm00dmNtOXVndmZhZkdUSHhMZERsQjY4aDc3dW9EZkk1VUlDam1vYnc0K1Y1NFVYQlJMalJJT2VTdE1MVGJvQmxKdVVWbWFwT2MzblhGa2NpYnNsSHVaeENUZjBoZDNwNDN4aUwrbEtFeEJtTWM1RE1BQVViS29mMkFvTGp3QTBHbDNkQVloZ0k5NzRJUFZHVkQxZ2hlODZ2OE1HZXdnZGdxQUtTeUw4N1lGZ1l2WEhxQ0JFLzBYQ3FVSzlLc1FrWXNXa2lvWHBTcEREU0xBMHBiWitkRzRyWUViaVBBRlpMa3EwS1Q2eHhhMm9LeE5RSUVQTE1CV3kxSUthVHRQclVOQWZVc0VaS2FCSHZBQjBLMXlMZ2FlUTVkYmlVWmFwZVl4MWNEbTA4Y3NkaUFsa0l3NUdSTmVYT2NhMHRyYXRSTWx5Y291VWZqWWtNNGlJbmxTTVZhNmNwKzFoTFlPL1VqTnBiZ3lLdnRDamM5V1NiQnlhMXRlYWxTanQ2VnlTRHcycmlVUzR5UktDTWJ1WUo3Yk9OSjI1Q0huR0JLeG1JVW9BSDlKdWJWNHhqM1M2NDcwdm5kT3VKMlVhdmY3WC90YWlVWS9RdkhrQVB3cVNvbGlKcWU5a0djcmZJM25tdVJGTk5sRk1Yb2tOdm4vR3JuSVo1bHRVSDZjSWZtbW9sMG81ak5MMGpRMXErVDRGMXRTcVlWTjhlVVBZVGpIS3JtWGQ4WEc0SXQwcGJmdDNXekhJWEFqVlBRS1hvZ0dGbytqMFNjYVcyVlN0cDR3cGJjcjZmYmlqVmw4L3ZPQ0JMUWlWU3k3blFPNXhUYUMwU2tacDJZaEVTa1FzaXpzTm9YQlM4WnNPVTBxVXRqcTIyYWpLeE5UbGRFUU1pbm5vZ3JXa1NOR2xaSE5JMVpKK05uL3FjaWUvSk5wVU5RSzAvcGVZY0JYNWNjb1Zjd0RQT0JUaTY2dE5RdmFpbWsyUmpETzI1RXZxdGVtTGludmtvRjZ2bmtsaVUzQThKajdSVEVHeDBsdDVxb3pBNE9CRk4vTGMwbDkxUXNlOVpFcnZmbXlkd3JSU3FiNVhQcUZJNFJCNVVtWWt6S1d0U3d1N0lFTS93WThwTnVJVm5VQkxLQm5aOVJpek5VelVtRldDVWxkcHRnbHdtQytJOU12bUlPU3g3OERUcis3NVRWcWIzRTJrT0VlQnVnZTdBUVpmY01aN0FFQjVzUmE3cWN4WTFkc1pjUlJUb0VWdUtGL2VpZDllY2NiZXJjMFp2RWc0UlJKMENJU0JXQk9QYlFlMjFFbjhDUkVmZU0zR0xBVzl6UjM1d0l2R1VnWHpuUVdlck1sOE1KU2RORVd0bEZNLy9BUlprY21STmdUbG5kTFdFWWFhR0ZSTUdOVjZFRjhRc1ExZVJNWE1JTk9vZkZSZzVRUTMvY1dRTFIrSkNVYUZqRWxLdlVBZFVJekNxZzNDaEEyZENFWEtIQXJXeFpNM3JWNVQ0RlRPNVpsY0tTRFZOVkQ4VVNGVy9NY1NCVWFveVlhMkxKYTRhWWExNEVDbXNFZUMvQVpQZitVTTNLeGZnOFZXV2hWTitKQk4rWXhCWlVCR1IyQ1BlZ2hPUytWSldNQ0lmMURXemhWV3dMQldyZEJUZzIxTm1kek5vNmhOdGRCTGc0MUVPaVVndWRoVnB1NE5qSWpSSElDSXZSQkh5UVdqTVI0SUI4UUgxUEFWVnpGQjFQZ0E5Z1RmeE55ZmFma1A3QTFFSFRsWlZjRUU0b0Jib1QzZExkeFZGOUlPZjhBQXA3NEllYm9IcGN4V0c5Q0g1cjRVSm1oVzVYQkhjU1lIL2ZoSHdNaUk3LzFPbnp3QS92SUJ6V3dXY1hpSkR5UUlLTkJpbFV5Z2hnaU1oamlQM2ExVThqeEVuWVhGUWdVRndzZ09aU3pBb2cxRU4waFZyOUdFUEJsaVhWemp2OUFXY0g0SDREQ0IwSGdXKzQxSXZ0Qlg3SWpPeVlTT3pXUWt2NVlIakR3RmhQL2duMjdCQ0VLV1NYWWVDRTh0aFVZTmhVWDlSblhBd01mVWpmMWdWd3RBanYvVURzRHdTSXlVbHlBd2pxdGcxekpKVDk3a2lmaXN4OTVJbVY2RWdSbDRDa3kwRHZIcFIrRWxVc0VzUnFEVXpaVVVXZEF4d2JaVVZnRzBqbWVCU2h4Y0Z3dmtpSXUwbG42Z1NJL3dDY3ZDV000MGoxQzRqNkVhWlk5a2lSTElwVXlBRUdBd283YUpTVWkrSG4rMDFvK0NYUUZNUUJic3liRGdwVi93bGtvNWlJRVVaZ3dWaVJDSWo0NDBqN21RMkE0b21LZTFpTTM4cGdVdENlZmN5Q1IxV0E0WlNVVmdpa0VJRmVhcVJOVWxZejFVU2owZ1I1VGdBVDBTRis1NHoybU1oRDkxVDQ4b21LdnNnbGxNR0JuOEdjNFlqNUpraUorRXBNS3RnS2YvNEU0bU1jZ2J6VlR3Y2xJQTdDR2I1RW1hdE1hNFRjRlMrQnF0eE0rNE5NN2VYS1ZSS0ppL3lBRU81SStvd0lGbmlZa1BJSWtFS1FuTVBJNWRQTXlVdktiSUtFLzZla1FFdmtSQm9RVWFmRW9sZUlZSFVJQ09nQkJwK1ZBK0NFZXloazh3dWdpdVpNN01EWkJXd2tqdHlNajlMRW1uSUdURStabER4S2hGQkZ4a0lkM3JDVWNWbmhSbWlFZWhNV0FqS2daSGpZaThyTWtwL1dTZ3JJbktRa28vMUNUaStobFdkS1FOdG9WdlBGbGFMSmFmdE1SNlZSQTJWRW5JbElzVDdZZkNQWTcwYlZCTGlCbG8wVUMwekVodDFlbEU2Rmx3a0VhR09JU1l2SjBuVUVDQitKQU9WSUczRU1RdlNNRitpVUZiZllQcWZJQ1hmQUNMaUFEdy85akljWUdwMS9DQm1GQ0pVYVdIY2xZbHRjWktxQUNZQURtS211V0JQK2dCS0ZLQkVyd0FtUEpCeWh3QUZJeWVaQWFLWERCR3JkaHFhMG1BNEs2WnFBQ0tyRm1CSmxtYUtiQ1FTU1FxbEtLWjYxYUxRdlpRNDBSTEM1U0JyYTZaa1NBYUViQWFhV0NhS0RDUVNQZ0dIU21HbFE2ck01akt5eHdXY2ZpS2dPaHEyZUFhSWpHS2x1d0NVVFFCVDB3UEduaHFGQ2pyU2JURFNOUUJtN3dBaG5FWWl3R0twcFdFSzRDQlVnQVZLK0tGTmtLcnowR0dScXdpQ3dRSXJKekt2dTZLbDNnQngzQUVjV2pHbzlLc05XQ1RxODRGUnV3bmc5Z0FpT0NJOHp5QlA4d2JCeUJLYmhpc1NZekx1M2FHT0Mza2tiVUhkWFJyaHV4R3NLS3N2SW1JcW00QWltalpoRHhGQmNFd1prMkswTEUxa01Ec1RVRGNUL1RFYlI4MUJoUndWUTJFUkFBSWZrRUJRY0Evd0FzSEFEQUFLa0FVZ0JBQ1A4QS93a0VJTERnUHdBQkNCcGN5TENodzRjUUkwcWNTTEdpeFlzT0J4UWtTREFoUTRRSUc0SU1rSkJreUg4QlVKNXM2REdseUlNWVk4cWNTWE1oeUk4bFI0NWttTklsU29NM0N3QW9VT0RmZ0FBRlBIWU1XUlNBd3BvUEJmd1RFSUFxMVo4K29XcmRLbEJqMFg5Q3d3NkFVQUFEMFFjRkh2eDdzQ0R0UDdKa0MwQ1krKzhBV0xJQklQaE0rVlRoMTU1Z0JYNlYrSlFuU3FzRnF3WUc3Sk1BNHNGY0kwTWNVTUREQUE4RnZUN1kvR0FEV2dpVVNSNGxDaGhoVWFLVWlhbytEVm9nWUxCcE42K0FnWUxGQ3R1NFY2elFjRnNEaXdjWU1FVFFUZHoyaWdoRklTaUFYTENvQUFJQzdkWTFLRUNxVk1tUmI0STlpakt1WE04QzFmNy9RekY4eGI4UkpFYW9INkZEL1hrY1UrTDcvcmVDeEQ4ZTYwZjAyUC9qUjQwYVFmd2dnd3hCRUVnZ0ZQOUE4VU1RUWZRUWhFQXlPQmhFRGdIKzg5OEhLN1NGVkZYUVZYVkFTdEFKSU4xelV3a0VIWFlvWHNUR0F5eG9RQUlTNTZHbkhna2FUTkdlRGozdzhlQS9FeFk0WVE1QWxoRmtnbEIwSVpBVVVuUUJSUm4vTUNrREZBejJjRU1RVnppNFh3OGo4RkVESHlOTVFVS0dTZWwxMVlZQ0ZIQ0FBQkE4ZDEyS2JMWnBWR0p2L1hRYVdBY2tKVmRlWUQyd3doUWpOQmdFbEFoRzJlQS9CdjRUaDBCbENGbUdGRkF3Mmg0Sy94QkFRSnB1Vm1xcFRHek0rWTluQ21DZ1h4bG5uTkhGQzBUOFUrcXBXMlJCeEJaYmxIb0doU09zLzdCQm5YVmVhdXV0VUpuVm1WeThCdmRQRGtadThzOFdVbHpCd2dBYlFERHBwTGcyNjZ4TVphVTFBSEEwQVRBQVJ4dDVCS2RPS25GVTBrSloyZlRzdUc0cXhaZTVPdVVVN2srdXFmU2FTejVCVmhoSFNiWExMcm40UnJTVFNOL3U5VkJDVGIxSkZHd2grWFh1UndOdEJCTzJoVVYwMVdFUVYvWGFZUkpmdDI2K014RUZ3VDhZL0tNQUJKNnA5VUFFblhHMkdjaHdWUWFhWGlXUnBCSk1TUTBsOEVETXdRdXdhbk90cGxwSFpBV21zYzcxTmlkUW1WTk5MQmpHRWdWd3JVQ1lxV2FaMGdOY0ZqVm9CYVJXZGRXWUJiWVpDN2l4UUhJRUVmd0RkZ1FMYkxhVzJQOXdyWUVHZjNTSnhIb2ZDRlFEai92cDEwTU5kK1A5MzkxMS8vOURnbG9MU1ByVnh0QVI0Q0c4MWcydE9OSVlzZUY0cGhnY3NOc1VPSHlnSHQ4QTR2M0QzUlplb2Q4L1BmelFFSU9rQzVRRGp6eWVIa1FaZjdMZUlKUjBCeEdIN0Q0dStNSHRVK2pHVmdIVm5hbFloeUtXS2Z6RGpLUFlra2t3OGZWV3lSSFFPTVUvZkg3UWcrWHFUWUVFQ3haMHdNTGJTR0M1STVOL1VraGg2SFZmT1FJU1NLenQyOW9qL0VFQ3lRTVhZSGp4OUZQRSsvMy9lSUNuQnkycVYwWVhTUkpDRjBMMWoxQVo4QXhFVUFJQy8wR3FCUXFrQzJXb2dYa09zS3o2V1JBN0pPQ0RETW93SUIvMVFBWURIRlpCV25XR01vemdBUjdZUUdCT2RNRVdhcVVBS3J6TEEwQkdIL3VZcmdkSTZNQmF4dklkQ0xBQllkWnFHTGovR3NhdGxWek1oVWlFaUVLV3hqQ25aRVVoNTlySnQ5d1ZrbTl4eXlCVFRDTEdpcUlVb0xqbUprNDhTRUlLZHErOTlJdGQvZ29YdkZpaXhWdDVTNHpwaW1OV0prYkh4UWdOS3duN2lVYmFTQzV6d1pFaWM3eVh2WVFDRm9MY0tTeER1UWxTN09WRmNURXNqeEN4amhyeFdERSs0a1FqVGltS1JwUzJ5S1BWU3pWeG1wUE9lZ1liYmIxR2lJUHNTZEFlOGhYbVlGR1FpVmtUWTlxb2thTlF4bG85L05qSFRHWVFDSmhzaG0zNURGN0VPTVcrRE9TTU1XbWxIVjNHVEU4R1lINHVXWk5CQmlQTkMxYnRMUnZ3d0F3eHNKbVFtU3d0bFFsVG1MakR6STZFUldtRmhNbWI0SldVRDgzbFpDTjdBQW8yVXphMGRFVmdhSm5oREwwNS96Q1pjZkU2MVJUa0dobW50S3dsNXkyeFNXSFVLTFBRYTlsU2FkZDhFOGc0NDh0NmNzWm5ueW1BQWdiUU1XNjJpQVJlNGxPWDh0TysrUEFwZW5Dem5IeG15TVhBYkl4dzA1Rk9RUkpIVTZTQnNTVkQ4VURWUUtQVGlYWlRaR29CR3d2c3M3WXBsSUJHTlBvSGIzaGpHL0xZWm0wMFFnS2YvSUNsdXdXaEJoRWlFT29pMUlQVDhlRnVXWlVCb1VBbmtDbWdnSUluY3N5STVoZWR4U1d1aGFJaGlXckdzcFlOaEMwQzVLa1BDWERBQXh6a2g2dzlBQjFKdXhRamdWenBzSUU5WGVwMjVDT3hCdloxWFMxUUR4UVVvQWhaYUFRZjRNRnNGbEFucVZCUVJHOEJyV09tRTZtQVdySWhiRmpCK2V3Mk43Mlo3NE9CNWRFVlltZWdKZjhscWtrRktkS1JFcVNrSlFHS2RMUDd4eFVJbEtQcDNlNER1VnZCQXc1d3BzU2xLVTNQcE1xSGduZGFpMmgwTFYvYlROUVUwQmx0c2dCNjZwa2JvV1NRQStKK3RVRVNtaENTcFBDcklpM3FIMTFna0hEOWRGanAxVUNxT0NBQkM2cldBVzZTWlZKZnFXQjF0OUxNMHVSbGtYN1JTRHhyTTAreWtlWXNTdTJUamc0MHFDc3Q2Qjg0R2tHVnBJZWpQeFhvUHp4WVFIUjROK0J4MVd0RHFpeUlYamIyZ1BSOG9FQ05ZdFFtbUlTZ1J2MkR2ZXQ5UVFnRmNvWWlJV2dFR3dnUnBVcDhRY29JUklVYjdZQUdzSnFrVUxtS0NHY3cxUmRNSlpCUzhWaEpPVUF1bUV4RVpFdktCVGdhR0FFSTRkdWtKUUhReWFacVZTNXlVVUFaYUlEL3BjcXFDd3U3ZkZvMkNNYzNDc2d6Qm9ZS28zK3dlVlhESWdJVWtMREhqYjNsaUhSTzRtQ0tvc0lEakV3REcwd1FoWHpnc2JRQStLV0o3dkswbEFQT3JTbVZUMkhiRlNuL1JjNHlmaEdXbVU3MUxOSDRSUU5uNnlRdEd3bWlVNDB2ZUpHVE1mdGFDUmhaYmVxQ3pacldsUnFNMGRxVkUzZjlVVjJ2TERaTE9pSkdZTHZwSzl3UmlrS2N1R3R2VVh1T0sybVhkbXp5YTJjVCtDbmFvcUs2MGdYSG5oalJrUU1CU1ZCbzloQlVldnNpaFluaXVJdU5Talh1K2lqYjNtUWlHZmx1cm9RYmkzTGNOc0FucVREdEVOSTA3UDQzSlAyTjZ0UHVKT0RqL3BleEJXUElkTWVNWFJkM2QwVTBubXlHU0pKNEZveDN1U0dPclZaVEVpU2EvM3lUek9DRUZhWTBmQ0ljaDVNMEFlb3ZQaTRGMlNZLzR5eHJhWlRUak9VeW1yUlRNL0g0Y2lXeU1aQzhybGhLQXFxWUV0RVNZUHMramNhaTFuUFlCQ1paSVNQQWF1QUNGcGZ0UzUxeXVsaTlZUm56bnNoU1RvdHpqV21SaGs1cktZMHNuUUZaQ3VGZWdBVnNRSVV3Qk53R0ZyQ0FuQjBnWlNRcFpzSmU0OHFHTWFhVnJ2em5RRjNqeXFLcDNUbUhhVHk1eElJbmtlMVJMVEgwVEd5QWVUSzV3QVVwUWxka3dsSit0RmZLc2lPVTBXbjg1c1RzbDZWRWZuYnlHVXFTOGt5SnpiUXFmMmtoQURaV0ZtUmh3SnY2UkZteVVCTW0wQ05GaWswUkNqcmZ0TWZaNDJuMlh2R0FMeWxhTnJnd2xHWkVhUXRSektLYVlaZWVkMm8wM1AvYW5jV0dGVk5tQThpYWV6NlROY1BsaEhNb1NCbU50NVMvbmFzeEZEVUhNWFJlNHJjVzVjNEdCZ0RJQWpEQU5ad1JBWjZCZnJJUkFWNERBeFFsZFl3blVOS0ZFaDNpR0pMM0xPZ0VReWtrUXhRRkFUcWxVMUdqTktnbkZnU0JHYnlIRnA0M0Z5ZXllbkJoRnR5bGdGeXpHelZpVXZMeEIxNnlOcE1qZ3lQQUEvSGhOV294TUlyUkUwM25kQkc0TVI4Q0hUSmxZa2hCRnBRQkY1L2hBUjI0VTFPVGV1SEVVUHNVVkN4Q01tenhTd2JSVGNIeEFOcWpObSt6SGtId09TUVZQZFRESlZpU0gyWUZBWFlSZUV1bkdGTFJFNFl6aDlOaGhKR0NMM1p5Y1BiM2hEM0ZVSEh4ZDNlblFwNUJNdXJqRzdkaEc4TXhITGpoZ2x5alh6WC93ajc1OFZpQmxUY0J3aDlZRlRwZkpTQ3dWUU1mUUFKZlluZUxoRGhCODF3U0tGcVJrZ0NqVld1SlJFZ2JBUUU4d3l1ZFFUSmxvMXdLcUZUcHNWb2paUi9QQTFJdWtqWlFKVktSU0RlVFdGbUZzaUN4VlY0QjBpRGxWUkJ6Z3lHeXNpRXo5U0VtNGxrTElWb0pZRUhuOGxBSHRubkRNVEs2UVFKOVJUbVhjeDQxTUFMaWRSNStZeC8yNFZmckFWdjA1U2NKOGlTLzhpQ0RBZ1VmNUdHZzR5T2djemUzbzRQS05UQlVJWDRrSVJYT2NTWm5NbE9wMkVJLzFETWJVMC9qb1JzeCtGZDZVeERtZURmdW9SK2ZVeEN6ZFl5a0l6NVBJbzhROGlDVDVTZkJSWTg4OGdOYVVvN0k5UnQ5ZHkvUWhDYkRZNUNnbFdncjBnM2VzQjRXLzNJbG9DTTZYMlZZd2pWWlFJazZVUENSZ0ZJUVRMSVFaZEFvWlRBbHN4TUhnWFVGOUFWYk9WS09QR0NJWldNNGVTRWl1QWVUd1dNWGFUSm5tZllBWWNZZVpOa2U2cEUrNWdnZ0JURlpIL2tyRzNSYkJtRWtaSVlnQm1HU2YySWw2SFVsRFhKY3ljVlN4UmVRZGNFaElmSVBQL1J1YkJBQkhUTlVhOU1pQ2xnYllCTm0vekUzUkFsalBXS1B5NmhZUnNJb1hmQWtTY2tnVURLSmlEVTluTmdsWGdJRFYzTWFreUk4eWhJQVoySm8vWlladFVRMTNWRTFVZk1WdXBHVy9RRTZFV0tPK3ZFMlY2QUJWSVdYbkprb1VBQWx3SldYZFNNOTU2TmZpTGsrODFRckx3V1dyN2tRWWFFcDJKSWN0YVFuWHZPTklxVmZVL0FiM0JRY0xmK2lBVHp5SkRrd2xIZHBqT2cxV0NNZ0VOMkRrVjN5andaNWhOT1pORjBuZEhGaWRhclJkLy8xZDNrb0YwT1ZKVmkxSThMNFZmdkJWUllpVnNpb2xHV0FKVk9BRnBLQ0p2VVpHV0dDRmQxbmFLZWhUV0pnanJWRm5JcmlKTVdaQTRtQ1kwaHlZMTBnQkt6VEE4cEZLek01b1pHUktVbjRmQUtURnFyMVFUbUFKR2VRSkVsQ2x3QjBabTRBUUMrd1FHY2dRT3QxQVd3QkhXYmlvcFdpRnllbVU1dWhnRmkxS0FQMEFnMWtLcUdpQktlaUJLYWlRQWFFb2pLZ0F6d1FRM2VvcExqeWM4aHlHUzNDSUdWQUJLU1NwVVJnWldsV0VLSFNvSjI0WEFSQVFhTkdwcmFTTW9uWkovOGpCVkZHWmxWbUtrWmdCTU5pcUJEQ0cwVUJIYk9wSWg1Nk9pNlA5cFpKbVpRYjFDaHlLUkM1MENwRUlBUkJNQVZtY2FkdjBSYVBpalJUVUZ6bGVEa09NcWdqSkJBYVFCbDJBV0FWT0txM0FoeWJ3WUsxeWdLaTQwQWEyVEc4RnppMUlxdjRzakVZZ0dsNWh3RklFQVRzdFFrOTlnK1Vwa0lFOEFBRUVEaUJBYXprc2srK05LMTZjamVBa2dNOTBBRVJNQzBCUmxyVUdxd0NjYTBndzAyRmRSNGR3Q2xINWtQanlqajJaR2l1cVVQaHNVK3grcTVJbzB1RktSTUJBUUFoK1FRRkJ3RC9BQ3dKQUw4QXZBQlRBRUFJL3dBRC9BUHdyNkRCZndJSklqeklzS0hEaHhBalNweElzYUxGaXhnek9sUzQ4YUZBZ1FNR1Rnd0FnR1JDZ1FaTmxoeG9NcVhCbFFkTGN0UklzNmJObXhaUkVrUlpjQ2JPbmkxWkZ2ZzNsR2pCQVR3WEl2UjVNQ2xEQVFXaC9wTktOYXJWcVQremF0MXFjRUFCcFA5Q0ZpaUFJYVRCc1VjSHFDMDR0Z0NFQWdIZ0xneEFsMjdLbFFwSk5tVWJVeS9Ub2tVOUtqM3JGR1VBQVNnUmMxM01WZURRcjJNQlFQQ0t0QUFBeTNIcnlnd2IxNmpiRFE4ZVBEWWI5aXRidFFVOEZBak5nb1FHRWl3MFRCbWhRWFp0MjFOWVRDRXhlMHB2MTFOcXMyQ3g0a0hZMGdVUFd5V0E4RUJWQVZBRkVGRE11THJFa2tnL2duMUxBTUlCZ1FjMkZQL0U4QzlDYmRja2NPRDRVQnVIaG4rdUM2NGdBZi9mYkJ5elI0em93Yi9IRC85QjlDRERQeklFQVlVTVVCUVVoQXc5Rk5TREh6MEVNVUlRLzlRd0FoLzZqYkRiQ2d1NE5aMVZoeEVna0FCRGdZZlZkTk5KWmQyS2l3RW5Xd2tyYU1CQ0JLMk5VQU9CL3dTb1lJUkIvQkJFRFFqS2tFTU9aUkFweFQ5U0pEamdnVkFFR0dBUEUrNkhCQkswYWZBSGZpVFFzUUtIRUlqM2dBY2J2UFhXV0FKQUlKMEF6aFYwQUl0c3R0a1FYSENpaE5aUkxvMkkxbnl6OVZERGdrU1drU0NUT1FSQlpBNHlsT0dDb1dXVUlZVVVPU3hLWUE3MmtiREFQOStsNmVhbG1DNDJsZ2Roc2ZDQkRESXMyc1VaaW81NkJoRUhHYkVGRVZ2OGcrby9ONHovd01JREN6QUhBVkZzWktycnJveU45UlpSWldIQUFoSTlTTEVKcXBFWWhDb0xBMnl3Wm5ocThpcnR0RC9kR3RoQkVXQVFRUVQvaUpZVFJEb3RSYWRJaHNIRTBrNHlPY1hTdVFsUjYrNks3VFlVTDAvbW9xc1hVT25tdTVSZjk0b2tiN2x5WXFmVVpmSkdwT0s3Q0lQckw3NHFOWnl2WG42SnRCS2NraDBWQUtjRXY3U1FYRFdwcXhGaTBFMFZYY0s3OG5RclVRTk1CdGxib28xMnNXVndaVlpYWEN2eDVGaEJid1ZRR1ZFNlBUWVdCZy9BOE1BQnYzTEtLV1U2SHlmbWFxRXRFSnB4a0IxM21VQWlTamZWWVlhQlRQSldtUTFGVUdVNk8welgxSFF5VFNNTEtNQ3diWG1oRldSY1FSdVFWMUFFSFF4M1hvYjZOY2hIampVMC8vamZmM3BTeUVjUGc4dFF3K0VmK0FaYmh3aEpkU3ZXeVlHTUp1Um9WdjdoMWoraFVSQWJiaFUwYVd2b1RZSERDQjhVVkhvTkgrQmRlb2I0amZDUERub3ErRStFT2NZaHFJQUdJaGpFN3JQUHpwL3YvNHpnaHc0alVJbjNGQ0JzNmNCM0JNUk00ajltY3Z4ZG1RWkJ4UnptMU1JNVZrSnFtZFgyalBEMXBxR0dNd0tOUWQzdmFUQmxoQTJDbXVPVC9GM3hJSlhHQi8vSEZQWXR3Vi9mSC93UndkQkZPY0Mxc0VkQW5OeHNUQW9ZQUFsQVZhb3pqT29mWjRpZ0JGOFFRUW9xNFFVVUxNZ0xpS0NFSkpYaEJ6WGdRUUdZRTRBMUZmQ0VsekxPY0Q2QUlRM2Raa0pRaUNDci90R3FMV3poREZDUUZjNytRWUMzb2ZDSGJvS0FhUDh3VUJRVmpzQUZrSUtDRkhEb2d3NG9vSE1DaE43MWVnSVJwbkJFSVJ3NVNVUE1CY1F1MmlSZURKbVh2QUJBUm9odFppOE84ZGk2SG9JWE5YcVJXbTRNRjJlSVFzWUJNSVVtYmRUWVIrb2tyamVpMElySkNhUkc1RWhGalEza01ZY01wRWt3MDhlTVZXUmtrTVRLeVB5b2xUdWlLeU9rSVVnYjRYSXlveVN0a0IvQlM4Y29pVUk0emZFNGx2a1Y5QzdqRmFOQUlDNGxpbE5SdUloRmpManhrY3FSWk1nT05oaFNVZ1F5a0FGVGFiejFGZVBjYWdOdThkbjI0b1FRazl5U05DNHhpa0s4Qmt5Q1dJWXowRnlYS1NIQVRhS2hCWkVwb1FyV3FsWUFYdnF5SVdqQXpzdWc5NVczSU9XZE02UExOZk9pbExnMGp5akJwQ1BNTkFuL013ODhBQU1yMkZab01FQ2U0ZnlQVzdQaUZOQzJOYU1WekNnMFhucUFlRUlpbHFRWVprUlVHeEVQejZsSDFienpIeDRJMno3RGxxNmRkYXRMUFFTTlNnUHptRnVaSldVS2VJRGRhaE9jOGVIdHBubjdBSlR5Umpvb29hNTAvL3RIbUtJaXA2dVZzM0dOaTJSQnBraEptcVVFbmtoNXBWc21OcFNVaFlRRktYZ05jVmhRa04yODV4OE9YY0UvaGdNZmgycEFETFV4WG9aNjhJRWZ1ZlVIQTJMUWdITDBINzdKOVI5OHNKQit0a1FyQWNJbE9vWjVYQWxIWkwycE9JY0I1aVFsU2REQ0hRZ3daNFFGc1p0clJqQzYwZWxIQjhIN1IyVkhRQUxhQUNjL2Vnb3RnUDR6MXh3VktGQ0JHcENUZnVlSGYwQW9TaGNLUXVvVXQ0QmEvNVVUYTlDWkhxVUNjTDNLVVVvcUNlQW9Uc1I2a0p1dWgzU3UwOEhoY1BjZkNpbklkb1E2a0hNTjRpY0tMYWdNOEFzZThZVEgzVDlvYURkMFdJQUJ4aFFBTTBVUGVqampMUTlMV05qRUNyY21RQVBOQTU3b0ZRd29ZRnV2Y2Qzdm9MVFQ3UnFQUWdNcVE0RUU5WTh5NEdpMVY3aUM4SFNnMWlyNWhnY1BOWStWU0JEUUJ6aDJLSlhxRHFYZXk2THMwS3hFQ0RtWlcxSW14S2NKYlduSmhJQUN4cHFmSHhVSVZEM2E3dzk2NTd2OUJXNUJDd0xWalNZMXhRRnlHR0daZVdYMW1va1dGSFQyQTBEeTA2S1MxQVVveEZBS1FwQkNGMFFsaFJsMEFZTnVPQU1GdXhEbEp1bEFSZ1FJYzVuYysrTVRzaUZYeVF5TGVVWlFxRk9kaXY4SWNIWVZxdUJzQkNQOHd3aW93bk9jcHd3bEZBd3R6RkVzTTRkelpVenp6SzVIcHdWVm9SNG81My9rSWhkbktFZ1pSaUJSYVBXUXFZTE9kSG1FQmhxQzFrMEhCblkwUTdiUWhSN0FBTDIrMHJTcURkS2hEaGxIcGhvb1ZBdzNJV2NvWE1HK3hsa1RCRHBrd2xXdjJzSkVhUnR2Q2pMakZHQmdBK0loeWxCOXpXeUdUT1pMQmxRWXVickNsek11ck5ubkJPTmU2TGxGblYzUmpQVFNkbks0aUcxcTNiR1FiSndqRnJYSWtFdjJLNHpuTGplbTRsaklsOVpzSXVlTzk3dlRKUmg1LzBUY2dlUzJ4T1lTa1hqM2hWMCtTVGhRSWhJVWYrTzdpdW0rZDdkM3NuQlJBdXd1ZzlHa0lhUHA4R2ozbStJYkQrTkZiSWJHbUJ3RUxOei9wcmhkS0VMbWppOUU0TmZlSWsxNEVzdWVnRk12Z1RraldGaU9GWmRiaE52M2F0Z1hFOGtYbWZVU0lVZ2hXOGtmVXBXZU4vM3BqY050TG50ZTVuZnZhMThQeTNxN01GTVUwc2lNWXltUkoxdXN6bkUrN3ZIb0g2UDZMWDBwTnExdlJpOUozMk8vWHJuenpJaXJYRVpwWmpSSkxuZTAyNFNYVW1mMklwTmpSNTJwaG80VTllUloxbkoyZWRvbDZMVnNaQnJIUGhKQk9rU2NjeWxzM2cvU2NrcGFVeXdwSThxdk5zQ3BwWVhKTFNzV3BGeGtKc3B2VC9zZ2dUbjdXUmFHR1hJM1JEb2poT3pxR1M2ZHFYUFVOTjgwVGVLcjZzcVVQUWFXbVpsYVNVNXlTYm1VQ09RbFQyWm9UcllUcjZUbWtKZkpmbHNPc0FBWU9DMkt5aXk1LzNLbWptbU9zc0VzUnZQS1d4VHdGbzlTYkh2WldmNjdqeitueU1BRlhmZUhXWWt0RE94WFAwMitEMEJSVC9NMEVlQTBDd0FhUW5WNmROUVVoekVVejhOYkh3RTU3L1VXckFRWnlLUWFVeE4vTGFFVEtzRVd1ellVS21NYVNURk5BekNBQmpVY2RoTWNVeUFHcmpFcjJtSTNNVUlDc0VFajJjSXRRbFVhbVVFaVJSVTVTWEU5YS9kRElMRXBVMFZOSHRad0lCRVhZaEltOHJWc0FkaEpvbGNhSlNoVGVBSWNuU1ViNHVOZDRpTSs0NU1mdndFRHpkSktrb1FWaHNGRGFNSkR6TkU4ek5GcmxHUVpZSEV4WVJOM1djZEkxZ1NBL1BjQUtHQVFyM1lXWVRJQUNkUXRERVZUSlpBZitpRWhEZEkzL1JFOEdmSWplbkk0ZVhVanJ2L0JMY2sySFdZU0lvYkZXMk5XRk5hU2FSclhFdm15R1Yvak5nOUFJMkVWQVZ2eVZhUklpcUhZTm1kREhEUlZQSGt6Ty92QlBySm9FSVVZT0FUQ0J6K0FpOEhqRzNlWWUwZjFTdFBCUEZNUkdDS2loaHpXTUhZWGdkc2plc2gyYkROMUh2V2hnZ2F4VmF3b2c1T2xWdjN4TzliRlByc3pJQTNTSUxPekp6V1FWM3V6TnlQd0I2OVJITWRuT1ZaaldBeGhRa3gxT1d4SE5yK3lKa2VsYTVOU0hxQ2pBUm55T2p4UUVLTVRLUzBJSDV4Rk9yQmppTEdUSXowUUtETVdLQWVSSUQxZ085ODRBZ29tSVE3eUFhbWpJUlRtTkdjNE9TWTBXTlpUaHBieUQ0aFZmcjZFWnFsR0taMnpBRlBJRzZOVEF6Z0FrNmlEV1NPd1hUZ2dnKzMvVVFLdVV5Ry84dzhKNHBNK29qdHhZRm9FMWlOR0NZNVJBaVVLdGxQNndRTVV4aUdXT0l5SFVUbUh3VHhsYURVSXNHSE54Z2FPSVVUZHNBRGZRRG9Ha1RvVm9sdzFlVm5JQlk0R01WMUQrUTl0MlNSUXNKQUY4V0k1OGo2SHhoLzc0UWM0cFI4a3dBTWNzZ0RmWVNiTjlIZzhVelhPVVU3UDBubmw1aHBVc2dSNDAxa0JlWmN6QnBFTVFpZ0x3aVFQVVYwRjhqN1pxSmRUY2xPSzR3QXJBQVBldEZoMThWak5NUlZtRW96dDZITm9GQUVwTUNNZDhEL0hSb3I4dUQ4eXdBZUtxQjk5NHlRdmRpQklRbDFRZ0YzWXhTRHdRNUVMSmp3bG9ENjdRUUtpNlgwUGdGYi8wekpvY1NhWmFJeXVHVVl0MVJiV3R3RXhGUUVvTUIvLy84QURVNEJrZUVNbHQ2RSsrbkZvTDdZN3FCVUVnOU1EOHFPWERMWmQzeFVjSkVBanhuTS9VekNkSmRJOFpaaWRGYkZ5TWNNeGozRUFyellqc0RHSzAvbHN3ZklBUHRCWlAySVE3c09OTTlZZysvRVBHQms4L0JVZ2NEV09JMEJjQ05FZGlpbWdiNEp1YkdGTmdZUnlrNUV6QlNCQWF3SUR2SkU2TlJDVUNXSmRSRWtnaWdZcWNFVW9nNUlvQnFFaEQwQTEyR21pQm1SSzlUUVh2N0pyS3pBYjQzZ2dSREtjZitLVGZsSWtpeklEVlhhbFZDWmxCTklEdFpHUEJ5QWlSc29pUWRZWmpvV0hEeEFqQXFJb1VNWmxFVFFxVTJZcVYzWUdia0JCYzRaQmtYWWtVSUFoSk5BOFlhcGVZNW9wWnpvbUFLQUFMRUE0T1RBcVJPQm1jZjhHWjBTd1FZMDZaNjhTYVZIMkl5SkVGQUpVb29GcUhTV2lZaXQycUdVQXFYQ0dRY3BTRUlpUUtvZ0FCcmtBUVRrd0F2L1RIVEM2cWU2Q2lXNkRBZXJ6WWdXU0tMckthSGhtQkxrd1EwamlwYitpWVZvcHErL1NKV05sSDNqMUk3cTVId3R5Skk2MnFqYjBLZ1ltTndMa2hNYUtPU3ZnbERNNG03VVJCRkpBQkwrNkJjbENRMFJRYXN4U0FBdndGb0dXclZ2akZxTEJUYVEzQUJvUUlaRkdCT1ZhRUxSMkJibjJvbWZxcnBoRFROYkNHa2dRS3JObXJwc1FCSDZRUUdIaXA5NEVzSmp6R1YxeUt3K2dBYUNXSlArd0NRNTBCVDV3YkViaExPQUVzUWtqR2hhV2JBYmhwTENUS0QxZ0F1U0JnSnNuc3RqelJGOFNKcWtISC9RUkVSd1NKVkV3KzBZcTFyTng0ME1aRVJBQUlma0VCUWNBL3dBc0JBQy9BTUVBVXdCQUNQOEEvd2tVQ09CZkFJSUQveFVjdUJCaHdvY1FJMHFjU0xHaXhZc1lNMnJjeUpHaHdJTVBRWDVNZUJCQWdJSU5RWlk4T2ZFa1M0VUpUUzZVU2JKaHpZNDRjK3JjdVhGaHlaRTJnUTU4U1ZFa1FaY21DeFFrK3E5QWdBQk9UUnBFQ2RRb1Q0a0NBZ2k0eXJXclY0a0hDd3dRSzNEc2dJSURJQmhFNm5LdHp3RUhBd3lBQ1hOcDA0TnpJeGI0QjRFQWhBS0E5K2FGQ2ZjakFLY0NBUk1BdkdCQjRNQk5XdzdOK3JXeTVhRUtYVDdWN0RadTA4T0IvejRZQ09IQjZIOGIvbzBkdUZjZ2hOSVBXRVJnb1lHRWhoRWovaUhCL1EvM0NEOGpldmdPanJ0R2p4bzFQdkFXdUdMMkFvTnJXN2NtOEc4cjVRQUVWUDdMWHYyeTk0d3U1ODcvM2Z2WHIrTUZwbU5IaUxEaU5na2NJM0JNSVVIaUh3b045MWV3V0RGd0N1NFBPb3lnZzBEQzFVRGdQMEgwRUVRUU12UUFSWUlLOWlEY0NMc2hvWUVmVS9TbTNCUXJkT2hZQVg5QnRSVjFyaGxFbVZvQ0VMQ1ZRQWY4MHlJQkNYd25vM2RzUEtCQUFRcHNrRjVzSkh6d2dVQjhDTmZiUHoxY2lGdUFPa2o0ZzRKUXlGREdQMDlDS0tHRXZpRUJuMjYzVGFFbENSMml3TUkvTEpDZzVSOVQ0SmZZUUNvZXNOVmVMYTQ0NDV0d1B1UVVZbWQ2QmhWZi81aTJncGcrMWlDREREbVVFYWdVaEJiNnBLQ0VsaUhGR1ZKMDBhZ2JqZjdqNkQ4dXVCQWdDWUJCSUlDbTNNWHA2YWVWc1FIaUFBOWc4SThHQnBhaHFnd2ozTlpER1ZDVS8zSEdHUThaOFE4WVJQd0RoWEFyUExEQUFTQUNDK3F3eEg1M1FHclBvVWFrRElzU3Nja1dXL3dUeVQrYlFPRkhCQVVrQyt5bXhYYnJMVmM2cXZaQUFhWUtGQUVHSFp5bXJFVjJlUVNkVDNUOXBCQUFOdEYwMUZCQnlmU1N2VUY5NjY5MzdkWWIwOEJXU2JXVXZnaGJsZGhKU2hFVjFiMkdxZFF1VS8yRzVPYS9HRmRrMThac1NYVVJXM1JGaDVoMklYK2tWRU16ZVVYWmlpcGxsUldKR2Nkc1VNUDBhdmFVU1p2RmRmTmU4cTRGa1hTQVFTVVhTeURtdVFGc0dNeldaWHFsUVhCMGVpekF3TUorKzYySHdtd293SURhV0tQeEhGa0JXV2tsOXNVWHkvd1ZTcDRwcE5SQWMza0FZZ0VQd09ickErdngxK3VYYzB1MEhtMjBrZjlRWVlBU0d2Y0RrVlAyZ0tEaGh2OFQ1RUFqOERHQ2p6eHd1TUFHRzNoOXB3QmdnKzJpUUZ0aDk1Q2JBc1JvOWxkc0NQUmMzdnpOTjhXVkk5UUh3ait2cjA2Zm1EalVOeVNSLzN3UUJPNjhFNWhERUhFRXNTdmhpUHNHWEt0bDdya0NDbG1uNTllY0pBYnRNMGhnQzZCbVg1dTNPUHEvT3Q4SkdkeWtvV2NhdVFXNG5aYU9jTy9uSDI3SHliQjdEdi9JOEkrQkF5RnV2M0hDS1NsOEVEL3dVUU1QbzFGTEFQb2lnTkp0NzRCWDJVdW1BRU0zRWpST0NpODR3d3R5OVlLQjVPcUNSTWdnRVNMNGp6TVE0UXhLb0JXdFpKQ2NYd0VMV0NwQ29Bbzl0WmNISEEwd0d5QlZiNEtRZzAwUUlSY1F5V0FYZ2hBQkJVQWdXU3NNSXFqL3hxV2p5a0ZBQWYvd3dUOElKUkFQZHFFSFNQZ0hCdDZtbHFOQkJGNGhJWWtXM1NVUmd5bE1pR0RjaUZFQ05qQXVsaXdtYlRsS1VKRGlFSUZsNW1BcnFWZ1lpZFV1aDhqcmpnU2hDblJHb3NhT3BmRWg5aXBaeFh3aWxTL08wVjlHU1NRZzBTakdSYkptSkRZalNGUzBzeEpESG5KMENtT0pIeE9tcnpNU1pUd3plOHBVNG9LeW5xRk1aZDNKNHRndXVaTk5pZ1FsYXh2TFV1RGlBZFU4WldTUldjb2s2d0lTdFBHc05aSDVXVVJTZGhGZ2ZnUnpuaE5iZFE1U05sWm1aRFZtR2RYUTRKSXp1T0JNbEtLY2lrTUdCa3pxY1hPQjR4b05zSmhHRmxrcThDOXltNXY0MVBsRDZGaEZZUUp3R2N5Y3FiRzJGREtTcER4VFVrQVQvNW04Z0JKUFNsRUtYTVpTbWdOQWpXOWJtdHJVTk1EUU1vbEpUTFhSd1BwRzRKOHlyU2RQQ1ZFZ1JEQVhFWmR0aHpMMERBbmFEZ05MU1Jwc2dRVTRHdVdlZzU0RnFBV2pnbW1LV1hRRXRkbUlhVGhDR2hEeENrZTRHdkJoZmo0VkNHOCtFRG1YVms1Nkl0bktpd0tndllFMGxYTWhCU1FiWVFrVnNvRG9hVHZTazBSUHRaL21lSlU5LzlCUFdDV0tnOXJoWmpmQk9ZNkUrS2VnSDBEaEJ3bEMwUHp5TjV3UkpNZHhQT0JCcjhZVnRMaW9CVVVwaW1kMW1xbFU2MFJWTHdQY3prdGJ1Z0N3YmpVM1FwVlA3dWlqVUJLd3dLRVQvWWNPNkpjNENRbmtmWWs3bkpTRWN3VWtWS2loWXFEUEZQVGFLeGlNajJkTnBRN29xa01pNi85dFozTUlPT3hWSHFDOEZhU2dQVnlpRDJRMUt6Z0VHUWQzblpYQlc0SDNqemk0THdmdTI2bHhjQU9jMlZHTlMwdHo2UTlOQXdQWG5tWXpFQkFSbXppcXBxZnE5aXBQR1V0Vm5VYTNDSUJKVEZyQ2dVUmxFNEgyWW9BRkptQW9oWHJBQi9nUmlVSDhXOUxnUm5DRlZ2bEJCMzhJRHVQb2M2cUpCbzZpS0FoWFlnNlFuUU5ZOHJ4ZWdVcGU0dUtVOEtvbEx4NFl3RUJGZkJBZHJVQkxQUEJORFJna3Z4YlQwTVYvZ2dKMG5RdmRNcmdnVUlOcWt2K1NzNExuTmNXMkdCNWQ2Y2pERjdpWkJnWCsrY0FQQUFYQldVV3dDN09hMUt3a0tFRTN2T0FGYnFEVmxTVW9oVEkwU0FQMXJUQjJnQnprTVA2bHlLWVJhbjhsSllRdVZQRC9ERzVJUWdlN0lKQU1HaUZYZDI1aUJ6WExBbDh0QmxndkxmTmhtUnJNS2JCQUFRTlFBTjFZZ0lRcktEZFhZUGdIRG9rUUxZRklvUWRpR05jQ3pDUG9UcnNHV0VCMEZSUTgrSTlLVzVBSU1tQ0JFWDNzYVVFL2dBQVBhSkVSVDFXRE1yeWdDNXY0QjZWelVTMGZkR0FBcVduS0FRTGQ2aUNUQ201T1c5Yy9wdkFqdStvQXpFaHNDZ1FHWU1CaVcxc2dwdkpodVhReVJxRzh5OXZ4dXBmSHJuM0pidmV5ak52RVRNMHlneStHSkhMY2VpVDN0N0M0UlQ3eXNaY1RPeGhFVnNKdWhLVzczUmVXOTA3cUdHNTRHVHhsY3NSWHdUU0o3bEpLZGR3Q1J5L0IwaTB3bTdCRWp4eURHRTBvNW02MEdhYmVad1I1eENsQ2I4eVlQSXZ4L3o0NXUvdnR5SnE1UEY0ZU14aTZSODRUZzN1N1p4RmhDc2s5Z3ZGdEhxWWtEVnU1R2gwNUVZL1NuT2lDM0xkSTl3aVdrS1Y4ajJIWkY3dGY4a3BUL3Z2b2pWUTV6SW5DU1RZdVVvOVEwYVhhZUxrMmQ2WkVSaVQ3WExFVFBwR3VvOFVnYzVHTDJyTDVjNU5Ra3k2Rk5KaDV2K0laa0hZSGN5N1RDdGJMQXJLaFdEUGtER081dmhVTzhjc29jaUNBTDRDS0JQOHl3YWZTMm5FdlRJbW12VGFlaFoyWGRza213OXNDa3JubzI1c05BVXhUakZrWHdraUVQQVVBbGtZeGsvYnVCSnllc1BRQVhxYjlEOTNIM2Q4dTc5NG83YTNOalpOa0w0ZHBTamhYSDdUSFpGU1NDM3pORDMvb2x5TDNjK3lRcjg1ZVdJYmgxWXh4b05QME4vOGJzWW16cE16K2phdS9rMGdDVTdsak9TMDFvNm52YTV3djB4M1ZsMjYrV2tDSGx1ZkNzcGdzSXRTQkhYRWhXRUhHQmdHZ2U3cEhVcHRCVFdqRGdDNmhVWkF4R0FhQlBUeFRHSzBoR3R1RmZ3bzFOUkVBQTN0RE5mcGhXUnFnSCsyaEFXRmlXU2x3TmYyWGZrSzNKdGtVRW1CamVicUZCamJ6Z0hiSE1HRnhKa1h6TnIvRUlxNWhGaVFWVUI1QU9hWXhHd3ZGVUF4VkgyV1NHN2d4VVJUaWhJL3pBZk1CSnU2VkdQUVNkMDdoSnQ2VVRFWjNlWU5XU1p2aE00ZEJVTkxtTk9pa1V1d2xFUDAzRm02akdpK1ZIa2JvUUFJeUlid3hJVVBDaExtREhNZ1JKQWJ5SS85QUptSGxRbVVIT3BhM1NnZGhZWUduSXZQRVNqUkJGVS8vdHhvTUZEZklkbVFETVJyb2dSb3BCUmx5c3pkSmlGWjBWVGk2TXorN1V6L0d3WWVQRTRXUXMxY2dJaElDYUhSYUVYbWQweUpxRVZ1NEZ4Yitwa1ppUVZBNnNrNTB3eCsyd1I5ZXNoNzFsU2RYb3g5SHlGQm94VDVUZ2p2eWt5QzdFd2NFc2pzakVBUk0yQU82OHdGL1FGUzk0aGdoUWllREpZRFZFVjRXQmhFd1F4Mkx5SWplMDN1a3NScnBKQnNleUZCQ1pSdGhoUUw2NFNYQkZWRnk2QnYvc0FTRU14QndsUU1Sa2lDRHN5UkNoU1ZJc0Q3S3dRUGFpQUt4OWpaUHNTSksxUjNtaUNab3NpSU04QSs1cFZ0MGNtYm85QnBRQXliMjJCdTVnUVAvZ0FNZllGbGU4bHRmOGcrMkFWbDJkVnloMVFOd3RXUTk4RnpQK0ErRC8wTWx3QUVjU0NoUldqSWZIZUpkZmxGaEV1a3luTUlpVEdVOUtUSVF1VVZtdWdVVmIwaFRwckVmQWxFZnJYT1NQOElESWprN1hIa3F1VkVoeTFnL3UvTStDL0k3TmNrL1VqS05GUEtFcmNJbFhkVWhjeE5yS3VKM2h5Z1ExRkZlU2lsYi8zQ1JBbkNSMTRZR0JWQnRlUUlESjhhVjlNRURxaVVmSDhBNmlZTWNSTEppVi9BUGtia3JOZmxmdXVJK1RXSS9FZ0ljdTJFYmxyVTgrMmNhNVNGNXN0Z1ltME1kYXBFZFlJTWltek1pZ3djUjdZVi9uTWlTajNNY01MbGl1WEVjU2JKV3YrTStEZ0lsTXRZZ3lFV0hGR0liSStpVDh1RWhMYlYvN2NHUXFoY1czTUlkYlpKQ3I3bHZZakdHd0lZQnZwSUNQR0NTdmFFRHlvRWJZUDhXSnV1ekc4S1JJTW9GSzJWZ09HanBXVXk0bGlJcGt2UEJOeWUyUHNhaEpSSDJVbjZSSWt4MWp0V1pjN2QwRUdjb1JhbXhQT3dCbDB5amFLVnhYN1NSSWI2eFZsQndPRk15SUxsNUhNSHhBWWJ6bm1tMUlQM3pJMS9DSnF0SkFQNzVuOFcwRUhzUlBXZkdnM0RCZVdyUklmQ2xqRDBBWFFuaGpJYnpJUFhEQnl5V283SGlaUVBCQXpDd0FkWnhRaVRLRVZFWFRCK1JObkMzWGdlZ2YxTUFBc3JJWW9JQ0t6a1FLTG95cFRtd282cmlBb2xTS0Z3YVAvK3pBbU1oZVZ0QmJFUEtGZDZZRUhQQlhlcVRISDRTS0dmUUJXMEdwMXphWm5UNnBsZDJweEdVcDNTMm5xMVNPU0phSGNKU3BqSUNHZ3AwUHFYQkowNHlRVlAycGszLzlFRVRSRUZ3NWtFVkZFSkVvQVJMQkYwNk1BVW84Qnd3czNlQ2luYVpBbjhSd0ZCT0lnVnV3R1owSmtFYnBHY1JZU3VXK2dKU2tBTWpFQUViOEdkRCthbmRNa0JpVVNxaldnTmQ0QVpXNWdhTzBnV0tBbVYxSm1sZnNBVkZzQVY1dGtUUDlnK2NLcUtzaDZ2RU1xQ2pNUUpMUWdJOWhBR3VzanU1Y2dZNGxBdEVnQ3M0MUFWUTBEb280RFRtU0tiVVdpeWlVa1gxOVVLTHBnRTZrQVBOc21lU0poQmJRQVJDTUt1bUFpSis0YW50K2kxWDlSZmtzZ0pJa0NCUzhFR1JFQzI1cG10YjBDUmlvSVlBeTY0RGl6RXRKQkFLd0FLdlFpc1ArN0M2aGlBcktXd1FjQUNDZWJIL29qM2trUm9hSUFPekFyTFRRZ1FQNGdPbWNrS3BVbEUwS0JzejZIUlZHSUFCSmVBQ0x5QUUvM0FEdW5ZR0Q5SUJHQkJzZUNLd09kc3RUY01YcFNKRjdtVWdNaWtGQWdGbVAxZythZEcwb3pOdHBUR0VROGdjdFlGdE9aSnNYQnRFTWpRUXRaUVRBUUVBSWZrRUJRY0Evd0FzQkFDK0FNRUFWQUJBQ1A4QS93a2NTREFBd1lNSUV5cGN5TENodzRjUUkwcWNTTEVpZ0lJQ0x3NjhhUENmUm9FZEQ0WUVDU0JBU1kvL0RISXNXWEpBU0pNd1A4TGMyUEZqeFpzNGMrcVUySEVrU0lJZldRSTFPYkNBd0FFRFlicEVDcURBeGFjcGFXNEVHaldwMWFvWWZlN2N5clhyVmdCTS96bTk2RFNtd1pncEE3Z01nTlptVlk0aVV4TDRKOENvMGFacXhRcUVzRUd2M2JNcEN3Z2VUQmpDZ1g4TC9qM3d5MWlnQUlJQ3RIcWRUUGxnMExJZVRlSU40QlNDMFg4UURENVk4QUNDMkFJRFhKNHN3TGFsVVFnUEhrUllRWUxFQ0J3amN1dmUzZVBEaUg4MVJuem8wUU40OGVPKy8zMFFHSHVEWUxaczV3YUkvSml1Mk1jRkhoTXdTT0J4NU1yZ2J3Ny9hS20yNlFDakcvZ3VackdDUFlrVksyWkhrQjBieFlJVktOcVQwUEQ3OXUxL1NQeWpnNEFqRFBqUEZRSWRGOFJ4Ly9TZ0d4SlRhQkFmQ3hHd01GcHNvemxIQUFSelVXZVVkTloxMkIwQmN4MUdVSW4vbUJqZWl1QnhKaGhzLzhCWFcyN0w2ZURiQ0Ntd29FRnRHa3lCbTNBNjFQQ0RETVVKMkFPUnhCR28yejlUUkRqRkNFL1NLTncvUExKQXdwTi9CT2ZiQ29zSnRsMEJCMFIyUUFBRUhGQ21paXltcWFaQXozMkdFRkVYd2JhQWUxTjhVTU1GTXVSUWhoUjhkaUVFbjRBR0ttaWdBa2tCUlJjRTVkQWJDYkZ0Q0dLWmEwWXFLWGhzQ1BaQVgxWmFpSUVDRVZRWUFYODlCSkdERkYyY0lSQVJSaEFCQmhGRW1DckVQei9vLzBDQ2ZZTk5hdXV0a1JaZzJnYWJBaWlGcWY4UWtRc1JXeEF4MEJreWFQQ1BvMzJCaWV1ejBFNzJRQUVQZUpEZUF4Z29SdUdPRVhUUTF3YUxNUVJYVkRiMTlDWlZLYm1WMmJvWmhYVFNUOUhHSytsSTVhSTBGYmtaWVdVWlVTclY5Tks3NUxwTFZGenBvbVNTWFhySnEzQ2FRclg3MUV4QWxkWFVaUzBaUEhEQlFnMzhFa056SmVUVVJKOFpaTlIwWkpaYzNjTHhOaVh4V1N6MSs2NVpRZlVMRW10Um5RWFlVYWVwTjFwK3M5azMyejhWc3NBekNoRVF6WUtWdFNYOW5nYWROazNReU1zNjVsaDN5OVpsSGNwcHh1VFUxaE9QcHl0bzRENkFBZ3oya1lhQ1loczQ1NXhuMUNxR1lkTlc5bGhDZ1NNUXR4eUQvOFN4WUtnOVhQK2hneDg2SUVIakJ4ODBTUUo3TUV4TFdIUWtVMGN5YTk4eDd0aDBJNlo0TXRaY2FUVEFZbk4yS2pRTFFNY0hIM3NWUGtBaDNNcitzMlJ1U0FUZWV1dS9OWmpnRDFEOHNPRGVEdXAycFlRVWpyMEFEQXNFSC93QmcyMllJZ0VGa0pnOFhTUkQ4TjJJQWh3V3B2U1lLMHpXMWdLQjYvYTBiTE9kbXFWOXlRYjZDcXIzd0VjUU1xQ2ZBL3BGSm5pN0RGQ2tMOE9RUk5vK1pCbGw1RURrQjF5eXRoMkhKQW9BbXFwSHdKeTRTV2NSdUZKd1pQQ1BMa2hoQm54eXc2Lys4UUtCdktCVmlETFZHWDUxaGc3K3c0TXVBQTRKSWtBaXNjeUZRd1ZNNGFUc1FoaExaY3NIT2loREI0VlZyRlNsNm9NYi9JY0dGR0NhQWlUR1RTb000cVQvNWtLQURSQlBNUjBZUVJrZytJOU5HT3VELzJEQ1AzaVlucjEwN0Y3d3NzbTQ0TlVUZ0FueGkxbEQxMCswT01aOFNhWmdFRnZYU2J5WUxucGRURjFnUk5tNFZJSVJmY0VyWHd5QjJMdlc2Qk8xK0dRbGFXUmpRdUFZeHpYVmhDcUh2TW9aTTlPeVJpcUZNMkxKaTFncXhoS04rRXNqVzRUS0luK3l5VUpTeHBMMmNrdkxERVpJTnVFTUtRbHpXQnN6ZWJHQzJZc2hVSXNLelJKbUxqdHlzbWEyOUNST0dwWVVvV2pPSTJWUnpXZFUweHArc1ltWHVOUkxkVTQybDg4QThXa055VTRQc1pOSzVQbGxZN3JjeVhqOFNFeGZzdXliYldGVGFGNVpGYzRBQm1FZk80OTZGQk1CMGl6QWlNc3JFUVJnYzRBTHhhWlRLQ0FhZkVpVC83YW9zVWxrSFhsTVFLWDJ6R3cyQkNxZ1JNbGRZR1pLZzczbU5JSTV6N3I2TlFEVHFBYytHRTNhamphNm55czFxVW03a1ZKdW5xUkRvcGx5WkxFMG1XT2dWaGNCZElkTUJqMm96Q1o1RWFTZ0pnQWVjTk9GU0JPYm9rUVVOZWdFRGJWa3M0SWQyU1kzQTNKUWtaSkVuS1k2ZFFSQkVBZ2Zha0M0d3Ixbk5LeUJEdVFNNHRMcFJLMWpQWUhwNU1JVVU1R1FaeWw1T1k4NnJ5VTIrTXdtUGlqQWtGeEhnNWlqellaSCsrbFBnVm9udTRGRTlSOS9iZEFWUnJBRXdVSElxS01EWHVMWTVpV3VlbFVnMndrUlc2NWpUcnAwNXpCVXUxeFovNEdVOHhUQUEySzVFQXhpRkFFcTBZWUVNWnJRZk9aRG45bHNkSFVDRXB3TzZLYTZCdi94RGJBOWdFSlRRM3E0K0xBMk51NTg1NFlXa0x6aVVtMXlIdExPWXdsQ1BiSnVsaUpzcUJRYjZ1bk9ETjNuYzZpMWpYSjZRemZENmtZSFNSM0lrZmoyZzZiT1ZuVWpxRko3TWtvK0hpRG1IMkZySzN6eXN3QUlFSmMxMlZuZUhjMWtwdWRPNWlTbWVZQUM3cW0wV1hWcXJoaUl6ZEYwdENNY2FHQnVQYWpCZ25EYm9CRUV4MEVDaWQyQytNQ0hDSE8zYmtHb2dReEdQRlhFTkRaRjJha2FFZjJicHEyRkxKSXdqdVM0N2drRCtEeXBCbndZc1o1Mi9BOG81Q0FILytDeG52NVJCaWprVHdiNEMwS1I5ZVRqSUFSaEJCcXcwSXNjVmFaT3N2aFpMdG1hQis0cEl3dnpZUVlRN01JTHBQQ3FmL3pxQldJK3d3dlVyTUZTK2NuL2dUa0VsaFQwbDk3NldqTjVLTHl5Snl1VlBkZ2tjQW9rT0JLSkhTUmkvRG5RVHoxdW9BYU44STljQUdzR1pXQWcrVFpnelNQcW1jVzZVaHZicGdXdUNpR2hCM3ZTNExCRzNTcFR6VmtHNlgzQVlVekRoa3U3bWlDVk1vb0NGQUNnVVhsd1dNSEM5UWVsMEFNV0RCaE02VW5NcTRlOUxBNDk0SW9qY01FTGhIQ0dUUlJyQzVGbzRnMlFVRm9ybW9iWXcwWVAybnBLcFJFMzZNZEIwQUhvRkdNVWlXTDczQUpodzVhcFphMWU0Y1JjOWNvbHV0Rk5MNHlROFY2aW5Na2E4MVhLZVZjdjNtUk01QjBkTmxOR3J2TGdVMm1sdnlVMVIzTFdzbzU0TkRpNkJEa1VVaXEwbDJpaytNTGZMVVo4M1l1T0JwdTRLL3Zkcm4yeGF5Z3gveHY0eGkxU3g0QkhIQ3NhUjRrakc1a1pWSmE4S1JqVFRNTEp1ZktLd0x1T1dxazNIcjNvVFV4R1BPQWxTYVBCQVFPd202a2NJYlBzdVZYdURYS1NQNFExbzB6TFNkeUZzYXU4NWQwMEE0elk1ZjNxY2NYYm1GbVg2U2lSY2pIVjRITHJ2VlI0UkdaWnk3cmYwc3BYL3BkQ1lIWXc4dEFjSVk2MEY4ajFqa2E5WVBPT1FEUTZWTTQxRXFOVUIwVHpMdmhCaEdsSFpHWm04SU9QKytJbnk4V0RmQXlJQllWNk9SUDJvYWpWcFNOWGZMWEM4WXVYdjVTYzczRGhDTXVTZWJCLzVqZVZucittWUZMWmsyY2lUS2dzdkhQVVlMcGNxYUVib2QvY09qSWhLZlBXOEw3d25Ea1p6VmdJVkxlOTg1MWRhbUZocUFVYk9aRUdlT1FqRGY4S2liajdnWnlzT3FIMzcwcG9qdEM0ODV0ZGt6VVhOU0g1ZTdHb0ZUMXZXd3h3OTJMRXNQRVVROWQxTkJqVlR0bmpUci9uSnRJWEdaR2xXYzhGQUVXbkZWakhieUd6TVorQlBJTmhFR3lYRXFqa1dib0NYRDJ6WHV3Qk91eXhYaWh3T08vaFVTT1ZHN1dSQXFWMVlLZGhlRGFUSGNVM0VGZUVkekVGZC9qR1dmMHlTeFdJWXNGVUhrNGhVYm95WUcxMWdvYVRYZ0VpT0ZDeUc3NXhJOE54SXdjeEF2RFJKY2hUTWpXelRJL2xIU1JqZm1LbGZ1YXlVS0dFTUtEVmdmWlVSYWV4RkVGVkFCZ1FObTlsRzFHU0d4bldQZ0x4Wk1WUkF6WFFHOEJCVmNyQkI4ckJBL0dCVlhRSFdjdENPWTJ6aFpkVE9TeldkNnlSWlRqblRDLy9BbHh6ZFNtZXdWaHFCVjk4RVY4aHlCKzhZVnRRNVZRSzhSc2ZFQVNoU0RnZnRRTEJ3MWhuY1VYWVVZamIwWXFQOTFWNjloZG9OWXVmZFMyK0l6UmM4bjg5cFQzaDBvSkhvd0hBcUluZlpWdExKVHNJY293QXNnUWpnQVNDOHlTR000WDExVUpuWVRXRnFJQ1VreEl0TllnbTRsSlhFMVBuNFVmMUIxcmJaam9vWUNYdFVZNUVBNGx4UlRaa1F4dUE5aVNvOVJ1Qzh3L0syQU1Hc2xSUTBHTlhFQVJYMERlQXc0eFFGbVZDQXdNUkFEeFlCVS9Kd3hZeUtFdUc1MC9ZS0lqY0lSQUprSG94Vlh1ZngzLzNWQ0ZGWlNYLzhEbmx1QUNzWlNIcmhZSlJrbUVGNGdjTkFqaEZFbFV5RUFjTVFoeDZ0UjlDRTRudTFIOGw1QjNNLzlNZENkbUtqWE1kSFJNbTBFT1JtK1ZpOC9RMjdjR1JHbENPSGZrZVF0Tk9JVmxhS05BalB4STdKam1QUzRBZ0RWSUREUkpWbnJnYlZWSTBjc1ZUd2FNOFpJazh6UVFhVnBNaU5NaU5RT2xTYmltVUxBWXdvMEU2aXBFNHdkTk9jUVdTRkJLQ09yUWJmYVU2aGhVNHRRVWN0ME1jNVlVYzZFVUNPTUNVNk5nZU1mSVBvL1ZPTCtKRDlKUVloK0Y0ZHRGU21PV1RMcFVBVWljU2xlSVpjZ1VmeWpJRnlpRWNkWk1iT0xDYVNJQWJTaGdrSWhZRVErSmhUdlZoTnBKZUd5VVFVOEFEdThtYnFIVTY3TEVqSUlVZnhOVWR6dU0vcldoKzNmaVpiNkpPYlZNaFYrSWJQSEFsaDBNMGNQTXAvSEdhZERNQ2ZtQ1k0L1VESmttVmNQK29Pc3ZSWVhieWpzSnhoK2ZUWVg2NEFJY2hBQnpTVXFYSGdNenBNU2tSWUQwVlY1R1lOcFBJS3dxd2hnbTJZQm9nT09Zelh1S1ZsYlZKSEh6NEF6aG1qNFNXWS9HVFBvU3pBcDZ4VEFKaEp2RlpueEdCYzN0UkZKN2xHZWJFR2hCUVVhVkJOblJpaC9RVFAva29QMzhsbS9DVFB2b1RQNklDb3pSYUJpR1dhczdoUHlqbVhCb3FFVkdIWHlkMUduNDBpUTlRWTdUQkF5STJZdmdES1BqVHBFWm1ab01TcFh3Q0JYeWlQejBRSVlBWVdZN1NvNU9CWDcwSEd1M1VaUitRWXk2d0oyN3dKNEFpRUg1eUJuNkNac3dHUldUMkQ2OGlCRzhtQlFKQkpEakFKY3NDSmdMVWhWd2FIczYwUFoxaUd5T21wRzVnWmcwa0JHdDJRV3YvRml3Q1lTcHd4cVk0cEVGQnhnZDE1aVY2WVdsL2VpdEVtRUFqSUFNeklBT0g2aWY0NHdLa1FxbVN5cWFiOEVGRW9BUlBkQVp1NEFJdWNBRWpwQ3VPNGl5YkdpMmZBVG9kTUFYQkFZdzZZbUYxZzJTaDFrRWV0Q3BHNEVGLzRnSlhxaGdZQ2ltNXVqQjlNUjhGd0ZheDBRRXMwRG9NQkN5NThBK3JNaXhnQUtjNUVCeW90UURXMUdyUktpK3RwaXNXcFN0cXFJWTZoQVF5SUFXdDBxM0NJaXlOTmhCbDhBTWpFQUhOZ2p3RGxLNEx3d2Fla1JvRHNDa2RJSzh6eEdpTmxndWoxa0ZTb0pYWlF6d2xKTEFGeEFhWG9vWUtvQUU5NEFKQ3dDcG40TERkMm1qR0lnVkJFQUcwRmk1bGtuNFdLeStMUVFDTEFTNGFjQUV2b0FTbmJwSUwwYllGd2RJRlFhQXNpOEVoZWRheW1KTWV6WElBZmRHUlB6Qm1iOXBFVHhRRTJTSVdSb3Q3UW9zMVBrUThwYkVZM1JKREJHRnFSYkkyUVRXMTFjTVhmR0V0QWlZUWJvZ0REcElDSGNBY1lzRnFZS3RDbHpJdFUzUXBBcEV0R0RBZnRLWVliMnRRNEhLME9CRVFBQ0g1QkFVSEFQOEFMQVFBdmdEQkFGUUFRQWovQVA4SkhQZ3ZnRUFBQkJNcVhNaXdvY09IRUNOS25FaXhvc1dLQmdjYVJLaVJJTUtNQXprZUhMa3hBQUNUSmdzU1RIbnk1QUNVTFZHR0xObnkzOG1MT0hQcTNJblI1a2lWUDRHcS9OZ3dJOGVqQ0RtQy9MbDBvZEdtRUFzSUxDQkE2aityQWhKbTVjbTFxMWVKTWcyS0ZUaDI1ZFdDVXEzQ2xDb1NnTld6Vzk4V0NGQ0F3SU1GRy9BVzJERFZhdHAvQkFvSUxnQmh3WU1IRVdDZ2lCQUJCUXNVTUFBVENDQWdJMldRSUN0di9jcTVjMUdPQmR5NkpUdjNBR0dwRUNCTU5Sa3pBTXFYb2E4T0tIQjRBWW9WSkthTTJEM0N6d2lCUFlEcnFCR2tSbzBleDN0ODBMR2J4QWdTMEZlZ01HeDZydXZyS3drVTFDeXdjdmZMVk1rQy8vWk1ubWRhQ0hkcncxZ0FJejJFRGU4aEVJYi9iMEdFRmY5eTZ4Nm9XOE1JLy92OTAwTndJd1R4UVJELy9OWWJFaVZvNENBTGp4MTIySHVEeVRmWVZhNEJCZ0VCazFWVjFWbmovWE1BUWRxVlorS0pEYUczQUg0a3JNQ1loUEFSOXNBR0Q3Q0FHd2tPUnVDRGcwZ2dGOXlQdndFbjRFQWpERmljRE1naG1HQ0NJeHhJbkhGOGZFRENBZ3RvTjVsQUVBaEFnQUJaL2lQQUFTV2lLT2FZQXFHaGtrRlNiVFNYZkN1UzhFRU5mTWdnWnc0NWxDSEZQMlg4MDRVVVVyend6d3RuZEJHb0VJTCtjMFpDVUFpMHA2Smw1Q0RuYnlzc1VKZDhwcGxHNXFXWWNwWm1BYk1OSnBoOEdIUXdnZ3gyQWtxRUVnS0I4WStxaHA0aGhCUTVJUDgzeFFvUGpNZ2xWSm5tcWl0bjZBbjB3RDhzMU5DRkVrVDhrd3NSeCtieWp4SC9FSkhvUUhWaHVldTAxSFpGMjdVWS9QT3JRQnF3TUpBQ0ZCMWxscmhMS2VVUldUWEpkRkJUTU1GVTdidGlFdFdSVC9NR1pSUkVOOTFrMDcwMTVadVN1eUhSQysvQUJOZXJVTHYzaGxWVFFRc3piSmxQSjBIMUZyU2VZcGhXVnB0NXFYRmFwMTBvMkZTVnpWVXd0VEV4OU85Y0NMMDFnRkJxSmRYUVhGYlpKZUZpTHE3Z3JRYkFrc0FDamxQMHpGdVRRRHVIOHovNGdVRDBYWUxSZFYyR0dtdG0wSWNZV3pteWlURkZETlJwTXhiMnEyRVBkTnpwQUN2UGQ1aTIvMFFBTEFzTytpZGdrUU1tR053L3hBbFU1QWhJME8yZ3p0SlJKMWhnZFFuL2xwVllhVzVIMVphQWZSaWlscFFOcnVXWEdVL3QxUU9wL1NQZjVIZ2gzWFY4RzlEMjZ3cTRUYUdCNTkxcTBBSGFFVGpJVzNCUEF0ZURnalg4b3h0MDBObUlIK2N0OGdBQ0Q1ejdPbU5laitWTkpRRWpFcjVsZUl4dmVjQ1hDUnp2ZUxVZ3FUVmJBQytWRFAxVjgvMERBd3RUZk5Ba0h6M0lFSVNjVU1nUWZobFFrRTgrRk9pVC8wOE8vOGp3VHhEc04wcHFHWEx5OFJ5dEcwbzEyUUdxZ2JuOC96bVJ5c3F1OHA0TjhJQVBmUGdIRDJiRkFnVU1BQU1rcUFHcFp1Q0dHZXpwVGxKNEZhSDhOQkJXdlNwOFVzcWNpTWd5SWdDYUVFVnNrSndLSmFjQWNPbEdCa2tnMWhuQVFBUWFLdXNmcUFKT2JlcWp2eFA2OEZLU0tneHQvLzZCQVJNRTUwNW5PTlFaaUJDSERuUkFBWHo1aTBNMllwYUFXZkVqTHRPSVNIN0l4YTdJU3p3Q0U0cFB5aFV3bHREa1gvb3F5QUFKTXNBdGlnZFhYUnlZdURwQ3JuT0IwV0RyU3VOUTdHaVRMVVlNaTJnMFl4d0hSa1dEaVFRa2JseVhRcXJXTGdBNFVpeU0xR083OGdpVWtrM2tMMUxVMkNBOWM4aUc2SEZma1V4WVFUSTBscVdZOFNad2hPTktVSk1XdWxRbEFOckIyRUF5TmpIUWFIS1RQSkZKS0N2cE1IcTVCalpuY1ZmRWRBa3huN3h5VXlTOGlwVThkcFdzK0FWYTliR0xwQllBQWY0dFFETEtLOGlWYnVrZFhGNkVYNzJVMkZuU1ZEVVJXY1psVXBFbGlEUkVvOE5FWUFObTg1WHVmaldodyt6c1JsT0Fqb1B5U2YrQzZWenpVNitzek1POFJKbUVsS2h4M3Z5TXV1Ynlrb2FpQkdZQmtBLzFyQks5VVk3U0pCOURUVjVzdzdrYjRjQnpQZnZjQ0hTanZScU1vQVlmVUU2UUdwU2I1MFJuT2crWXpOSklxWlZtZ3JGREtrRm9RbGU1bXRCa3FBRFdKTUNHcXBtYXdVVFBOYkVaNXo5V2xpMGFSUUJ0TFMyU2dKU0RJTlFocUhWd1l4SnZQanFyU0ZIcEFCczR3SFc2K2NZemVRZGppWnZsZHdvWHBwMUd6NmVPbktpRURCT1o5a0JPUGpINlZGNEVzZ0FXd0lBRStmbGNnMXpYSUNUOFF3Y0RraXBCQ0VRM0pLU05kSW01aTN3Q0kxVEtoZ2N0Z0lGbGlMeDBzWFFLWkhnQ0NkNU9YemFhOTFBVFM5ZWtwbUVrQmJrWXRYYUFOc3FuNjBhS0JORC83Zk1mT09qUkI0YVV3QjRZU0c1TXlrMkxwTE1lS2hrM3RRWTRnS1ErQmxiL3RmS1pzYVNLS2tkYmtXR3U1Vk1Fb005QWNJT2ZzMkhnQVIxQURBdWVtcHZkZm1DM3V4blNiMVlYaEo4bGFBb2xBR2x0ZWFNOVB2Uk1aNHhaUWMrME4xTEFpa2lzV1JIci9pb2pOUzhoZ0xxY29RdVZZUG9QQlJpVkxvSnh5MnhZNkt0NHVrNDViVU9Ta241UVZlLzlBd3JmQzhJUEJ2U0RIeGdIUVQvd252czRqRklRb0NDbStlUFNsclJUUWdTajZDUWlzNGwxV21JMVRrbnVMaXY0UUF6NFlCendpYThNZWVLVGtxVndRVDRoK1I4WWxJTDYrQVJsSjdldkI3TzZDMkNBS3RSSzJaaGdLYU9MZkI2QUc2Q2x0MzFQUnZLYzNDZW9GNXlLL3dpQWFqS1ZEVldvZndqQlZVSW9RdzkwTUtVTkJHWkVsdm95TGlIY3NhNE5BRDZIV2NGSm9keXFWaW1SaG1BNGxCQnlBSVVCa2VCWGdZdW9vQkVNNFlpdUNUMFlpRUFLUnVXQ015Z2hoMFpRWXFxTGxlY2ZqQ0FDTUw1S2pUZE5hN0VKcEhRMWVJRU1sWkNMR3pMTFdHZVFnUVltRlZhZzB2cllCSlFVV0drVGdScElRUWxMUk5ZV2pQWGhIb1MzQU5jVUtsQW5obXdiZDIxQzB2cUhCcFpqV0R4ZHdZa0prWW9IdXMxdUxLMXNBeGhvNTA3bUtKNDZ0dnZlWmF6aUZxR1N5cVRnYXJyNEpwZ3B3MGhHTWNvTGtZaFVKRWxFQXoyTU1reU1BYjhVdmZjNFJqc09WRjJlbkVtUHhWZ1dqOUFrNGw3NUlpOE5lY2RFUm9TUkR2OHIyVTNnbW5MTUJBWGtGaG40dnZtWWNIU1J4Sk9OaE9Ra1VRbklQMkw4SVNhSHVSMW5Qc2VhUTN5UHVueEtRakFqdlhRbE1pVmVhU3ZJNzBYeU84NUU0MVpjT3M4MWpoSjNKZDNtSWcrNlFsQkRsNFdvczkwRkY4b2MweGhKcDlEUjVXZHFDeGxWbm5XSFVJWGJFYUhsVkxwdDhrQTJMSlFvdC9wS092bVRoWlZrdW5jZno0Z3lXc3JHNGIzaTJyeTN5cUZPTDZYNE80MEtjem5oNVg0bU1Ub2VsdHRlWmxXa2ZzdHhlb3BqSExxN2g3UUpjQVE3WGVjTjZ3amMzVjU1aTE1Tms5b0pEMlg5TE1WSmVWWThIT09hOEd0RkpRMEJqeW9mNnREVG1JYnZoRW52NGExc25uaFNhTytNYVhaU01aMVJiYUxvcWRTeUVURlBKUy8vaEd3MDNQV0F5VG9DeFE0ZWtXMTRudXY4SUREVDhabllBdis5bDJVcCt0c2RQRmNiQWNNd3Btd280Q3VPb1YrNnNSdmFBeDFUOEZIZDVRRFh4SHVJSTFCM0JCSWQ4aUcvUjEzVFpVWW9JekpJdFU0QlkxMFNNMFI1NFU4MWd6TWFRQUlsa0JzbEtGSkFnMkZ6Z3dQaVZvSlR3QU1DZ1I5Vm9qUXp0WFJ3a1RoYmtSV3hSR3VvdEZSWE1Sb0RKQmltTVRtU2d6SmRkeDArRlJwcHNRRURjQmUzQVR2emhRTjBVNFZNSWhESmNSeHpnMXQzYzErYzh6dlN0VFJIUjFCN1J5SUV4UjAyVm5aTTZCWVlCV0ZkOW0wOGRCclgwWE9DOFc3LzBFNHJFZ0U0d2h0RDhpTUQ0aU9wd3owS1FvWDVsRStQUVNWRFpZTTBOVXZoMFlnRS8xWlFaRGhMQVRCcjN1UVNKbEZSVXhFZkVySXRYV05VWU1NcFBxWkNmRUZFMzhVWUtaaGVXTFU2YjRNYy8zQWdURkkzQUZLQ3c2VTNrd1ZSVFFOTGtOaE1mNkY4ZjhOV0dHTXJGc2d3QU5CUW5BSTUxS0ZsaGtFaDhnRTJBeEFmWkRNUUVCSTZuNE5iNG5aWXFrTWtXZlViZGVOWWR3TWhEL0JpRmxJcFJLaUJJZk5LMGFVbElLTVpKV0laNlBobFBMWlVHUFVleGxnZkN6WlhZM1l0a3NNNytvV0MzUElQamtVMy9sVUNPcUFEQ1lKVkJiazZJMUFDM05ndEx0Si90VklycVpGWHFvRWRzSlEvTTBZVlhTSkxBOVVkSS9RUERLQlRnK1FTUitnQjlMUmEyc0kxNlBHUXRJRTVxbUV6S09nNS8xQUNNVGtGU0VBQ0RGSTN6UDl4SEtsNElJelZIRGpDT2Y2RWlFRWxJdFVFTTVOeWZGa3lGMDZ6bEFZaGRRbEFFQXp3Wld3Z0kxcFdIL0JCSTRpbWlkZUNPUVBCTXkvNFdCcGdBZzZDV3dPcEhGbWxYdTNGSkRnQU96WWpIVzY1QWpEZ0FFQjVUZHF5Ris5eEFMVVNhSUZCaG0reE9NYmpsNHZUYlEvMUtVQkZLYWZSWE8xRU8xT1FIenBEQW93eFhrK1ZBdEJoZ01iUk91WWxOOGh4VXJ5Qkk2RURPejd6QngvZ2hTLzJBS0hHT1QzemhRc0FKb0hoU3BvRlM0eVRHYVFIY3pCRElmOFFnTG1SSHpZem10cjNBRERna2tzU1dCcFFBbXpUWGlhbElHZVdYcjd4Qjd2QlBlY0ZOSUZGWDhxQlVsTXdIVUxGZWh5eWZDb1VtMEkzZG5leElyUnlHRFF5T1lMLzRRRXBXU05tRXdHaE5qcW0wd1BjSXlTdGs0cC8rQVBjZ3lSSVloeW9vNG8rNGo0b0ZacXBHUzNuZHlXSXM1MFZjU0ZmTXhnUTVoWWVJRURhSWlIa3hSdEJrR0h3QXovckU2RXFGZ1FXR21JY2xnTXBacUhpVTZGWUZpbW1VWjJUK0ZraktxQVVFV0UrQmtrWXdqQk1LRkZBbGozbnhRY2haajdsa3lkSVppZEtSajUzb2o1MDBpZzBhajZPVWdPek1oMUhPVGhia2tJbWFoRVR4cUxtOGkrelVSc3hpRklTQkFWMVVqNTNnaWQ2d21SODhpcDNJZ1FDWWFNTnNhTXU0R3FPT1I2VUZVdVVtS1FYY1JSS0l6SnVvUm9QNEJ4dklpZDBpbVJYV2dZem9DZDZra1J1bGtUUTFnV0U0cVZaS2loSmhHZGVXZ1kvb0FPTE9ZclgvMGs0YW5vaVVrRWpDc0FZRWFBQU05S0tCQ0dJZE5NOVROWUZnT0luR0FRRmZOSUZBbkVHSERRUXJpSURycllDdkZjWFRmbW91MUlic1BaQTdYUVlUNmlIVTJBY2RzcGtlbW9velpKRXF5SVFzT0pxWlBNV0d3S3IwOElHS1lSUmIzb2FZK1lZVTBBcWZRSm56U0lRUkxCRVMrU2xPU0FGaVdVMnl4V2l5QW92U0NXZUVSVVlLOU1CR3JBRU10QW5MK0JteEhJc05KUnFoK0lDU0RJQzFEbU9qeGV1dWtJWTFLTlVwQ2x1YnpJRE1hUUV6SElvcUdLd2Z5SUZJM0FZZ1dHWSt2by9RNlFBSHFBQW82TURaWkFFT0ZSRHl4S3ZSTkN4NzNPSDJnWldkUG13eTJNcDd4RXFPS05ycTNLdHkySUVXMUN3LytBRGV5R094MHF5eTNmalp4dlNOYTZUQTBuUXNXZWdMTlAyRDlNbUJVaVFMWVNoYlBscXMvQUNWRGhMR3hoUUF1NXpaOGFTQ3k5THRENVFsNnlsdEQ1VVBhT1lJT0lUSEtSYUJrelFBV2F6RitHbXRjdkRCb2oyaERNU2J6bURNNjNUQVhlSUFheVVvR2hyUXFQb0FWZjVyMlFqdDlxWHRIZDdRaWZidFJjUkVBQWgrUVFGQndEL0FDd0pBTDRBdkFCVUFFQUkvd0QvL1FNZ3NLREJnd2dUS2x6SXNLSERoeEFqU3B4SU1TTEJnZ0VHQ3N3bzhDTEhqUWtKQmdBd3N1UkJreVVCWEx5NFVTUkpsZ1pIVnB4SnM2Wk5oeDVCNWl6STBpTkJrZzVOTnBRNWtHTkttVEExRWl4UWtPay9wazVqR2hVWUZlVE5xMWl6VXBSWmdPQ0FnejhEREFoQTlCL1pueUlEVklXcXRnQlRBdjhXQ0lUd0FJTGNCdzhPUEZqd0lFSmZGaXNBYXlBeG1BV0pmeWdlSk42N29RQ0JBbW9GQ3JDcXRiSmxpMmM1TW9YZ0ZrSmpDQ1NQbHZ4SWxTVFVmM2d4c0lpZ1lZV0dmMGorNFlnOUl2WS9QenIramRpOUc4a0lFbE5JckZpTXR5NW56bVRKTnB3c1FMUFo1dEFsazU1OHVmckRzVStwRG5BTEFNTHhBcHpCdS8vMTROUURhdFI3V1N3QXZHTEY0Y0dFUi96TDNhUEdQL3M5OHUvV0lmLzNZUmFyNFRVWGFvbTF0OEFDRUlEMEdBSGhGU0NBZ3c0U01GbEdBa2c0R1Z3Q0haREFBZi9BaGFGMUlHcVZvSGpmSGJjZFpFOGRoMWNFRWZ4RHdnZ2ZqRkJERHgvVWQxOFEvL1R3d3o4eS9CUEVEL1hsSjVCOFBleFdaSDc1QlJGa0Ric0Y5ODhLTUN6Z29RQUhWRmpoZEIrR3FDV0lRTVhrRkZONEFSY2pmalhVd0ljTWZBUWhBNXByeXBDREZQOTA4UStjVW5RaEJaeGxRUEdQbmxEQStZOFFmd29rUko0N29qWWlnd1Fja09pV2pEWnFHUnRxQlpDZ1FBLzhnNEVDQ3Z5alFXNVNuUEVQRVovK2N3WVJub29xMEJtRDZxYkJBd3M2bHFXanNNYi9laGtiRy95endRTVlQUENhRkM4b0Vlby9XM3hLUkJsQnNJQkJZeHhDZ0tpc3pEYWIxUWFlZWZZQXRQKzBTQUpoNTFIMUVFZEpGWVZRdDBwMXBGRkxJM1ZWbHJQb05wc1J1T0NPdXhCS0xwbmxMbWtHZFVsdVVqNlpsZEcrWHpZMVdWUlZwU3N3US9RQzVkSzVESkUwVmsveUluVlV2QU5CWm05VDhtYm5scVQ3bW9VaVdXNDk1ZGdHQkRDR1YyTW5OU3pad000K2ZKUzNFbk1IV1ZmL3NESFFTLzlnZHk1VVVERW1GMkFBQnViYUZLOU5zUnNPTWZKV0VBNkVrU0RHa3lnY21CZUNpQ3BIN3ovUUJRRGRxeEpTalhKMVlrVlc4Mm1jL1JOZWc1d0JBTE41WWtOYkhHSXdzT2hhWVllUmdBUnR1dVhZM3hXMUlRSDB0UUFTLzdjQVZKT0NKelpWa1VJb3dJTWRaa1RBdmhWUzdhSFZIVkpkcGVOYlp4VXBlVjFCSUZaWEw1c0Z3UURTZXNaWGNkTVdkK3RmaGgxbVVKRjI2MVpqMGYwMU9ZSUdHb3dnOUIrMkM0Y1lYdTRGTjRXVGNqMzIxT0lja2lVQUJGUW1YOURobFF1OHNGbEx0V1h4WEFYQXNNSVVQTUI0SkpJMXVDbURubnQyQWI1QlpmaVlRNTRDZ1E5RkVGRG91YWFTTlh6d0FXSi9DdzlYQUlySzNQeitOVVZLRllNTHNCNE02bEs2Q0tBZ1IvWXBRNTFlWUtvem5LRUxEaXpWcVlRZ0JXTE5qaStPaVlxaStNZEJScEhJS1E4d0R3dDZ3Q3Nsa0VwVVlBQ1ZFWUpGQkNNUWdRZ3lrSTlqbEpXZER0clFVZUNCRnJVMDFUMkJ3R2xVVVBDQkJmK09WUUJvYmFZQWxSSVhSc1pGbW03aHkxMDNqS0oxMWhVVEplb2tZVHhabDFDSzhoSXR2aVFwSm1tWEZQZkhyVzhscEN4YVBFa1h6eml4ZWhYc2pRWlR5TlRHYUIyWVVMR0tHbW1pdUJ3R2tUa2k1Q01aNnhKU01IS1IwOVRRa0NnQ0NTRHBPRVdXZkNTTzhGSlpTSGhTcjRxWjhTZGN6Q05Mb0NLOGwwMGxPU2JMaUZ0RzJURThtczJQaklRSXpiTFl4VmFXU3lEWStZclpRdU9UTU1vTEtCbGpTeFVmcEptd2pjaGlPZVJMQkZZUWdiNnRBRFY4d2VDa2tzTVI2bGdTbGFsOGx5c1pCajJNakdWaEVnTWtKcmNvU292OWJTK0tpZElEVnZBQUZxQ0FQZkFCRGdsNGNDMG5FVVl3Z1ZrQU9UZWdxSXRSVFdvUFdad2xvOW4va0ZaV3MxeWQ2WmptUEpBU2d6bEZsQm41eWxlUXlUdkRHRVlEUUtzZEVsN2ttOWpRclFlNitVMXdBa01jdkVRTFBNMlJTTldhczdnSjNZK2ZDakdOdGtiNXk1YVJoS0JraWVWVHZGYVE0aFJ6QlNsZ1FkQ1FnQVBkOE1kSXNhc04wUHdUbUFnTWNIVGVBUS9IdkdiSTVkMnphaGdpcVVEZ1FwM0pjTWlaS0IySlFqc0dPcGFLNTZ2YUVodGUrTksyY1pZVEJhM1JnRU5wVnpmV1lYUitkZHZOUDRBMmhTY0ZDQzlGNUV5dFNEZTRSTUtGUXcyVGtHTVNOeVhJQWZaRFdFVnB4TFlxbHJDSlo2Wk1rUjZsQklRYW85NjFMNzNUVFd4WVp4K0IyR2dFTk9yUFhEV2xWclVXa3pDK0U4NEtvQ2EyWkNabUFZcWlvWVFDb0U4Sy8xbnRRNHF5a29RQXE5aUthSVpEZC9rYmdvd29uZ2NVY1VXWkhZRU9YbmVmNXQ0SG93Zmh6UWh3SjU4L3pEV2l1aEdhZEczWEhuSFdMMExNb1VwSUN6SzUzbWFscTU3TVl6WTdkeXNVQUFkR3V3a0NqUGp3anh6OElBZzUrTjczZVBTamZ3QXBQMEFxU0ErQ2dDTVpFUGdILzIzU0ZFQ1F6QXhPQm5sVlNsQml6YXVWcnBrTXNwRUJqMkxlYTZZQjN4ZWpQVEF3ajhhWFBqc1pCRTVReUZNWlZNd25PZVZKeFAvNHdCUVNNN3dDeFBaVkZFN1pYRzVWekx2NkpRTHIvQjF3QmpPRi9Kd1BUaEMwMDUzOGhDb0lBa3FDWjVCQ2luOHdCUllZOXpHS3luS082VGdWZ203SElBOVFBQXVtVUNZWEtQQUZaM2dCcUF5aWhBajZVUDhLUmRKQUJFckp5UzJibHcxT2NXd0JNUEFWRXRUZ2ZHb21sYWRHTmFwYytPb2ZTcWhnRFY1akVCemIyYzdHVlFBR05pV0RMcGpRVjJkSTRSWldTSVFzRUVGT3FISExBU2IxNkZJWGhKNkcyb0FIT29DRU1qeFFncUtDQWhMOFVrVEJ6WVczcHJhelo1NVNxU1Irb0V6UWphR2xicFhuQWVndjE4Z09OUVpRczFDYmxGR09sRW0ydEc5cFNqVlNacEZWVE9PMHgyaEhKbFp5bngzWjRoTG50VVNhYVh2YjZIcTJSYUQzTURsQ1RDUmNmR1FXMGIybE8xckZrWlRFQ1ZqR1JiTlZXdHRlRXhza1VjUkk3MzVXRWQ0Vmt3bHBFTGFTYjlkU2pBNDdHTDdEMHZCd1FiUGcxWjZLdDZITnNIalorOXZ1b21hODR3VXhoZlNyaG9UL3d6aTdVbnJ0c0R4RTVDa05wTUpaT2NncjlndERiRWtreGU3WnVWeDN5OTcwNGlQRHprVnhiejJ4bW1ja0pMc3RlWnFtVzZWZlViblE5SncrMDJUMzVPUGhwa2didmZWSFJlTHgyTm82SG9OV3F2TkR6dERHT0NQbE5RMHlZZk1heGVVRzI5YzB1eFpac0h4OGF0ZytwRXBBQXFFTWNSSmdiUUVjZ2toSGVNcFNaV09nMUZxcGNibDFOV2JNaXRyNnVNZk5GckVsYW9aQlRTOWw1RHpXR0hDMmh6MmZQMmROLzhhWkExaU5tWkJ6Wm5TUVBVZC9idkx4VVZsSlNuWiswRkVlQUZvTHVGVXkwU05NRkF5elBlMXBwenF2MVJvVzdBNHZCMEE3OGlLVGVxZVdUR3R0VDZYS2l0NmwwRFRsNm50RTJGZWFqbnU1TE1BdmlWbU4vMnQrcGs2aHZRZ0hJMEEvOFhXSEFtSU9VQyt0a3RwNENWYlZDMi9abjAzeG4xZW9yOGt5UnE5amVZRVk0Z2RSdEVPQW1yVmQ4aEZYT0RBRlNNTlI0SFFnRGJJeDIvSWNEdklja0dOcVMzRktPRU1lR2pNU0d1Z1NUdUVWTWFVV2RMRWlBSUphdFZNQ3NGRWJ1WkViUkRJa1RiS0FxdlVBNHFRWERSSXBGL2NsMUhGNkpLVTRKeE45ZEtRd3VVUWlrTlVkKzlJMVhQRksyOUVkNk1FaUFQSlFVMkJSRnNVZlB4VlV0aU5rN2ZGYXlHZGNHZVEvME9RZ3ROVk1ZVGhlcVhjbGphTllJb2dpZ2dNenBQUXljVWQ1VUhFNkpuaFRPZ1UwYzBVYnVURWtHVFU3dS9FYXFzVWl4UUYvR2RRcVZSY3BjR0U0aEdWYkZFTmIvNEJyRXYvaWFIVDBGYUlrT09FaEtRSGxNbDlXWEhUeEQyMVRMY1BrSXNlRUxZTVJHMWZRT2lNZ1gzdW9HMG16R3VwUkYvUTBXSzNpSVZNVk9RU3dPTGJJZzg0MGhuLzFIRm1EYTlFa2laQTFLVjAxTnBlNFVEbGpGOGxrVHNEM0pDUmdHQzZTVVhZalgva3hQNkFsVjRUeEdvQVJBYU5UQUFOUUs4bmtOSCtqTGNuWE1NM0JnMlNCYzFJbEdZZjFEd2d3R1FnUVRiTVVLWjh6aVYvMVZXYkRqVStoTmtpRUh1YTBHdGJUSGtPRkE3WGpCem5pSXpFV0JQaWhYQW40akdybGU0cmhoT09uV245alNEWW9KVzR4SVpBQlZZeW9QSTVESlJzQ2hGS0VCaWlDWG85bFQrT0JqMGlVa2tuVUY2TmpVNnloS2JOUk4vaFJrQmhWamZ3eEpMLy9veWwwUllDMmd3TThVQkNlZ1VUdE53VlplQ0Nib1J3bk0xdVMwWXVOeUk3SWhvOVN3eFJqQVRnYklCY01WUnpTSW9kOU1VNy93QU1mUURSQ0lpTmxFbU54QlYzYkZZVjhhSDQ4MDR6WEl6UTVTVTU0TVhZT1ppRWRJbldQYUNVWWx4QWtVb0xUOGgzY3FDS1lkUzJIb1Z3MWNoOGRsaU1neGoxQ1VwTXdLRHQ3bUpDN2NTM3RFUmZCZzVlSFV5WGx0WGw1K1VkZTlUa3ZBeG5YeEkyQ1V5bTlJMTIveGdjNjRsOEVCZ1VHQm1NNHNwaitoWmcvTUNNQmxpTktFaU5ZeUNvZFFsVVZXRks3dUpudllubHFnVWthWXhaZk1VN1lBMTl5bFIvMGxRUDQ5UTh2bG1Mck01MXFraU15Z0ZGcXdwcjRaV0FFVmgvV3VGb2NraWkxLzBoYjRPV0x3Q2xIVXBNVGhiTVpLUEE3UlpNZk5hQWtPNEpSUDVBRDliVW5jd0lGNHNNbmVDSVFlY0luS3BhZitTVmlNblpNVTVWQlZGT0I1eGtSNjlKVVRrY1hZeVkvOVpFbVBjSmYrWVZmOWxrUVAxUW5QbFErQlpGaTRSTW5CNUVEZkZBRHdPTWhmN2VnenJaUUt1VVpNR0FZOCtPV0dsVW1KU3BkSWFaQWNkSUZGTFJrZDlJblBsUXFvQlpsY0lLUVNJQUNJTE41YjZHaUllSVdBL0FBb0hNY3QrSXpIUFZlL3FsQU16QW5kVUluT3ZwQXA2S2hLZFlET2tCTVVuS2d0Umd3U2dvaWtpSTJYMFdDYnJGWEVUQUNhN0ppTTlBcGJ1QkFKdVFwSnlRcVNwWURJMUFDUmpwWVRXR2VaN29seUhFeExZVVhIVEJtSVRZbnBmL1NRcU1DQmdiaFFQL3dBdlk1VVgySktLUTJxTTd5RnNyU0dBV2dBQU9nQUt4eG82T2lCRVlnS2hGRUtxQUNLbWRBb3JOV0FNR2pMR0NucVpVekxTNVNBeTd3QW1xV2FTZDBCcm53UWk3MFFsMUFaU3lBZHN0Q3E1VXpJa3loQUIxUUFqTFFLYXdhS3IvcVFsdXdCWWpnSzFkUXJPRnBZOGpLUDJ5Z1Z4andJcFZtUXFheXFzR3lCV2RRQmt1d2JMTDFGSUxhcmVreWp0a3hhVDlRcDZPeUNXdEdLajJBQkIwQUxTSHpyMkVEcjhuNmlqbWtBQnJ3SmxLd0NWRHdRa1FnQlZmUUFVU2tMRnhJUXdKYnEvdDRIZy9RQVNRZ0EyWGduQVVoQXo0d2JPR3hjeFc3TlUzS0ZCNUFMYnp6SW5JbEVKY2lJQVhnQWJOYXNzMFRMY1lUdFd5OVZreDl3YTYxUXJPTWhGZlpNaE1CQVFBaCtRUUZCd0QvQUN3RUFMNEF3UUJVQUVBSS93RC9DUnhJTUFEQmd3Z1RLbHpJc0tIRGh4QWpTcHhJY1NLQWZ3WVJYbVFJSUdPQWpSZ1BYaHlac0tQSmdSOURidXo0ajJWQmx5a3J5cHhKc3liRmxSbGJMc3laVTJCTWdRTXdEdmpZVTJGS2d5T0podlRZMGlCU2dUQUhGdWhaNEYrQnExVUpZSzBxa0t2TnIyREQ3alQ1cytsUW53QUtnRndLTWlYTHB3NGgvRHZ3WUdEZEJROVFzRUN4WWtXRUZmOVlBQjY0Tis4RHZBY2dGRkE4MVNtQkFBUUdDdmczbWVEa29tSXphemE2MXVuVW9Xb3p2aVVZdW1xQm9SNEVRcWo3NzBFRUZpd2kvTk13WmZZSUpQOUdDQnd4b3NRVURjQUZ2OFlMUVd2anh3R1NWMzRZUUlCQkFZOGpFeEJRQUhyejVwT1hiOTVPTVVCVnA5NDdmdi8yN2pZQTZPUldyMXFkdStBZkRCVC9TUHliZ2dUSmlDdi9ndlRvTVNMSVAvNjUvWU1iRGhxUUFOd0tMQWprRjRJSUxqQVlYcTFKRjlrQi84aUZFWEtVWFpkZFNBSkJKOEFCSHdxUUFJVVVjbWVpaVkwMXRwUjVubFc0d0Y4b0dDaGZnU05NTVlJT05kUVF4QTg1eVBDRERFSFVJTkIrLy8wanBJNDlmRUJrYmgrTXdFY1BSZXJHNUFja0REYlFoRGt0cDkySlhIYTUzbnFtZVVlQWhZR3RRSUtNVTVDUVpwb2E4RlpERG1WSTBZVVFYWnp4anhzQ1NTRlFuSHIyS1ZBWGQrYXBadysvSFZZQUFWcGxkMEJrWGpicTZHYUhGcmRZVndNbzhBOEdUcFl4d3hrdkVDR1FFbjhLUWNRWm9IcDZSaGN1OUVBQ0MrMTFWZUtqc01iL3l1VlZDa0NnZ0FJKzlOQ0ZFcDcrazR1blcyenhud1lZVkFYQkJwRXRNS21zekRZYjFnTVBGQkR0QXhzY0c1aDhnVjFhYldzTllYWlFVV3NaQlJGWkYvM2trclBvTmhxdVR3bDVpNWxvVGExYmtrcjBEa1N1dlR5dDVSVkdYS0hIVTdvQVc4VGh2MjNKaXhKTEJaZkZFRkxKbll0dlZ3SXh5bGg2VlIwRzdRTXd1SWJYQXRVYXF4NTRUbEdHa1hOYkJpenJTU1Z4VlM1UkxFZjFrVmNHcVZWeGF4dERHd0VNcndFMmhabHJDblNtbWdhbXVZSUdLS0NnTWJSamFnWFowbzhKc09HM0kxOFhjVVlsbTh3ZFdVK1Y2MEhJYVNVM1ZFWXlTMlhzUDNqVjljQmVDZEpXQW04alFDbVFILy80b2RzSUJRWm45TVdMcWJmYVlXVnIveVZaeElkRzExeDF6V1ZJV1hYVWZUaFhoNHkrYXJWbUhiR01VVnBkZXllejVWY3Bwdm5ZQk1XNFFtMy82SEJqRFVrYStSK1VVcEtBeEl3R0NxU0JRTFh4TU1VVVBQd3MzKzE5c2ZBZURDdndqc0lDN1UwbmNvai9URmNpbzQ4RGZORlV6T2UwMkFLOEl3aDBnTHo5YzhVSWN2Y1FoQXh3eHZtUEZPQ0RYOGIzY09id0Q1QS9CSkhEOWtGQUljTkE3Z2Z4cEc3QmR6aHlkY25uTDlaUlMyMVZ3QWIvK012c2VQT0RmMnpxSDJmQUU1NytNYWNGQnNwT0xoQlNCRFlBd01CWmhRQ08wNThHdXhReWpHeEFMeXlvZ1JTKzRLbGMvTU5VL3pBQ0lveXdoU3dJcXd5RUlzRUNEbEFBR203d2hzemFuRlVlWUtrZnpHQlUvNEFDRWYrNkFDVkxIU1JhaW9HYVJtVGlMUnc2OFdydDBnbEtGc1l1a1VEbEorYWEzTUU0aERDNFBERi9UWnppd2pZQ0Y1Q1kwWW9FUVJpOTNESTVjL21ySVFiN29xTTZBeFYyMFpGRGVFUUxUY2hZUjdLZzVWMVY3RXBQdk1Pdmxwam1TM0xramhlbDJERDBhSVFvS052WFUrQ2xzSUlzQlk5TXFhTHpyTUtZclVEZ2t4dVlsb1hJNUs0d0pySTdYVnhJVU1TNEVwOTRwRFBsV3FKVldoU3pHdFl3YVp6Y1FNMWVoTEdiNlFWakY0TVdEV21ZeE9ROEJ5RlBPeVhrSU9rV1NacEVMVnFzSkNHN2NzZ0tQWUJNcmptYlh2b0NHREZVYVRZeWVoMkNpbVlZNG1nRkFrdkxEdFVvazh3OERrK1pGZmxKYUF6cHIwYWVpeWNHQ2NwcDF2UC9TV3B4aXdWMVNkQjhBa1NiZ3M2dVFLc3pFQXRJOEJkb0tZYUdTMnZNZFFybmtIMUpKM0hTTWNoMFRBbFB5Zm5yTEpURENIcFd1WjRCY0dWc3E3RlFCRndERzlrWXFIcEZpdHR0ZEZPM1ZmbGxZM2xMVVZhdWdyd094U3h4NlNSYzA1Q3AwZUtKREFId1JFaDRsam9VMEtpUllVMFZaSHFPQlNHTDlTVSthbUlibElMZ3BJSE1yUWU0QVU1Z1ZucXhnVUFQV2k4S25ta2ljNmlkUnNkcFZYRk8xT1FhTWFjUkpBRTlUZXEzS2tjNXAzUU5KcDloWGljckpLMjhuQWs0TnFwZTI0cmtOb0Y4WURlNllSTndiaWNZd2ZDbEw5K0V6KzgySzV0VzhmUlFOR3hQVm81SlBKR1JTR1I2clFsNW1FZXhXcEtIazRzNURGOThWaHZkLzlSZ0JFSXEwZytncElPRlNLbEpUZUlEMjVqMGp6OE1kRDRqK0VPYWZyY0FSSGtJUk5XaGtKYnltbHF3Tkl4ZnI1MWxiQmRRV1RXMUthc0NhaHVVektlK01zQUpDdWFGd3ZyaUI2VEdRa2xJNmZzUCtvejBKTm10b0xtUlNkeDNNQ0xkNm5icGtLc2RTR0w0eGdJYjdZWS8vSkhiVEh2QVBlL05pWUZDWU9BL3lrRGhDWi8zZlg4QzMvY29uQU0rek9lK2dRdkFBUVluQURiNFYzK1prMVluTXdmTTFid21kRFVvNEo5bUVLZzVBYXFCZElLd2p2K1JBMVd4WUFOZWlVeFJUM3pLcVZCVFBSWGtJUWJPcHBzNHZlQ0VTckRUazEvUUJTSk11WUVUbGtFTlNFQXQ1SkdKeU5WbHc5aW1ZcUVDc09BRE1waEJFanFGa0RNUXdmOElSQkRXbTRsQTR5b3BheUJmQnJPZUI3S0JZblhBQnpLUUFwdmR6S3NXQ2dzUnVlakNENUFnVUt0UUtNOTcxak1TMDRNQkJiQkFWMnplQkJGTTZDbGlBZEJGaDNyQW1DSk42dlZFU3lBQTNBQUxMaURqSDlYZ2RUeTBrRDVMVFd1RWVDQ1VBNmpMa3JmVGsxWldzdGFrbHRjaVg2bkhyQUdieUxHVTVWanFKY1c5dmxKaFNrSGpzV0hGMFY3UHkxN3hVa29IcjZqVWNzV1IyMzZjTnVTaVNFZUhSVEZrbVh3SlI2dDRMb1NGTzkzaWxraXlwYTNHcGpSYkp4M2N0cmZDdlpNMCtuV1NseHlZRnU4ZGI1bUVLOWxyQ2RlNkxSbklmREV6ang3WkY3WXpHVFB0Rmp5SzdpektJcTNJUDM5ZmtWek1WT05vSHFhVTcwQnprQVAvWSswc1VXS2F1QzQ4MG0zQjk4UmxQbStIZ0J4bERFc0lWMWFwTWpIeTZ6SVFNM0xRYzNxb2xmL0xuYVVHRjdZNThySjdpZVRsRG9HTGtWbnJONjRjNjFqQkRPWUZLOFN1TjBvODJIV3NvMUtjbmtZako1eGgzeWE0U293Sk1Zd2s4ZW9WcWxiWmd2bWlqTDFJSU1xaVlVNHZtU1g3UVIzbUdtOWx1ekhKY0pTQVIxNktHVk43OW5heGpjRmdZMmhEUVFRa0g0RzZYd3pJUEwxUTM1VktzbU1DRzJVSDZkZEZRTnF2ajAreDE4d3pLZGRuWnJiMzdFVjZaZ0xNakQ0c0dBMzQ1ZkVXVXhaak5GUzRxbTErTW84QmZMaDJya1dRR2o0cFp4U2tTZk9tdWF4bnE3S3lyMm5yQklLRE5CMjJRYmszVktJSVJ6S2ZvM1pMZExVTS8rQVJFcFNZYkVSbVRrL0pyRDBHU21pNUo0Q0FXZWpyUUZlYitzZG5QZ1Q2elRndGRzMnJqSmozam9SYTRxY1FsNkZPVmFObm9aRlBYdU5JWkRRU0oxZFNGYUo2c2ZWcEF2RWFRWk5ZY3pNMzgvRWJCVkpaRGRWL21tTk1Fb1YwQ2VFYzNJZE1Ba2hkcVhVZTBJUnZRNEZPOFNKRmFmRWxsS01lMFVLQnNURTA4cGVCdWFHQi8rQWJNZ0liZDlOL1Z4RUE2Q1JYVTRHRXBMR0VuZGQ5QXVnY1BXVlhHYVJNNU5LQ01WTlBmbVFlUHBFNWRpRngzTFZOczBFZjJMTWJCSkU2dnlFY2plYy9jcUY0RUhCbmh5TVpHcFVjK1RVZDFGRTgxUkVkd3JNaGVUaUZIYlV5UzNFV2pjUjNHT0VCWTZNc2FIVVhFV0NCdE1FMmJkT0lBUC9pTnZUeEc2dHlNOEhFWW5peEFoYnpaWXFoWDhVUlZKT1JGWXdTZkFKSUlRbWdLTlVWRTB3aEhtL2hoNjhWRkcrM1E4Q0RObVpDSTd6eFhtN1RXSXExT3NHQklMS1JGNG40Ty9kbE1RSXhUS3QzSllja09JemlIZENCV25KUkdkbVJBUDVGRk9QaFNpdnpOZGdWTW9kMGRicmtJRHpUSnRXekg2UURKVVNTSktLamdlRlVKdEFIR0F2Q0Y4QkRkM3dEUEVrMEpvdGhITnYzSVpBQmZNTm9WQUxBQU1obVNKRmpTQzc0UmltQlVsamhUd0drRnlpZ0FTbVFWVGVTSkQyUVc3M2xXTHRSZmEzek9qSWllejlqZlZYQ0YxV2lqaWlRTVhqM2pqT1VLTTRCSXNXempCNnlPTFRtYmFlM0lyRDFTWG1ET1Z1aFMvOGdlYmZUZ3pyL2dDTmJKUkF5Um9ZRVVSdHFFaUJLVWlPOElUdWdjMzIwOFRNTzhIakZNeDFaTVJrbVNSQjhlSEZOSVZoOTlUVm5NVldISVJoQjZWVTUrUUU3OGo0WVJoQWY0R0Vma0ZzT3FTVC8wQ1JyS1JDMzFaYTcwU1E3UXhCdkZUTG9OQjBZUkpWd2hIYlJOb05Yc1pWOVVTRHlNUUk0Z0FRNEVEci84Q1BxSXdQdXcyTVlKZ015d0dDSk9abHVlVHBHRWlTVjJRTlA4Z2M4a0FJY0F6RlNVeDEzcUpjUHdWYzZ3WUkxbEJkY0tYL1VNeEJJMEZ1U2VWNFROajZ6YVY3Y0l4QkF3bU1QcVQySytaZzdraVE4RURGV2tSMFFJQUF3cUlLa3VSQWtzVHlXUTBnT3NrMkRLU1U5ZUNNanNBVG40eC9mRXo3WktUNGN4bVBzcFQ0VEZrVGovME5oOFFNNkFpWXlJdlozeWZrdHJQVmFrZUlpWnBJYkdNaUlXZ1daY2hKaGR0SUZmakpoZlJJblpZQmVHa1lRZ1BJZk94TUJOdlFkTUtpZTY0bHhKbWVIbklReHdwRXhHZk1BM0FRWVN0SmdldElGbStJR0R4WmgzeU9nZEJLaWdGSUdQekFDRENWcVhEZGlGS0tnQzhwRVZyRjhSaWlULzdNQkw0WWpQK0lDWmVBR1F1QUdkbklHcDBJbkwzQXFFZ1poVWlBRFM2QUIxRklWaXlKaTl0aWlqMkppallGT0ZTY3RyUkViTE5BbWZKQURYUkNrUWVvcFR5WVFuRElRVk9hV1ZDSnFrWEpMWCtla2p3SVoxSlJxbDFJQUdCQUJHdkFEY2JLbHBtSXFQanFrVmlZRU14QkJVL0E3L3ZlZWFtbzFYUGdQUWRFQkk1Qm1kc29yZHVaeUVKNENLa3J3QWtWcW9uaUJRYlkwcUNaallnY0JBU3NnT3pWUUJwMWlCR0RhcUc4bXFnTHhCVi9nQmpWUU94d0RhWmlhUDZDRUFSclFBMjdXS3dpRVFDeVVCYUw2QldjZ0F6V3lBTVZ4UWE3NnFsWXpBQmhRS2EvelBVL21abWVRQzhHU0JmL3dBbVZ3QlN4Z0tSNGpIY1NxUVhuekFDU1ZBMkY2UXNLU0owdlFBUjJUU3pURUd0bWFQRml4R25CcUFUb2dCVDdLckFMaG9RcFFGM29uRjFTYXJ2bFRMUUIwVFplQ0tab1NSRGtBUGxmUUFaV0dhdmhxTGZxcVA5YlNodmxLTzE2VkFwWEdyWGkyc0lsVUxRK0FBZjlBbzdHeFVodWdBT3Boc1VuRlF6VVJFQUFoK1FRRkJ3RC9BQ3dFQUw4QXdRQlRBRUFJL3dEL0NSUVk0QitBZ1FnTElseklzS0hEaHhBalNweElzYUxGaXhnbktqd0lrV05EaFFVUGlnd0FJQ1REa2h4TEdoeUlrcVJMZ3dvSHZ2U1lzYWJObXpodHhoUjQwQ1JCbVA5ZUxpUXAwV1hMbFVGVE5pendNeWhQcEFLY0VoQTQ0TjhBa1Zhek1oWElkR2VBcnYraTVoeEx0aXhFbzJnOWNpUUtVMlZCdGpBTGZQMEs0ZTNBclFNanNQakhnZ1dKZnhvRXNsakJBZ1dNQ0FzZUtJWkFvQUNCQUk4TENBZ1FRR3pDcGdLaldrNFlkYWZaejZBSkFoZ1psTExibmd0Vlh0NEtZWVBpd2hwUWFOQXdCY21VRVg4WmtpQ2hvUzhLeFlvTFFDZ2cxeTdZeWs2ZGJoV3JHZTlkZ3BPWk45d2N1cnBGckNrcEF3MDZBR1RQcWdvanJQOGdzV0lLaVNtQk5mZ1pPQ0lJKzM4ajR1TkEzMXZ2YnhZTEl2eExjWDdLaC9PNy9ZVUNmdmFoc01BL0R5QjRBQVFQd0xDQ0F4QTZBSU1CQnh3Z2dJVmhaU1lRQXY4d0lFQUNCMWduNG9oQkZTZVhjcFROOVU5aURRN0dnbDRhN0ZaRERUM0kwRU1PTXNnQWhZNWw5TmhqRGprRThVTVFQZnpRd3o4MUlQU0RqVElFMGVTU1MvSlJnM24vNENYQVZwWFZaZUZVSkhicDVWSmZjY1VVVXg0UU41eHd4S1c1Z1FJUmtLQkREVXZpbUVPUFV0VFp4UXhkQ05HRlFIditvNmNVWGRRcFJSa3V5UERCRkNod1JRQmpCSVg0NWFPUWhsYlFWcFErUU1JSC81UXhBeEgvY0VyRUdRSVJ3YWtSLzJ6UjZSZElrckJYQVFjNDVseWtzTWIvQ2hvYmR5a3dRQWRJbENIcXA3bHdLbEFPU0NoQVhKVUNMY0RVQnJJbXEyeFpEekQxd0FZUUNQVEFYZ2orZzhFR0F5UVlrVStZSVlRYVN4OGwxWkJTUGJWa3JyakpMYXZ1aU54ZU5oUk42ZHFsMmxCdHNaUVdYUFI2eE5hMzlDTEZWYnhQclN1d1JqOFpoZTdCb3RtTFVsSWJyYVNXVC9vNjVOZy9CMnpBVkxTS0lSdnRRQThjS0MyYS96eFdtblp2ZFJZZFF0UU5yTEs5TUwybEhjTWhUUnJ3dnc5cy9BQmh2UEgyenhRbDZBeVlxaXRFY05odkhiT2E1bHdwaHVVWlZ6Rko5bTluandrZ2NtY2hwN3R5ZFNxaE5sTmJkbjExMElreXIzanplUDNGTjhJSDdoMzVqM3NqSUlGRXppNUdFRndCQTZUNUR3UWVJM2JYbU1ReS96WFZZNEJESnJqVFNvczhsZFNhVmMzbDFhREZaQksvSTZzb0Y5Z0xQV0RZQ2l1QXNETU9INHdBWHcwajlPQjVmQTBkMlVQbm5ndEVldXFyd3pmRmJSOTh3TWZaS3lRYVlsU0hRM1lseFJreVByRE1iNTA0RUFRd0tIWVlZWDN4dGtKdmU0MGdRNloxbnBIbjlBTkpJVkFabVJJcUE0NVE1SEI5cHYvZ0tEb0pNR3pBWlFDT0NnREJaTDYzanhPdHhJWDU3M1BWL3JNQ2tpNUk0Y1kvKzcrdzV4bjcyeE1SdXFDRU03emdESU9hUVExQWdLd3FMU3BsN29zZ2llRG5nWDhvWUM5bGNJTVMvdEdyZ1d3aEN4OFVDS3BJRUp5N1NmQ0VzSUtBQWxyVG1tY0paQWFFQ2dJVXlwQ0R3Q2lnV2MwU1RwVTI1aTU0bmVTSC9Sclh6UDlRU0VTTTBLUmRNbUhJMG43aVE0ZXhqR0hsOHRZU3VWYkUzL25MYXVDS1NjUVVOak1rMWd0ZTVrS0xGSUdpbEN0MnE0cXhBdU5PSUpld0tZNXhJdWQ2MkZxYThqSXNFdXNyM1pHTFNBcndOWmVoc1hGRFRJNVhGQmF6TUM3c2pVOVJpN2ZtOTZxZjhFMkhDQm1XY0tMRk55NDVwaklGb1U0bTNmakhqSnlMSkRRNUpDR0I2Szc1T1c1eVcwbE1ZaGFDZ2dpMHNwVWRRMHpIRk5NcVZ5RXRSWmxraU1rMjJjbWJDQ1dKVlZKazFvSlltcGFCelRuT3VabCtOTEM4d095TU4xTWdUTkFJTk1zREVLQlZCSmdNTHUwU0hVeG1TRE9iVEZ6VXdDS3lYbGJFWUN0cEdCVHRJaHE1VkdWTUYwT1dhL1R5Rjk2TTREYXB3MEZnekFQL3RBaklMVGlNaVY5eHRFTzFzRFJTSUl2Ylhid21zN2lRVlNhYjVuU0lVSkpXVE5VWVRDVlZ5V05RaHZNQVIyRnVOdWp4SEJKWXB6YjRsR0EyL1dSUkRvbmpsaW9aelpSeU9SOEJBQmVVYnNxRVN3TElLVUlSR3BVRVFEU2lQSkhYUkUxaUd1N0ViQ1ZtUWhZS3h2TTZzNFZ1YmY4NG5Yc0Vnb1FsaktBRTZPbUxYb0FEblB3SVpEejJxeDJDR0FVdHY3bEtJQXM2d0FJV0FJTUZWTWlhNCtRcFFoandEd1I4eUZGQUxaaE1rdllXQUZDdU9IN055Z0NpeGNNWDBmTWZKT0FCa3Q3a09SMDQxV3ptNlkxQWRqT2ZzOGxuQ2pqQVFlb1F1eHZFL2dNRnYxbkFZTWFUT1JEY3o2MVRzUkQ3RW9lUWh1WlZKNExzbWltNWtwaEUvMzEwZWYvbzNJeWl1cllmL0dOSnZTMFNuSHliSk5DSnJnYzArZ0J5ZTlBRFBpeDNSc2lOM1djSGdqZ3VSZXNyRjRvS1hsODdscGZ4TFhnRndWdURERE9ndnJBZ1J1ZEJVZzJhTkNjb1FDOVFnckplcGx6d2p5ZlphRWxPbXFwQW10U2tRNUZ3dTllbHpHTzJ5MTEyRVdSeWswTFRhd2FFT2ZFOFFHNXRRcElNeWlDRk0xaVlUeGorQjU1ZUlCRDVlcThoWmJBUm9wcVZXdlJWamNBRlZ0bGFqRE9RQmdxRVRlT0pENXllTjRNejFOaC8wcE9lRURRTVFDSHNENFl6aXFheFVudWxDNlg0ajhPNlMyT3F0SUVJVEtFR0xuRERDMTdBcVROODZoOEMvSWNTUkdXRVR4MVFnUzVzVEtzNGVXUTBocGUyOStQRERBUUNLbCtKcXY5VFd6QkNGa0lsQTBUQjRHNHZMYk9lQmFKQ2dYUWdmRjBZVmFjV1FnUVpzRUJZZkY0VVd2ZDhaRzBKcElFcytBR1ZCUUtGVDUwaENFamd5Z09tTXB3UWVZelJLV1lEdEZ3OGtOeE1BYkg2MlFBR2hLT0FIWUw2MVFpNUZnWWVnSUdjSEZHSVMvUk1FMkg5eDFzM2NXbFQzUFU2V1JaRmZQRmFWdXA4aUxEM1pVZUduY1NONkR5Mmw5cTFSRFpHTVl2aENtcDJ5dlZMZEdVTjJ0SytpYSt6ZlJsRmxqS2Q5ZklNVWJ5eUZtSGZXdG5oTGtvZ2NaMGFYZGM3WUVkRXpid1NObXpST080eWo0dTNSYXFkcmkzNlVKVDFEaU5GOG0zc0VqbWNLRnB6WkZaR0FwNW1neG9rVnlSenZjWUZjWmtZMG1BYmNkeXVLU1V1ZGV1UkorNy81Q3RlL2kxdFk2OFJsSEFacGhSVk01SnRvNnV2NElhSVdKbzJrQUZVNVI4V2c4QmdWMTVIaDBEd3RXN2M5N3dXOW0ydWdkRXA3QlJYVjhDaVJLNXNUSWVPTmlIUVhWaXR4YUNKTWdPMU9EQVp2YkNaNEV0ZjUxcmtkcWJvSGVGTmppQVFpTHNKR2NTaWdSVHZRRnc5a0xIaWgwbHRGbjBvM1pST3VPOTF5SkJueDJvdmVkbWs1b0xnOElxM2ZxNTBFVjhJWXhpNXFiUTF3cmtTSmltYVN6SnJYTTlwa2NuUEMvYnRYV3NVTTRROWtELzNzcGZkeENoR3A3WmZZWW8zeTVvWmpmRjhMV2JWRldLWnBSMDlyOFptT2xFMy9rWHRqRDQ1azl5QUtzMjd2SnloNXgvNlZGNWg4SU1mNEtTcDhia3ZtY2ExWDlPZnVEYkZvZGVPLzh5ZGduQ09NTVd2Rnp1V3R1N0hHOXFVQVBxZUZVaGdYR1FZNEZqTVlucFV2TmlMakRMcWVsTnE0UlFXckZWZ0pkRWQ1SmRPSlJGc0dIZGd4S0lZbitVWEtLVUI4NEVESXdVZms3VWJ2dkZQejNJbXVaY2NtcGNaQitWYWZsTVpPWlZKMlFST0RsVTFTSmN3MlBFeStuSittREVwellJZzRvRlNKTkF6OE5FMkF1RUhxVU1mc3pFWVhMVW9ac0o1bk5aUW5iRVZqekVwdUtNN09vVlRrRUVzSnhNeXYxZEZYdEZ4THVGZFRIT0FyS0Y4RDZZZmZzRXorT1E1cHhNNklvVUVzeEVqZzZHQlp4SmdpM1lnYlFVdENZRTBoRk5UZlhjNGt1RTMzNFJXWXNFaEVTVitSSldBQ2ZnVzRNRkhHMEVwcmFGNlRLVlpabk1rU2VKY3l2OGxVb0JCSDRUeFQ2c1dkdzJFaUV1bFNuN0RReGR6TjdyakdFWjJBSE5oT0pHMElUazFoVVYwaGJGMUdqam5GTy9rWFhpekFHVFRWRTVsVmN5Vlc2SmpnYmpCR3kveUlseUZHT0xCV1FHQ09ZbHlONHFoU3JiM0wycVZBUkV5SVJYeU55cG9JZEtZVTF2Q1hZclhNR2RuRU1YUkZIR25HS3ZIVFBJWEdKbm1XTG9JSDUyaldlZnhnNUdIT2VlQkF5QXdCU0N3R3p5UUc3dHhQMHVWaVYyM1ZqRGdBSFJBQnhDU0FRY2lOWXRHWkxlRElTaldoODBXaUNSaEltR2lFRXlSVWY5UUpvLzJWU25BQTdFalhhUGpXSTlsSGhQb09aMFRPL0dCS1NJNU9qdHphckhIV1ZQQUE3ZkJBNHAxSURObEdiZXphQUtKaXJEV05XSDNkMVgvWWl5ZnRsUjhrUnVodzF4SmdoQzNDSlJHUWlOSklqcWRrMXNEZ1NuLzhBZGtlRHFuTXpzOGNEOUdKNEI4cGlFQ2wyMFkxNUJaaUNCckpSNnlZVnVhUlNOeDBpUnJneU5sc0NNeUpDUkVFbFdpVTF4STRsekFsUU5EWWlRMWNpUWdrQ2pHMGxvR05SRGZsNVVQUVRJb2NoY1k4dy9pOFNKQk14c2ZNQ1A4NVY3WTh3L1dJeWcrc2w5dDZWdjdWU05Cd0QzMUpTVEFoVmlyRkJiWkpCa1c4bEFxQ0pqYkFuVnZseHg0dzJEVDVCZDkwUnNoMVZ3elpDZVE2UVo0c21aNzBpUC80QUs4bVNOUnhWKy84Zzg3SWhBOThEcUprVTFiZ2tuWFpab1l3WGdsMGpTTzBpTGowUmZJMDR1MzhRTXVRR0Y3MGdVNlZtR1FDWmwxQXBuWS81T2QyS09iQ0JFa3VJRWZFd09BcFZGT3pKa1JYdEY0aXhKMzNYaU1FTkFxdzNGQk9GQWpqeGxmZG9Jbkw5UVFnZklDK3BNcE9aQWtVeGxKVTRFK05QbWVPckZOZkJVOHhMRUJGQm9CL0JFZnlNV2JHV1E5MGxOaGRTSUUxdk1DUXRDaGdMSm1Nb0FiS0VCcW91bWdYOUtRdVBjcUJYQkRzdWNYT3BDZGZTSVFIUFlQT1RZUUhNYWRNR1FvSTdBQ2pyS2lEY3Fpb2NFMzZqTS9DTElWNitXZFJEQnBXS2FqQjJSbFZEcGxOdVlDSTJBeGR3TTRCMm1rc0tKRGVORWFUalpoYnRBRlZMWkJWc1ptYmZabVQvb0NidkFETE5Bc0cxT2tYdG9sY2pFY2ZMWVZBN0FDSTFBRFVpWm9neVlRUnJBRlJUQXFST0FHTXFBcUNDSm1CN2xWcDhyQ0JtTXlIQXlpTFM1Z3Byc3lFSU82Qllnd0VGOVFaL2l4cFpEa3FPM3prSURSQTJWQVFKMXlCcm1BRUNDRUNFSXdBbklqSEVVb3F1N3prQ3BVYS9XVnBxdEtCS2J5RDFrQUtoRUFoeUZqSnExQ3E0d1RwaHRRUVNXUUE2SmlaVVN3Q1p3aUJWZmdBNGlHckYxcXJPcUNKcExxR2lNd0ExSldQV1Z3QmZweGxkaDZRZ3hTQU5yaUhFRUpKeVBRQVErZ0FCNEFMY05SUVJWVXJyNWppYTF4QURoa21BanhMR1d5YXZhS1JnV3dhczhpYXpVUkVBQWgrUVFGQndEL0FDd0VBTDRBd1FCVUFFQUkvd0QvQ1J6NEw0QkFBQVFUS2x6SXNLSERoeEFqU3B4SXNhTEZpZ2dORnZ5SGNHUENqaG9kQXRCSXNtTkNneVk1QmhpWjBlVEtnaWtQWHB4SnM2Wk5taDB6RW95NTBXWExuU2hmZmx4SmxLVlFsZ05ISmsyS2txUEhBdjhJL0NzQXRlQUFwQUNxWmczQU5lVE5yMkREVGpRNnNLaFprMGhmZ2x4cXNtcUJBQVVneE4wQTRjR0RCU3hnQ0l6d3oyNkVDQ2dlUkhnQVl3RUVBbFM1dnUxYVVJQlhnaUVET0o3OFQwRGx5NVRGYXQ3OGtPZkhzZ08xQ2l3d29NQ0R2aHNFczJCQkFnY1NIRk53akNEeHI4US9FaHB5azJBUlljRUdxb2tId05WSWRhcHhxRndoajdaY3dMSFV5bThKd04zb3VPRHp5NUk5Y3Q1ZXNTbFFoVXBCbC8rdWl4ZnZDaEpUTkF4TVA2WEVsSDlJUnNnZjhVL0Q3aFVyL0twZXZZSkYvOTNvS2JSQ1lBc0lkTmMvQlFxVUdtRXJPQUFDSFR4a2tBRkJCeEFnZ0lWU1dUYVFBQWNnd04ySElNcmtsRk1GSU1VUlZYZWRodDgvSTN4UXd3OHlCSkdEREFLVkFVVVhOdjVqb3d4UUJQSERRQ1AwMEVNTlEvWWdRNHovMEVqalFCOTh3TU1LQlI1MjRaUlZGWFNBWmRlRnFPV1dKWXFZMVZSZGNRWEJjTU9saGdFSkkraFFReEJIenBnREZHV1VJVVVaYmdqVXhRdzZ1akNqbkYxSThjOE1aY3g0Z1F3WFBQbkFiOHNKZE1DV2pEYktIUVRHQmZCY2dTeU1VSU9PLzNUUnhSa3ZFSEhHUDBUOFk0UkFvLzd6QlJGZnZGRERWUnNGVUtHanNNYi91cVVILzJDd1FYMDlTRUdFRVVhRW1rdW9vWlpSd21seExWREFBUnNjY0t5c3pEYXJtUUlRMENYdFFDdjhzd0pmRHhUZ2dRSjlPZVFWVHpscE4rSkpJam1WVm5nQ0NlWHN1bzJtcEpGTzRzSTdWcmtxT2FVdVU2Q2x1NU9JQnozRzdyOWdwWVJ1dmYzbWE2SlJDRGNGQUVndHJkVGxjUVRKdGVnL0VGVDh6d0VXQ3pUQVA4S0ZPZHhpYjZXcm9VT1pBV3p5UWlhU3E1QkJMNzNWVVdrRExDallQeXdJVkMxdHQ5bVg4ejhvc0dCWEFkSjVuQnpMb3pGRXRMOENhVGdaMFJzaWZiS1dSWWtMazczQ1FXWFhYZjZSZ0Z0czg5RUhKSDBqNElCYkJ3OTBRRmRjYVA4anMxMExwSmdnc2ZvbXBQUmh4eTVBd0FHTFZtaFF5UnNPLzVUQTA0eDZwZGhuRzI5czBIaW1DYlpBQkN1OHg4TS9QT0R3Z2VSZUMvU2VmRG9VU2VUbWw0WU45a0E4Zk1EaUNEeTBhSG9OTHNhQUlON042UXRwVkpkZENiakpPVUcxMVVnbHdyV1ZjRERIckFEamFkWWdReG4vK05ubnBnSzkwRVh4VXZpWkEvRXl1Q0FRRlAva2tHUVpNc3o0UXcwamFQQ3pkTEpQYk56czVJUEYzSFFMWFdWYUJHaStLSkFVYmtqUnhRdG51SEdHRUdjc0wxQ2RuN3JSWnhtRjJvQlVuak95OGhrUWFuSkpZSWtLY0tZUnlBQjVBZ25WRmhEeGp5eEVzRTRQS0UxVlhIWEFEallyTGdNNHpSUmtNSU1aU09FR3o0T0NEenJRbDJoVjVUQUxJY21JL0xXV2lUak5nemk4aWJ0a0lzT2wzUEJlYkRFWHkvOGFwaEswK091R09Welh0OEREdzMycExDaHhhNGhhZ3ZJVG1CQWxYMVBqMTRqSWtzVEF6WkNKVWtQWnQ2Nm9GQk85NUN4UkF3b1JxN2dXZEQxc2ZGL2N5TWE2K0NGNWlkRmVSR3lJWnhEMkdTQ0dLeUdRZ29vZzVRS1ZBUlR1SUNNaGl0QWlReENsUlpHT05Ua2pUOUJZUlNraUpDZnZTa3FWNENneDhoUUdCb1RwUzRMcUVraXFJQVpvaTBuT1E2ckRTc200c29DUWpHUjR5TUlTdEpURkpmRWEzOGRPYzZzRkxBNEcxYUtXQmxpekdwcEI2UUhLSWhOWEhKTWRwcTJzTEt4TTJ0NHdNMDBreGxLTUNac2tWcTRvdzVjWlNHWTlPdzhPTkVBZjNOUW5OL1ZaeldDT2xaakVoQW1PTVVST1ZTaFRRQUUwSnlRYWt0UkNZSG4vVFVzNkU0c3pkQXZGVXZNUHdMQm1DcDZUalh4Y2c1NXhUZ0UzMTdMQUF4UUFIT0RJWmFES3FsQ0ZCTWxNZmJVT014Q2drajJ0azUwQ1NnZDJTZXVuSlhzQ1JWc21NbDF4NmNzRFVJQ0NGZGdIb2ZJaENOalNOSjl4RGpORmN6bE5YL0xTTTVxaWdIR01JOUFETExaSnFWQWxiNzVjUUFZTUFBTUV2TXFla3NFUWh3U2dvZWRrU2FWTHFkY1pQVUttOFZrdE5ZeWpXUVJXMDRGaTJrY0Q3NGtybXJTbU5adlNoalgybVN2bFBpQ2ZEMHhCZEFqOXgwUHBDZ0wwbk9laFUrQ0JZaFZMQjBYbGJXOFd3a3hVTE1NQWZvSlZoK0Y2Mk1aaUtwQ2EwZ1pOTE9JZUgvNFJCRGJSS0FoSjZvR1BndENESE9qZ0J6MWdFWXR3SUZ1Qi85VGd0a05hMDIzL2dUclJGZWh1ZTJ2T0FUZ29rTWhlbGpQZTNLTExXRVlWQ0JpcmJXdGxBUTlxTUNnbzhJaEgvN2hSOFFiaUo0SDRLTFlDK1pHTVlqUWo2MzYzU1NPWUFwU0FGbElMRFZkMnJ6dXVsakw3a3dCVTdXTWZJODBEV0tBQjRlWEFlUElUd3ZMODFOMkJsQUZRLzlDVG5wWVVwemk1UUFhenNWWlVvR0xjcExGQnZ2LzY0OHJrcVpBTnhJeDlYaU1lbnU0a0VDRzg3eC81ZThGQVNDeUZHUkRxQXlEd0RXSUlpT0YrRm9kakxDUEFhVWp3Z1J6TW9FNmc2aFNvL21FL0pRQnJDNmNLOGd4cXdDMnEyRk1BOGExeFA5bXdTWTROQUFJRGlJQUdoamMvWUoyQkNHQVd5QllxaU9UYkdESXhHYjJ3bE5jc0VBOFVRUDhCcXZtQnJpSkloRjl0SVFzVEpJSWJwcEN0QkNKR1dXd09OTWV5OVFBTVJJQStLdllVRklBRkJTWllZSTVUeVJ2UUJCMW9TTmVxVnFMN2h3NkNoQm9NaEpBMEE0MHlwZGxzcTJoaEFGSjIrUXE0bWhqV1VZOTZoL1o2cEIyZE9LN3dXTlBWdENOckhKMTR3MHVxVWRkcVZOY1ZjUzJySlg0bTFxMkdqRXZIQmNZWU5peGhZU1MyV0dBTnJ5VWliZFdlRVJFVUpYa1dwdUNTMXRtV05rT3F2ZXV3SWpFbXZoNjMwYkpKUmVXa2hXRGhGbmRud0dqSFZZY0VYZHd1WXcrZFBleUNYVktTTXRGd2FEWWlHc1BKTzVQN1J2YTZyYWh2V2o2R2tpc3I0MmRzbVd6UUxKQWxYWHFudkhrTkVTQUNNZUpwM05jVTRUMURnU05ISUdQL2dpbXRobWdXUlJiRUs1YUplV01FSGU5ODV6dUwvUzVpMVBEOWIxeStoY09DcE5qRllJY3NsRjlaT0U0UlRpSVh1Y3BiWTlqamxkUTVlRUt1RTMrZEhHSVFnMHEwbkp1aXF4bEdnUlg5dVR1N1lobU5XTFpWd0dheldZcUk4NEgxaTR2alVwaVhFaEl5cmRPRjYyMUR3VUFLMVBXN29JMlF6UWxaZGZ6VnluejFNT0ZzWnZjZWhUSld1YitMdVI5RDlRSHNvcGVDcnJXZ0JiMFdDMUl3b01GVUxQQmRTV1ZqVkhrMHRNZU5hVEprNXRuN21YTnZyOTJIS012aXp3ZkNkWUVVaGkvcXVVMHhiM090RllBeVd5QWorektQK1BJd3VySXlwY2VxY3lSVFpmbFNNdWY0Wm52S0NLNDI1dzYxWjIrdEQyM2V1aHVhQ1FiNGkyVE0vOFAxcFRSOE51WXRJNzJNZE5LdnI2L0tGKzVHbXhyREZETWQwOVRGTGl6QUMxemg2aDRTOUI4MzZ1RWYrZmNid0RFMHBhY2NDQWhQNWRkS0kvTlJsY0ZWRmlJcFRvZERiaGREekZZUUlSTWFwM0Uxak1OZlNJQlFDaVUyL0xkLzluRXRod0o4cVRRMGZpWklCUmgwWmZjUTk4UlYyWEVkK1VSOTduZFo2VFpMS2dNbWN5UkFndUZaNU5RMW8xTmIyN2NiZzdFQkZCVjJkbmQvcElSTXZwUXNNR1VRV2djbUJRRXBBNVJTTDFjZGZhTitxOGQ2bUpSSFExRWxCZUJMTlhWWVFaaFRBb0U1ZlVVZjlqRVlQeU5BdDVJNDMzYzFsYWRVa0RFbUxFTjJGWU0zQndBRGVMTUFlSE5TeTVFbERMQWhOMGhINkhadlRaRkpWVE1WWlArSUh5aGdIL09CQkVBeU9ndEZIK08wR3o1ek5YNmhWZ0k0SUZwekd3UFJHMHRWRndneUZZZ3hGWkRpU3c0QUF3N2dBQm1RSUZlaVZRbUJBQUtRQUFlUUFGeWxVa3JCU0dZa1JKZFVkNmF4QVcxekh1ZUVUZ0toRysrQkJHaWlBY3lvQWVlQkg3eEJNelRER2xwakh6Z2dHeXpTR29KRkFqWVZqWkNJSDc0M0lDc0FBb3NGQXYvZ0FQOWdBRkZoRU82WGk3bFlZY2MxYkY4b2ZWT1JGU094TWEremdSZ2dVM3ZSTTdmQll5Q0FBendRSUorVkcrbHhHMytGVTJ2NEFadW1VT2dGV0pEekR5Q0FXRk53a1h5MVdCZFRJUnpDUVFXMEtGalNoVStYTGxoaExra1hNa29uRkJ0ektBdWdkNklZSUx6MUQrQTFFTEZGSkVJQ1c5di93MXN6K1Erd0lWZ0NJVHJwUlI4ZjBBTWZ3QWVYVWdQdllTeTdhRnk3T0NXS3dpRWJ4MFR4QmxNYnNTZ3QyVE80UVI5RXdscEhFZ1E3VWxybU5TT3M5VjJ5bFY3LzRDS2FreVErOGlOR2FUbW5LRGN4NXlwWWdvVlIrUkRFUVgxbFVURXBJbzdvOFNKdGdsMXdBaWZNMHp6RUl4Q3hCVjVETWxvL29wWkswZ044NEpoRXlUT3djeUVvTlJtVUtUNTEyUkFicEIwL1J5WS9KeGNuS0JnSUpUdzhraU44c21JMW9pUG1sUkF5MEZxWTBwaENrbDZIb2l6Q3BVOGpCV1h5bUprZEowWDQxWm5BOFFBMkZTVERJeWVaWW1LZlFoQnhNaEI0TWhDblZUM1NJejB4MGdNbDZFdDBDU25ESlpLNnFabG9OeHdZaUR1OUNSd1lzQUtXLzVJOUJOWThVa0E5eEZPWThOTmlPcEtlMlNWaURTWURuVk9ReUJRVk1BUmwrcFNkTnlFNEJ2aE8yVUVRdDhJKzZCRWtmRUFqejVPZThkTThtZEpkQ2pvbnl4a25MK1o3TTNZeFQ2YWZJREkwSG9VK2JrRVZNY01hd3VNQ2NoSS85U01FYmlBRThpTUZuS0k4OUxPZ0p2UmdIN0JleUxFb2FtYWhJV0lRRjdhaFZtY3RmaVVRdzFOZ202SXBuUEpsWjJCa25hSUU5Zk1DWmZBQlFxVitoMGlqVzZJUno0RSt4dkU0ZUpKa1J2WVBpVVpub3pKbXY2SUVMeUFEQ21BNEJCQlN6ZWVrc2dJcC9sSWc0eWtES0VvUW9TSXEvN0FGUlVBRVpjWWloaVJEQVRDalpzb3VGNFVjaGpRQUdPQkFaWENjLy9Bcm4ySUVjanBtaUZBRWJxeXdLbHV4S0s0eWdYdktMSCtxQUIyQUJGS2dZcVVDcDRNd0VFbVFCRFJUSEJvQ2FKTktQcUNaRUtIU0s3a1Fwd0xScVo5Q05zWEZUcGhacWsvemQ0YjBBQTZrUDZCQ3A2dDZCajNRQVZYeU9uTWhhclQ2TDNSQk1kcUNLRExnQmlybUo0dldCVS9nQTl3U2FWUFJaOFZLUG9TMmRhbWhBQ1F3V3EzSkpqL0NMVnUzcE5mYVFmWjNyQVUxb0FaQ0VCNndBYlJTcmptMFZQL1FybnNobVgyaEFCaFFwdkNLUS9SYUV3RUJBQ0g1QkFVSEFQOEFMQTRBdndDM0FGTUFRQWovQUFQOEcvaFBJQUNDQlFjS1JNaXdvY09IRUNOS25FaXhvc1dMR0RNU1BQaVBvOEtPQ0E4dVRKaHdvVW1TQWdPSUJIQVNvY3FSTDFtQ2xKbFFwTWFiT0hQcS9FaHdvVWVRRFdsdUhLbndaOGloUWhtcTdQZ1NaSUFDL3lEOEswQVZBdFdwVkxOaUxRQ2dRRXFVUEI4R0VFQnlwOW16Wm1NUy9WcVE0OUtlTEFFYzdEb1ZJZFFIRC81RmdCRmhCWXNWS0Zqc1hmQmdBUUVJQkFnOERiQTRKZGwvajNzK0pFc1pzbVhMbFNzUEZFQVVyZWVkYkVPK1pkcHp3RUM2RUJaczZCdmhyd1lTU0ViZ0dFRmlDZzRTZnZ2aXBicllhd0VJcGlFODJBQ0IrQVBoaGZFZUoxNFhxbGVDbkI4ZkdMczVaWUFEQ3NsK0pZRDU4dWZ2RUVjYi95d0pWQ1ZVMDg0UGJOaWdWMitFOS9EL3RrYXhRamZlQ0F2ZXMvajMydmFJL3dEK3B3TVNTSlNnQVJJYWFQQVBiandNTkFWdUpQd0R3Z3ExOFRDRmhSZE9NY1VLQzBEQW1BRFJsUVVkaUNDQ1o2S0puVDJsa0cvL0hMREFBdlNSd0VNTk5OWVFSQS8vQkZFR0ZHVkk0V01YVW5TeFl3NWw1Q0JERHpJZ1pHTVBPTkw0RDVKQjFQQ2ZCdThWOWh1SkJ3aUFIWGVRU1NWQVlpZUdLZVpEdnFsSTBBQmNjVFVRVkFRZFY5Z0tBMzFRZ3d3OTl0akZQMjVJOGMrZFpaVGhnZ3Q5M3RuRkdXNmNNWU1VaDdvZ3d3Y2tMUEFQZTl3ZGtNQ1lsRllLSHB0c29UbkFmbnd3S1lPZS94QkIwQlpiWkVIRUlBU1Y4Y0dhQjBUS3BhV3d4djk2NGdhL0tjQUNIMlg4YzhhdUF4R3hSUzVTWElIUUFnVWNVS3lzeUNiN25WUVkvSU1YUWEwNWlnRjdGTmtrR1ZDbmxXWFNTZ2JCRkJaS05IV203TGhocm9VdFdFRjFHMWU2b3NXbGxyc3J0VlhTdXQwK3AyMVlCa0UxSHJuOE9xUnVXNlBCSlNLOEk4MzFrVWY3dnNYaVZWSkJrQm9NaGNHQWdzVC93QkJWQVFOWVpSMWpCWEVjbmtPWmRkZXZwZTdPRzFwWUhOazBrcHJCYlhBZkM0R3RvTUVLRkxKZ013b1I0S1ZhVmdNdzV2Tm1kYTBKOHBvQ1BNZVpYV1FWOEZqUjBZMUZ3TkV1amZ5WnR5WFg5SlJ6V0tWR0dBb295RWpDQ0ZQOHQrQ0R0WkVBTXd1RXZmZ0FBUTlBNWFoeUVlakZRb0lKMnR5YWZoTzNDTUVCZTdmL0NCVUVBaUJXMkFJd0dPQkFCb2M3WUFEUUE3MjY5R1dSU1cyV2FSeXhhVnJRalhYY1hGUXUva01ZbkNSb01NSUgvNjA2Wnc5QnBFNGtGREtrL21RY1BlZ3dvR3dKaGgwbkgxTFcwSU9jSCt3Kyt1ZzhPSEJBbGdSQUZUbEJVbTJXcGVUanNqbFZiMllLL2M4QUE2d1hRUXB5L2tCa0R2OFVLVVdmZFlMUHZRemtCOUg2RHpmK1FMNE1ScEwvdys0MWtNNERDb2hOOWVXSC83REIvUDQ2UFdlZDg5UXlEUW5pSnpyMTdla2ZMOWpUQ3doMUJpSWtrQWhHRUpVRS95R0ZHdURuSHdSWW5yajR4MEh3Nkk4Z0hpaUFBdml6aEZEOUl4ZG5HTWdXRUVJRUtXaEFBV3pLb1BNNlNNTktDYWNBYlF2aEFQQ2lnU1E5NlI4eTJBOEcvekFXTlBiTU1Gdm4ybGUyVWtRYW1TU2xobEJNUzlSKzBwTFRlQXNzb2ZGWVVhNElzSTBjTElyOHN4WlBmaUxHazdERmpCL1pZRlBhbFpLVWNTVmc4VExZQnNFSW5wUk44U2lpWVlnVDFXSkZMMXJ4aVVvQm1MdlloTFdDSFBFcWpKR0p6NWhJUnltaUMySHIybUs4bHFLU1NDS3hLUExpNDJrVzlodW9IS1pZVW5rQTM2eVNsMDRtNzJkelZNcnhxSE84UmxhcktYdjhveUQvTlJPZmZNdUt2cmxLVlpMemdQM0FiQVVQc0ZpSHN1SVZEeTN5bUdWcEpYVVlGekpYNWtRb1RXa2pUR2ppbGk1ZTVXSnNld0I4L0VJenYvempMMmhMRG1LeWNrenRQS2FLREhsY2RFSlVuWkF0azBUZWNhYS9DRlpManlCc0tpd3hEWm9Lcy84YXdmeGxRUnFZZ29KbVpqYmw0SVY2TEZsa1FhelNTZWRVSlN0RmE4NHlSYlFacGZYa09WN2hESFVXWXJ3U3liT1A4d3FrMElnWkZaZHBNMFlrK0JvT0hQUUJzcGtOTU1NeEZqRko2U3prRUdZK1orTmF6cHlsbXNNb0JqTFhFVWpSakhXWTRRMHZnOFhEb0VJVXd4M0hXUVlCZEZRa1Q4UlRPYWprazRpRm9ROFB5dllQZ2M2dE5SMW9UUy9UbGh5eVRpd0NnWG1ONkFCVU83cHBZRC8wY1ZUYWhKTWFYa0pzQWQyazJUL29zSm5Ba1FVN2thT01SejhxTDRyaU0wM1RFNGhXTGdjY3EzanVSVHJGR1h6NkFqb2UvSzUzVE9xQjduN3dQaWFSN2g4bEVDaHVCaks2ZjN6Z0Ezd29IZWxPZTlvNFJlVkQ2MnhsWkZwSldJMy9tR1NHaWhYSUFiS2FVZ0Rwcmdmb0F5S1BvT0FqS0hRQkN2OUFibWFmMUFPeGtYWUV6UjNCUDJwZ1dqN0lxWFFiV2tDcm50YTR4cjJLcWJTdDdVMDJXQ1lXRFVROUwzclBDbkJRQS9WeGIwZGxBRklYaEVEQjd2WEpTRVlLUW82T05CRHEvdUFmMmh0SWMxK1QxNlYrS1hBSmVScDJ4SHVwaEJEU2tMMlpubk1Db0U4TVBDQUYwT1hERmFBN2d2VzFUMGRFQWhTZ2NxQ285ZEVKVUNyNGg2TDh0TDRhVEFFRmJldGtpOExMNEdRZDVISllDY0JQclVPUUFrUUFCejhvd3d4ZTRBWTNJRENCREhuQm5WSjRoaGVJNmdWS2ZzRU1Ma0NDRFNTR3V5MnFNUmpaOE9EbkNZUjZJaVRCQjJUZ2hnV0txbGNJaWVBV2lyQUZJaWhCLzFRMWFCWUdBWmRCTGRmV1F4KzVDZ0FHZ0lFcDlNQUZCREhDcUxKUXFrRmtBUkV6ME1CVmZCb1ZPenZhTHMxU2dBNXlwYXRLRXlRTFo1Q0JDUlFnbGVLMXlsakdlclNkWlN3VkJkaHFCQzZRQW5JSDlZOFNQc3Badi9HY3FHYzlrT01vQUMvc3lRc0lGdFFldXh5UjFzQzJkVjV3SWthU2tQRmU2QVMyZU0xRnhXOUpGWXRmWEtNbWxjMDhPMHJtMkZza0Q3b1lpYTR1QXBMYVlpcTJMYjNvTFZpbU1tcmdTbVFiaHhJMUpZTGJrVis4VnNHODNTM1NLTVZhMDh5aVBUTXBNRXllN04wVnNYYThMM25HTkVMYjRCMUw2RlRqVlJPWGlKRWwrbnFJVVFBdTdrczY1ZDRPTjdkVGJFS3dxbUc4SWZVNkNJdDRmRENycnRHd2R2OW1OcnEzSlVtSE41eVMwT3lpUkU1T2tvVnRoVGM5NjFnbGM2dTVuZ084NFg0VVdMM3BCY2tzd3VWZElsMVRiblhwMkU0NnlyR2ZsSEhQejQwUTdRQlZaSVNkdUx3VXFYV21jRjFjTVhFNHczWE9KcWxRaFcrN0pXdmFJRFljb1kxYjIrSTZIbzJWUFpxUzFmdmVQbGszdTNueXQ2Z2tOVGx0K2djSzJzUFFqbm5sbUZwVTVXUW1Ddks1T3pPVjBWUTRlWVNDTUxhWTEySE93c3ZFNkFOTUR1V0ZXT05VbXVqSDRqRnp6VEd3cEQ4bmVmNWQ0NFErMjJSRlAwM0tQRmFBNGhYbllmVGhmTndBQTB5OFdPV1QwOG5vVjFTUDhuaENSNmd0K1FycHUvMzRwR2lSbHNYR1Zwb2VlcC9XcEpRRnVIa3JDZUNqcy9XUTgvQ2RtWEQvMHIwelc3Rmt4MzdRNGM2WGFoeE5rQ0piNUlkVnJFbTV4aGZzQzFTZzM3eFo5M2tEZm81SjVXcG01eUg4VjFIRUYxRWdweEQ0VXhaS28xakZCMGFzdHkxRVFSY0ZrWE1GNERLNzF4cllGMUE0TUZDMVV5VzcwWCtKRkJVWjAyZ0J1QUY4NHp4SHRFdy9kUzMrQTFRYUZWSDNreEJrZ1dVZlpVbTBOR0U5NHh6OEJDTVpDQnZTOVEvU0ZTRXA1UmN3ZGh5OHdSaFowVmdPZ3h5REF3TXY4b1NpdERZTXRSQjRab0JhVWl6RGMyRG5CRnVRb1JtdjRrejdGbmJXMWh0WnNRR1FSU0ZpRmpZajBDQlQ0Q0JxTlRHNzhYdTE5eHM2Y3g5eU16UGdsSHYwUVJDMDBsUmRBaG5Ec3pkcFJ6aUVrMld0d2hoMTVvZllBVlhHVjBOei94RXdlK2RnV0ZOWCtVRWhPR0FiQ2hJNmIyVXo4bUZRZ3dONEE3RjVNaE02bHpnQ0FUVXpSSWd6TUVZWVJyVTNoM0ZlYXdjRERqQ0xEa0FIaW5OVUJ0Z1pVTFdMamljNWNZUkp4WVkxV2JFMU5iT0puSWdCWXNWOTRmUUFLSkEyN1RHS1gvTWZzY0ZXYlJnaENySWZBeUV4MnVnb0ZvTTJmOUZOLzVCWHhhSVlXaklXeTFOK3ZBaUdRVkZZRWlXTTY1RnJ6bUpTempKWmdiR0t6TWdhZWpVYkhBWWd5d1VnLzdDQkNXSTJBMUVoR2NJRFBFQTZvNE5hckFVMks2QXhSN044QXNDSTBMRVpFdmxSbEdRWG14TmhrcEZMRHBOZWp1STU5SkVDYUZnYjBwVlo3WVU2TnFKZjNQTmZ6YVVEcGhnNmJkaUdDVmxkcG9VanZVTVFwLysxQWp0R05NUkRmajhYRVNOblNFTFRkakd5VmpUU0Ezd1FCT3FqSTMweVhEbkFPc3oxRDhMaVhES0prOWIxRDN4UWs1OUZPbzFpR0FuNE5BU1FBT3NuVkF2Mmt6M1dFWmlTUnZ3bk9NeFlObkpTQTBtSlBxd3pYTWQxWEtEQ1BqY1NCMGtpSlo4MUFqclFYM3p3QXpVU1A2WklKVmFHR0V6VEhlWG9IV1ZwbG5iQmM4OVRYaTBDSTNpVlVxYzFKK3hESk4xelFIcGlYUERGT2o3MFg1MDFYVWZTS1ZqNUpLWm9OeXp3TEJZbFdCRTFFbzNwbUkvNVB4ckpVVk5CSyt6Uk5lMlZBN3c1RU1ZVkpENFNuTjhEUG5NcEEzSHdQbk5pUHZxVkpFbmlraG95aFBZalZJYW9ZN0k1RVJ3VFlmYXlHQTFoR2k0ak9uTUNCVGNDbmsvL0NRVkVNaVIwd3BzbXBwU3R3ejdNQ1dqbDh3T0JlUUU4QUV6T2t6UlpWcDBYZ1h4QXBXTzJsQ1lxc21mNVJ4OTlNUUlUTUNjRFVTVGQ4ejNkTXdOKzBqNUdFajUxa2lkQ1psMGswSFpLcFNXOWlKOHpOM0QzbEoyMWwxNFBvQUdvbFdwZHNFQzY0aU12b0NkOVFrRlJGbVVsV3FLSUlnTTF3Q0VZRkpzYUNoN1hPVlZLaFJWNk1VQitRbWt6Y0dSQmtrQkdSZ1JkOEdadTltUUw1QVl6OEFGdDB6aFFZYU0zaXFQY01SSkd0Q1liZ0RNS2dBRWtJQU16TUFOR1ptUjNFaXBPRm1nUzlHWURzUjRZaEZSU09xVmpjaXdNT0JVN0ZLSUdHaWhuMEFWdUZpcG50a0lPWVJxdTBxWnVhaWtDNFZnSDRRSE9nZ0VLMEVOM29nUW0wWFFHdVVBRVdmQVBwb0lxLzFnWEFZQVlWQmVvc1dJdkZZWUVRZEJBS2FRclJKQUxwYklGcUhJR1ZJSW1yK1YzbXNvOFhCWVZXOW9CTXRCa0F4R3FLNFFxUkFBRkpWQ0JVNkV4b05hcXpHTVZVakVBcU1aa1JKQkNtN0JDVzNBR1FkQUIxTktyeEZFc3Z3YXN5WklYcE1RZUxEQW5RUUlrREZFQ0hZQkRYR0oyZmtPdEkxTWNIakFjeFlHb0VkQURSZElEeU1VZmJjS3I1eFZyNURveUcrQUJ4T0V5RUhCckVZQ1F6VFVGRWFBQUlUUXRoaG8wOVNvMXk0RkR0d1lCY3ZaUGFRb2NjbmF3VUlSRE9oaXhHUkVRQUNINUJBVUhBUDhBTEE0QXZnQzNBRlFBUUFqL0FBUDhHMGl3b01HRENCTXFYTWl3b2NPSEVDTktuT2dRUUVHTC93UXlCQkFBNDBDTEhRVnkvRGZ5bzBtU0Z6VVM1R2l4SmNXWE1HUEtWQWpTcEVxVUZ3ZDJKS2l5Wk1hRUxFbnViTGl6WllFQ0VBZ1VXRkJnQTRSL1RxRWVIVUMxQUVlQkFXN08zTXExNjhPZ0dvY0tSU255NTBlUkhRc1F0UHJ2NklHMkQvNHRlUEJnZ2R4L0R6WThhSG8wUUlFQUJMSUtDRERZcjkrQ0FpUVdTRHk0c1ZhdmtDTUR4Y2x3UUlBQmF0VkN5QnNoZ2dZU24wbUFYcUVoQWdxNmY3T216aXIybjRmTkQxaXNrTTBDeG1tNmN4R3JUZHlXZ002QmlROElJQ0RnZ08vRmdBVUsrRHNRT2U5L3p5VkxQMWdTYTB1c1ZQOWhiZzRWZ3Q2QmVnZlEvMzNndmZ4ZXVIYmp5bzJ3UXJTT0hpUGl3Ni9SNDhPSWYxTTBsTzdNZ2oxN0ZDejhFeUFMb3JYSGcyaFRrSkFnRHlEOEF3TU1SMEVuSEhHTUdmUldBbTh4TU4yR1d3bkVYRUZxL1ZSQVhTdVV5TU1ITmFRb2d3dzVzSmhER1dWSUlVVVpVSFFCUlJsQnlCQkVEa0g4RTBRUEEvVkFYMzc2cGFEQkIvOWNNTkFIb0hVR1ExMExNTFVZVC8vNEpnQnZ2bkdvNVliTVpmVWJjeEgrWlpsVnpBRndsR2trMURCREdUTzRVWVlNLzVSQmtCUUR4UWpqblZKME1VTVhYWnpoeGhsbmRDSEVQMUxrTUVJRUNyUTFrSEJ2YmVub28xeDVtZG8vRUN3MW9sNHNqTkRGUHk4UThROFJaeGp4enhaWi9KUEZxVi9JTUFJRzV5a0s2YXV3U3YvSEJsSklLZkFBQ1QzSUlNVVovMnppcWFmL0FPbnFjYlEyR3V1eHlGSlVxWHBxYmJBQlh2K1FRQkJkMmtHUUtFMW0xYlRTUWo0Sk5kSklJWUhrVWJmSmxydmxUVGRwVzFCWk9vbkxVTGdZeGR1UnZPcCtTMlZtcmhya2tWbm05Z3NSdUdCOXUxTklsSGs3VkZCbkZieldBVXZWdGNGY1VlSlYzZ2FZc1dheFNvOGROQmkvaUJIbWNYVCthamt3UzBQMWRCTmJJZnAxVkFFRFNPd1V4Q3lnc01JL0s2QncybHdGS05YWHhSbjlGU0tJaXJLbDNkQUVaWmxSaFFoRko1akhSN2NGY3Nnd2xZWHh1cGFaMmRHeWRpMmdGd29rdEtmQnpMTUJ1RUFFRUI4bEpRRktFZlR3QXdBaUtCb0pCSVpkODBBd1pEMXRYZVBGQmZFS0MvRC92UUlNY2gzd0ZGS01MV2FsY05EOWswQ1ZqRVA5MG5VdVdmMlRoNUpMK3M4Qmd0c2xPQUZ4alFjRGV6akkxME1RUCtTNDQ0ci90TmpERDBMR2R4OFMwV29nb0EvNnNmRFpmUjhnT1VXQ0xJeTN3Y29EWlRsY1lsTWI2emlzaGhua1Y4dHRHWllaWnMrdWdPSVAvNnlvSTV3eTNBZ0ZGTm5yYVBxUFBjQ0hCTzFJaEYvRFFEdTY4SThMTHBUaGdnb3lmSURDN3o3eisvVHgrSDgxVm5OUFVVelZBQW9ZUUFSUUJLY3U1Q2xQbS9JVHI5d0Fxb0VBaXdoS0lFSVJ2dkNQQ0xSbFFzVEpud2FuRTZGS2pRZ0FMVU5DR1hqMUtSS082aCtETU5VWmRHQ0IzNjJGTjAvWm9BdzVoSUVSallnZ0dCakJER1R3Z3l2MElBYzE2SUFGL3p6Z0ZLZU1pR0dWMGxkT09FWWRuQUJnWHpPTVltVFFsWlBIc0dzbGFCbUxUdzZHTUlSdEM0cFNQSjYyMUtVd2ZhVUxMZUlhbVJPeCtNU1JXZWVMM2lwWXZNTG9xSDFoSkdObTNKL0JxTFJGa25rUklTWnoxVkU4R0RTMVJFNHRGbU1pSGJ0Q1J1cGtzVjJQWE9KSjRwZ1JnWTBMUkF6VDJnSDBkaGZ5UEVzN3Ewa2tSQmd6dGFQaGNaRVVTYU84S2ttd29OZ0xLKzFhMkZJZ2hyY294Y1dHbUFrbGEzN0RFT0w1RWppb2xFd2tTMEl1WG1yUloyYWFWVk1HQjdFRjFPMUo0NkdWemdyak1kVWNoaUFiMjlaSjdyZ2JrR1dUTjBoekduVENHY3gxV1JJbkIyc1h5cmdqbmhHUmlEM3RLUkhOYnFNVXd5VHlpbTNaekZ6R0EvOEJ1NmlGZVZaYlRvVjg0eUhIRkNjaGdWbU9SZ0lEblZPRzBTV3diRXNhMmRJeXBIem5BYWFKQUlHbUVMc0NvYUJ1bGZLZ1BSRkpxL0d3NEtSVG9NMUpWOEFlOVF4a0FSQjRpM0ZjcFJHMVlPNHRVVExBQWc2d1UrTkFRR2xGQTJZd1NjWXZrREN2WlpXS2lsUHE4aDhCb1NBQ2VZc21CSktDRkFJd3pLSnNROEh0NHZNSDEzMGdRVi9yREZUM3VRQVVqSTFtbjRObTMwcFVJZ2ZJODI4N1RRb0VuTWVZREJwRVErV2NYTDB1b3hPaEliSjUyM2tLVTJCS3FTTHVoVHcwV3dFSVJDZWtId1hyQi9TSmp3YUlGQUVUbkZTc3BaRmRhRWFRTy92Z1J6OEpTdEFLSHFDVTRRQW1jZUEwaU5FV2w5ZUlqQXVXSG9KdFA3bjJ0aEgvbU85SFFlRGVqWEpBSiswRjRiZXNJMGdRNkJOY0pOVE9TRGhBVW1kNU1KdlJ3cFJXdXlGTVJvUmpVTUR3eG5pdHBVanl3TlN6YS9KVWF4c3d6VCtRVkFNNFFTRk82SzJUalhEa0l6Z0ZLMWhBa3F4K1JrQ2Y4NFh2UFRySW5aQnF3QU83QkNZNWYxVmtkcWY0b1o2dHhTOW1jbFVFcG1BZjBlQmdDaU9RUWZ0a0lLZjFWZGk5ckt1djZkQUxvempGU0FvemtJSUxaRkNERlB6T01JT3g2NENSOWMrRU1ROENOWmt0Q0hJWG4vSkttRkNDK2hPZlhzQW5CYnJCZ1lBS01xQzZrSU4vYU9BODkxdHgvaWIxRStJeEo1ZDZpWUNDUnNBSENuZmhCV2NBbFJMK0lTb2plRXBVWDNpQkRFaHdIdXdxT1pqNFFrcGJQRENWQjJoQS93WlovdFEvZUVVRUkyeUJJRmt3UWc0MGdKbW5ISWNBTVQyem9QOTVMUTM4SUVaOUlvaW50a0FFRnl4QkFiL3pKNldxS3VoS1AydXBFQUFnQm5vUW8vTU81QXhCQ0lFQ0ZEREl5MUVLTDJhdTlJQVBXeDZhRFVRSDk0SFdRUVlBQVRhbyt0WURVYzkzTUxBQkRGaHdJbVBrR0JoeFRXd3FHZHNtVFF4a0xGdFRiRHJhMFpnS2NhTWxtWDJXT1U2eTJiRUtkcm9XRXNsdzhXU1ZabXlqdUZtNUxteExoNHJiZWt3anY0MUdWcXFTamRXdTVMY25wenh6eitUWkFsWWVGS1h0Ym5lbjA1eEZDUXU5Qnc3YllkczcyY2pXWmtMVStKcy9WanRjMU00anUxT1dHZUMxN09KRFk1NlhvSTFyZENkODRhOU5DUmlyYzg3Si9NWjVWLzhsRDFQT3c3S1dEeURCK1c0MnZxMm9ieXhTVW91UFBDTzl0QUpMbjJVT0x3L1lwQ2U5UTVDV1hXV1hFWUZsWXhLWFhZT2J6RjFFUGVmVXlQWEhWamJQMUREVnl6N3h4am1rVk94aUVYV0ljckRKOUxDM05vMXhiQ1hCSGk3dms1eXgzdXFzVWo4M3M4bDlvdHFJWHdkN3pNdWQyckxURzdabjl2YXhZNGtTYStPNzNKT3pLYlNDSHZSVEg4Q0lxZEdsbHh6S3k4ZHNEQ3VBMTBocWt4ek1OeHFUWFkva1NJandaYzJnTVlWU2RubHBORmQyQU5WUTAyUEk0ZnUyQzdhWTJNdis3eHBycmJjSDVrU05RTEVrRlNXSm1tZFpsMy9JN1BpanpZdGIvcExRcFEzbVp4dkxwa1M1ZzVNUUxmM2swc2ZLOVlQbm9iM25UL0NBN0wzL3ZGdU1WQnNlbGk1UFpXbUorb1BSdkZRcUFITUZ1KzhOdWJLcEpoRXpSci82ZjdOVVUrSWxoLzhiZ3h4TEkyamdJbStVZzJDc0ZIeHRnVlVWQkRZejQyb3hBMVZ6SlhsVzh4UlAwVExqc1FBc3NIWFVvaE0waHhqQjQ0Rkd3eHNxQVU1YVlUUVB4VWZDQjN4cGNVM05raGRseFI2Z01ZTmZ3MUtvc1JjV1l4VnBrV0JxUVJjYUJScTB3VklXeEN4NzhUTnJFU1loWWh4S2lEa3h4VENBdGh3Z2VCQjRSVWUrbHpETllTWXcxeFFQc3pab1FpQ1RKVHV5NFZ5azVVRXJVMnFGeFJrRUFqZWlFVGNEOFZSUWtuck5sRTlWVlNsMVZ6Zk9GQ1YxdzFNNVUzc0NOU1hCd1RpK3dWb3pKQmFRZzJCcDFoeS8wMDh5K0Rhem9WSDkvOUU3ZFBGNGMvYzdqL2Q0ZDlFWlg3ZzdtaWd0TE5VZnQ0RWJ1YkYxdFBSTUQxS0tmNU9IbFZKYUtwWTRqWkpxTXRRVGxKRm1sTk1XdElZWEcvQlVRd2hWZE5GcnFERVhtNlNIcDlhR011aFZuRldNQS9FWk5JTlJubWg4TlNNYk1oT0diT1VBQjVJZ0lPQUFxdWRCdzhFNGlJTVFiNEdDS1Joc2lzUXl1VmFHNXNjNW5nUlRUTkZQbkdNWE1pTWFOUlkrUXJKZlFtSmsrbEVhSGRBZkpPQVpNYU9HTThOUlBQQmdTQUlhSENVdElEQmFSL0VjallJQUE2R1FpNkk0allOS1lQUlhDQ1lRbGpFbTJPRVhTYlFCajZjMTVURWlFQ016TkpZcklza2lPdklQd1RVQ3NDWlpvbEU3R21BN3RlT09TUElQOFJFdGNNTldlVEZPeXYrQlIwYmpHOTZZWFFFMmk5d2xTTTN6TTNaUk16Q1pJalh3STlmeklqUlNaS1lUWERKSlg3WVZMRk5RQXZwaEFoMHdYN2x6UGw4Rk56ZERWVk95R01ZalV3L0pLQWMzZUFYR0hVdlJIaVFBQWpXZ0EvUnhQUlNHSjRUeUQ5cmpQZWlUT2owaUErRkRqNDVJQWg5d0FVckNKRFZETnFpeE0xZHlKY0JFSEQ5MVVEMTVsdUgzTS8xVVZsd2pPMGlpSkN1eUl6RlNsM0Z5SXpTU1c5bmpJN255RHpVZ1gvcEJFRWg1SDIvekdlM0JGTjBYZXgreWpaQTVFWWRSY1ZvWUxTQ2dBei9nWGpSU1BYZXBXenZpV0tzVFdTTmdsVDRBbDN3UVBqK3duRlhXQTN4UUEzeHdBVitGZzZ0aGhLWTJtd29SbE4zRkUzKzFNbXpEQWhCR211SC9RMlhPMlNJRFlaNDZBZ1U5OGlQeGdRVGxBMTlGZGlkM3NpY3o0QUxTQ1FJdTVCZFFpSjBRZ1RFc2MwMzg4aUZUTVNKdXFCZnRRV1h1NDJGdllwNXk4aVk5a2dNUStpSXlNcUV5WWtBOHRpYXFFZ0hQd29ldHg1OWVrVHhtUnhDYmdRSWZJQU03SUdFd01tTG90U2NEY1VBeThtRkIxaWxZQmlwWEpnVTljR1NrWldxUDZhRXprVHdlMkhJOHlESUswQmxHTmdXNzZRS0o5aWt2c0tROEpnUjlRZ1NkRWtGZWRnWVJwQVJKSUFOVFVJUThDaWxsWVNZRlFKYi94RExpY1ZML29BTlZOcGQwRWloWmxtV0xKaXFmOGdWZjhHTTNLU0hadUtXdjRuOEd0b0MyT0JlZXdRZTdBaWh6Qml5amtnVmJnQWlJUUFSZFVBTXNZSUYwOVdxbjVlS0NnTFlVRUlBQkEyQTdNa0FFRGVTbXViQm9nNUFGZzBBRVBkQTdybEljQWNBd2pvb3NiTUFHTWJTcTJvRUJMQUJuZ3BvTFdYWm5BOUdwaUJDcW4vUVVwWG9VTzNxcXI4S29BMEVWSGRBRE5VSm5ja1lRZzJBRVp6QUNrRVoyRCttclVHTnIxa0lWT2FRcmVTS29ueUlGU0FCcGFwWVVTbWhWMEFvMXBIVllBWVFCUHRBRFVyQUpYYkFKRHZRUFM0QUJpWktqL2ZTbDFobXU1UklYUmFSbUZzQnBja0tzY1lJRUZqQVFSRWNyR2xtdjlwb3NSVFF4RzlBQlNFSTk1MU1Ec29NUWFtWnJCd3MxejVLampkSWVCK0VCQ3JDcUZGdXhqck1YR0ZBZWswb1FuN01DZXRHeExnV3lVWFJETWhFUUFDSDVCQVVIQVA4QUxBNEF2Z0MzQUZRQVFBai9BQUg4RzBpd29NR0RDQk1xWE1pd29jT0hFQ05Lbk9nd3dFQ0xGd0ZZM0VnUTQ3OEFBajErRkdnUVpFZU5KekZhMU1oeVkwdVdGR1BLbkVuejRNcUNKQzh1TkRrUTVVdVRJSUgrSEhxd1FJRURSaC84ZTBCQTZZWUJCVHo4S3hBZ0FOV1BWYXZXM01xMXE5ZWVCbk9LL1NjV1pBRUFCYUFPUUtQZ3dZTU5jRGY4ZzFCZ3c5RUNFS3htQlRweTZyOEJVOUdpOVZ2Z3I4UENDaTBpSGxoQXdEOENYeU4vaFVuV3BPQ3poUWNBZ0xwVXdRWU1FV0FzaGVIMkFZUU5wejJrSFZCVklBQ0JBMDZYWG9FQ3hRb1dLMVpFV0lDaTlJRzVlSDlmRE9EWW8xVzZlQWtzV0FCaitWelVlQXRUdGVnWXNnQUNDZjR4K0pkZHNuZUVJbldDL3hXWU9lMWZ0RkRSVzJWTmx5T0VCYlJKNEJoQnY0ZjlIalh3Lyt2eDc4T0lmeU5vSUNBTEdyQkFBZ3U0TmRkY2Fjc3h0NElEL3ppd1FnWUtObmpBaFZjSlFOd0JqZ21IQUhjRkllRFloOStWR0JsSkVQZzEwQWExa1lBQ0NTUk04VUVQZkVBaGc0MDI1aUJER1ZDVUVVUU9RZnpRZzVEMDBWZUNnQ2xFb0dRRUJwS3dYdzM3N1llZkRIekljTUVGUENobDFVQ09YZmZZUU1LWktPWjNHQldtWVdOYmZ2UVJWWmh0dVVFRUpIendBUi8vMVBCQkRUTDgrQThVWGZENVR4bFMvQ21GRkh3SzBjVVpSSnlCcUJJdkpIcEdGMTNNOE1NVWNrRTI1cVdZUm9aUlhpa1NOTUFBSGlqUVF4bEVsRXJFUDduOFU2b1IveGlSeGFsZmRQOVJBd3NQRk1ZaEFRSkFZR21tdlBicVZYUjBZYUNBQmpKMEljUS9YUXlVeXhiL0JHcVlYSVVSUUJkZHZsWnI3VXlvZmFZVUJnTkY4QUNDU2syRndXS0prWVdUbWlxaHBHWkdmUFVVSGtFYUJjWFR0ZlJpbXBPNUd4a24zcm9uOWNWdVNDMnRxMjlRNTY0NWxWRUlFNVptUWUvVzYvQk9KWlVGYjhQckFoeXhTc05OaFZTdFNwbUdHbFJzSXF5WFZqVlI5MCtYSnhPbnNvWWFQcHdwUzVTTkY5UllQV0VHQVdBRGhQdUFraXNzNEJZRXRVYVhWbXVWd1VaV2lpa3U5NERQQnpEVjZVV0ZjY1FZUm81bHJPSlVBU0JGUUFFRS9FWkFBTHNTNS9KWCtuWkUxbGtXMGVYQm15aDQrOWJiQlpnVzIxM1RHclhBUHhzc29HUUtHcEQvMFBjVVU4VG81RDhzRU82MjIwdkRKZTNkRC95MndBSE5PY2ZjUUtMZGZlRUJFR2lvTXE2Y2V3blpkcERoZXZMWU1vbDAyV0NBa2FTVlNtYnBoZFJTS1pCUW4zMTg5SkJuRGovSU1GRHU5ajNaZzV6K2ZURFFCd2ZxNWxaYmJrV3dBb3lBdzdqQ1A0SUhUc2NEMUhsNWNuWWZlajA2NmRaYWRhOTRldWtrSFc4d2xrK2ZEQzdvTHNPT1FkcTMva0Q2amFCRGtUU3V2Nk9nVWtRcVJSbGwvS01EQ3hHQXpzRnkxVEx1R1pBaUc5bVZBTmhrRllSdDRBRzJpZEVJOERRUVJmM2pES3JDNEtsUXBTb2xFRUVKU1NpREJwNnl0Wk1kWUZjSFRLRjNwblV3dWp6QWJ4cm9RUkNFZ0VHQ01Hc1FYUmdCQmtCMWtkZGRUWVZBL0U3Yy8wNURSS1hJcms3OGtVRVBGQ0FzeGhTR0xsb3J5YjdNRlJhelNTMklXQ3pSdlVLeUw0NFFiR1lqdVFuQjd2VkZkUkdzTW1iTG9ncHZBaStzb0l1THhpR2pUeWhXTm96MWhTZGVOTXJCd29jWU82cFJUSDZrNGs3bVNFZ3dobVZtWjNTWHVxU0RzS2FVOEdyNVFwY2IvMmdpakgwdll2NmEyTVFDTnBSMDNaRWdSamtBYXQ3U3RLVVVRQUVJdzh2SUlqa1RqcUNzUzJLalpFTU1tWkUwSXNRMU9FSGthMHdDbUZBbXhXTzFla29xNjdZNmtzV0VZaENKcFN3YjRocVFqSVVrTUlsbVpRRERtS213d1MwUDlObmRwZ0xGNkhpdktxd2hHbWI4OGh1aEpTeHFmUlFQVlFySXNLcGhMSlpmaXljeWx5bklObExtTEgreENNNGcwUDhXdVVSZ0lLWDVtVGtGQTBieWVBQm9ibUdPUWl2M0dMdm9VU3Q1V2VXWldzWW00R0R1aENmVTFkYmMrUkVCZUhRZ0tGeW02aENTbVFCOEtpcUZlWXVTZGtZYW44V3RBQmpnNTdUYUE5RzRKVTk1dU1ucDgwaVFtOUFFMURUSW9jc2o1NEs1eFJYZ2NRcDF6aitFYzhLVG1hbHFWVXVBQUxxekhWbGVjVGlxUTR0cWR1WTJxR1RyTkZDcFczUXdkNVNkR1dnS1JScUJqT2d6bzRIRXFHOHI5ZFkvdERuWGdTU3Ryc3Rwemx3ajE2RGw2R3FCMUdrTUFVSm5LVno5NWdBaVNrQklyZW91eGx6R3BQaWlDbm4wZ2srckhHQTVLK0FCL2V5RHA5emg3aDlDK2tHZDh2T2ZLZnpoSDRCclhtNSt1clBjOE9DMUlBQkJiaVNVbTViL0xyVjZWUnNJaVFyQ0FNZGtKN2YwVE9ZbHpmV2F1U2huQlp1dFFlNXlseWZiZ1RaUFB3aENjMEhiZy9uNWdUNUlHQUVKVWdCQXhDbHZlWnFsRDFwSE1LTTdmWUFIMDd1YUFFZ2tBQTVsem5yQjVRcEdSc3BBSjNLTmZQLzVqNUR5dEw0YzZLaC82cE1oZnV3ajNoTEFjQ0QvQ2NJL2dvQW42Zkp2Unp1UWdTZitCN0o0ZnVRQUp2dFNmTDB5WE1UVWR5Q3NXUXAwNHZhaU90bnZIenBhY0EzMHhDUCsrV2pCdVFOVS92S25xRWU5d0EwRUtjTU9zTFFBdXp4bVF4dDJHQnUvT1ZtdS9RTjVLTkRiV3ZrREtCZDNvWDgweHFBR0ViV29EV2JRQlRvSUlFRnVGV1FzZ2swbldRR09Yell6QUFXd1lBUlNRSlNwaUFDR1ZSRmgvd3RFWUJVUnZpQUZHWXlnVm4vRmNGTzdURTgyekVYTXNTbXptWkVnM1VPOW9DQ3AyaUFSY2xDZzZEZzFBSm56TTU4blRaQ2d1WVZBUFFqVXNUYkJySC9BV1FZYVVJb3FkVVZxU3B1NklBc2c4UVhLNEY4cDNDQlovN2lDQ2ZEMm1DY2lSVmZrT25XUU95VXNmcjVKZ200ZENMZFVVMDFkRzNzdU1YMUFUSmZDN0ltd0VTemhHZTZ4ZGIxRmZwM3hxZ0NiVjd1bVRVay90bXNsOHhXS3RpK1p5R3VyaTl2VmVqYSt6TWJGWEc1eWpQQkdJL2pBWnpGcG83c3IxVzZZdm5JeUwwNkNlNDRwK1plNGQ1a1REenYyM3EyY1lyc2JWa2lMSmVUY2ljemt2a0tXU2ozaXM1a0lyMGc5eWJnUWk0MzdYMkg4aVUzNHZSaWpVQ3RvMVA5MG94Y2xtZkdDUVZzbjVLNW5MZnVseTMrWCs5eWcxTmhMaVlpYXY5UUZhMWpaaXpGYm5rYlRNVE9PZDNRNHpCSDV5Vm9heGJKSVdVQVJ6Zm4wNlZ4bEx6U0JKY3ZqRzIxMzR4eU1FUmQ1UXlvZXQrZmdEVG5lckFvRHA1UDFsRWx5bmtHR09ML3RMVytZZjVJa2pFU1lhUm8zNGhFM01IeERqMGtCQTRsd25NOWRZRjIwb3Bxa2M3RFM5RnlzU0dIVDE5ak9yOE1ZQktwY2draHhwampwbHhUdG1aYXhqR0c0Q1FDT0lmVHNSMEU3QTFlM1M1TTgwYjZwL09IMnFoYTFyM0ZwWmVxVVlqcnArVDJZYmJKbzhNSU1Xb0FXVnJmMGhqWkZGZXQwYkQ0U3FyQVFBaGNWYThhdWNwV2NYNFJseFZZTTBJa1R0UzB0RUxoL2pLYi9OTXNDRzVNMjhLQ24zOW0zQnVJem9DSk1OYXk1dUNCLzZaWVYvSFRuZ1dIODFNUlR0Y2xqVFZxRGhXc0ErR2NnUlJEd3hYc2JsMDg1d1JwUUlSVlFnUUhKUXpqcTV4YXFvUnJqa2hlcDQxaG9FVkE1MVRhVjVoWmtoUnh0WkRhTzhVU3BkRGtYQW4wQWFIRWdaU2tvazNuZEJrMjNkQmFiQVFBcGdrbzM5UzN0VnhyOGhGSkcwVzZCc1JSY3BWTzVnUnUzd1FLOWtWQjBJVURrSWpXaUJnSHZrVmRLTlJWYkUxaTJsMXZnQjM1QUpCSjJwRStROVJjNTh3OFIwQnNvSUlSN0Z6ZGZSWFlyQWhkbTVUYzg1VHhPa2xPSWcwMXN1RFdPSkVwTDlUTkx0UlJTZURsTGRVSlc0VkZaY3gyRUdEcGY4b0pxTkRCcXdvQmtOZ0FQLzZRa0xQSUFiUUVxTUNVMHBMWTFEc1JWY05JMzRsVWtmNkJkQWlJZ1RPSVdacmdpUXZVNGN5VTVxUmc1R1pBQkZnS0FZUE5sRnlFNm9BT0RHdlpISzBkY0lHWlMwQ0lkSURNM053TnBBYUFhMFpLS0tHQWdKVkFmYVRWQnY1TmZNTlJkdElHRURMSTBUTE0wRlFJRG9uR056RUZXVkdGWXhjRWhDdEZlM1pHSUxCY1NHUWdWQTlOOVdCRi9rSFlVeW9FQ0RnQWo4dk03dFpNZlF4SWs4QU1nSTRBRVU5QTM1UU1qR3JBQ1UyQ0dFZWdBRGtBSERpQmJ1YkdRdE9GWDB5RTZidWRiVTFXQWhiaE03M0tPeGlGWkRKTlBhOUtPcDdFOEk5QURTTkFESXhBRU1oUmRvZ1VGMFdVZk9UQmdOWkJmZElKYUlEQUZ1V0dHU1BZZ0lQOUFCeUJRUGd1cEpFaVlhakNZVzdzMU9vZDFhdFRrWVZyaGNTT0ZGcEMyQVRBQUF2UXhQL1poa3RJVkJ6S1FBLzlnbGJhalJFb2tKUE1ESVAzeEh6aWdBVXFDQVJpd0FXMmhQRHkxazlHempHcUZpWUgzU2wvV1hsbzRiV3pFbE5VRWZXK0JBaWt3SC9SUko5VEZIei9DWCtyRFh5WkpZQ0dabUtKSUt4RUFnUzh5a0JPVVZvZEpqend3QldsUmZkdkRFZUJJZEFlQmQ2Q1VJbmxuTnh2d1BQb2xBMEx5RDdmelh6ZkNYNXhWWFVZeUlFeWlKUEJ6Si9jUkJId2dYZXZEQjU1UUE1VHlkRitDSzRvQlpKelptUVdSYTl1bkpucXpUYklqUHlGWkF4U0VtajdDbFVoVUp6b3dQMU9BQStNVmtqSjBPenZpWXZ3ekErdmpKSGIvZ1ltMmQxc1FPWnpnQVdLZ0ZKeTVKaEJMOHpZUHNEeXlnejVYcVQ0bXVXQXVvQ082QXovVnRaMDl3aitEQWltUElnVXpRS0M2d3dNb0FDMVlFNGpvQ1JGVk56VjZCRFZ6MFV1UVZuOGpVQ1gyc3o1Qm9qdFFRQ2pOTWhBdTFpTmRRR05kOEFKbllLSm40QVlwR2lnejRBSVhBQUlneFNGYzFxQVRzWGJ6MVJNUVlJNGU4U2FadFFJek9VSHJreitHZ2l4L0FtWEk4aWdXZENxT1FoQW0yZ1V5Z0FOYWRqSzRNcFEweWhYRlJSN2kweEZwSVJkS29RRVRoQ2ZkT2FKSW1rR0prZ3Rua0dnWlZFRVhrQUtWUXBlYldhWGVVWFViOFdGNTl5bWdNWkJsWUN5SG9pcW5raXF0WW1XTkFwNy9GRXFEOWFad0tpWVJCV2tGc1N1VS8vZ3R4ZUpCY2Fha1lFQVFiMFlFcitJR01rQXJjN05VZzNXbzNWTlJCNk1XQThBQ1YxQUdOV1JsdVdCbFdiQUZpTUJvUGtkcUdFVUFrdWFwdmFKL0hoWXFhUkVCWHNvSGdFSmxwY0lzUklBSVVvQUVIUUFZbmFJclMyV2N0Rm90czRvWHlrWWdVNUJwWGJBSk5nUm5SSkNwSHNBZVg2TTFUN09zRHRNcFVYRmtMQ0JheVVLdHFUb1FSTkFEeFVvUUphU3MzbG92aXpFQUVUQUZNNEJqMHpxdEF3RUZSd1ljRzdBeGp4RXU3L3F0MmRJMGNjTURINkE3UVhBRk9SQW9HdkFQM0dKWFM5V3ZwaEd3QjBTS0Q2QUJINkFEU0tBRGR1SWsyZm9XVWtGckZIdEFENFFhM01Ja01WSnAxQVF0SVR1eXBKTXQvZVFVNnRjYkF4RXFMZ3FiUmNvV043TktFUUVCQUNINUJBVUhBUDhBTEE0QXZ3QzNBRk1BUUFqL0FBSDhHMGd3d0QrQi93d1NYTWl3b2NPSEVDTktuRWl4b3NXTEdETVdIR2dRWWNlR0FoVWVGQmtBWVVJQUhVdWVIR2dTSmNvQ0JmN0JsQ2t6UU15TktBY2tGS214cDgrZlB4R2FmRGgwNVVLVkpYbXFsRmp5NW9BQUVBVHFMQUFoSWRVQkJaNGVISm1RWmRlaVFBY0srRGMyck5tellWMFNSQmxSSjBlWVZYZXkrY2NHTHN5WUJVSjZwRm1UNmdZSWY3Rm1kUnZBb0dHR0NoT1REU0NBc2VQR0JBbEFFRkNnTE5tdWFETnJYdHMxWnVHYk5nc2psUW00S3RXN0FQS2lSRnBndzRNSUsxaklYcUdCaEFZV0MyRXNlTUQ3UVdtN01tLytPMENRZUFIaVZRbjhrMHpnQUFRQ1ZBa1FNRGkyc1lDeGhua1NaTEM1dTBhMktRdDgvN1RKTnVGVUNJQmhyK0JCWXNTSEhqcis5WkRmNDBlUWZ6L3ExL2czb3IrRy83ZXhFQnNLTVBUbTIxMERMYkRBQ2l1UU1NVS9KUEF3eFJUdXVjY0REeXNjRUJOa1loRlVYWWRrRVdDWmR5U2VaWkI0Q3dubjJnWUxSUEFQQ2dPOVYwTU5QY2dnUXhBNUJISGpmRFR5MFFNZi9JM3dJQWxFNHFDQmtDUDBvS1FNUCtTWVF4bFFScm1ERERXTXdNSURYVEcyMkZoVkhUQVdjU1dHS1daSUtLWVl3Rk0yMVJTWFRMeXQ4TUVGTThLWEpCODRsdkdQRkYzZ3VSQVIvL0RacHhKOEVnRm9uelA4bzhFREc0cm9wWmlNTnJyWlhEVWxGSmRPdkduUVF4QjRucUdwcGd0dGdjZ1pibFM1QW1uS0ZUQ2RvNmltV2lKVkNrQ2dnQUlQYVAvd1F4bGRDSEhHSm56bUlzVVZIZENrNFQ4TFFMQ0FxYW9XYTZ4bUQ3ZzJFQVlEd1FERFFodE05TkZXWGxFckZFZHN1U1JTZVVZdGRDMjF4NGJiS0ZqYWVhVmRTZ1dadE8xR0U0bjNWRXc2RFJDU1cyaG11UlZZNHViNzAxTHBwcHNVU1ArQ0oxQmVLRTQxUUZVblFuWGFtYUtGeEZXNVozMm83OFJiOFN1UmVBVERsZVpwVkNHS0tGVlFrWmRkYXNHNWhzSEp2UkdFSG5vd1RZZHhkbFpoVjlhSXh4V3d3QUVMTkJmVFpPSkJvS1ZsbE1sTXNaaDUrWHdTVmg5REFGTnFxekdNTkd3c09PamdCemowWi9WQUkveUR4QlQvNFJZQkN4SHdSdEFDLzJ3d2s2bFZZVWtRakFUNUJpeVd4eWtuMHN3aURpUWlBUWtvdDVBQWVnLy9IUlMyQjNsV01VZUEwd1RCQVE4d1NBSkJQV1I5NlEveTVmZ0RrLy9RaU1UV0FFYXR3UXBmZjUzc3EyMnVRQ0dGU283Z280NUIvRkREQnp3Z0dwbGlCOHc5bHFKK0d3dGFtWkd5aTFmYURmTHdnWHMwQXM4SEh6YitZMk1RZHFJdUF4UlE1bGdHbmxMODA4VUxaM1JSdlJ2LzJNbkhCeEZreGRHWEVOY3VQa1VJUTBaWnlLQ1pwNU1DTE5UWWhSdUFZdi9QR2ZNVFlVUkRic2dnSkZYTEhaY1FtT01MWUtNZTRJRU5ZQ0FDR2xoQ0RxekhLVDhScEFzYXdNQmROT1EvQUFyd2dpWHltRjljOVk4VlZHa0p4cnZBQ0REUUtnVjQ3elJLUXd6aFBDSVF2WURySy85aVNmZ3dTTU9la0l0YUZrT011dFNDTGFUbzVWc3RYSXRpLzZaVlE3OU5DeXpYS29vUEEwWVNkY2tRaVJpN0MxNWdnaFN0cUtVdzJpcWlveFNEcjNXRmI0bWMrWTdUYUxJN3JEQnNKeTdFbHhaVDViQ2o2SVdKM0pwSUhPVjFFK0c4UlNZZWdJbFd6dml3T0daR1ltdmMxeHNqNGtkc0VVd21BNk1KZVRJMkVCUzlNUzg4TVE1ZldzSVh6SWlGT29rUldrUVVNck1aQmpLTTRFcUt0a1pKc05Rb1RXbWh1VXRwUGlhZTBCU21XakR4bUcraWRVckJ6RVEwS3JTa2RSeFNtZWI0VWlhVVlSZGtIUE5KaUlpeWtZWVJEd0NtOG8rb1pHVm5Hd3dNQko3eWxKeDhwalc4aVVEWXRJa0NiWWFOTjdzNW5ObVU1cG5DWUdjbnpTeExhSXoySExzdDV6bVZ1VXgxSHFPWVlucUxrSG1SbEdIeStQOFh3RHhUbVlWNVYweGVReHZiRUtrMkJxMk5vVzdUelcrS0xWcW1rbUpFa1RPc1pnckxPYzVoRGp4clJoYklLS2R2QkVsQVpFSTZJbnNTTGlsMDFBblRkdExLZ0JhQU4xR2owQWQrOXpzZEpJbHg4d25TQ0JJYUd4Y05oSE96dEV1MEZ2Q3NuNktBUVIyY1Ftd1loSUxkSkNTWU14TUFtRURxSVFTWXRIQ1F6S2RucW9raUltSUZBZytBZ2VJb0ZKOGUwT2hITldLY0RNd2FKQ1Jvd0VoVEVGQnNkQU5PY2g3c1JTc0F3UlIrWjdYR0JlRURmRmdkRHdqSHJzc3daSFpYOVVrOUJ6S1paaTRBQlNTb21nN2dJNS9UL1FOSFBjaUJESElnSDlXVnptb0FxbzAySDJBQmJUb29TZjI1MUtWdXBGa29FSzhHVXlEQkE3Q3lHSTcvOUcxRHhMRmdZalZ5SXNTNGk0eGtURlplWnpxakdzamd0ZklaUVpYMnM1K0IxT0FLL1FuU2ttb2tBeWhKNGJyU2kxNmhYRkM1RDZ6QU5KSXFpOTUwdTl1d3BJOWRMck9KOTZqNUQ2eWdBRVpUVSs1QVppQU1GNVNCZVZESzNwMEd3cnpyZGtGNlp3Z1VRYWozQXV6SndMc2JDVURzeWp1eEtON3VNRzk1YVFFdzhBQVdIQ2w3WGFoVm5nSk1QeUp3bUFpNStzY0xpUENDRjhnQUI4d0swWEtreXVBaTJsRk5NaG5BQWZuRGh5ZGxTbE1lTmdJUnRtQ0VMQ0JDQ21YdzdzMDRhc2tXQjdJcWNVR3lBamFnZ0E1b3dNYWN1aFZEdGtBRUdiQUFBOHprbjVHTnpBYWxGYkRKU0NqREdhZzNrRTFzWVNFYVVNQlUvS0toWDIyNS83eDJRWThDWU5DZWYwQUJDdlByQXE4VUlFRzdES3VpYjk3dEFEekc1S3BnSUZvZFZDam5TRGpOMlFiNjBReFJHMUNPU0JFaVFyckZOMnpoUjdJbHhLRndTNDA4dkxRUlYzaFB0V2g2aDMxMENMNUdHY05xaVRwTWxQWktFSVBvNmh6S2NDU2ZQbWFuRlZsSncyVHgxV2JKTkNWQnlXbCtxU1NMb1hZSlFxcUptVFFSeERNaE9jeTNYZ2hzcHBBNmladnV0TVg0OVdscmdZdGt0RFVOYlkrQ1MxK2prOXJWZGtpc0llSXdVQk1SUE9qbVpYQld1aFBEYU1WZVFKUjF1aGx5UTVBVW1Tc3VQR1ljUGRtUWY3a0xSYWFCU3VCU2c4WEJ4WHZmL0ZhM3FubUNiQjlTUkZ0VGJPL09tamxGdXpDOFlWOEplV1lPUTh6RXRydGZGdjhMdGJyZk9CU2IxSkovS096NHg2T2RSb0x6OXQrWW5qaG5iQTFIaTNVOHhrbzdtRVRieXpBczRsTGxoczJJK1RMNVZIcGFSMHVFM1MwUC9XanJvMUR6VEx0Ylppb1JwSlBEUUJ1UjBJVG52UHR5cm92Wml5RjZPOVhyZ25aVnBmVHJZbGp2bUxrQ1VKZVdwVEJoS3RFS3hnWmR3TklnT2l1bkRJRGFGMnVtcHh1ZVZBamFVa0dlL3NsV1Y1MGdia0ZtSHJIeUVnQ2M4aStTdWNzZVhZS1g5ajdnME1sNkFLeXdoS2hUb3Eyck0rU2tRbTV5T0p4RlJ6d3lvODZXU201U1ViYTZ2VnJQSjlQVytjd0QyWFZrRFl1bGdiWUpnd2c4cXplSFl4a3F6OTNJbWxTbk1wOXBwbktJVXlwZk5zWXhzaFA4aVRoa3owM0xTMTVuSW5yL3BJSXVZZWZBNVYyY1YrOUxYMU44MlZoWU50MHMwQU5RNEJ2bHE3S1ZDSXVuZGpwdmt3TXc1MWZRSVZXdmhGakxZUkRUd1RjRXFFWFpwbEx0UlJvd3gzRVNSaHFCcDB5UTVIa0VWUnNDb2dGY2cxQ0xzd0pINVZDOHdURXB4RC9qQlIwZmhXaDI4eHdxeUJ5K0pIdmhJekY4VTBTemRpL1VNaWsyZ1JXRHRnRWJrRWRLd3pRRWczWFpWRkJIUWlSVFVEVlYweCtMVXdJa0FEYWpGVFlMc0NJeThSYzIwMHpMOFE5WW9pQkZGU3lIRXgzVUp4MjdWRGZob3h4NUU0TTFOSU8wNWhiWGtoV0lRbmtpQXdBdllST3VFVFZFWWpYOVlWT1RsVnhaZ3dRamdBTzJZU2hnWTRYQTRsVERvaUZLSXhuL0FBTkhoWWhXYUNEUDRsTWkvMUlkZHlNZENpWWlESUNBZFlNQUJJQUExMEZWSmdWK252R0pTU0Z3NndjYkUwSlRxS1VrT1RVUTh6RWZXYk9CR09naW5DTi85VmN6d2hJdDg5ZEJIVVFrSkNBNlFqSUZGNUloNHFFb0xEYU1tb2gyREpZU1J2ZEdIWEVUeTJhRkVIQlVJT0E3SDdBZlNsSTVRVkNOOWJHSy9QRVBVNEE1UzdpTHNsRmh1M0VnUE9nYU1BSUM3ZEVmTS9VN1BmQWVGMElIVkJSMWwyRlZkaU1BM0NFQUlsVk1MUmVLeWNnU2JraURmVEVjTFBJMWRVWVFQckpXQ0RrNVN2SURJN0ExSS9BZnU3aUVBN0lDRDdBYk85Z2FMMElDZXZVQk1uV054dFVERjBBbGZNQURLYVFjalVGOVNkY2wrOVlTUzhFVzRsR1JSN1U0OHVFSGxYVWZPUElEK2YrUkE2cFZPcGNqSkNVUVdpVGdUYUtYVFRIVkg4dVZPanB5UEtXekFqQ1FRZ09Ca21KeEtvdVNkTlhHY0VQUk0yd1NBWkRWSGpoUWhOTjRWcGRsSDVNREJRdVpIelRDSHc4Q2tiZVJBcktSQW5yWUg5ZW9JMURBV3MxelhCdzVLdU9XVy8rREhYcFRVaXRaV0Mvek1pZHlBQzRDQXU1aFZ2ZHhJL0t4VmpRU1BNcjFIci96RDN4bFUzTnlLZi93SkZFU1Bmb2xBNVdUTmVtREl2RTBIQkJIU0RabmRaVkVJY3ExSHo3eUFVSFFtRE5DSjZvb0g1TmxYS2lEbVhheVlmOHdBMEJHRUt1ekF1TzJFN0hqbDZPWlM3a2tOekVCSGVHblJ4VzVBZzdBQTRiSmpqTXlFSnRWWFhpR0k1Y0pKY3lEWndNaEJmUWpQZitBUGFCU1lMbi9DU1Jtd3hFK28zYkRlUkdoSVk5ODhVeTh0Z0ZIdFZmL3dBZFJVanpaazEvUUl3VjRSaitjOGdJRWNRWktJR0lpNWdabG9BTWtvQURBNUJtY21KNCtBWnJOdEo3Sk1VVmlCU01Nb2pranNEd0FkaWZXODEvLzVaOExjVCtCTWlnYWdHaVN0Q1lNU2lLZEY1aTVNd0JZb1FBSWRBVzA0Z2JXUTJML3RSQm5rQXQ5Y21Za0pnWDZBMUdMVWhua2RhTGRrWGhrQkIwNEFRQWtZRnkwUWowTTFFQTY1aW4zWTJKVzBrZ0N3RE5DR2k1VVJFR3A5SStXSXBmY1dTdmQrUStlVWdSZmtDY2oyWlMrb21CQmVxV01VaGZBRlJ3RDVXUWpVQVlqVmozejB5YzQrZytEOEozN0lXa0s5azVzMm1COE1XaXhVZ04xc3FHYjBDY0U0U2xTcERBRldPWUIwdGRtZ1NvK2c0RUJIY0FFUVNBRWZOSUZ1SUlyQytFRGF0Wkl2L0ppazBveE80aWdIZEFEWlFDZUEwRmxmU0lESmpBUXBaZDVwVm83U3VNeGxESUZOZkE4ZHhZb09ZQUVGakFBZjRGb21TY3N0VG94STBnUXJoRXJ4bk1GMlpNREd0QXJDSW9sMDJSNng5cGdqdVlxQkdSQWhzS2JJeEFCak5ZcVdvYUMxem94ZlRjUXJaSXNQL1VQUHZVUEhvQ2dwRnF1ZmtOQW42ZXRGTmF1RnhFUUFDSDVCQVVIQVA4QUxBa0F2Z0M4QUZRQVFBai9BUC85QXlDd29NR0RDQk1xWE1pd29jT0hFQ05LbkVneElzR0NCQU1nMVBoUEkwZU5BRHhlN0pqeFlvQ1JBd1FXSUhreVFNcURCUUtzN0RoUVlFYWFGWFBxM01tekljZUVQMzhLYkNreDVFV2pMbHNpTlhvUVFNeVlBVDdLakFxU2FFR2hEQVg4MDlxenE5ZXZEckVPVkRwMjdGS09CWnc2dlZyelFFZXFhbTBPTExDeUxnUzYvd3BBdUxwU0xOZUVXclZxakFsVVpjRUNBZ0lRaUVvQXJPUEhCbzlTZlJzVmdGckNIZE5TM1N4VDc3OEhvR0U4Z0JFQkJZc0lLMWl3K0xkQ0F3c05LQ0tBdm50M0t1ZW9RL1BLL0FlQlFBSGYveG9MSURDOGJvRGVnUkVqRnJBODhlRy9XeUZMejFseXNNMlRMT3ZxSlFCaFFYZlVHa2lNL3lpbzQ0TkFIVmRHNktpaFF3Y1NIU1UwaEQ4ZEcvU0NCOTcxMHIwSVljUDlGU3VRb01FVUJJNWc0QWdmOVBEQkNEeE1RUUlLeWpFbjRXSUZ1U1dRVmdkbzFkaDBIRHFHRzNhNzVaVlNBUS84ZzhJL0pLUTQzbmc2L0ZORER6WEV5RWNQQmk2SW9JRW9Jb0VERWdjYTJFTVBRY2dReEEvL0JKRkRHZitVb2FRVVNSWmszZ0FGRENEVFg4UWRFSUFBMEhXbzVaYkd6WVRSUUhFVnRKZGVKVVpBd2hUL2ZDQ0REREQrczZaQVRMcHhSaGRJS2duRlAxMTBjWVliUkx6d2o1eHUvRm1HREIvSXR0VUJ4TzIxNWFLTVFnWkJZcjFweEYyVUEyeWd3UWMxeUpDREZIUE9LUkFSL3hDeEJTSjl1aUhERkNjRzkxdHZpamJxNnF2VHNmK3gwZ05lSXZIUEM2Q0NXdEFMUDdDZ2dBZjZyYlRCQVo3QmF1eXhYa0ZBYTRrUFlQRFpQNnV0OE1BRy95Z2cwQUFQc09GVGJnb0ZkUkNJTnhVV0VtWUZ2WVRzdWE2Q0ZObEdONEU0VkVsbG1VVVNTeUhScEJtOU1VbnBWRkl1amZWVVhvUjU5QzI2Qk9za3NMdHlnWXNWV1NiVjYyVkxLVWs1VlY1RDNmWldYeW10UlpOWUJ1TjBsWE1GaDN6ZFNBcGg3QkpkSGhDbGIwdVYxWVRXWFNzcEM5cG56SDZHd1FZZWpEaFZZb0pSckZGZ0d3MjFZY3pjRVdCbFhzeXhSZHlWMFluODJNRWJ6NXNXQkJ3aFJaUitEOGdjQVF1bUNUakZDRGdnK0lHTjQ5bGFnb0FrUktBMmFNeU8rWnQyZWJubDJ3TC93SURDQ2c0QUNLQ0RCRHIvU01JS0tDQ0tFSFFDWkVoY2NJRVJrSURUUFNHOHJtRVYyN3NTbEo4dHdFS0FKT0FnVUE4Q1pkckREejNNK09JL0JwS1F3bWxzVHdzQmxET1hkcmtHQnlvWVl4QTl5UEJQRGtLdVdjUFkwbnFFbTBHTkxlYldjQUpaeVBpeGFLa1U0bUZpTHJEQTNRNmdTT0RZWTQvd0k0eEMvbUM3UUZDc0dRUVVRWlFoQlJSbDNDbUZGRjBJRVdnWGZycmhndTBmVExFQXRRWUowTnZ4K091azNYRXlBV2RRWDVoNWdQVmM4SThaRkhCT1FqZ0lFYzVnaEg4bzRWWXprQUVTREVXQURWRW9meGpVa2tmMjBpcG42WUFQbkRyRFB6cFZFQ0lZZ1FobDBBRGtWc1dkRExxUVVmcTVDNjMrZ1FFU2dEQUkvNERDbkNRb2tCbnlobTUwKzlLWC96aTJrSnN3aFlndlRHTGphaUpFZzdnTFlRcXJGMHdJa3BMQmhHUmxTRm5aZFR5bXhQeDlaQ0hlY21LOXBJZ1I3TkFyS0Zma0ZoVXBwcHRyNFVRc0gzSlpGenRFc25BNU1UZGZKR05rcWpLdklaSU1jdGRLQ2x0VU1pNkJiWXlQVWpUa0hCdjF4SG9KeFl3UElZcGFsSElTelVncExjckRpOFVtSTVlRURiSWhYQW5saFViSnREc3VzaUo2SkFzaUlSbklTVVlHa3lIeVhXVTI0ekZJOXFVZ1BhdklGN25DdEN2NWtpMktQQ1ZGbUxMRmJyMUZTditBMGw3MkJRR3JuV1V0d1lxWlFPaFhBR0JGYkM1UlFVelRCaGNkUThhRVoxZWltdUVVdzViQStESkx3b3hJVUxKNXNzeVFCQ3FVcVF4ZHlLU3NCWWhHTlArSUFMUWlRUCthMUNWemRadWhtaUU1WXIrT0pJWXd5am5PU2pBRXdLUXBKemlqSkE2V3lKbk9zUGdNbXdOb1prZVF1YSsrWkxNL29HR0I1Vlp3dXZCTVFYTXBFcEJBWUxPMSswQ0FOdlAwV1dNR0k1UUhIQUEvem5QZVAvSUdJTFpSYXdHL2NRdHVjcGtWSkxxUUtBY2ppTVkraEJSM3l0QS9za0ZOZ01DR293KzBxQ0ExR2c4TzVPTWF0VVYxWnZjcFhwZTZzd0dwcG9odm1mdGFqUnEwQXFCdWFDdUlPZHhXRGxlNEJCU09lT2hNSjhtd3N4U2NTS3d6V052QUE4eEVBb0dNcDAzLytORS9RSmVtQTAxaFBnK1FWdXFpU2RiUnNFQkFJMUNyOVJJa09oamhhQW93T0loemZ2S1hBekNnY0Fnb1hFVjM4cE1vQVl5RGRBdlFQOUNVV0JmL3NXbE50UU1TNTNxVUlxNTl0UU9ERlFobVk0ZTkzSGJQVGtwYTdHeWZSWk5IR2U0ZmJrRU0wNHkzV3EvOHhGek1xOHRGbmljOTBwSHVSVDJ5a1E2c3h6bk8xZUFITDZvQjdZSVV2dTRseVh4NE9wOEJEYUpQbkdDSU1VYXRybU84OUpUbHdVMGxRZFRibWNiN0R6NzhnSUJsd0YyZHpuZSs5QWxrZTNsNmdaOXcxUVUzekVBSUJ1VERCNlJsRUxjY2dMcjZSUllBbW9uSnRYZ2dtWjB4U0U3dkExUmxUYUVHZGVvQ2s2RFFZQ0hvcVFzR09jT0U5OVNGSDhpbUFJSmJ6RnREL01Ma1BZVnFWRk5KbERhZ2crM0p5Y0doS3VFV1JLV3JNclJvQTQwQjh0Q0l2TnBiQ2lUSkJjR0F0WFNRQXowdEVNY2lwSElEaWNBSE5HMm4vemQwQVRHWHVheXR1MVRySHo3b3dSbk9jT1ovYkdISy81QkNEMWJERzd0TWFzNklGb2lzWUZvQURBeWdBejFBM3lZRWtvc3R2RUFHTE1CQVhRaGcwd2MwcGtTSm5qTUhoWFd6Vm8yZ0JBS0pYd2V3aGEyODBDYlVzQTd6WGg2QUxSSmhBTlM2NUZZUlk4M3JnZFdSWFZ3VVdGTkh4aEhzOXRxRnY0WWp0NzZveWorYU1sNHN5WXNlajIyc0x4cnprMVdCVnpIeGFFZnJJSFhZY3ZFU3RUM0V4RTZLa1lzYkd3a3J6MGpHU2s3N1lVUHByNzJVR3JWeFUyZGR5bjVqMU1BdFJySllrcEpYUkdyQU1pTXdaQUlRSndGenRyMnZqY1JIbHFYWmxEUUxVbXVTUllCUDVaTHFEaGduSnhadGhTLzhjZWEraWgzM0hVVkpScHdzeHY5Mlk3bVlkMGpPYk95Vy9KNEkwQktkYjJzTFpkb1BjYmE0LzFldXBMekU1YlI4ZG41Rk84cHRHclRlTkxjanp2ZElUSURmcXlrZ2NlMEFsQXBQV2lveWpFc2tvaWk1TEJLUnJ4dnFZOXk1dTYxdFRZeCthREp3NU5oTThyb3RYQXBGT0F2RkphS0p5ZlNQS0hWaExFZklHaWx6c2FCVVVXS1E4OGhNOGhWdnNVaFgxMGRubWxhMEdaMlpJejdVQ29OSUpibm9GQ3RaclNwVmRBcGQ3QXhUV25sZ0E2N3RTTXAyUGhGZnhneExEeVd0NGt0WjNZVTkweXJ4SmlNbW9adVJXVElGQUJIYnZINE9NT3Nlc3BxTlNSNTZRVFpVeXNObDJXamFWTXlWMW40aDFxOFc5aFpQNUI5aDJmS3p2OVkzTWtzZGFQZzVzMmtta3k1b1Ivci9WWmhHL0psU0RjaDEyWmh6bkRQa3VMTVI4amJCWkV4TTB0L2JzQk5yV29zc2FVZ1RvTldnYmpielpCdStFMHEvMDNnTFJUWEFVUnRiNFJHanBYem50SG9MT0dlUWRIY2I4eExJNUR0UUVSVWprbjFxY3puOWQxYUZkVm11a1UvNGtUV2dGMVBnWnh1UEVnQlc0aG5FOGxKQWxGUEVBakRwOTFBWHNsQThneERDc1ZyMFJtK0RsQlllQlhDRkpsZ1B3QUtEZFZraXFGWmZRd0k2RWg4a2NCcGVOUzBaRlUzcEIxSFFGUnpkOFE4NUJTQThSUUlPOERjUDBsWjA4eHZCY1NWNTlSZGFrUUJ5dFVoSFFYRmlCSVNjTVVrcFVZSUFRaG9SRUI1bmNpTTI4Zy91Y1ZYL3dGVmVKUnRzOHc4YkFGUCtFeE4zWVNGNnN3SWdjRllEL3lJZW1UVUZEckFBaURJY0UwSjBMTWdWaWdOZGkzTktQWGhINjdRWkJzZEJKZmdBWGFOV21ISWo0MFVqUFhCVkk0QUVhTk5WVzFPS0pRaFU0T2NVV1JnZ0sxQWdPUEExVTdBZ1pETUZLNkE4d1FOUmExZzgvNEFBLzVBQUI4Q01uY2lHYmtndndPUkc0MEtEdk1jc1czTW0zdFdLTU9LSGJYSWdTQUNJcUxNQXNuRWZLUmdUUk9nNjRZRURZYk1nTDRJcE9JUkRmMUJZcmVKaFdDY1F5cGlNYkFlTlEvUVcrRVpJMGpaUG9IRTNLYktOTlpCWTZtVmUxOE5iR3JBMWdtaU9kRUVyTXpGWXJYRW03UWdqMS9NRGZCQUVubU1lVXhCZDVKUWgrZVY0UkZZMWlsUXZMMUZpTG5GKytNR0lCTklpNVZVUW41Tlk2RlVEanZXRWd2K29BS0FoV0J0QVB4V3BXUWx5UFVLU0EwYXlQWWJWVm1DV2ZJSUJNcTFpZEF2WGh2T0dFNkNHYXVPUklERUNPdWxWWUQ5aUl3dHlVbWlUVC9rVUhqMkNrVDhRQkhId1BUSkFQbXFwSkJ4Sk9pdWdLRkdCaHIvRWd0TDBjWHBIZXVSU2FEU0RWUWN5WHF2WUk3L1lJNWxsV0RSQ1hwL1RBMFRaUGVDakpPSVRhRXppSm54d0FlYWhLS3JGYkhZWkVSeWxFWCtuTG9aME43UEZBMm55aXoyQWlsVjVrSnRqTzdRakpIR3dKbEJ3SkVhU0E0RW1FT2tUS0ROUUJzS3dQYWlDYTdvaGt2dDRtVEJoUmdReGUvdHlTVUFHWFN4MklnRUNBZzJDSU5qekE3QUptemxVSitRalB1Y1RuWEN5SnhQMkFsS2duVjFBUURVd0JiUjJjRmovNHB1b2RCMnpGeVVUc3o4VWN4OG9jRGNxdEI1OHNDYTJzejBNaG1NTXBwYUIxaWw5Z21NajVBWmRNQU11Y0FINWxHVUNJVkhrMlRIak1oTDlwU2dYNFNWMnRnREtHVDhtWlNCcklnVmw0QVlKVkQ3bEkyTWpORUtlTWtJdmdKMHVvaytnSnp6RWM2RFM4UlFaTVNZY2wyTDJNZ0FLUUdoSDRwaDRNaWQ2VWhBaTFLRWRtZ00xRUFIVUlqekZpYUtMb2kwVWs1ZnR0eHNSTUFVeTBKanFZMk5kc0FsZEFDcGdFR1c2SWtKcFU2RG9oeWlrSjZTTXNoY3RpaGZWOGdBa2NGNUx3cUVDd1djbFZBUlpJR015UUFKWlU2QjdNV1JjZWk3SEFUQjJtaytySVFOUTlnK1RKaEJybGdWRWtBU0U4cVpGNDJGYk9xZXV3Z2JhTWpReXZnR2ovMkFCTE1BNWFHb1F1ZkFQV1JBcWZ2SVpEam9wY29xb0lrTVhPdGtCSlhBRm4zS21ueklJZUlKcG9NWXF2aUU0bm9vLyt1RXNBbEZtU3JCQWFTYWIvOUFCZXZsaGI5V3ByMG93cTdNc3pSSUI0eEdpVWtZRU9KUk12TEVYTC9pckdRUnFDaUJtSTdBcFRNSm5SQ0FGU05BQjFxS1hrOUtVemxvdzRwWTF0MlltaVlVRVBhQWtnNlpwSkRJNTM1by9iRUEvbjRFdE9sa1FtVE1DaFVXSW1uWVhIa0NrN1lvLzhDcXJQZVNRdytocWg5cXZHRlJxdDdZVEFRRUFJZmtFQlFjQS93QXNCQUMvQU1FQVV3QkFDUDhBLy8wTElKQWdBSUVIQlNwY3lMQ2h3NGNRSTBxY1NMR2l4WXNZTTBva3FERGhRbzRZQTNoa0NFQ2tTSWNCQmdnczBEQ2h5WkwvWENwa3FiR216WnM0TVk2a2FKTGt5Wk0rU3dwTitkTGtnSk1BQUJRd09CQmtRNW9IZCthY1NyV3ExWXRJSjRMOE9WRG9RWk1Gd2c0WVVNQkRnUTFuVi82RFVHRHN2N0ZMajhLa09WREFQN3NOOFRJTUlJQm1BQUlFQXdRT1hGQ0EwNnVJRTNmc1daSWpUWlZBWTg3OGgrR0I1UWNzSHF4Z3dVTERDZzBrTkV6NXA2RzBtQlgvVmtTNC9DRHMwcVZOWXc4c3lCSENnUWNMVUtDQXNhSTNpZC9BV1VSWXZRQ0NRc0NHWnhORTdsU3Y0dWNha2I2VXZQaGZnWkVRSUR6NDl5QUNhWUVqL24zLzBERkNoNDRlNDh1UHdGRjY5WU1ONzltR2xYOTJnV1VXb2Fkb0dNRy94d2ovUGRUd1F3OUIxQ0JEZ0NQOHdZSUNaQWxFZ0FBSDRFV1FYU0Fka0VDRUNVQ25JWFNDRllSUVpBMnl0SUJDSlBCQXdoUW9iaFlCQzd5dFFJSkE0LzBUWUE4MFF2R0RERUhJQUVXT1VNZ2dVQkJRQ0FSRkYvK1VzZEFPZkV6d2xuWFdCWERBU2dJWUoxQ0VHMVpwSlVwTENRYVZXck10T2RDVHhoWG5HZ3JpMVZCa0dWSklRV1FPUU9aZ1pCZFNDTlRGQzJkMEFhY1VNN2pBeHdjckVRQUJYblJkS2VpZ1Y5SEVFa2hLZWFmQlAxSVFjWVpBamhKcEJCRkcvR1BFRnkvOFE4SUFHeHhRQUFGY0VpcnFxTkNSSmFWQUxPZ0FxVUpiQ0pRREN4Z2MvOGZXQWl5ZFN1cXR1T1lFd1FZWXdCZnJRaXlNK0t0RkkzSEVWRVl3K2JUUVZ3T3BGT3BodVViN25MSFVTVVVzb3RNVkpWUlgyblk3bElkZFBlUVVWOUtXKzF5eUxSa0VsRlBPY2h0VlRJSWRSZGhHTVFYNkViZzVjU1NBWVJUZTFhVzV1UTRsY0xiY0N0YllWN0M1dHF0MnJBWExna0M4d2ZEUHc5c0p0QUY5Q09PcmtMNTdQVGtRQVFSOCtnK29XU3FYbkhWMmdlcnZ4Z0NmR3htK01tVzFKRnZhNVlhYXBxQ1JzRjU0T0h5dzNqODRsRUFDRXFBSjl3QUdDaFR3Z0Fkb2hTWFkwNEw1dWF0OXZZazJ4UWdmWE8zekNIendCOTRmSk1CQTY4Zk9NZW1nQUNvTGdNQS9DSlRkY2xWUmNiU3RzZGNaZEYxWWxpM2c0b3Y4cWYvNlQzZ3kvbE1EZi95ZDJCc011NjB3WW5jUnJKQkNaL3YxVjBNUUEvYVFnd3lYOTFpR2tRb052dWhLQkVFdzRaZHJqZXprWFNxL0xlMVhTbEVycjluTGpXamZBZ3RzUURzS0srQlFBeDlCWFA1UERsQzQ2VUthVXFDcFVCazc1bERrUDEyYzRjWS96Nzh3d3d4RzFxREJld1ZJR1ZqcXFuZGZGVnNMMWVxVTBpaE04WUdCT1VqaGhwcVBudkdvRWtRb0laRDhMN3hRaHFyd0xSU3l4OTczZnlVYkRYbkFBQlRnZ3lXVTRWR3J5a0lXaUZBa0pIVGdWd1h3bE1mczViOEtWb2xwRUZEQXJ0NERIb0VzSVFocENvSUdGQkNyczRCUElBRFVtRlNncFJOc2JjdUNNTFFKczJhVEVHdGhCU2JvNnNoVEd0S3Vka2tHaHkrTDRlci83a1ZER1VabUp6QlIxOENVVWhLNU1NWmRzMGtZUWZ6Q01oc0tzVW9zckVnUWN3aXZ1QW1sYmt1a3puVzRSVUVpY3ZHS0xldkpoeGJqa1o4Z3NWc3NpZU95ZWhLdkR2M0xJVlpNelBaT2hrYWJ1RkZkWFF3aUQ5OUNHSk4weUdCRURNQnJyTU5FUTRXcU1VNWtHVXJ5Z2k5K2RZaVBmYVJLRGowU1JoZktCbDVSbk04QUlEQktockZtTzdpeFRsdFcyYUJETGdVdmJoT0lYaWhrR080WmhpOVFxNHNkSFJMTFRFSkVXMTNxMEZleWtoRFhaRTlwbDhuTWlqcXptU2xzaGdYUGRNL1N5a0xGcmV4bFpmOTQwcE5veDAzRXJRQUY5ckZNMHdBalM1cndheTlvODJWRWtyaVhZY1l0WElRMHkyVVFCMDNJaFdZRVE4TUJQalVWLzVyUUNNYzkyU1BMTVp0RVRxZ1I1RGIyZ1VIalhEU0ZFNUhnQXp6d21jOVFOREhMM0dVcDVHUkpjZzc1b0d5aVRwMDZGTmU3RUVMU3VBU0FacmJyamtCT3BKQ2ZoU2M4cXZwQWlYNWpOSEZpd0RXS3hPaDh3bG5QaGs0QkIxZDc2WDgrZ0o0ZzhPa1AvNGlBcmE0NXBZVWNvRzF0UzBBdmZhbEVtYzJOT2lzaEM2Y1VJSkFJdkVnOFlPMkJRR2dFbmhFSVRRTTEzUUJhUWhhV2Z5eWdudERjajg3Nk15TSsvTU5IT1BMUlAzNHd1QlYwWUFNK3hDWkRuZ1FxN29GMEtuWlRpeUlWcVpEdS9FWlRXSXZzMXZpREloTFF3UUYwQUFGd2ZucTF5T21nQmozZ0E0RnlZRGtlNFNoenlJdFRrTVNhdGUwNGl5TlBZc2tCL3NLWFAvK1Y4YkNJbldFY1R4Skh0dHhHSWIwSmJnVDBkck1BeWVDME91cWRETXJnSnVDNUtYZzlDaExuMUtRK0k4MUFJU3hva0VMNlloZis0ZFpLVTJ4SzNUYTJ5UEJOcVQ0UE9KRStQNkFCZlJxb0ljVXJrdkp5NENhRkNNRU5SRmdmbklya2dndkl0RFVMaWRKM0t5aTZncnlHc1lHNVpZRzdNNElmRklsNnk0T0NGS0JRcDMrY2dRaVpxaE9kMXZjREhIUW5MQkdhN2NnR0ROTEZMdFZMaXhyZWhWL0F3SCswZUNGYm1KVDl1UFFwNzVJWXQzUUpER3hVRWlzbWlGVWhtM2dVQTF0MWhqS1lhVWwrWXV1SmI4emt0YlNGaEgrVFFhTXVUQVFpYkFFUmxTckRGTEs3Rmo5MWVjbE4vaTZBVWVvQkV2YkFEV2NJa2tBbWRRV0YwQ3oveVNjTWM1ZzF1Q1JlVll4RVlJVVAwenhnSFRETCtjOFcxV1Fpc1hvdFVPYnh6eGFjNGJFT0haRS9zcTZkMEdJMG9nWGxsQlZHeDR0VlRhSk1DQjNTTlU1YVVNWHlrS1RURlVoUWttdlR5MnJJZExvSXowL0RMWmpWTXVMR1psaVFKWHJySllkNk5BNjE2R3BlZDFxU0lhRTF0d3l0UmcvWmk0N1RhZU9CR1hMYlhtTkYxSmV1SXFKb0tMZHV5YVZ1Y3ZGUVNtSmp6WFk2K3lhanhpTlgwSlhEVllmME1ROEJJckRIOWNKdnUwelhnSXlNbzljVmxLSW9wekZCN0xhMjNmMXVLRVlha0hOY29xRkVnbTNKR0hLU3N6bUt4cDVqbDM0ZDU4L1ZaaU1nZDAyU1pqSDJNZFd1SXhFci9xL0RaREU2RFVjd2NtWXoxVEIvUzFuei85N1d3WVE1R0M2ZVZKU2xLNTF4WGl1dlE1SnJYZ2ozMTJIbzR2Q1RTV2pTNkVxNTNMUnRTSnZQaGcyY01vdDhIcENkNGpCZElDb1pKVFVWam0vVDRSd2x6aEhNT1VWSEliNEkxcExuSkxHMWJoMnVsaE9tSkN4cFlsaVlsajM0NUkwMS81Q1ltOWxpbGxZdWR0MnlUREFsQzV3bFhKN3phYllFdHJPUG1DWEkwQ1VoWkdrTmF4YXdJdDFzcGpjc1FxVjlJSERUVlQ1dDQ2cjIrcWQ4dTVZRGNETTcyUnZab1JRSkdKTFZraS9rZkpEWGIvekVZdzFtWG80aHk4WGN6bmpWUEQ2dW4zbThhcVRKOUxJY2ZIVGJkZXFJWjZjM213WDNjTktFUUdGcFd4ZVZqVnhmaHNYdHJ0VmxzRndHUmlWbnVjeHFIT2FpRllqaG52OW82UDlYbVRrYzl3aTBMUWpPWlhLUUV5Yk5yTUFCNzNmQVRIbUFOZjJRZ0FVb3NFekkwdG12alRySTVIaTBNWFprUjJKQlNua3pITUhsR2FVQk9KSDFONkdoQVVRekhKZGhLaURHRm9kMFM4dUJTcHFCSDc4QkFqSzFOYUJGT0NQUVVMUlRBTERrR0pTRVRmdFNZdW1DYjlRQ0xyV1NTZytBTzFXak16N1RVaTZsS1RqakdkS2tOTWUwV0ZCakhBU1FUSHV6SCtZVFdlZ3hBcURGSngvQUovK3dWdWxrV0NMbUlHdWpGeloyV01saUxJR3hja2ZSRnJNaU95andNQzhTVkhPbEExdnpOeU1ZR3FweE5MeVNQV3gxU3hHRVROM3hHVHF6SDBoQU9QNWhWQVZ5WktTUkdaQ2hTTndGS2xPVlRsZUloUjQzYkdsWEx5UkZFRS9uV0tMLzRUV0MwMEVpNkU5cGRVd0tVeHpHSnhyc2NZZDBSU09UY3lNRXdsY0NvUUV3MEVvTDRXY1FJbFZQVlhKOTVIS21Sa2hNdEJkdE40Y3VRbi8vc1JCKzRCOGlpRS8zUnh5NFVRQzBZaCs0Z3grZ1FUam5BVnBpUlNONGxUa0s0UjlUc0JvYjRHWjMwWEQrUW8wZnhZcWZwbWhyRVRxZHNoQkRveDQ5OEZrQkloNVo4eHZIZDN3azhCbjIxQi8vUVNNL2tDTUU4anU5RXdRQ2dUeDZKUkNqa1dQVmVCZTROQ1hkeFc5YXNURUtCM1dXNFhnb1FBSWc4RGRYSTM3cDZCc09ZRDQ0MEl6L0FWcnYyQU1IQWlRNHNpUC9FRjJjd3hDN0V3TlR3RlVhSlVzNk54dlJCNUFRRVVlaEZoaSt0UjBrNEFDYXNqZTlVWkFyTUJvMDRvNy8vMEE1T2FKY3lyVWpQb0tSVURCZGNiSTh3dkFQZkRBRkdLQVNEMklYQlZZWEtKa1JoNUtTYW1FZnFhRWIzRVE3SzBCL1AyQWptSE01YnNKY1pRQW5tMU1rUVdtUGFxWW1tZUlHUWtBOUVEWUNFYUJkQW1FY0p2aVVON0ZZQjNZM1poTnpUbVlidUtFWnVpTldGRm1QMWhVblhXQWttOU1qOWNVb0FzRml6VE1EYVZJR01pQlRMSkFXS0VNbGRFa1Zka2tiUkRHUXpnSStJNElhUEJBQkc2QUFIUUE0QWhFbmFGSThiQUlreUdOaHpjTmlwK21Za1BrQklKQktEL0lwRUhLWlZxRTlzQkZ6amVRUUprZ2YzRUVDQm5KZGppbGZyYWxtQW5GaFo3QmgvekE5TmNBbjBiaDhCRkNJdXBrWUtTU1hBeUV5c0xFVjJSTUI1K01qbS85VFBHbFNZY3o1RDdrZ1A4MUpCRUtnRUJGQU1pQnpBQ2Q1bllKaUt6a1ZsZitBQWw1MVpHZ3BaRVNDbnBZU29DNG1CUTZXTkNNV2g5WkpuNExDQnJzMVFUUVJqUkdKT2ZEaktBcnhLSlhpWW9pQVlhK0NGaDdsS1I2bG9OSENCb29rSllFeVFMSHlBMmhDb1ZEd1lwQ1NCRjFRQTF4bUtJVGxaeUE2S3FHM0V2SkJtaWJRQTV6ellwV0NaVVFnQlNPUWxLRzNlVWxXby83REVuZVdtQzVXS1Zrd0tZSnpQVXAzWGdtS3BPYXlNTnNSQVQrMm5DNjJCVlVtQXhyUUt6UXpNcjdWYkZhS0s4YzBaZ04wVis2alpsNUtCR1V3UWpNaEppTlNwV2RhTHNZUkt4OHdBMTBRSkkxaVAwdFFRdEhJRXAyeUFmTjVwOUVTamRHb1FRbzA4QUJjOVZYL2NBRXlFQjRNMGhvekJ3RXBoS2lxc3gwWFF4bTcwaEFSZ0RSSU13QUNSS09hMmpMYWNWT09TbmwzaGhFQkFRQWgrUVFGQndEL0FDd0VBTDRBd1FCVUFFQUkvd0QvQ1J6NEw0QkFnd1FUS2x6SXNLSERoeEFqU3B4SXNhSkZpd2dOQWhDNE1hRkdqdjhBZkF5SlVHR0FqZ1ZGb2xSNWNxREtrQWRUcG14NXNhYk5temh4Wm9USmsyZEhrU1pSdHFUNUVDRktna0FEdER3S0V1Ykpram1qU3AxS2RhTEdxMEJac3BSNTFXVUJnV3orRllDd29jQ0REZjhlbUMyQTltdUJBVjhEREpBTGNpTlVpQUlHSWlSUVVJQlNnMzcvNVEwY3dPL2dxb2dUQngzcVZHL0hzWEFod1AyMzRjR0RDQkUwc0ZpaGdRUUxEZjlZZUY2eFdhQmx5eDRHc0RUNGRXQUIxb0lMRUNpdzRNR0NCVEJXNkNZQllncUlEenhHZkJoQmZJb0dEUjBpUEJCN1dLL0FBb0gvOFJXc3VIck5qWFlUWWlmNUhFQnJzWEFyWS84K0xuQkUrWC9ELzAyWlFtSkY3UWNLSkJjUXFiVEFnWCszV1N5SThQbTRCdUlqOVBCUGdINEkyTU1JTmZTZ1lJQWpHS2ZjWkdJRmNKOUFlVEYwbndBSUNEQ2hkUngyK004QTRHMEVGNGdMdUxjQ0NpZnE5bDZKLzVEQXd3Y3dKdmhERDBFRWtZT05NdGdZeEQ5QjBQakRQd3JTYUtOQVVFaFJoa0JCeUZEREJ4K0NHQk1FMGtrNDBIMEUzT1hobGRVWkZFQmNyMEhBMm1zRmhHbVFsN09WK1pwU2NIMVdnMEE1L0ZOR0RqZmUrQThVUjNZaHhUOUNDRVJFRjN6T1VFWVpTaXJIMW16U0NRQkJoVmdtcWloVjNqMTM1bk1nc3RBQkVsQzg4TThaWFFnQnhUOWRERVRFUDBRb01VTU5HQ1JrcUtHTHBxcXFkV050UUJZR0dHai84RU9uWnd5MHhVQmRqTUFDQm1PTnRSd0JFQ3l3NnJERVJrVldXbWxaOWs4RUtCQ2tBQVlLRk1EcmNnMk54RlJCTWYza1VsTmJiWFhRU2lmOVZKS1Z4WmFiMkxVN2FjdlJSMHgxK3hSSldaVUVnRmJZcmxUdFMrOUNSYTY1L05xVTFicngyaVV3VmhBOTFaRlI5Y3JiazFzUnhzUWhvb0FSaEdpLzVyNTdMVWhRdlJTaEIySkJ3TlpabGtVQVF3UXJrSXdDQzgyYTlnOEVxYjNsTWJhRjlTWHpRbUhLQmdHd0JOeG0yMjIxZWV4eG1OSlJSMWlGaFJVOUhjV0t2YlFkdmR5SzlZOEhsVjEyTW1rQ3RVZUNRQnJnY0J3U0pQaW5uMlc5aWptWFlIOEY3ZkZwSlhQVzlSUUFDc2VnZ0VHWWR4d0xhb1hKRjNUL0hDQUFBWHZ2LzAxZFF0TWRqZlJVODI1Ymw4RXR6U2NXQnBVSkZBRnZVM3lnQTRJQWNyMlpjbldQSmV5eXVvbEdBdHNIQmhpa2drRCs0OGVhZkNUNWp3eHVydjRQSC84Z1YxWnJlV2w1MEgxVVVoajA0UHpxKzVwUUF0MW5uMnhoM215ZlFEb29LSU1NUjdwNXB4VFFHd2tGalFybXdMcU56VWNQL1VBeThGRUN0UVJKdUMvdjVGZWtaVWxnb28vUVZ3L2dVSU1MZnVMYUJhYTFEcFJML1MrYzRVWVhQK0JBbVVCODI5dWh5a2ZBUkVub0t6NXprZytXY0NjaTFPb01STmdDSW96d3FUWjE0RU5qV1JuT29GVEFEaXJLWjJaeGxRSTZVSU11SENrSWVhb1ZFaTRJUHZ6UTVqc09zNVpKRm5JWGk0M1Bnemk4Q2JxeTFSVHViQWNwNy9KSXUvL0NCYkFnTHMxd09TU2ZERDNDdzU2b0N5aEZoQmRXaUZKRWNCMXNZUEJLNHVDV0dENmYrRENLN3JvaXdSWnlzS1lnaklwSFNlTU50YWlxZncyUkt4b2pJeFdGaURpVlpBY3BaUHhXRDlsWXdLUmNiSS83MnNvWno3Z3Q3UHpzWjFpQzJPNG1aaGloOFRFblV3eVl3ZlM0UjdDd29RQnNVQXNFVG1NYjIrQ0hidFRpb0Z2bWtwU3Y4Q1U2dWpPVlFhcmttdUtKQlRxdkdZeVdHdW13V2o0U0lsb3hJcllPTWhRRXZtVmxiREVMWnZpakdjK01obVFzSUVocVJnUWk3OXhGQU4rSlpwa1dFQ3pjb0dBQktFQ1JBMWJRbnBKeHNpMlBrbVVqWXdhWU5kNlNLODRoeUNpTDk3RUhkT0F6bnpGTzEwSlRUQTJ3UnpNc2lFQUh3QWIvRnpFVlJDbi9IQWcwcFVNYnk1Q0dteVFnQVE2QzR6YmlyQ2wwN0ZuQksrOVdvUU9nTDVXbU9pY2VZWEl4ZFQxSElCN2JISDRlY0xMWWRZWnJBaW5CMVJLcUd4alVMVExPTE14ckNBQ3M5NGpzWkFsRndoUW1SeHowdk8wREFocUJINmFRendYWXJXZ01FY0RFRklJQWpXcG5sM1hweVllMlJKY1JIWXRrM0dSYmpKZ0VvQS9nd0RQWnJCdFZnVllia1pFc29jVEJBWU5rTURvQnZjNTFiZHBSa1A0aGh1V0E2RHRGcTExQ0RzQTN2UjBnQVU2RjVMb2k5TEpnQ1dRRktlalAzUGlUdGs3V1JxVHNZVnVBa2plNkhmMklJQWJpUXc5dVZJWWQwU2tJY1JqSUNxQzBFUTRpaEVwYm90Q0dBb3NZcXVwRmNXN2hHVGF2eVRPei93UkxOekJhSGhSa3NGczYwYWtNZFBxSDlhYlhveUg5SUFqQW5aTUptN2U2QzZ6SlNRY3NDSlNnRXdDYU5wVzFWM0x0bUNSVXBlbTg1amszdTlseU1PTzV6N24xSHpOd3c1MXVGSVRwS1NnT3ZDM0Q4NlRnQmlIbzcwN05HNEd5V2xOZENTMFZ1NzNqYjlsMkNWQ0FVdVlCTFBqQUQxelF2RTVwNzFJQ3FaVURQMlVuTndEcUFpUW95NFdvWTA0QTg4NUxYUW9BQndteUFZa09vQU02WUoyRTUvU3BNNnc0RndLeFZBMGlnSmJiL2RmREdyWGR5ajdrZ2N2MFFMNHVwdkFtUGtYQkdNdEFBd29BcVVVdE9rQWNPeG04SDFLQUJVelFneTY4Z0FoWFZvS3RRSlVyMEJBRUFnYzQzcE9kckJaWEFWTWdQc2lCcGY2eENZSGNiLzlUYWRrQVh3N3dnT21PK2NsckFWbGxLa01DOHdoRUJpNFFFTFRXQXN3UjMvbk9EK2p4Y2g1UUtweDROSjBqc2VXaHg3ekRldlh3WDA2VWlVdm1PT2trcHF1U2xwWXFSNmZvRkN0eWRHQzU3TFNxdUFocEx4WVNpUGdhNHJ5V2toR0VmWXZUa2xaMVRpck5SVXdMTEl0b0hDT3N4WlhxTjk3Nmo3bzJYeE4zK09qdERDVmVtbzcySEhQWjBVbU8rdGVHNjdDcUh4MURWM01MMXczeGxoU3BYY2RJNDFGYjRoSjFzb3V5N0UxN0c5dGduQ1JqdWxpd3J0anIzdTVldDJDNWpSMXdQOXM1VUVUaVJzL1hVWTVTVXQ4YyttRzhHV0pET1pMYk1hSSs0clU5aEpDOHdOREovUVoyR0Rzc1JxWlorakd2L01sWEpxTnRtNVJFcjd2L2d5cWxoUTB6Wkw4NmkyV2tHVHRCdWs1SXVXWW5KV2VpN2k0YUhkdEZET0haS3JlMG9maVVyNFNsWnNuaXBOSXRFNjNKakMxZmNjR1dZY2hWY2VycUpiWDZ3cWpLTzkyVmlCaFlKUDNFNUo0dncwbVNtVDJmYWFIbWgwQmFrUGxnbmNNb1YyVmVadE9yQXh5Z1ozYVREWE1nUGZWMHNoYmNUT3gzelB0NTVrNE9rN3hYMDBESmtqa1F1ejVnUkk4cXNFUGNRb0F3MC9rMkJuQ3A1bEgwbmcxNG9HWlYrdTdVQ1lPdGkyTTMxUnQ5N1pZKy81VU5MRUE4K1h4Y01WdVVUNm90eXpLTVkzMzZEQ3hRQ20xSlF6ZTd2RFczaVZBUXZLaEJ4L0VtQm43R1gxVENzRW8zempHK010MGFoaFZXUFB5UnZkbzZJd2JQR0NlWkxJaTkvMlhnOGhjdmpZdHNyamtBbUcyakh4VHBoZ2NnQUFFSmh2T0JHakNJT0YxclZwbDhQL3JDTlBKb2duTkxTNkVkdEJadzgxRUFVQk15aXBjQzNLUjRMZElabjJOUC9xRVptQk0yYi9FVVZFVk9JRVZObGdFRFU3TWVEVEljOXdjZ0F5SVFkTk5QZkJGQWd6RWRBL1ZSaGZJM0FraHRQSkV2THdFQjNnRWlPOE4rTUJBYVhkTVpHb0FFT0lBRUpYQWNSRVVhWjFFenJFY2ZTUFZLbTJSUW92RVpmZFkyb1pNZUIxSTFtaUZuc2pGM1dzZzNyR1JSd1lOajExSTR0NlpwWUFJMHoxRm5sNUZNV2VVL0FzRWsveEFjSUlBQ3l1RXFOVk1mdHRPRUNIWldQb2dFSTdBRWJ4TWdwUk1FOXNjSHhFR0JkZU1vVHVNM2ZMRVRNQ2dZQWYvSVJra3hiajRIRTJQeldnRHdNbWloRzUwUk9laWhBMHhDZndtRk12emtBZlVCWXFjaE1zYWtVTVRSVm00Rk56emlPai93VU95QkFRT2dBSGNWSFNQMlRCa0NRR0NJT0FUMkVxUTBWUU5SS3BlUlZaR3pKdVVCSU4rM0FrZG9nWnZrVWdmMU9UQVNJRWhnSUhNVmlEOHlKRHl5UEFJeEJZOFhFMTloVWFqRWY3cW1KZndGUldYMEduTXhBR1F4WWhMMUFWUFFJZzNTTmFKQk1wYnhXTGJoZmhMMU9WRTRIRDFRSUQxUUEzSkZPa0FTQkpjMUo2d2pYTERUQTBTbEZxd0JGVW9sZFJVVmZRZ1hjQTg1TnRRaUh1NkhJdGxFVzUzMGZzWW5naldnV1FIcEl6bHlYSE5palFIWkk2M2pKc0RWUEZYb2dyV2pWM21CV25rRGRPSC81alJTQkNLcVlSckN3cEVuY2syVlFRQVBvQnRUOENJQm1TTkowbHRTQUFYV295T3NjMXd6d3BMeGRTUyt4VHF3d3dNN0NIZFRWeC9qaUpNNWVSSmYwUkYzTlNZSHNBSENweFpxWVZTMUlSQThVQU82OVNkeXVUMUhBbHdHeVZzNTBnUFQweWJOY3lSMzRpYkNVSUpUQlZCV1Z4QjZBNVlTb1RoMHdSTXc1RXMxTXp6QWNsaWZJem85a0RvTUpsOS9hWlZTeVpMd3RTbFNrQ2w4RWozNWxRTFJFaTA2cVNFVWlaZ09vUzBGWm5HRW9oQjhOVHpNZDVhV01YL000d0lEOFNZNW9wVHRKVitjUWo5dThBSkM0QWIvSUFVem9DVE1DRU81bzVwUkFTYmhzeE9pQkNYbjh4ZXRnV0FJSWdQV0kxekZPWmROK1VBUmRnYjVZNXhsLzZBQzlvY0NRRE04R3NLY0hUSldpTVF3TythY3JiRUJVL0ErWlVDYzlQV1pRcEFwZXZLZGx6SUR4dmtQRnpBRkc0QVdHK1EzNm9rbDB4VTRJbFloZHlNUUlFSUM5cWNCS1dabEVBUXF2eWxoWjZBRURvUmVPZUJuNFlpZUIwb3NiTEErWnVnYXRhZ0EvOUVEVXVCaXRiSUp0RUlFdVVBRVJjWXBNaEFCbERFZFliWmpJVm9zNnlOZEF3RWlDcUFBUHFBRCs4a3BteEJrUnJBRkZIUUdRVkFDeEdnekFHUm9PeXFpMGdXZkJmQXNFWkE4bTFJLzlmTVBSc0E5U0VDTFpFRThkMk42VTFvc2hnWWlIakJDUEFKQkZlcWwvN0FGWDNBcFBaQk1raUVkbGlkbVoxbytHL0FzSFNBclpXQXBuL0lQdVRCQlc1QUZSTUFIR3JBYzlvYVJnc2F6cCtRREpkUlNLaHJBQnhYYUtRTHhwUzVRQWdxQUZ1cEhQR2NHcVIvV0t4QmdpeDN3QTJkd0p6Y3dxRjJ3QkNhZ01tSUJMQmtrcW9PelNXc0JBWnYwRHlud0R6OXlCVlgyQXB0aUFXamhNUnpqR3JRNk9BT3dIS1ZxWndLQkFsZkRpU3Z3TFBIaE1tRnhyQVMwYUhzR05RTmhvLy9BSzU5WHJkYktSd3FnclRZUkVBQWgrUVFGQndEL0FDd0VBTDRBd1FCVUFFQUkvd0QvQ1J6NEQ0QkFnd1FUS2x6SXNLSERoeEFqU3B4SXNhSkZpZ0VLSHZ5WGNXREhoQmxER3V3WUFPRkdBQ1VKb2h5SnNtREtoUjhiZGpSNXNhYk5temdsWnFRcE1PYkRseXAzZnFUcGsyQkprVEZES2hUcVVxTkduang3RGhTUXM2clZxemVKZXZ4NDFLUEJsaVVMRklDdzRNR0tDQThlb0MzN1lNR0dBdi9HRG9RTFFPeEtqaTJuL3FNS01TUGNBZ0VLQ0FqQWx5UFZrSHk1WWwzTXVDSFlyME43am9XUVZtM2FEUTgyL0h2d0wwSUVGaXRBc3hBWTRXd0VGR2tIcUFiQStpaGtuaEFFSGxpd0FNVUtFaDk0ZkNBeFpRU09FVWhHQ085QmtBU0xCMklKQkZBdWNEQkhqb1NqNzFYYXVIck5sU20vdXN4YkVNQ0FqUmorWWY5UWUzc0VEeHk2UDZqL3NHSkZXd2dFSUFSZUhoamxBQWdETUM4Z0FXTEVoeEU5OUhDRmdBUmVRZEFJQXZFUnhBOHkxQ0JERDhCcDhBOExFV0NBSDF4Ny9VT0FobnNkME9GVUJ5UlFtSFVrV29laFFBV2dCQmhnY1drSUh3SEp6U2ZXYkN0OHdJY01PY2dBUlJsbFFMR2pqejFLQWNVL1VBUUluSEFJZmlBRGtUMEtOR1NPUGRUd2dVQWVuSmdRWHg0R2NBQmhKWGJwNVVJcmNoUW1TVndCSmw4QWFQNmpXZ0VrT0NnRGoxSUlCR2NYTTBoaFp4Zi9uSkduUUYzWUtVVVovendvNFpxQ0hTQUFBUWRzK09XaWpEWm01bnh4UVVDVkFMRkZnSVFNU2hDaFJKNVFiRUlFRWY4UXNZVkFaK1NnZ1FJYmZBZmZBWVpDNEdHanNNYi91bWdCblAwelFobHVoQnJxR2FBYThVOFpTSFN3QVFSakZVdnNxN0ltcSt4Vkh2eERscUtibGFhUUJ3cFU2WkJXSGpsbDFMYlA0ZVdVZHBBMUJSSkx5NVlMYTB3SVJkWFRTTTkxbGQxSjhBSzFrMFpBcWVRVlNST3BhKzYrWG1ZM2IxZmRCbXdVZHRsNlpLWllMWDVYd0hmZm9SZ1Z1RGRsZE5oMC9GWU1VazljRVR3UXU0RUp4RlpsYmJYbE1VRVIwUGJQc0F0N2Q1UzczZnJWY1l0L2FVaWJBZTJ0QUFJSVBJQ3dHd2thVUlnQkJnckV4UlcweWprbm5jWFd1Y2F5YXluV0Y4QUFCbDFJYTFxZS9VT0MxUklLbEhVRUhYU2dnR29yQTBhUzJHS0pSVFVMSkFTSGhBNEF0djBQRW0rUHdMYXR0bXJnMlFBTGswVEFZSWJ1LyswM1ZSNEdyaUZWREl5SWRFNUFzU3ZWVVFNOHJhYWFsWVdId21hV2hUd2JBWmduVndDaVpjRmdHd24rQVVoZ0QzSDhFd2R4UlA1VFE0USsrS0FCZ0tyL0U0VHNzd2NvRUF4QnV4eGJob1FKMExmdlBTRjdPTklzcGhtUzhYOWxkSUJtRUdDMmdnWWExT0Rra2tUS0VFU0FBdXBBbkF4dkJ2SGpRRU9Xa1VNWkxpdzVRZ1NOdHl1QVlIQUpQL3o3TmJFUmM3c3JlcGg4NDNoandNSUlRVWloSjY5bndOT2VRUFdDTHB4aEJtV29nUVl3Z0RmQndFZGk3b09mQkVrVW1QaEU2anNZc0FBU2JnQkFnb2dxQzZNNncreUFKcERZRkdXQ0tKd1ZaUWJDR1Jib2dIbzlnQUt2dXZBRERXeGdXTTRheTF2Y2x5NkJuVkFwS1NGSlh2OEFsc0lpTWdaZEc0RUp4OFpGTDVPMHhDUkJaSWxyQ3JhdWVSbHhlTmlTU2xTUzBpNXY5WkJjRzR0aVU3UVRGSytFY1dQWHVpS3NGQ2VWaCtqTFd4ZURJaytBU0RBNjRvdUtkM0hpVEw2RnhqNnFzVEZGMmVOU3dsVXZKWjV3Y1NqeGlVZ1N3aUk5MHVTUjJzcVdjeVlwc1VyK3NUSGM4WmNXWDBJZHZDaEdrekV4RzhoQ3hwbXlXWW1QVDRsa1JTVFdNcU1NeG1pWHpNa1RrZkpKaEZpeFd6cWtHdVVXOEE5ZS9nTTF2SVNCTDhzbXhVenlqaStIV1YrTG5EVVErTXlJQUxTaERYTGlBcVBsVUV3cXlvd2w0bFM1RWI4UWl5MGYwd3htT2tNaDBhQ0FCU2lBUWVSVWc1ZTZvS2tvWWNMUVdLTHBnSHJpUmpmOVFkSndrQUQvdlJXZ0lGR3Y5QWdzMDJRWWdtcFRKdHNoU0lwUWxFTUlVR2FGdFZLTFowQkRndEE4NzNrVDljelhWSU8zUkJwUG9YSDVDMWsraHlTMTZSTnVDQkxJRktiUU0rU0k3WjFpZzQ0eWo0WXZhQjMwSVBMeTVHdFVrajUyWW1BREdQaE1lWEFBdXQrazFHNHVoZWs3bDhNaVlpRm5BZTBCbmR6OG9MMEI5Y0FQS2YwSDltSW52WCtzMUdzZWFGZ0JBT283YSs3dEg0SkRLMVVJZ0FBQnRQV21RWEdpSjFtRVUvczhEUzVVVzhFVTBoTURyMVowQmRIYzNJb0NJMDlubFFVRnVQa0FoTERIV0swU3A2VERzVkdnRm9RNkJDMHdQTjJTbEtRS1NoQzMvZ01CZXpFY1hGZFpFTGdvTElmQkkwdFpvQWtqek1rSFJzWDZCd3hXb0pzYS8vU0FRVDBJZ3ZkMHBGc296TzU2YitNblA1RlVneUFzU1VmVys4Y1BJT1JWeVFUU1VMTFJ5MmdCR2FiRjdXV3cyTTJJYllaajNDQUFDbEJ4NnRPUWRuc0ZKRncxU2creVhnNmcwSVh2VmU4SGZPRERCMFlEbUZkS0NpN1dESkZOcDJ1aU5rcWxlTkFKY0VqRXh0RUJkR0FLTmVCRER2NlJBKy8rQ0VkdzR0SDNBUFVQUHlGd0J0eWI3OElJc2lWRFJaQy9zV0tEUitRejJOakFSVDRCL3N2Q0JoQ0JLVWhWT0E0Q2xBRU4rRCtCRUVGUFhlZ1RqMzR3aFFoVXlabCtPOEFwUVZ6RUFKaDRRekdkajJvOGdBRU45RUFLTDdpeG5wd0VxandCc0F4TDhCckNPT0toc3hJWnJnVVFNVU14aEprT2pFQUdjZG9WalFteWhRQUtwUDlXY1RuQVpna2c1aS9iZVNCQjY0QVB5bkNHR24vS1Z3TFp3aGY0SUo0U29raklkNzV6c1lvMWdQQXNvUXhDNk1JbTlKU0xMVWloQnlaQVVXeUlGU2xmSnBySXpRczFMdytnbGc5TW9RUndDeFNDZ2tZc0UwT2d6cC8rOUU5am81bTBCSFdiMmRyaXhXSWRheVJ5YzEydDFHSTN4YVV4WGsvUWltd1VXTFlVNmExM0pSSFlDc0dPdEkwdHF5dytSOWZiOGdrWmV3anNRdDdyTGd4NUlyVUJhYTlmTjN1VFNXUlhEOTExRjRDZGNJNnpaQ08zeDQwUlBuSnhLZDNLSkxuRVhVeWhjTWUvYmZSMnR2OWRzRGZTZTlmQ3hyY3gxUjJSZWhtMGlqcDFkNjRaZ3E5L1EvTFo0NTUzdExmRjhDQTZKSXBJV1hiQWlGanhoQ3hSS1ZELzRhTytEdmxsWDV0YzJkc1pTc2JNK01rdVF0em1UWnlpbFNJREx6VE9rV0tVdkdhczRRMXRuWDVialA0RkloV3Q2NVQ1dVNSOVBFL2x5MnN5TWVkOCtsL3hQbnE4MmEzMHhYSHh4RzlwS0tkL2ZFcU5UNzBpVldkbGN3NGVzSERkeTVNRlc1a2l4Zkt4dHBTbExEamtkUEZjWm5DRktHZklhK2ZTc2tjMEtjT3duZWtBQi9lMUdkcTh0SUN6TXdUeEpmTndtRGVETkUyZ3JvUkxZUXE3T1JkaFRzZ1dMTnRhZTRMTURBSGN6aXVEZXh1TDdjNWNWbVlCRVloV1F2eFpHUTF0NEdsTFhka2tnOTJpOWEwUFJndUFaalFYVUU4UU9PQTRsVUZZWUFwZkdLNVluYitCTERnUkxlOVF6RlJ1TXdMUnpHYmFVeldRcFNwRktWS1ovOGZCeEV5OXQ4VTJ4citaenRTREpCeXdRQU1kUUF2cFRRL0U1eCtOeUlxcDZ5TEhTcGJLZ2F4a3A5RVpwbUVhblFFeXF3RTFUVkVVN3VScXZXUWJpSVV6SktBYnZZRWtQZkFmZkNBY1Y3TUFnaFZROVJjZEpBRkxJRVpFVzFGYThCRXlkM2NaSjRNVzUzUk9FekloS0dBMzVmUUFCWlpJUzFjWGozTXNiUkZWdWlFY1JxVlBBR0piZFhNY2J5RVdhRElZOWVWOCtESXhMSGRGWUtGc1lmRWMrT000dEtZQW1ZRVdvREVRVTZBMU1NZzFRQU0ycVdjOGhTRWZQMllXYVBNNlBvaFNLWVVnL0FROWRuTkRlU04zeDNOZFFWZDYwMlZIeHFSUXVNY3dVM05yTEVCVVdUZ0NFc0pTME5NQkRFU0V1YmRVeENJV3NYRitHaUJWMnYvRE5wQW9FSDVBTjFvbEVDUEFVc2VoQUF0VExFWHpjTmJVTzRMM1ZxS2xSdThFZDJsU1dBYlJNQUtoaDBHakdSUjFpYUVqSmVvUkdpN2xUbWp5VWdnekZtbHhHeE9vUGFPelZRYVNJTGNsQXo4Z085THpCeXhBaU03eUhRU2xLTDdYSEliaU8yKzFJVzhGVjYvaEYrVkdWMnBTRXZmaGVMZXhIdXJ4RHp4QUFuK1ZGc1JpaEV1MWlaVnhHend3SExiRldBWVNqMW1GSURjaUVEK1FZRmMxQW43UVVoMDFPSjBVVUdnMWpaN0ZYNm5JRWVtVFJNd0lHS25vSFkxSEhyd3hCVFhUSGlpd0FLMG1aSVN4SlE1RmFubUZHNHNWSU5kVEpMSlRpYmF5aGhwZ1hnbkdQVnIxSUxZakVCYlNlNlozTWNJRFdwL21kblZoZWFzNEZ3di9rNGpNWkhkdHNUd0x3Q3FDRlJpY3RnQXdBQUtnbzFpTWxWdTY1VDI2SlRzOW9BTWEwRHBzNkIrRUpqdFFnRnpYQTRob3BCanV3eVg3ZFhqWlpoUWxWamFYQTJTS09Ca280QUEyd2oxTGVaVS8waU5OWW9uQ1lWSWp3QWU1eFZ1cDR6M0VNU1hNcElxQ3R6aDdjeWlqQ0pZMzJSSDRWVHh3QVZ2cncxUXk4ZyswVlFNNU1qNXZLU1JDMGw1U29GdEcwcEVMMG1ESU5TUUMwV0RGK0FNWHNDMUJGenlIUXBnUTBURHBrMTJIT1ZpbitHYWwwWWdJUWh5emt6cnMxU1BYMHdOSUVCeEsyWmxOd2w0UHhqMThFQU1hVUNXYUp3Q1VzaGVTY2lnZmhwb3djVWN1MHlLSCtKcnJvNGozb1Q4allGczRRaVJMdVNEZHhUMlNxU1AvLzlCZVJQSW5QT0lDZ2NJSEphQ0pqeU1tcCtlY0UvR2FSakdkMERFZktJWW1IRFVoYmZJbXY1Sm1GVllHZjZKakFDb1FkbEpoWFNBRVVvQW40bE1EVS9CVERiTjgwQVdmVlFFcDhkUXhKS1lVSjdaTUtlaGt5YlVnU3dKZUJ6cGpNOFluNDVsbU1qQmZHRkFBbWdGQmU5T2NFb29WTWhJU0dDbGtDS01aS1hPTHRPSkNDMlpBYnRCbmVESmxVL1lQTTlBRlpkQWdKUEFYOFRFaUx2cWlpOEVHVG1wa1JrYUVZelVXLzNJZkJXQXBOY0JubjhJcnBMSXIvMU5BTHRBRGFQRVdzZUU3dmdONFRNb29HWHBDdEFZQktkQURRdkFwVHFJbmNYb0d2a0tuZkdBQ0thcDNMYXFoYWJvczkwbUVydllBYjlvRm9JSmpRZ0FGUkpBTC85eXdCWi95QXBqV0FaeGhZcG9qQUxEMnA4cHlZbEZxWkNjRE5DV3dCUDJqSzZKcUJISktCQmpXQVQrV1doYUVxWWNESHdLaEFPSGhBMDhnQlZYV3BhR1NCYUVDTEIwUUtZK0NhS3o2UGs2RkFidjZRbDJ3S1FPMEJiZ0tLcWhUUXNVaVpFdjZxL3VpZlpaQ1lXZmdLVFoyQmozQUJKaEZLODZ5QWI0S3JZZWpmUVNoQUQ0Z25xa1RLa0lncHY4UU5IRXhUVjhKcnZ5eUFSNHdMTFYyUXhvQVgvK3dCQlhtQnJyYWlsV2lpdkFLUDdSQ0s3UEJTN2J4RDdMSkE3RjNNdXRhQU0wU3NDaUVRNVFURytFQkdqQ0FHYkVGc2JIVVBKaFZFd0VCQUNINUJBVUhBUDhBTEFRQXZnREJBRlFBUUFqL0FQOEpIRWd3QU1HRENCTXFYTWl3b2NPSEVDTktuRWh4SW9CL0JnZGUxRWh3bzhDTEcwTWFCR0N3NU1XTUgxRUtET0FSSWNsL0lFZXFoRG16b3MyYk9ITTZQUGtSSTh5VUs0T1NISXFTWlZHUE1qZVdIS2h5WXdFQUJRb01LQURoWDRHZVRJUDY5RG16NWo4QldiK0sxVW0yckZtR1JwRjJaUG56NTFXb1ZnZFlMYkFocWtBMlVTRlFMZkJnQVlwL0Ird0tMRkF5Z0dHU1N3bGI1WGkxY1dBQ0N3Z2NPTkIzUWVVRm1ERS9qdHBZSzFpdlowT0xMcGl5ODl5NGNhWG1IVkIxd1laL0R4NndlQkFCUm9UWWVpRk1wV3E0dDJHTUwwdFNwUjJCaEFialUwaUFtUEl2dVlaL0pGYVFTRDVGd3dvV0syN2pMaW1BQUZpd1h3V0kvKy8rTlFCWUFnSUZnQjdOM3VGUm8xc1hEd2lRZDhFQnpKY3hvMEJobVgvbERRVG8xUnNFQVJDd0FYRVJhSURFQ0F6cTBNT0REdjR6d29KSWFLQ0JEejVZcUFGekkvenp3UWg4MVBEQmlCOU9rUndMbGhWQVFJRUJpcldlZUFja2dGNTdOTFpIMzJDL0xTVmNWTUlKUk50eEkvUndSUkJFQnRGREVGQUlGTWMvUmhvWng0UC94UEZEazFEa1VFYVNaUVR4RHhSYWFxbUREaU9zQUVOZ0tIM0hsVThRaUZmam1td2loRVpXaXQxNEkyRjAwdGZZVXdQQXRjRUsxMDN4UXc1ZFNORkZrbEFVV3VpV1d3NHF4YUU1eU5ERENMZXB1Q0o2NkIzZ1hadVladG9lWi9SVkZZQmNBMFF3Z2d3emRDSFFDMFQ4NDhZWi81emhxcXRkdVAvZ1FnMlFicUNYaWdLa3FlbXV2R0w2UUFFS0ROVERQMFFRd1NxeFcveVRMQkhEVHZVckJMYnUxZXUwMUo3MUFBUVBDTFRBVlFLeFlDRUpKTncyQUFaVU5kVFVWano5TkZKUEw0a1UxbElORFZYdHZMMHFSVnBZYllIMFUweGE2YmpTU1dvbGxPNjk2cWJiRXI3MEpreld3UVc5UkRCd0tMVVVYTHRXZFpwWHRMLytLbEJWLzB6bDcxVy9IZVJ2UlVVeEJaN0NDU2RGVTB3WDNUbFZ4NXdKdGx0VWJFREFjUVFyUExDQ1paYmRHdFZKT2E3RTdXSlhWWVV0Q2crZ2dMUFNFZXhIUWdyNzdTY2RueXpjbGlLUEdaazNWbmhhbTRreWpVUUJ0NjlSdjVGRTJBQ3h4WWF6ZFN4TTU4QVVmT2FNVzh3OCtxVFl4Z3MwM1RZSkkrRC9NQUtZREk1UUhSSW1ibWppQ0NCMCtBRkJ6M1V3bTJzRVJINnBtdjk0NTkxVjNRbHdRSGNKZk4wZVlrczUxUmg5Qm8zTzJWUzVjUlpZWUREK0F3RUJTVXYzNGQ4UFBnaEZENFF5K2NNL3crcUF4TzhrbEREaENDUHlFVVFOTXV6K3cvSTk4TkhjUHprYlJPREpHSUgzMmVib1VlNDV5azhGTmZUM3BBOEc4d0FleURiZEZVZm04RThaVXF4Znh2dGxXQW1GREZWZW1Uc1VWNjV2WkErMGdvQjBWQVNvVXdBT0FLL3RHVEFuUE9MWVhEckRzVTlkUkM2amVsOFhYcUNxZndTcWZSTnNsUVVYOVNnUy9LcG9CVGpQMEE1SXdrd1Joa0JWb1lvQ0ZOQ0JKeVRwSUt3aXdoWlM5UThaYUNCYmVzRUlnUUpUd2g3MktqZXVHOGdJLzhxUUJDa3M2Z3lweWtFSk9pQ1FhRUdyTlNMcmlCUTV3cEdRaU0yS1BzeGlqZXlGc0loTmtXSStjUmhwd3VhdzlTVEVqRnFjMTdreVlyQXdzbXRmTkFsSzZHVFNNRFMrc1l0Z1JJZ2QwL2k1S1dKRkpWNlJGM3dJTmpHMmFBUmUrcElYQVBLMG1KNFU4SkZiS1JuQytDZ2FMTFpsUFYwUkkxTmFvcU4ydFN5Rnpzb0wzVloycGdMRzUwd0grVXhRMUZPZVZpS0VlcFM4U1ZyZ0F4OHhzakdPWW1NTFZENFZBTDNVaFZ5eGNSMVZiRWFWQUZhdU4xR01KQ29iQXNBQUJ2QUFWbUZkNU1Tak5WVENNcFkyR2FSSHJIaW51TmhwTjNJcEFGNW9kcFcrOU9VZm1ObkFBYUlWSjdZa2hqUW5uTXNHOU9NQUZLekFuaWx3UUQ3dDZmK0E2TnhUV3luVWtTckxvNTVyWWxNaVJ5blhyWHBacnNZTWdEVlVlYzAvSWdBYjZLWHRXbnJ4QUkvbTA4NkkyZVYxMktJTmRzQkZVbkJSTFc3WG1WclZZQkFiVHRHbm9HTXhVK1lJTXFPRFNxUmxHUEdZWFg1bUZRKzg1ald5OFJFTFdHQ2J0UEVGb2dJczIwQzRoYTBJZUlzNmZSTmNoLzZBZytxWWlEbFRRTnlKdEhPYmpzMUZjcGZ5amt4RGFCQldwc2VtZXVTS3Z1UzRWS2hBUUFFUFVBRE9zQk0zRWdqRUFUdTc2TlVJSThtb0pNMnB4cUhRRXBiZ084QXRhQW9WR3VxRy91RTM0dlhnQTg0YkNOeFExSmRwVWlwN3lremxUTkdheklLNWtXaGZGWXhlRGdBQm51RUhNN0FMb0lvS1ZBRFhLQTFjV2EyQkRtcndvQi8vOU9CSlRQcUhEdjd4dXhKWXlBY0pzbEJ6UmxDRGZ4UzNCczVqMEVERThJRGZYQVU5S29FbE5BZkNBTTZlSlh3OU9pSHBlRVNuMWo2QWJ3eTZnb09haENRa0NTUUlPYWhkRHdBSHBnZlJsa2owa3dHUmNzdTdSLzNET2h0N2FUVy9FN0t2MU5TNllBTVpSdXBFWUtJZEtBTFZZZENqbW9RNzlNcWdodkw5QVJTbWxBUDVYWWwrVEJvVWszSVFoQi9vSURvTDBJdjFlZ01XQW5hSEFRWUZzR2ptYzVBUUN1Uy9vSVVKSTMwS0ErTm9vQWN5a01HVnJPUUNJL3A0VVZzcWxJYWhNS2dkTzVoV1UrZ3FkQWwwcWNxcGVIdERJeDJCNk9Sa1VNVVJiUS9RZ0I5NklLZ3pkS0VMWHY3eFB6QW9CQ1ArZzhNZlJrRmRqamxkekQwWi82Mmw2MjVHcm9JQkRkUkFCVzZnSUtxa0lJUlZ1YXBWUnN5QkMzcWdBWXB1ekNvcnlsV0szeHhMcHNya29SdXc4L3NFb2dSaURRU0paekRDUDVUUUJScytZQURSNnVXaEdVM3F1L3pEQTNMNWh3bEtjQ3FCSE9zZmlQaUhFWWpRaFNtd1lBREJJc2pyU3MxcjJKUnJJQVBvZ0F4ZVJZUk5LSXRZU3Z5SFJDV3FiTUQwdXRSODhRQnNLSk10RGNoZzBPakxRUTFZb0d5NXZBYWlDbnoyc3lHQWdXejlBd1Bucm1oTzJuakxkYlZGM1BDKzVNTzg2RWVlbUlTT2hveTNEd2YyN241TERDdjg2cGRRYWtsd1RlcDdXbXQwcE1JdENVZDRaUzJNQk8vM1F3WjU4RDZlRXBCVVBDUXVRN2ZNZ3dETVhGb2hwUjdidGNlS1MvRmNHZi8zTjhTQnNzbElFdVhqTzhtYXZBUjJ5ak9hL0NIc1ZyaG5XVjVJVXVaYmpBQmcyQlYxeVpLZ3czRW9JQk42elRFZThwc3puZVk2OTZQSXhhYXVxYk9NTVp6Y1pMNDd5OWFPRTJUUmpCWjZUWlR1YjZJZlVpbUp4TXBWVWgyVm1ZMlM3V2JyU2xZd1BoUHFsZlh1VytQMXczbnVicy9PUENVR2Y3ZlppSFk2bjBhRmg2TUxUbHE3L3JDSkZBWHNBT2FKeFByKzhqKzZoQ0FnMU11MTBCWlJINkZUZkJXNzI3c1dZc2JucGhCSHozV1J5UTZ1eUlqcHN1WnU1T1ZlcEFJQm4wcmJkZlBFQzJ5d0phM0NpTjZVRHVGVzVLS3lMYnBFQlVEMm1ZeHFiMVJUclpWY3hmOCtPVnhVUS8ycGJNRHRiS2laWlQ2L3NkUnhGNW1rbTRuL1UxQlBsNzVFYlQvMWpObzk5Mk1aMHI0WTg2Q0JQRGEzemk1M0RnWXFwK09NVjU5U0FBOEVJUHNQQUZUL1lFOHdRRXlCSVNBbTBVZ3laemRmMVJkTnN3TDdoQUxSNFUvMk5EVjhFZ0VMRUUwWVVSZ21ZeDdXNHpXUk4wdXRoMU8zNGpNN3BScElGVVRCdEFLd2tUWjY0VEdnWXhoM2syK044VHI0OFZyWXdUWXBOVmQ4NGs4c2dEUUIrRkF6U0JqZlVZVGhjWVM4MWhMaFpCVW0yRjI1c1J2UTRob1h4Vkl1cUFDcUFRRzcxQnQ4ZFRCRmMyQnR3d0xWQVZza1VGVWtnQjFmYUJ4RGRSMjEwVklFVmxCcThvYmhnVG5WOUdZQTB6MTV3aElnNHh0WU9HWGxGMHc0SXhzWDVUTStFMzd1QmhkTEpWTEd3VGZnTlR1Rll5TFEvekVGSHpBZDBURWJSalUwNG1FNVJraE5ibGc2NmdGakIyVklhd1Y0QmZNem1nZFhFVUJSMlFFOS80QWRTQk1ZcU9OU0d6Y1lmRUViSzNBY1NPQTNmZ000R3ZBSFlhZ0Jnck00d0FnZHExZzFIUkFzZGFFaWtxSW1ZVlZRaVphRVFYY3dhUWNWRjZGUmFrTlhmRUlkUEFBQy93QURDMEJaMTZKT2ZMVjFuS0UyeGVHTGpmVTNIWEpmaUtVaGk1V092QU5adzlJaHg1RWRzWkdCTXBJQTR6RVEzckU1Wi9WK0FvRUFhUFdNMitSWnZBUVZyQUViODNSK2NZTlhZcklBM01pTnNSRVlmTlZkVitFYXA0Z0NHcENMWVBJbER4STRGY0tPd29VRXVoVWtRUUtNZkNBNHhvR0JrVEVlV2tNcFp4VnUvNEFBQW9CaUtrWkxXSUZMZy8veFRKTnhIL2VCVGp5VEg5Y1NJQUEwRjY2eEFmWUVMbjdqWHVyRk8xZndEMHZnQngrSklScmlpTVQxQVRXQVhJK1NqaWk1TFNRMkVDYTJFRExwYkUrR1NHMlJhcVVUWjNRalN0aXlMYU5WQUt0ekd2MlJBaUF3aGdwV08xTnlsN3lqTzc4RGt0UEJJTFRDQnhjUUlvS3BKZklJQXpDd2dhQ1hFSnNqSXdJZ2s5T2xkN0gzS1FQMkV1MFVKeWRVSnlib2JBc2dIWUd6WmVpakpYSFFKV2VtWHV1RkJFdndPdzNpWGo4Z1h3L0dKRVRTa1JhRm1DNENVMm1DV1YveG1EZUhFQ1BFU1h3MVlIWkNaVWtEWGoyd1pVY3lMRnRDSkkyQ1hyZEZtdnhqSk1rcFgvbVRXMGd5TERVQVlySnBIaGxCUUNFVVF0QUVrN21aVmxoa0VITC9vU04xc2hnYjBEUjhVenRGVXB6SUdWKzRnMlAvSUdFU1JqLzJZeXBKUXA5R0lpSDBTQ1pHMDRsQjVEcVpnNXZmcVJEYzhuQTlFajRVS1RSdjlTTUxjZ1Vka2o0Q0VUOFZscHdjcGo1WGNpV0RvbUZsVUVQdTlRRndjeTBNbUNhWUEwMzhPS0FWMFQwRHRsUldJUUNtOFVBZG96YStHQVRRYVdic1U2TlM4RDZGRWdRWCtrSVJ1ajd6d3orQ293SGJza291NW1RbVdoYWRrYVFWMHpHTHRFajk1MWNLZ0FFc1FGdkV4VDg1SmhCZ1pwOCthaWo1Z3lYejAySFZPUnVjOGhWVm9UbEhhaFpVUmtWU3RsMXpoaFhPSWhzM2xnTlM0R1dtY2tFL2RxZG01Z0kvRUNacnBqa3IwbzludWlZZ1U1N0w1eHRuNDBBRGtBSklJQU5nLzdZcXJtYW5ZR1pCZHVvb2NKT0JrME5BM2VtSmdXb2p2a2tndmhsbnZaRW5KSUE4WmVBR00wQkJaK0FHUXRBRnEycEJMOUFGRStvb1lwcENnbEU1bXJxcG1kSkxCZEpBd0lZMm8zS3FML0FDU01TcXAvS3FYeFpvdEpJejRTUVprV01wdUtvd3YxWVZEeVVYSFJCQndScXNSQ0NzWVBZcVN1QXE4Vk1EVTZBQUJ3a0IwMlZNejVvd2JOQklKU2dWY3JGYnhNSXFtMkFxU0RRUVNrQkJQb0FCcVVOQTU5cEROYk14d2NJRUZuUnBBa0VFUnBBc0FwRURHb0FCdDZlcklMV3ZKVlF6d1lKdXhvbXFBbUVFV2JBRmlLQnBxeWh0cWZNNlBPU3dCb1FYMEJKWEVNQnRVa0JCbHBZc001UURJaGtzM3Rld0lHdEFkSkZEdDljRGZsRDJEOGEyQmJuUUJWZkFSTS9DaEc0NVFqSDdOVTkwTFFGSUd6WGdCckFLQllKU0JqcFFqQUdZUXprMHRGb0VWTFF4TzhLakErRWFSTGJDaEZTclJScFRGZGx5WU5yeHRkYUZBYThCVnpnUkVBQWgrUVFGQndEL0FDd0pBTDRBdkFCVUFFQUkvd0QvL1FzZ3NLREJnd2dUS2x6SXNLSERoeEFqU3B4SU1TSkJoaGNCRERSNEVTR0FBQi8vZmRUWWNTVElqU2RQRHRRb01DWExpakJqeXB3cGt5REpsaTlYcmxRcEVxVFBrRHNIQkFCWlFLUEdBZitRRmhWbzh1UFBBZ09MRW9TYXMrSExxaDMvQ1VCSnM2dlhyeDUvUWlTSWRLZElnUVV1UXRnQTRWOEJObERkTGlnQWRlakd1eTNMdHF4TEYwS0JCd2NlQ0Y3d1lFR0VmNFFYRkNUODd3Q0VBd2NLRUhDck11dkdyV0F6YS9hNDBpZ0FsaVNWK20wcnQrMkRnZzhnUENqZ2diWFBvVU9ySnFVYmdZVnRFaXcwVE5HZ1FjenUzU3hXQkdlQkl2aGg0YlpaUkVnTllUUmR5bmVuRGlRUVFFQldBZFkzYTYvSTgreG5rQU1HRlA4WW9MSEFhTGJtSFVNbVFGZHlnQU1CMGtwV2pRS0ZCaEs2UitqWDMrTmZqeDVJakJCZ0NicnhGc0ZoTEpDZ29INGZmRkJERFE3MnA5OFV1SzJ3SEFUVS9VT2RBQVVJTUZsald4MkEyUUdOYVhWQUF0dWxxRmxaRjhWVjBFVXdRZ1hWQWh0RXNBSUorLzNYM3o5QkJKRkRHZi9Ja0lNTVVNZ1F4QTlCOUJCSGYxQUUwV1FPUWZxbjR4SklLQWlEZWRsQmdKbGxreEVRb29wZ2hobVZkQVdsUlpsODhhVkpXbFJRYmZEUEF5blVJR1FaVXZ4VFowRkFsZ0dGbm53MkdjY1BQWHhBUWdSK1RhYWxBQ0lLUktLWWpEYWFHUUdSblFsVkJDVDhJMmNaYnJ6d2p4di9kTkdwcHAzYUNhUU1IL3lEUVZ5UlJlcm9xcXh1Wjk0R0dDai9VRU1abmlLVUJSSC9sRUVDQmttUkZ0ZHByUVlyYkZjYkNDYVlRSWNwV0ZDc0VzbTJFVXVXS2RUZFFUL1pCQ05RdzJZcjVrMmNRUlRTdDJLZDVWSktCTUVHVzBzRlhaVVZ0TnEydXhtTVRFMUxMYlk5b2NYVVVpT2hCWUI1TGNZbG8zUGhtWmxWdEFjWkJkRnpDTHVWTUY3dUNsdXRRZmt5OWRtK0JrOEZWVmwrcmJiQVdoQnMzTjVBMXI3a1lsU3FDV1lqY2NPdGNPTS9sYUt3SEFxbndSQkJZb0sxUjllNUFuR1lWWWJXYmZWaHc5czVPMTdHcng2TEdBb3JQSkQwQWpBd1BaaGZhUkZrWGJuanVmWG1BN1hkcDF1QS85eFhKUkk0YUgyZ2N2K3N3REorVTNBdDBCUWpESXFDUUhNcDdCYWtibm5Jb2M5YjVTMEFpajhELysyVlVTbHh0SlJRQWtlZFpsUWI5ZlhYalRrR3dhTU1QRWJ1ZUE4MVVGNkREaEErV0RubFB4anB1WkgvL01CSERVRk1TRnhxSFFZQWdkUlNIK1NsVm12NlBXelVWdU5GSnVKVXUvVUEwbXgzVGlUay8rUUFoWjEyUXRGa2o0NG56Nk9UU1FMYXRvV0ZwYlY2enBOeEtQdjFNOFVuL2NoYWRkaFlqU3VNRUFTdFo3aHhSaGRkbkMrRnAzVUtJY1dlT2Z5bndYSnhGZm9lb3BKaHI3K1lMcEkzbmdZL09BT29jUFVQWEJtaElFUjRRUmxHc0FIWHJBNURzZHVmQkZWVU0yRHhxZ1l2ZU1FWm9MQUpYSjFoZ1FyZzFhL3E5NktHWklSaE5ua1d3U2JJUXJCd3EyRGRTaGU2c0FVdUdvYnNMQnpoRnIxYXVEOW5wUkNGNklKWWQvL0ExWk44QlU2Rk9aVGhTWXpvTEI0eWFvVWxySmUxVUVpU3B1UXdBSHFSaXNHVVVwNTBWWXRpWk1ITEN4bGlNQms2OFYxUjlJa1FJNFlRTllaRWk0TXJpaHdIUWppaDJLdDJLdHlodDlySXgraHdCb3BuWEVoVDVFV3drUXd1WFZMQllnQThNQlcvdUtVdGY1R1J3c29WRVlQNXF6M05jVXpIVk1NV0dqWG5NVzJKVEhZS2tyZWNBVEtRQ1dsaUg3WElFc0tWUnlOdFVZclZDTENCeUdCcGRiUzdWdTFPMHBjTkdBWUc5WmxaZmNxMkdKZ2w1cGpOSVFEVTdDSzQ3aEhrUTMxRHBTQWgxaFB5VU93ZmZtR0pyNkRpbDdpdEJqSG1vVXRyc0ppdnVoeUVOWCtwVFc1V0lBWVNVS2lkd2xHWnl3NzB0cmNkYUdhQ2FXQmZjQWIvcnhkWlp6SWQ4VklBTWlUTmdpMnhJT0pCSE1ldytRKzJ3STBGVnp1TmFweGp1S2k5Y1RaL0VZeHllSk8yU3VtbWEvaTVrWERHaGdJRlVlZysrT2xhYllEbEpyVEVwMmZaNlVqUEJqTFRncHB4SngrNUdBVEU0NEYvZUdBQWJDbFdzUXBEVk1JVXhuNnJlNmwwQ2pEVXJMbHpQeVB3ZzREK1VRSWtsQUEvQmxKT2JjNVdwUkVJUkQrajgyclp6TWEweG1qSklKangzcUVROHJwRkZaUmVTd3pYWHBJaUVLVU05R2JVNlZCYVNCUVlwZDBJQndJYVFRLzQ4SjhrQ2FRSE9ranNDQUFMMkNrQWRnUU5ncXpsK01DSEg5UmdkSlFUS3dtUzlvRFhhV1VnYnNXTVFVNmtGUVI4MXFZVWlZdTh6dm1TK0dUTU1KWDZodzRvMTZOLy94QldjazJLMGc5MnE2TWUvQ0JJUFJoUzhDQW5neDRrcVFjVDJxeGdwcWFWNmxDeVoydjFrbHRSMnhWem1nbGFhRUtUejl4U3JBVEZWaUNPeTFPZmhwdWtKU1dKZWNycjdRaDR3NExWVE84OXoyeXVkZUNqbFdoU0Z5eHgwUXN6SmZrejBoek9QQSt3RGN2Nk15Yzd6Y0FnZXlxUzQwQ1hxeUFkcVFadE94MTdRSXVkRHNISHMvZTlub3VnZGpQNTBPVUJKUGlBRE9qRXZ1R1orQi9HNndJVTNsZWtJZ0VvYVFTWWpDanJld0JsWnRpSjhoRkFXd3oxNFEyd1FNU1lFb0w1aHB5KzlVbkJmYmx5Z2FVcUJTeURZS2pHTjdicFhWWGJIZ1U4UUFQQTB5Q28vbkVHSXB6QkNFUlFnZ2IvOFlFSXRFWjZvR1ZEbE5jTVNRODhZUDhBSFpEQkM4SmNrRFA4WXd0WitFY1I3SVFFRVQ0eW5OTmRjNVNCWldVVzFLQUxXemFJRks2Z0FicCs4OCtDRm5SUVNlU2lEdWdBY3NFdGd3c2FqYzF3dGluU29EYklzVXJtcGlaWHhJYzRQR1dvQlQzR203cjZKb09zNFE5WHpjSlRubkJncVlTaXJJdklGRnE3QzlYc29nbGNRUU9hY1BHRWlMN1dUS3Q3RFVObVYxR05QSkdyVG40UzY0UThUSWhCVERaM1ROanJIL29RMmZQQ3FiVHY4bXhwcVV2Yk1RSDJEQ2xaUWl1T1M0MGNPWWxleWpJeWVNY3JKSEZsV0NYUlhjZ1N3Z3RlcllVMXU2dFZranRLUlNnN0xBdG9ObUpIVmFmeXBxTFZkNlJ4UGZBa1JxdGNKaEdMU1F4dVJqdlNGU1VwN0lpcXkxaEdmM01raUFmL2pUSzhvYTFIbEw5STQxNDBpbFRvU3NrelEvTGtxMzE0VGtxZUVIOVpyU2dzNFY2R01ZNXhuTmd1M2llOENyNndlQ1pIL29xV0MwT0tYUURKYzVGSTBtWWZzNW5jWlBTYzAyYjd4a2NFR1ZCZWM5QjhLWjF3S1J4YVE5MGJTYWh4cFovVXJBb21DekNYb2habUFZeTUrOTNYSXhrempjbVBvUTQyR1gwaWRhRTBQS0Z2VXRqY09Wd3VTc1lIWWxSQnkzZ3l1cnNIeUN6QWpFR01qZkNPR0x3VEZVTTMrL3ZSblR0SzFMYmNpa3l4NCtHeHVKUi92YW90SEp0TGgrVXE5UzcyYXFpR0tVNEVpaE9jZnlEdFpVWEZPODA0QnRDTFUydVVRZy9rSU0yeVJLb3NSZVJ1R2NCYURPVkxSYUdIdzA1NWxyaXNOaHJMSDBnNEprV3AvOWtFakUrN0d4VjF5K3huZkdtYUljY0xPaU5wTWZ4UVBHNnZybnVUTFpCY3krUU5GeHNYUFY3NnFsRWJLOEFiQlRJRklQVVB0aUZQd2xFYzhhUWNndUVZV3BjbWZtYzFvL1JNMVVGVHJFTmRINEZ3L2lkSFdQY2NzV01zYjRKMTVpSjJqNGNXSGhDQVdUT0FITlZvSDZVQjNqVWNsSkliWGFNeUtyTWNoeUVRTGVWUHp1VkhHN0loM3VNOXFGUnNlb1FVemlFWUUvVW1NQkJSeG5KVWZ0RjR6TVJRV0pTQ0dQQUFIWkExSFBVUFUwQWdXNGhWTURnL1pLTWd1b0VEYkFOWStGRXB5d0VZamRGMy8xUmYwNEVXTXpWUUFtRmZQRlIwa05kOUQ4QVdWaVlRbFdjWUN3QXp4Z1FZeXBSZEhTRWVhMkV5RWFBQjY0VUV2SUVFVnYrMWhRUjRIOG94aVNsd2htZjREL29CWWYvd0J4VlNWbzRoWHdRUk81NGxZMUVXYTFwSEYvNnpVNGNJR01HblRJTUlYMmpDWGNaaUl4cUFBd0VpVmZweEJTTndCZjlBSll5NEcvUHpEeEhRQVNsd05tenpBWkRGQjVnSVdTUEFBNXRGSElveFlSZEJoMmVWS1ArUUFBU0FqVysxUW15RUxxcmpXaCtvVjdoa01XdEJHRWlqaUZDbEkrRDFEMWVnQXdGU2l5VUFpUWx5akpsNFdaVnpXWm1saFp1bEFUQ2pJZDFUSWxvUmNRYUJJaWVDWWRJa0c4Zm1mUEdTRW1qSEh0V1JTMzVCSWtxREl5TXdXeU5BV0k1allqb0NZUXlpQThqb0lCQVdLUGk0VzBiU09ZZlZJTUJCR0JnaUVHMGhXbHNoVXlKQ0l0bTRhaWtFUmlFekZkRC9WemlxVXhBSFlDTTRrbGlWTXpsSkFnVktBaWlBVWhDL1paUytaVnpCOVRzSzVoOFFvaCs2c1RTa0lWb2tzbU02OXBJZmdpam9Ga083UkMxUlZCYUdZVGFsSWxhUlkxeHhRQ1RCNHlRN0FqbC9zaU5ES1JBNWtDVEY5UjhCRWh3bzhCaFM0elB2Z1UySGd5aUEyWldEOTNYMUpqMldVU3lKeURhQ1ZSQnorU1B3RXp4ek9UeE1HUVJ4a0NTTnFTTkpvZ1ByUlFLRVFSMWVNalZtY25NbVlqZUNpUkVMTVlIWlpoZVRkeG9sTlFXekJUbERNang0TWp4RDRqaHg4QStWMlNSbDRDUkdraVFRdGxrd2xoWjNJMXA5Q1ppQlZwb1BzVi9RZHhjNmcyWjlpUUlHR0NFRnBtakZBeVFvUmlUSm8yQzdDV0VVa2pTTzVFeU5jUkhILzRtY0V2RnZvdmVHaGlrakZyTTdVL0FCZkNBREkxWUdkQ0lRWGZBK0ttWVFmZkk3LzBFaDdmVWNNVllpZlVtZTJTTTR6WW1UM0dkeWlCTVhKSEFCZkxBbm5iSUpLQmFoS1dZOGZGS1MvMEVDS0xBQlhUS0tBaW1nS1pLZTBQRnpsL1FBYkNNazZZTStYU0FFOVZrbkp2WStmSklEUDlBMk01TS9IZEVoMHVXaFlySW1WNmxqdGFOTUFmZ0FJdFlGTTFBKzUwTUU3Q01GU0lxa2VsSmNNYm9DZm5aT1hJbWpyWUoxSDFLT0JiQUNOU0FNTStBR1VtQSttcUpCNlhNK2RpSUVCdkVCRU1WTlVIRTM0eW1scXdLT2FKWlJpamdyQitabEF2R2xCeUVGWlNBRHU5SkFqcVJqYThxbXE0SWw1clJUU0tFQUVUQXJtdUpCQkdRUXVMYVNweVFnZlg0SkgzOEtxTm15a3dPQU5TTWdCWXA2RUlod1FKdFNBeXlBQVExRXFTM2tGOFdpQUJyUUJXNmdCSFpXUUVhd0JRVTBDRVFnQlJyUUFWVkRxaTNrSnVZeEFJWldCblBXWlhjbUVIa21BejZnQU5JWEYrZ3hxYmc2T3dmQkFqbGdwRnpXcXJOYVZ3b3dHb3V4ck5nakk2dnhBQXJnSC9KWloxM1FBeG9RSys0MVd0Z3FPMnBXRUd2UlVHVlRLU05RQXpIYUFiQVNTZGpFQnVsNnJ0Y1RWSG1ZaHhpQWd4QzFoQ09JcndYRnJ6SVJFQUFoK1FRRkJ3RC9BQ3dFQUw0QXdRQlVBRUFJL3dEL0NSejRENEJBZ3dRVEtseklzS0hEaHhBalNweElzYUpGaWdFS0hsU1k4VjlHaEFrL2RnUWdzbUFBZ3ljOWtrUUpNaVZKa3lGaHJ2eDRzYWJObXpocjB0VEk4R1JLbnl3SnpoUTRRR0NCbGdRTC9GTnFOR01CbjBXSmRoemdVcVhFamg0WGRzU2FzNnZYcnhDQmNnMzVNdVZSc1VlekRpekFWQ21ib2s4RGJGVzdGZ0RiQWhBSVBOajdZTUhlQmY4QUMzd3crQitFRFhrVEx5aEFJQUNFQUkzbGVodzdVQUJUc0pnek95d1pnS3BTdTBzZkx4MXRsTzBCcFhpZlRzNDRFb0JkMEJBTzc0MEFJOEkvRWl5bURHU3hna1dFRmJUNUN2ZjdtKytDNHdNUFFGaUxWWUJIQXY4c1I1L3VuSUJ6NTVxelgwU0lWWEwzczZybFB2OGRMejVBWEk5NE4vUmRnWUlGaVNrajR2Y1kwZU5mL1g4ai9DQkI4cStFd1BnQWpxQURmUVQyMEVNTlFRaFV3M3dqVEVGQ0JIMGRKNEIxMlAwREhYUVZMaVFBQXY4d2tLRjJJR29HbllVQ1lmZmhVOHNKQkoxNTZxR2dnUVlESWZnUEZEbEFJVkFPTWtBUlJCQTlRRkhmZlBnWjZNZUE4eUV4UlFudVBiQUJBWTloZHdCcjAxa1h3QUVUT2tkbGlGaG1xWlZTckJVZ2dIa2hoVGVlVWY5c0VNRVVCZ2FSZ3hSU3pEQ1FGRkRJOEU4UVpjUVo1NDQ5L0REZkJ5TkF5SmhIMGxGNWdJV1FhV25vb1NBeWxwRUFlUTIyd2o4LzVQQlBGd0tkTWRBWlp5anhUNlpuU0ZHR0MzeU1zSmRoQkpUNklhS29wZ3JpWVFxd1VFTVpMeEQvSVJBWVJCaXhSUlpiZkhGR0R5d29rQlFFQlN3QWdXQ3FGbXVzWmluK005cy91djBUd1FhRk9RVFNRSE1oTkcxQzE4WTAxRXpaQ3JUVHNlQWFXdTFHTVZtVVVrOGtVVVV1VHpKNTJ5MWQ0Y2FMNVVzdktjVHRRYXpWZTVaS3FxbFcxRW5qZlZiUUFBWjVKdGRLRlhHSDNtakxzVVVhdFUvOU81bUswOEVycjdIYy9rUVNWeStwNW01Q2JUR01sM21xZmVtdFU0WXB0UmNMS0t6d3dBcTl3U3hRQkJINDVwdkxoSTFLQUY2bG5yWnplRThtOUtVQTJFbTU0b2luWHF3WnR5bUs1bGhxeXY3andRWWVGUENBY3FrZDhHUmNjb2xYV25yQ3NjRGJpLy9BU01LTHZuWFFRUVJycngyQkJ1NXBRRUo4OEkyQVg3TUNhZkNvc0tXTy80aWhsNDFaQjNoMGd3NWtuWFdGSy8xVlZWa2REQ1Y2M29GTWJXT0dRZERYYjQvYXZTQWZQZkNZVUJ6LzZEQ1FnUWFPd0NlUS85VEF1VUEvOFBFUG42WlB3ZDRETzUvMkpBUkVENXIwb0JnaU1LTGk4bmEzbHVIbWdibndQMFZWRFJnSlBjaVFnNlJsekNqRmpGQlVYMGFDUC9Lb1p4QjZMdGdnQ1gwVjhHUmpRd2RnOGxLTUpnMzgramRkbHRSa0Q4Q3dBZ212dXZHQ0cyZDBZYWxBUXRRNVk1MDFra0VRYXZDQktRZ21NUldEVHVMWXgwQXRPYVo0d0ZJQUNUNGdneTRRZ1FpVzJ0OFpjbEVyZ3NpQUJCaEkyY01hU0VKVmJXQUR4SG9BQmtiZ0FqYmxZSDhYbEFFTFFtTTFhUFVGV2tKWkY3Vzh4UzZDZk10ZUpRd2lpUC9HMVVNZTFxUmVKbUdKU0lJaXJTSUtVV25aSW1LM1NrS3ZyQ0F4TEZYa2ljSlVRaGtqZHZHSnFvb2lEMUdTUkt2UXl5ZGx2T0pBVUhJV3FuVE1XeEViNFE3UmRSVjRmUkdNaTRPSnhxZ1ZsRFBlaTQrVDRSWjVqdExHanV6TGlpSlJGMFcybURDT3FBK1BHTG5XdVE3U0ZvQTFaU21XQkpoZG5KSVdncEVKZVYzcm1zY2VncHE3b0laSnFBek1YWUFGck5Pd1pXZkRzaGlVN2dqSml0eFJlR1Q4MkNibk1xaU9RR0FBcWZGT2VONW5GNVV0QUVJUFlNRUNnTU1lNFBBRlFuNkpKdTJBeFJnVW1TK1VYM1NPK2FKam9scWFheXlkY1VvNEs2bVVFVGtNTlEyYnBYZnloYndDZUVBNGU0blovTTZtRzk3d3BqaDdhYVY2cEhuL21yeGN5SlVsSWxxSjBBZVphMXJIUWdJbDJpTzk2YTR1Yll5YUtYT1loYWdabTZ0UnMzaHlNZGxuekFNYWxWa3VtVFc3VGQ0MElJYWFwUTJlRVZqQXpXQkdndmxOd1VFa3dBMTdiRU04azUxdm05WHA1a0s5MlJhRExJYzFGRVZlTzRGSnpiczhrRHhRdXN0cFZtYlBzd1hJYmdMNUF4SmVSRld5amJRRUFJSWRmUVJTbi9qSVRaa0wwSnJXS0ljNzBoU0tSSlVwSEFQK2dZQ2RnaEZoNjNvY2VlRElHa05paHlsUGV4bHY1amFDQlJrSVFaMnp6Myt1WURmTnplZXc5cW1CWW1zZ3dCL0k0TEUvcUFGKy90QlNGQ3hnWjRlckRrSjlLTFFESk1BNkhHSm9WMUJHbVRFWmNTbFVBZFpzWENTZjFQMURnSFhLRWZYbTlLT0IvMnoxUUFOOEhZTWFOSUtZUnVoSlQ2clFkZjR4S040Sm9IQnVGVzFPVERRWFROSUZPbU95eXdDU3lTekIybWdnVVBCZmdqeVh2YzZSYmdSSUFPK0xsUFJLOHgwVU8rYkxDMU0wcTF3dDlZc3JlTzNYOERpaUFOczROVklDOGRUMHlzRGYxODVKZ0FKUmt3QVZXMEFVUE1Db1h6b29sUnlUdS9iaXNXSHZPK2JjR0p1RE1rakJVdE9iMGYreU82TWRCU0VPa2NVUENWQUFMRkpOaVhpL2N6QWVQVWF5NkpTNFRNNGFnZXVrOElKWW5ZRUlRcENDRUdZa0JDaWN3Y0p1a2tFTllJUVlwU3pRZlNwV0xoc3dXZUxrRmNVMmE2TFVwbUM0d1ZvUlFRbEVtRUVaUHZDQUFjVG1ka2tPODBPNkhBRVMvTUFObXNLZ3JISkJrQzkwNGY4SEdvaEtRdlFpNWpvclpEa0h4b0N2ZWxBR0lrZzVGMXY0aDU5NzBJRVFxdFpxZ2VtTG5SY3ROY1FvS1VWbU1zRUlmaEFFT1pWQmRCZ29jc29nc0dSR2V6b2h2b3BXSHEyb1EyeDkrdFJTNUVoRGFBSVVocWp4MUF6Y2lSaEpyZXA2YlF1TnI5NU1HV0dOcWxuTHVpSHY4aUhDTkxaSE5BSzdPOEhtOVdqSFdHcUxTU1RYeHphMnFmRjF4aDRtVzltNnRwYXFhZDFzVjlPU2kyVUo5MGljUFcyTlRCTGJOa24xWm02dFJJWWcrWEZMMlJpWlZyTFJkclhhaVdGQjl4cWJ2VVNzWEhHUzBrN2l2Wk82RllrVjVUV1dSSEszSnlJOEwvSjZYT2VXQ2JFNTBoS0VnUWRsOGNaa1p6Syt5WGpMV2lRS1h3Z1M3MldRa2ora0xJdi96dGdheFNKc0kwYUZTenVFdDNoZW81R0NuUXpjQ2NzWGFsQ0dHaks1cjNnQmMrNjNrendVclV5TGtXZzA5bmhvempCTUZrQmlqc05JYXJ3RVlhVWs2eW9tdytsQUdlM0hueml4NFZ5TWQxb000azYxaUc4QWJPam94TzU0R1ZNQ3l5OS8rUXR4TFFkM3d3VEdNSmM5RGZyR1k1a0pWYXlicUU1MjBrY2pTT2t5NVRSTHpranlHcmVpMDRLSmxXWDZxSEJzTTBObEVjWXZsdThMWWZEeXBHdGlkSllFR1c2RkR2cHdlRDJsNUlTVUxyeWJYTlRQODdCTFM4R0xjSHJUTXQ3QWJJWXdpTHZtUjdXQmF0b3VtRnpyaU45Y0xCMUhpcG5sa3B5Slo0UktrQkxqeFNqcWZlRG5weEw3Mktnbm1UQm9HZWIwSm9iZTZLMDNMQk5PLys4dDlBRExNY21vb1l5TythaWVQa0M1ZjZERHJmTzVvZElaaVY1bU9VMWJURkhqRW55aHN1VnBrdmRNS3dBanV1RWc5aFF6eUtRZWlCRk53UkZOS1lKSzZrVXhsYkVvRkNoUUpBSjRTU1lXbmdFc2lrUmNkamNRaTBGRFRGSlhrckZEUy9kMEQ2QUFLOU1lanlJM0x5VlRZZ01oR0NBY0tQQVBOUmd6LzFCNU1BTXp0a0U3SlhJMDF6UjZDWFVkR0tKaWhwUVUvOGVCSUpnYXJBUjNyTVIvR0hVOElYTjlEMkJTY0VPQVpUTUZZbU16VlVnenp1SXNjdk1QT0JCVE1WVmR6REpEZ01FWVRGSStSWk5nQmpVZDY3ZDFvb1ZFanVFUkwrWmxYblpvRklWSzVQRVk1SUZlZVBaTVluTTJaNk1CL0RFRmZxQWJKQVUzSnVBYmVmOURpQzhTSHdNQ0lJSmxOd1pJWXNSVk8rZHpJZVhDT3dLUkFKVWhXcEVERWt3SFRBVVJNUnhsVklPMGZvWVVpTW5rSHZCUk53U0NId05SVlRBaUVGaUZWVTkxV0I5d0lMNm9HMmVUVXNmQkdNc3hYSm1WRUFza0VGUnlYTzFGR2RPaVNWc3hWMnUzZG8rbk1qc29OL0toQXd1U1dLOVROdmt4QWt0Z0g1TDRWQXVpT25uaVdEL2dXQXppSU03RU40ZWpkUjdJR2g5Q0ljbllqRFVYY2MxVmdrOGhIZUxrZEhnUlRiM3hIZ0xpUGR3akE5NGxXRnpsaTRyVlY1TFZBeDhnV0hJaUorb29XZkhCQXlUZ0Y2WHlKeWNUTlBKWUlwNzFpUW9GYTVKMEdZOGpIYzdoSmNhekZCNWdHRXJ5QUM2aUczWmprSHhRYWR0RmsvZnhENkQvVTRuL3dCLzF3VG1jY3lDOVdFQThBRE45b1Y3bzlYN2FGQjBZNG5jVm8yL2JkbHFubFJieVpYbkw5QjRCNWw4MFFpZitZeVBjQTJMMmNWaTVWVHBCQUNBd3hRSjdjUURrVTFibWMxeERRemhxb1VCTytSQllFVEpnSWs1ZTRqNE9VNFVrSUJCWFlDQTU0ai8vSUNrRTBTTjlhUjkrOENNQkFvbmxWMDNEUlNVbzBwWldrbUp4Q1JFaGcxYUdCSFJ3dEJaRm9SNzRNUUlDeG1IVHcySFhJMENrUXpvODRvc0FFbE5taVpaQnVEWG0wVTFYTXBrV0lWd3c5NWJGZ3o2WGxKZDd5UWM0a2lCeWtsMmV3bDg2QW1BZTVsOEd1WkFPUWw2QXd5aUVVNElwS1p1enlSQVY4bDVmbzVrQU1BQXRvZ09XOWc5c01pbWVZaWM1RXBHUC80VWo0dGhiSzZCcGJMbVdYc0tXOVFpZGpSUVN0OGtjRDBPU1ZvTUM4TUVITXNCZlhaQmhjTklGZGhJOTE0TWpjV0NRQm5JYkxEQitMcFlWekJtYjdqa3ZvMFF4OE9VZWlwV2ZYZkFDM01tZEdiWmhBRFFuT1pCYi93QUQwTEljWk5VWW50aWdoc0lHMHRoaVJqRWlLekFGcnlJRmJsQ2gvNEEvRnpvalp3QUYrMWtHT0NKazRBTXRjUG1qSm1vc2JKQjRUVUZOeW9FQ0ZGUkJiaUFFRnJvcFhiQmovSU1wbEZJR1BFcFR4TmdZalJLa3dBTjVKNlFiOVhGaEdiUXBZb3BCU2xCajAzTUJJQ1FRc1NHaW5hYWw4Y0lHVDVNYU5qUUYrWWtwVkNaby8yQUVBcUduRmpvRkNwQ0VqQkp5YmlvdjFQUk9HdkFCWlpCQkdDUVF0YWx5SzdueVl5UFFBY0RrWlZranFJTXFMMnd3S2lQUVp4ZWtwd214QlViUUJid3lBSlNhTEl6Um5wY2FMeEtGQVN4Z04xSzJackx5RDFzZ0JUWEFBbkoyR0ljbW1hbDZNUnN3S0RqMER4MVFBeGZHcUxsZ0JFWkFCREtFQWFaWUdGbTZxOEJUZm1xS0dCdUFBV2dpVzVMeUFtV0FCSDV5WUpCM2RjNnFOTURFcmIwWFRSc2dOenJ3a0VPbVo0aVJNci82clF6RXJZaG1lVkh6aFdXeWt1N3FUWHRSQUpsMkV3RUJBQ0g1QkFVSEFQOEFMQk1BdndDeUFGTUFRQWovQVAvOUN5QVFnTUNEQ0JNcVhNaXdvY09IRUNOS25FaXhva1dCQkEwZUpMaHhJUUNPQncxKy9HY3dnRWFFSDA4aUJJbnhaRXFPTEMvS25FbVRwc3VNSkhIbURHa1NKY2lYSDNXSzVHaXdnTUVCSm5zaTdiaVM1TDhDRHdraUJXb1Nxc1FBQW1wcTNjb1ZZc21CQ2dNVUlDZzJBQUVBUVFlTUpDc1FLbFFJQlFwQTJQQ2c3b0lISzFhd1FQR1B4YjhIZng4VUdDQzNjRndJQk9LV2ZVcHdMRUtyV1FVU0dDakFLb0dZWFROZjdJblM4ZE9XWTVGbWhCcWd0R213Q2dlN2ZRQ2g3bDhXRVdCRW1EMGJ4ZDdhLy9oR1lLR1h0MjhOLzBnRUowSDhJQW9ZL3lBa3h5aWdjbVRtenhGbW5heTVlc09lS2xjbUZZa2E1cjhCM3dONC81QmJGeStMS1NOR2ZCanhyMGFOSGtIZUIrblJQcjBmSFRwNjBOZS8veDk5SFNQMFVFTjg3bjFRd3djZlRKRkNYWEJkZGtCbFR3bFEya0ZRWlJWZFFoZGFweUZYWWcxRTJtZE1vZmJBYmlUb0lKOE1RY1FoQXhRNTVIRFFmSEhROTk2QS83Q1huZ1lhd0ZaZVhBVk1abFprV2JIbFhBQUhGQ0FBQVVkdXFPU1NZSTFGbWxVaGpjWGRVd1U4Y0Y0TlA4aFFSaGxTZEhHUUcvOXNHZVkvT1pTUnc0cFpCcEdsUUZQOEJSZGxCRWw0QUpJSE1Hbm5uVjNCcFZ5ZFVJMVlnNVpublBFUEVRZHRRaWdSWUJCQmhCSkt1REhEREIvVVZVQ2RkWUtJNTZXWWNqV1hCeEhnU0I4UlgveVR5ejliQ0dSRUYvUXBNRjVDRzBDd1FLYXd4djg2MHdiL3RQcVpWYnV0SU5BRDRIblZWSFlhYlRmUVN5R3RsRjFPSTQwazY3SjRFbFdRVTFNT095eG5Hd0hWVUVvSkpiVVVSanRWeSt5M1d3M0ZrTEF0WWNidFRoK0JsMUpvWkUxNG1uY1J5ZFVxQVJ2VWlWaENSa0x3YnJzRG1mYmNoUktDbTJsU3p5cUVsRkVldWp1c2sxaDFsNXBBYzdubVYxNFJyQ0Nicm5jOU1CNWNQT3JwbG1LS1RTYkFubktCU0tsWklGR0g4a0hVQ1R4VHNoQmpWQmJEcFFWbG1zSmtHY2JhaUwyUmdPTVV3UDJqQVJJakFKY2VlMElMUFRSNlJDOUJkQThCenZnUEh3SWhEVnNFRzJ6UVkzTWNBUmxUa3Y5WStBOENrYlhzc2t6S1VtaHV3QUdYNWxob2JtbE5Gd29ya1BCQkQzejg0QjlDS0VML0VZUkFQK2ozRDlFbEFJZWVlaVA4TVFVSmVlMEZ3d0lMelBualpjbzFKUkRiQjFWYTZkbDJRdGxSaFo5VjFpRllTS24xMXdZZEFDZkRtR0ZDVVliclVQd0R4ZXJ6K2NjZkh3SWVpS0J3SzFoRkdwQXhMOGY1OEJiTjNGQ1B3ZjA1UXhkZFNQRlBGMFIwSVlSQVVKd2hoYURUUytIQ1B6SjhFTUVEdGxKM0FKR2VFMisraG5OMTBJTVVMeEE2NnFDaUVyb0ZJa1JJMFVNSDRHbDkvdjU0enBWY3EzSkxuUTRTSW9VUmRBQ0FsU3ZNcnl3M0VZTHg3NEVhY3RiTENrSXRDcDVrTytheUZnU0hweEtXbUl1Q0NlRU9WYkFsTFJKeWhpckdZZ3RxTmpnd3A3andoVTRobUFhNWhVR05CQXRiMFZxaENsR1R0bU9oRFlZc3BJZ0kvNEhJazI0TkJZZlNLdGF6cHFLdHFuemtRekpzSUkrczBoZ1ZaZ2NrWkpFUVZ1SVV0aUJHSlcxSmpFaEdjQktUQVBScUxEZXIyWVQrMFRLb0lDa3VJNnVTWFI1d2x6b3E1NDZNQVlDVHBuaVp4V0JGUWhiYTRoYkRGcWNQZXRFanpob2pXTXpJeUlPVnBWMG1ZZUlLYjJVcENMUm1BWG5SMVQ4MCtZL1kzR1V3SE90WXEwaWpMeTIyRFNIS2dRd2JRZkl2SXgzU0lkbFJER0VZbVRBMEVtYVJhNHdKVkF3Q0Y4QWNaRGZJMmMxeDhQSzQ4dERSbDY4cVQ4Ym8rSThGRkJOeVZQSU1sQzZURlZkaUJVclJNZHYrY01pV3l2WExLSXBocEI3VG1FdlN4U1U1eHJSU0p2MXlrQnd0N2g5QU93Z0xja1FjRFpCZ0NraVlRZ25Tcy8rZUtTU0lCOFRSeS9mMDV4eDhkVWRrMHVuaUJ0RkNNQWZtekdacnVka2lCMEtZWHRabEx5encyZUUrOEErT1ZrMGc3cWthMFVhd2hBRDVnVCsyMjF0N2dvQzBBQUVOTmxvamdFd0JTWkRKSUNsczJoUkFuUVJBdHN4bDZIdys1QllTbTFJekYvSVNuWFRMS0FuVTB4NkJ6R2MrN3huQjN4THlOLzVBRFFsREd3SFJFS1E3QklGZ0NucDUzSndvRTdETEVhbUwwZUZwMkJEd1NxMzRqa0lyR1l1K210U2FFWkVBQ1FlWkhmZGlOenUvNVVBL1B3QlFlbnJ3QVQ0Y0RVY3MySXRkRUhNWmtRMlNPUTNMNWo4TzhLQzIwZ1JlR2ZJTVNuWmxKZDRBWjRBcmtoM3JjaENFMmMySGFrMjFVWHFBUmpHdElVOUNJbXRPV2N2M1U4di9hcVo4RFFFUGVEeEFGeFlNVmt1eGM1NUF4SVFpZ2FESVJjWjFUNEhZOHozcUFCSWpMZE9tYldIVm1LTG9zUzNZRmNnR05QQUJHZERuSDJCNlhwZitJVndwd081MW92WHVnYWJBSythTWo0MEQyZHgwK1FjbGFkWmxxVFVvUS92T1FBUkJCV29UL3dqVUMxNXdoaTdNd0FVL1NORDNzSXZRK2I1U1Q1OTVnQUttd0ljdUtFRWcvUTB3b2M2UUN5SVlRU0NoNmlRR2tqTXBqem40eFArTHdIY0ZVcXBSYlNFTEw5NUNEcEF3NG45NG9DMFFSckdEQWVNYUJXQkFBVDRJZ2hTbTl6NGlJRUlLR2dCTUt2M1hUQjA3R0lCL09WMWRJbENqRVJ6b0h3cVFjR0ZTNmVRdUMyVEVkT25WRHpzUzFHeDUyY3NTREVzTXNZVWRuQ1JMLzVIQk92UHdkSEt1T29jUUxHdytsZ1BEbU1KSnlwbEpIUVRpRGFlMVpqZGprVmcrUVZkWVNnS3pQMWRIZ2pZY1Z3ZGhWc005d3l1b2E0bDBtUjFkRVRwUDh0QWxWS1FTeTJWQ01oTUZ6cHZOSWFmSHJPZzdVNnNuTWRGenVXaUk1OUJZRUZrdmpQT3FaeUtVWnpHNlc3TXVGZ2FCelpaMmpWTWpDQ3ZJTGsvOWxWMWZKTkxDRmhjWUsyM21yeVNsMkZXQkZrbU0wbWFYQ0hFZ1hMNXpWQkpxMlJQeXVZSThoRFZNMkF5dlhrMEZuTCt1SUV2ZWVwREtkTXd3RktMaTI1NHlUa3ZSMnBCdEplRzBidGpRUEpkTFhiVGtqa1FEYmRCVUhvWUFETkx1WkNCd0FJcHpyTmdNUzVnZmQ2aFF6SlY3MHkyaGRiVWEyWkdlc0VHTklQOTY2NzJLMU1zNituSlhrRHVtSmVPaVI4Uk0wVWhvTEhZREZZcGlTZzhiSTdwbFpia1k5aVNPMEx2bFYyTWNiMUJ3bkdGQ3dBT0U0VkdSRGtORm5QMkwzR3diSklUS0RXd2R4aEE4Vk1TbHUvYlZMK3llY3k1M21VMWVOcGtiVFQ0QUJxeWhPbUxnTW5YU1BGS3UwL2tqeTdUT3lqOFNKQUhTM2Q5UEhBYVQwbFdGTEJFMURSb25tcHJCOEFwOHU1bk54ZjRCZ3hVUTh5NnRzV1NSbmhMM1VCNmdWY2VFWEoyYzIvZXljbzFyUEEvOE5pY0tGYkEzU1dZSkUvdTdGbkt3ejlCbHlnaXBQQXdxUDV1TUxYTUJFVGhPYkNoL0hON2tSZmVRYzFYWUxaZDNsa21tdGcrVVNrOUtKdmFNUDNMMkdIblNMZWRTMTlsMEVpK2JUR3ovWWtuQXp0MzR4dmdhV053OTd6bUY5dk9BQjE4OVBqT3ArRnhYZHRHNXpnOGlaa1kzMXpUYTdPN1lGeGNERURGMUlSdWV4VGdhVURmQ0lSd2xrRFR3aENNL293R0ZNd0lsY0RndFJSOUlBMUNNVXhldTFSeHdBbDFIY2lRL2doQTJkWFhtSTMwMkZpV2xJUnJ0SWhwbE4xRmlBUjZYOUhZVnN3THROd0k0Y0RRQ2dWY3J4aDc2aEFRNWlBU0NkVFF5SWlCTlZRTWZoU096RVZOR3dqVStNaEQ0SnhDVThueGpJd0NBbHdBUTFHd2dkRzBUdFJiZEFVcTNwMDUxY3pRQmtsSURSQjkzVTJVMllqdHBpSUg3RVNCV1ZsaUlNd0lrTUJzUElGTXpSVWlYNDBaRzhpQTZGVGFWd2xZSGdRRHlkWUordGxrSzQ0WHdRaEIzZEZGNS8zRlBPV2dnUnFnbThQRURmNU1lLzNBZitqRWozOFVlOTNFMHl1VWVNWEFnSTdBQ0tBQStNOVVjYmhRWjQyT0NEVkdJMjdSbk1hUm1halp2VnNGamlUVWNISVZhQXRFZi8xQmFxN002djdpRFNGQTRXY1ZQaUlNZUFSVUJDNEFZZjJSL0k4TnpDVEZXQjhFQTBEZGZtbVZtdFVRV1VWY1VCWkExS1NBY0FiSWZLL0k2UVVCYUtkS0xnNE1FZURVQ0ZwZ2dPYUoyS0FBNVBUSVdTUEljeWpFWnNLZ1ExNGhpMEJnVjF2Y1VBd0FZRWJCVWVCTUVLK0lpWlVBbWZ4TUU2YWhTQmhLUk56SUZ3clFBRzVBWVkxRlFDb1VrbDhHUE8rVnNjT1Z2YXFNMkRMTVVVK1pQSXpCQWVpTVFMdkkzcE1VOXRTTVFmRkFEZkJBRUhGVTBPZit5QXQvREk2dWtVMWxoTHlDU0lmc0lraWxYWnpNakZucUViQkNnQUFQSlRqMmdWem5nUEF2SlBUQzVVZ0pDV0ZTak8rN0lPTXpJSjg5Rk9SRUNoUUJIbEZWa0tSL1VTQ1pSYzFqV0tWYW1IN0dEWHFQMUluNnprbG1DTngzMUR3QzFBcFh6azJBRFhkSklsQkRoUVQ3aUpFZmhSQjBTTVRhb0F6OVFKbEpRWGdmUklvOHBBMmVpSmpMd0E4b2xFSDVCS3dReFBtYmprNERwVm91Qk1LNG5HUUl4QUJWelR6K3dKWTM1RHkvd0Q5UFRQQUxoSldIaUltZGlXdjVSaWc4UUFIVDNYa2lDR1AzNG1adVJiT1hERXJUQ0Yzd3dBLzh3QTlhREVJMHBYTExUUEZKUUJqSWdBM3p3QVpiM0dac0hGaklGbkV0aVBQbFdPUkRBQWx6L0pabGRjQWF0V1o1ZUFnVkVVRDNvMlpndUlBTWp3QUtDTVZuZTlJZmNpU21wUkNSRUFrQ2RJZ1BYNDE4Q2NRWUE5ZytKb2dSbllLQ05LUU0xMENhQ1VYSEpvWHIzcVNTZTB4amZnUUVrMEFNLzhKK0NNaWdBbGlnZWRpaXNXU08zc3BuZUZLR3g4aGFmSVo1bDRBYUVnbUVINFdGYjRHRUJWZ1lhd0pRbXVqK0VvUUFhVUdGZkVHS0hJcVAva0FYcmlRUWRvQkIwUnlzM0tqQlZBaDdDR0NwRzRENHY2ano0ZzBvbGcxdEpDaXRWNGprS2dBUXVzS0drOHFJNTRCY2JnMEFpZWFXeXdocTB3bU9wWTRrSFlRUmI4QVUwQ2hqeThuSldhcWFZa3FXY3R5Y2o4ZytLcVRjdThGMEtRQ0VsYXFjdUV6R3U4bVVwQURUQTBRR0JEY3BraEdvK0kxWUFOVllUQVFFQUlma0VCUWNBL3dBc0JBQytBTUVBVkFCQUNQOEEvd2tjU0RBQXdZTUlFeXBjeUxDaHc0Y1FJMHFjU0hFaUFJZ0dCUWE0YUhEanY0Ny9BR1FNK1RHa3g0WWlUUXBNeVhHaHlJc1ZZOHFjU2JNbXpKRWxWK1ljZUZMbHlvMDlVK3JVR1FDb1JxQWlRV3A4U1JFbXlYOEZCRWF0U2JXcVZabE9lVjVrdW5WakFhY3RBd3o0R0xVb2dJc0ZERTR0VU9CQTIzOExGanlZdXlMQ2lnY0RDMEJJV3pRQTM2UjlBd2pvdXpOaEFRRUVCVVJGTEJqcTFjZVFHWTc5Ti9hbFdhTWhvMlpOTEJDeFZLaHNRMjhRT1BkZkJCYi9VRWRJUGZjQkNvRXNWc2hld1lLRWJSSXJOSkNvclZ1MzdSWC9VTXc5RVBnajRzRUUvZzFlN3Rpelo0SEpJMHVuaUhObzljdzhwVjRjc0JkQ2E5cTVwMHovK2ZCUHg3OGFBa2VvSHpHd3g3OGZNbnI4Q0ZLakIzcjFTRFRvMzYrZnhCUWVEaml3d0FGdStTWEFnY29sZDlnL0J5Z25tRUhPZGRaZ0FnY2tJQUFDQWlRdzNZWWJGbFhXVUpzUkpGSUJjN0dnbTNvNjFDQ0RRRUdVOFE4VVFRUUJ4WW8vOU9EZUNEVjh3TWQ1Ly9EaDNoUWsvRk5hWEJBUWtGeDAwQ2tXUUlNRVJQZ1BBUWh3S09XVUNrVmxwVlJxaWVVWEFHeE5GcFYzS0pDZ29neGxTQ0dRaTJWME1WQVpaY3dva0pzeUJQR1BESFRTMmNOdUQ3Q2xuSVBLSGRCa2cxUUdLcWgwQkxEbEZsdmVQUkRCRkQyVWNjWUxSSnp4RHhGZ1JEcXBwSmkrY01ZTVVzakFubDZMTVRqb3FLUk95UVpsQ2d5Z0FCSmxFUEZGTHYvay83TEZQMXNNc3NVWlFiQ2dnR1AvYkxEWEFSc0FXdXF3eEZybGdVQzd6alhhYWJpaGhoZFV6emFFMDJZWllRYVNVa3Q1aEZsQ21IRlY3TGVCR2hRaVFtRVZaTzVTSlFsMWtGR1dIUlFpV05vS05kSjE0Tlo3MWJqaTl2VFJWdTd1bTkxUUppRUYxTFVhN1l0VFdsQVpsTnhnLzBDd1FXdStObHlad0VRVlZiQzlHRFBVTFZnbXdUdUFWeWxoaTVaSEN4NTJaVnBmRHZBd1hxM05KZGRlb1JVd3dKY0ZJSGtBQkJBOENkck9oUmJabHBHTzRTVFljZzgyOTF6R2tYMWxjTDRkcXlYUXh3TTV0U1dvZWowZ2w2SjJtYWdma0ZPQVFJSUcvNENOeEhvNm9MaGVEeVBZT0lJZjZpSEVIcEFyTEZCb1doQjA1RFNXRGpMMzNISEthZitJOUpUdm9rV3VWRk54T2RZQU00LzE4R29hbU9kZWZBTmQ4WTk3OWdYaFhuM3JmWjJhYkNqRURZTmNjUTFZTjJHQmVUWlN6Z2NKUUtCblVmNk44Vmhpa1FXZGNnZ2ZOSlplaTBlZ1Fkc3l5c2ttRkRtc0dPZms5TWw1bm4zci9hTWVDVHlRNEFEaFR3YlFaSk9MQ2V2NjlUT2RxdGRIcUpPbEZva29STUNlRkRPY0lVVVhRblJ4aHBwcW1tbm0rdjlJNGFJTWZFd1J3YTVRTlFnQll0MWo3LytVZXBuYlB6QkFnaEZJZ1FpMCtnSVJ0a0NFQnNLS1ZrWDRSeGRXaElIUlBPdFhVL21mQmdVVkZWODlZRElXK0VjSmVnQUZLSnlCQ0VZNHd3ODZNQm9oZGJCL0R4blh1S0kyRW5WdDhJWldFZGRDaEhheHdqQk5LLzB5bUdYLzRLVVNxYzBRaHhtalYwSmFVcEpxRmVTSVFyRWh3S0ltSW44aHBZallRcUxycHBVVEpnTFJYUU1UWXNkMkVxS09xTXVKR1ZHWDRIaEZrTUwxNjRoYXBBa1hxZmpFZkwzcmluU3M0bEhhOVJHalhHdEVYTXJnUUJRVXRJYnA2U2s5Vk1qUmNxTEVPRWFFSTVEc0lyMTBlREdQaEd5SUZyTVlGYy95bExVWXFXWUV5Sm5MVmhPeFBQVXhNRm9LV1JPTlV4aUVPTEdWanBUSVp2ajFrNjY4cEhCT3Mxc2J1YVNsREdZd1o5NGgwVC91TWh1NFBPQm1NUXRqWHdhRHlzNmNheURIQ1pWeTlpZVl4VFFtbG84c0lsUzJBektTV0JLV0tIUE1MMEVqczE1QlpRQWUyQUFHV3ZZQURDZ2duYTBCWFR5RDB6bXJSY0JxTUxDYWtCWkEvNW9GcktXUHhqbk1nNUJFa0lVUkZKdURXd2tub3dLMWJmSFNTaGtKRmMxcWxxZEVSZUNpc1ltTkJsaUFBaFpvOUd2NkVhRUdjSUNERVpSVVBSOVlqMHJYd3dPQjRPYVlBZXdJWTQ0Q29WRGg1RGtKT0NoQ2J6TEYyUGtGT3ptWm1NeEFsYWdIY0hTakdwakNlc2hESGh6b0JnY2xLSStONm1Nakc5WElScFA3QnhLVXB6ejFLTFZyc3ZGbm9UeFVGTVZBaFRIT2VaQnpMT1JNRERFZ1E5WkRLQ0lIbDhhNVZ2RjJVUEZPTVpWYTBwSWViM0k5c0p6eExHZWpJTEFIUDFQWXoybjZJNXNBWlNBdUJHb0x5anBTRnVMc0NVRU13ZENGTWlUWHg0Q0VZdzBUSndIOHdoM1g1SVk5NkhrUDhXb0UyTUQrUUNCbEc0RjQvc0dERC85OEFHNFJrTXVoYW5hZ29ZMFdPYm1NM29FV0thck9SdVl5SkNsTGROSUNBQzlWTFV4aXVrQ2RaQUNGSHVRZ0NEbjRSeG5rSko4YTBJY1BRZmdCSCtLVG8zK0lCMndlRlE0L1JhdXpJMGxQZWdMSTJjMTBhdHpIY09rcEN1TlZPRHQ1WDVuWnM0RFlaWk1VQnF5bStKWEJCWFBLN2o4c0Z4LzRMRGhPUDdoQURXSkFnZ28ycHpFOHJDL1N0cFN6bVZscE1yeFN3QW9LZUo0VnVXZ2c1NU1DRkNRSUJmZjlic0JRS01OMWFjdUNBaWhnTDZvenExdmlxdUVOWGltMDBibVprRWJBaHdOckZ3cGRLUEEvMW5lR1RXUUtmbVc0d0owaVVFRXJ1WVcrUFk0bEd3S3d2KzBONEFGaUtvTWJHa2ptSlo5UVVybEE0VURPSUFPd2RXZi9MMW1PczJFUWh3UVhqQmtSVzRqZ3JHajFEMXR0UVFvOVFBMWw4bElrT1J1YU5GOXFqZmpLQkFWTHdXcFdaUUFiUWZMMEFBSWM4OUJ5aHNDTkg0YUJxRHhnTkFWRWp3czg5UThGdE5DUW1FNzFwQlh3NlY1WmVDYjA4cUpkVmExcVNtYm5sUVg3WVIwaHFTOWE0eEJmWmxSS2RiU0ZMalhpMGRZK0VTS3lmUzJvNjZEeFhNOFdvOEJVdVVOZVk5S0sxMloyRG1kTjEwVHFzSWFOOUthNHBTakZhbDhSSm5EVTloSXg0a3BvejdEY1RUdmpKYjNORkZ1RFZ0MFNDYmNlTXd4R2w5U3lPa2IwNDd5TS9hOUVPb1NXK0ZhSXJMTXlTenVLa1ZvRms1ckJsSzJWWVUveElQK2tJOEp6elVaYWM3R3VBTWMydU5lVm5VdU9mTnFUL3d5SnJBVnBPN2I4MUZ4WmhLWXo5YTNoVnhJUlhhdUVOc0NDUFhHZStyQnBHTmZ2emthVE00WUtUVnpNWFFoellwNWxPMjdySnpSa3ljVzZvaEpya2VUZEs5SE15U1pLMGRiQW1TK283RFVqOTNUclZkSmNyck5jbHhySnlFaW5PejJQVG90WldnaEFvQVZBNEFCeEdhWmRHRVMxdm9COUo2aWNLV01JNXNTbEUxZk84R1pLTGEvdVVMTmJUQ1I0dGRLWEdtWnBZeTVnQlNpQVFlWXpUelZRMmMxRGpHR0w2U3BKOXRDcVRqbnhGY0J2bDhNd1RFY3hqNVVSTng1MzhyRVJpVE12amhuTHAwMTdVYXM5QUFhSVNxYkwyOGlXNU1Bc05LZ3pXYzJXTkZ6ckpRZEM4RDA3RXZVRkU2VjF1eWl3MHd4UC9ISzMyLzhZZHgvY0ZmK3J2VjdSb1c2dllROG9xdDNUUHh5WDRlVUE2U2VxUnZpQ01NUTBxVE9OV1ppaEZZL3loSTI3amRGbmY5RHhZd2FCT2hzd004Y2lKT3hVR29xMkFIWnhHdUFoR3hrRkhpd0FBK0R4R25PUk05eTNTcWJER0wrVkVQZFhjNVpSRmg4RGNvTHpkNnAzV1htVlA2RENUa0p5VVEvSUFxZVJHaFdvVWJuaEgvNXhVZ1UwQlVoZ0cxd2pIdU1oRUhLeEFTNEhkcVBWUk0vSE1PL0ZLL3FIWlZwVUZ1RDJkQ2ZoYzdnSEdqampIVmNEQTZmeFVWeXpVVjlqR3lTMVVpT2dBMHExVW1YRE51bWhQUCtCZVhFUkdwb2tVd0pGTkgvQ0lDbklBTzJsTTM2RFVDZkJjeFNYR2VpbUhYbFZOYjhIZ1Zyakh5bzFCZjlBQWlYd05TTVFWWlQvVTFWVDFRTWY0QjVYa0RaK0VGdG95QU5URURmK3RCZmN4ekR1UlQwTm8zcndOVDFQa2xNNkl4QThwa1dYY1VaOHVCQnJFWHd1NDFIaFVVQW9nalpjUlJCTFlGVTJFaCtWa3phSE5UYjUwUi8vMFR3Q01sOXpsMk1uRXpURWNRQ3BkeVE2ODFZTmttTk8rR3NHUnhUSnRrMWNnaFpmUVZSejBUbWRZNHYxd1NQczhWY3JRbGlCcFRhR3RUWWxvQjhtWWlLNG9RRWo1Z0NjU0NDalEzK09NVnBGWVlxbWFJY0VrSWZQc1lwNmVHMXB0Qkd3dzBuYnVFMmZkVHR6c1JvWVZSdFRZQjdnRlNlVU16a2pFQVNTSXhBMWNJaUpKWU1laVhrd1lBQ1FKVHIzdUNRbVdZQU5ZNUxSQVkzL2dDSC9JSTJwaUdrRkNXKzVobTdjK0JsTy8vTXMvbEUyOWxHUmhSVUhQVUFqN3RGVllaTWFPTWc1K2VReWUwRTlxcWM2Z21GUVQ2SjZSemgzQnhHQ0NiZERGNmRjM0JjVkh2QUF0R0dJYVVNUWNoSUVjWklEVmZWYS96Q0pUSlZhNkdFYkhEVVhCTEFCMFhFZ0M1SXppcEY2VVRGYWx0VWtub0dLVitrUVpmRWhoaUVXRGtNWGhrZ25PVkJDMXpVak1KS1lQL0JhOWtFUU1sQWZPcUk4UVlJQ0M0Q1p4K1FXZXlJOTBRTlJKaU9BZnlrVEkxRTdiT1FVT1lNQ1paZzI3b0ZkN3BHWXdVTmQ5RkVEdExralBZS0xMb1VEUVBLVy9GUXpVd0dOZVFtS3FqaWE3RFl2QllNazFRSTFrT2NYRytDQUs0QUVQVEJlTXRJbWFQSVBveVk4QWpHVVArQmRXVlVmdFBrQkpQQkJVdjhSWDZIVlpRWmhXY1JKSFN4SFNCdG9mYXBVQUl1alZIRWlQd05tSm1Vd0F5ZW1YV1V3UEhPQ1hmOFFtM1N5blZPQUduSnBJUElWWHhraGtPbEpFYWFwRXhQREVWQVRGWGFCQkRVUVBObmxQbVlTUC9HRFpESG1JaXNtWTJ4Q0puRWlXOEJCZVlkeG9BcTZvRmV4Rmt5RU1pVFluQ25BSTlZNUExMGdCZXVqWWtwMllrazJZRzFDSnpsU1kva3ppcFIzZUNxNklRaXpsVG1SS09FekJUSXdBMjdnQmhLa1B1aFRZRXltUHVZakVBaFdBMEZpU29CU0pJVldwS1d5bEV0aUxnTVFBU1FBblVHcFBrdEdFSklpRUdlZ0JFczJZQzZ3a1Jnb0tsNEtwdURDQmk0WFNxSFVLeXd3QWpMUUJaQ2lCSkdDUUdaR0taYXlaQy9nQmk3WkVnRVFJRGVFZENwNFdpOU1vaGZjb1FBZFVBT0NTbVpwaGtCblVDa0xaS2d2SUFVamdEK0VKa3lUZWoybUZLaEpZQVMwWWdRb3hFQ3VtZ1Zac0thNjRnRkVGVUF3bEtwSW93QVlzRHN5SUFSZndFQmJZQVRGdWdWWXNBVlpzRjJvNFFIY2NYNE1VbzI4K2kyc3htb1l3Q3FUc3FZQ2tRVU50Q01Zd0IyZjRTdkJNcTEvNHlzdDZBR1lxZ0U5Y0FVS2hrRGNXbUNDQkova2lqM2M4V1VrVXEwUmtBSTBjajV6NGdQUVlpVzdPcSs5dWpKZjlqQUlrVktyMFdubDl3K1NLckRYc3pJQ1liRFBFaHVySVJVZzVyQmE5REFHS3hNQkFRQWgrUVFGQndEL0FDd0pBTDRBdkFCVUFFQUkvd0QvL1FzZ0VJREFnd2dUS2x6SXNLSERoeEFqU3B4SXNhSkZpQVFQRWpUNGoyTkhoQjQvQmdBd2NxQkdneGtGamt5SnNPUkFqeWhqbmx4NXNhYk5temdmaGxSWmtXVE1qQ1JuYWp3WWRHZkdveWIvRlJpcVZPRFNwMDRGL0NOd2NHblNwRWh6YXQzS0ZXZFFnalRCWmlXS2RDbllBU3FYUWppdzRjQ0NCd0lYdUMwQW9ZRGRBRXNIc013STFTckxmMUliWmd3Y1FFQmhrMVM3S2w3YzB1RE9sMkFCRk9CWVlHWFFnV2J0TGwwQTRZSG5CVEE4UHdBZFljVS9FaVJLakVDQ1pJUnIxejFHZklqOTRZUHNLU3RRVHlIeEQwV0V0d3NXRUtoYytLOVR3RlpiSmw0dWtFQmd4dEFsK3FTNFZISUFEd1ZHUDBEUmV3RUtHUDlXaVA4bk1RWEhQeDBDci96cjhXK0VhaDA2ZXNDUFBlSVBraWthOExOZ0VVRzA2QU5yMFZVY1pnSGdwVlFBQkNDSTRGUU1KcFpBUWdja0lBQURVaDBRM1lXTVNlYVljUW5oVlFBS1U0eWdRdzBra3ZnQkh6MEVBUVY3UWZ3alE0czl5QWZiaVRYOHc4Yy9OWHpRM2dnaGFxQUJDU3lnWUdGaXpTRW9BQVRPRGZhUGhZRWhnT0dUVUpvRUZrOU80V1hnUUFFTUFNQURHNXltSTRveTVDQ1FGR1hNSUlWQVpiaVFReGxsUUFHRml2OEU4YUtZNjlXNG0wa0hCR0Roa2dJSnNHZVVnQWE2R0YzL1FEQUFCaG9nVWNZWkx4QnhoaEpFT0NycFA3a0lwSVJBUXBqcFFnMHIwRVVBa3FBS0t1cW9GejRRQVFZZGpOREZDMUtjZ1ZBV1dmei9nMGdYSTJDQVVGMFFMRkRBQXFUMjZpdE9obnBtYTVkd25YYWFhUmpZV21pWDBoVlVVRWtsd1NUU2RKWnROQ1ZrbDBIMjY3YUFvdFFTVDQ0NXkxRzRDMVVMa2tzdk9RYUF1dXNxUkZPMkVEM0g3YnczV1Z0VVpEUTlsSkszM2twNUZVSldWZlpSd0U5UlJRQUJCeVJZNE1JTUYvalZoZy9KS3krOXZ6NTg3YjhmWGVYUldXR1pWU0FFQXRWMW5HWVE0RXJYeVNCN2x1dG9FY0NBQWdzd3NDQ2V5OEhWaklMS3VoWWdRR1ZTRWRUelFEMFRhUmlSRkM5V1lFY2JOV2F2U1J0WDZjRS9uc2tzOVFyNzhSY2VDVDVxNEZwOEkvU2dvNDQxZU8yMVFMdHBRRFYvcFhsMndBTzVRckJ3ejFMRi9WUmdPdXU4NEpBTk5xZTNWRVFYLzcxVnZpcGRySlJrVFZsWjJXUjIvY1BaZHR5UjV4cUpQL3p3enc4OVNNNWVqRHE2ZGxDSS8wemhPVzhyM0Z5WFpqc1hRTlZTdysxczJIUFA3ZWxjQWhaUzZQZTJoRGQxK08wZVdsbWd3QVVjZ0lKdU5jZ0F4VDl0dHZsUERqS1VnUkRsQXNWMll4QS9RTjhEaXE2dHdIYWZTL0dONWVvZ3orNDlUbnlscGRRR0cwU0FBNGw4L0xCbXExSjAwZjc3LzBEUnhSbndDK1RDUHhlTWNQTUFBam9IY3UvZkN5Q1VDUFVQQlR4QUF5NlN3aGYrTVloWVpTRVhzU0pDckl6d2p4ZVVZUXIvOEFELy9vZWtZZ253ZzFIcTNnYmdzZ0VGbkU4S0tCUUlFYVF3Z2dqczZsTWJ5RTd2bVBVdkRuMUxKRE9SQ1FoM21DR01nVVJjR1F1WFpmKzBCUzJzd0FzcFJ3RUtVWGo0d1hHNUMya2ZLY3EwckNVVWpxRHJoa3daSXJTT1NDNG1qbW92UWF6WHZkUVZGaWxLcTEvK0VwejQwaktXUHBWbEtEYjBZazBlb3hNcWRzZ25SVVNLVEt5SUZZWkFoU1RoODRzQStzWXdIenJrTUhMOEd4UlZ3a2ZCWk9zbmNGd0lWS2prb1VLWnJudHVRWmpDRHRjd1orRXdqbjhKak1RT01yRkVRdVFuWCtGSlNzQklscW9vcERKNklkQkJSQWFCRFJqcWx2ekRqcUh1WXBLNjRNVkNDZXVkNllZNUhBWU5VMi9KNmVQUnFHUktpVndyWDFiVUlsRXFJOFEwV2hJN2hkcWdYUVpRc3M1MFR5QVI4QTBLY3ZPai9KQm5DbjhZQVE5QVFBTHh1Qk1GM0dtT1hSUjJNU3NORFpFTUltVXpCZVAvcktOSXNTQ1RpZGJSdkpVUnVEd0FCZ3RvbVVJUnVnTHdZQTBIV3h0QjJHclFOWW1LYlRZakVBaDVnRVExNjMwbVFMdnJKR0FPRTdlUm10UTVWSW5kVkJMZ25IMitoQ3hXSk56RHpqVzRaWm5LblZKalFYaGtoclZFeFNkR1FGMlBpTmhUb3gyTjRFZGl5RTFIWC9ZV0FMM3RBQUpZSFhJME1zZ0ZMY2hQZm1LUXZCQWdGU2ZsMDZWMHBPbVV4cFU0Z1lIRkxtdExLRG03Tmh2YklFRUQ2TkhCRCtBakVJcTI1eC9wN0Z6blROTlI4Q1MwWkNLTlNwVlNLcEEvSFlSSUVWb1NWbDFhazc5b0tFdFlNdHdzZDdXQUZVekJOaW42d1p6aXRKN0x0YWhPTytwY1JnL0NBeDVNNFdVUitFZC91UFFBMHlWRmJudHpUb1g2bEJpby96TDJiNFFqaUZtUG81SEVsUStlaWxzQWVXcWtJdUVKcjAweVdBK09lbERVSDZTUER5aXFVeEM4eGdlSzRrWlhDcHJLZ2hMRTNUd2RJSHUzaFU1SVcySVlWUjd1UUdZUlNQbElFRHdvS085TUFwbEJtWlJIUE9SQklibWNYZEYwZ1JvYkRVU0FmOW85TE5BQTg4M3dic3R0dDBNTFNnUW1FQU9xOW54bHlFSDcvdEdGR2JpS1RjcURBcG1JTjd3enNlbStNdUREQlZhZ2dCZ21SazhwVGFhQmQ1amRnTEd0QXhxb2dZYlBNTDkvME5oVk50NEVqZzhDWDRwcVFBRUFuZ3FTVkx6aVJQcWxLZjlJd1Fka2NBWWlDT1FNRkNSQ0xod1ZaU01RNFZKdUtFTUxsU0l5cHhTNHlDdUdnQUlVWUlFZUtKQUlXOWpDUDdaQXdYOWdJZitDWmZDQkI1NFdBRnlGRE14NExsUnJ4ZndQQzJpZ0JPcHhWYVgra1lVdTlLQUQzT1JUTFhORkFBL21PYnkySEdGbm1KVmFpVXB1QmdlQkN3QWovZWhPWnhwcUkvU01hbTBTa3BDME1ZNmVOdkFlWDdwRUovWVRZczlDR3F4VERVS2dUSWRjMWR3SnZIVEl0S3M0ckZwNHBIWEZPaEt1VWlkdGliTEdscXlMeU14bld1eUhqUkgyWXREWVJ5ZTZlb2xEakRXV05MS1NiTFA2WE5TaVl4dWxQUkV3WGp0am5vejFQMk05Slg5R0s5bTNCcmRBRzJsSWNrZmszTXpzQ2F2Rm9pMCtJckZEVU14V2NqeUNGb1dVMUpWcTlEUXJqODFQU0k2eDNiMEdPRlA4ZFJualZNY3lBZE5lZWJPSTVJN251OGo0anNnVzg5ZzBJTGJTWDR6L1pLVzdETUpnWkU0MXNzUXBIRWJnSm13K1B2S0s3UFprMCtqOTcvQWxKSm5KQWVZeHhiSk0zU0w3MS9vNk9NaS8vU3grclpLUk1MV2pFVkgrODVFc3VDOUxBdnJPQW52MGlUZUVkWDBDREo0RkN2V0xYV2JXMWZ4V1NwYkNCalljWUYxWG1ncGJMRlFzenB4c2s0QkR0eXF4SnhXZDZkUGdBTjg0dWMxMVNBNVZoNnlTclRPQXNnTTFrTlZGUzRZQ2NDeUxIakRiV1JKSmhmSjRjandXV1VRZXh1OWd6cnZHR05MdGd4UzhKSnhNVGtvY1B3QXR0ZjcxbXZsSExCbGtVTGFOcGkzYWVVdG5SSzJVWVE2eVoveW1tOWdMa3oxVU03R01nQU4ydEZNZVJTZ1duRUFBZ01DNkFEQUFEUllnbHlkTEhOUk05VEtxY1JRMTdXeG4vMmpHQ2MvUUtlNGZHM0FPY1FnVDl2SStaMENETERMeThVaHRWUzc0YUdkVnluZnJ3alp2Rm1yM29BRlBMRUFDRWRCVEdnQlJJZklhcm1FYnBuVTFKSkFDSzFBYUtGQXo5TFJiN1ZjYzdqY2dnQWRXL2JZUzFjRmdZeVVTazljUmRMRTRuaEVhQW1FYU1DTXpLK0FqclNFaUZWVlJzUkVFRk1WV25wTWZwekUxd0hFQUNkTXdVL0l6QzlGU1VTVVZEeUoyWVdkS0xGRi9lemRUaUJNeTJlRVozVGMxM0tHQ3VURUZMd2hVWVlPRnpFVWZOemdGT1NVYXVjSVpDbU1ZaDFHR2lWRVpDUkovU2xGU2JDaDJEeklocGZSQkk2Y1EzdktCSTJFVmFIRTR1MWNhNEljYVFjSWZMT0FqSklBRTdSRWZTekFpc1NFZjhrRlJ0dkVhUHYvU1VYL1lWTGlDVmNUbkp3cWlPbWc0TkUzUmhpd0ZkbFNSVmMza1R3cFJjTW5FRVdpeGFOdkJnbncxVHVPeEd5S3lIbGZ3VTF3VFYrZWhnRWVGTlFNWU92enhBQ3dnRjZhVE9uaUJWWmk0Y2FwakpNTUhHQ2dGaC8vQUFBamhWWEtFTHNhbmRpUlJHYUVDVElWU015NURBbHZqQitqQkhyWklWL0JCVjBlVk5UcjFENEFJR3NEeEFOOTFGMDloVlhheklNTVhWUUptaEZnVklRTGdqUHRFZUxGV1Z2dUdHWnBoSlhwaEY3blNKYjl6V2EveEhnbWhpRWFWRUlSWVR1MFVIbS9SV3J5RVJHbllKNnB6SlBISEpHRUhWYktEajQvbWJRQWplM2dCU043U1BiM3pGdUlSSWg5UUE1b2xPWEhDSHVzQkkzV3lHdi9nSTZlaEFTRC84QTg4QUU2OEloQzNWd0JkUWsrR0FWWHFWMVVIQVZXZ3VGajJKa2xkVkZQKzFqdWpRUUp0eFFkeUlnUEoxUU15Z0pVQ0VRY3ljQVZpSWlPdmNSQW0waDRZUkRVUmNKYjk0WHNETVNSYmw0azZBMVhXS0k5THVSREZGbEFqc3hkME1VNVNXUnQ3R1R6VEpUdzlJQ2FBR1NORlZWVE5NMUZmSXh1dndRTWtBQU1XNGpOQUl6QVFFQmlwTTVmUzBZU1ZSeUM2OHhTdEozdDJrVkFJNUNMeEF3VnJjbC9ESXljcEloQW9naUlmUUlQQkV6eEFWVDBJMVJ6dmQ1U2JPQlZ4YUptdkpIdmxnaFY5Y1llN1lpb3NJRkhKVXdZcEJGOEo4Vmt1S1JCWjJTTDZwUU1qUUFJb0VFTmhsMTUxWmlBdHBac1RBWFRIc1RPK2xobTFBeGRULzlCZTc2VTg5QVZmOTRNOFFVQW56Zk1tWWdJOUZNVWJYQVlZM2xWVmt3bDYybmtScHRnaFZtSVNhQkdRTnFXTnRpR2FGRFlEUXVBR3hNTW04VU5meDNNOEVVWThMU0lET1RJRkQzQjZjSmtSMlptZkYySWdtOGNYQ2FXTnliTSt4a2xoUWpBbThpTVFYVEFtQi9HZ01wQlJIblF3ZXZLV0dnb29SamNjQkFFeWpmWWJPaVZSYkpLaVVpQS9RdEFGUWZvUG0vQmtRcHFpOVBVQktSQkRhRkZuK3NlRE0wb3FiQ0JrVGxnQUNvQW9WeUFEWFVBRTg1T2lDMEVFTDJCakZVUThQL0FCR3NBbFFLbC9tQmVsdnFJbmxrUVhyYWNBSTFBR1hlQUdUZ1psVG5ZUWVmb1BWK1prYmpBRGZLQUIvQU5Bb0VKa2JEb3FkV0VoZE1Fc1pkUVFLYkppQkZtd0JZZ3daV3JHWm1xbUJHY2dBMGdBQXdxQUs1OXlNb2ZxTjJ4UVMyUG1BNHJ5QlE2MEJVNW1CR3EyWnFwYUJuNmdRVS96YzZINlBiYWlBQWpVQlVVZ0VGTW1FSU5RcVN1a0FiTmFGVjFXcTdPenFBK2dBQjNnSWplUUEwMTJFR24yRC9lamFYWFJKVUNaSzhicU4xd0NOZWhuS3had1BLNkNZMXNnQkh6Z1F2T0pmb3VXcmRvNlF0a3hRdVdUQW5LVkEzSGdySEdTQWhqZ1FjeHlQZXBhTkd6Z3JtbTZyYW1GUVN0cEh1alhXbnZHQm9hNnJ4VGpybkFSQWVXaldqcVZXbW1xc0hMa0dlV2pBRGNSRUFBaCtRUUZCd0QvQUN3VEFMOEFzZ0JUQUVBSS93QUQvQVB3cjZEQmdRY1RLbHpJc0tIRGh4QWpTcHhJc2FMRmdnUVpDc1Q0VHlDQUFCOE5ndXlZa2FUSmlDRUxqZ1Fwc09YRmx6Qmp5dFRZTU9OR2xpby9qdnpJRXlGUGx5Y3pDcjE1c0VERGpSMlR0Z3hnOUo5UnBnMEYwRXc2czZyVml5TVhzaVNJZEd2V2p3VktHbVRqTk1DQUFnSTlNRjNic1FDRUFSQUtQTmhBOThHREJYWWpQTkFib2UrQ0NDZ1dvSWlBZDhFR0FrWUxFS0NxVXFUVXgvK2tOcDU4dFhMTXJBTXhVeTBKQUczS0Fnc2dQSUFRK3NFLzB3ditMVmhCWW9UckpTTjZ1SGF0NDUrT0VTVkdUUG0zZTRvRzN4cFlyTkJyZHdFTXZBUWVGRURMSEtuQ0FKSVhRKys2dUNBQkFRa01McTV1dWZ2QmxBaGI5di9zNlJJcFFiUUMwY0pkSHZmdWl2Y2tTRXlaNHZyRHZ4NzNaK3VQWDVBRUV2bnh4YmNDQ3Y4YzhJOW9CenFWNEhJRlNTWkFBVkl0SnBXQmoxM0huVlFJWUdlZ2R4ek8xRlJaWFJsVXdGa0tzdWNlRHJIVjhFOFFNa0NSUTR0QjVCQkVFQVg5SU5zSUgrQ29YMnozcmRpYkJuY3BwaUIwQkd5RVZwRXFXU2pBZFIwMjJXUjZVQlZrMUhtZERSUVdXZ1g5OVU4Tk1wVGhwUlFHdlNCRkYyQ1NtUkFVWlVpaDVqOHF1SkNEakRxUWdGeUJBUnp3NEQ5TU9xbm5ucFd4b2RnQmkwMjVoQlF2RUxIRlAxc1lRVVF1dVJDaGFDNy9MQnFwRWkvTVVBT1FFQlNZS1orY2R1cGtld1BrTllJYlJQeHpocVQvSUNKRUR4aHNJT1NCRzV6LzlxR250TllxazJsemlmYUFBdjhJWjllQkRFYmtYRUpjaFFmZWN6azVoMU95dGpiYnFVY0xGU3NTc3l6dDVOTktQbjFua0ZCVUVXVmtRUU1naEt5eUNqcHI3a1BrNW5RU1J6MHhGcFM0d3lxRVdGSllCckFVZWt0OXBhNTE4VExVRkZJQ1NBWGhkT2ZxK1JOQjRJVjBNTFRGWWp2a2NoQzd4VjRCQjJ3dzExNHNSQkNjQnF6Rk4wSnIvcmsybjN3RkNVZmNBd2NvVnpFRWh5bkgxSVAyVWpiWnYwVTFpR2ZCTTdYYmJiWWsyUXZYQml5bmJKckZkaDJ3QUY1OWVUeENEYTRoNGRzVUpVeUJZbXNhUkkyREJ2RnBvRUVFR2R1bEs4dHhQZFZSU3dMRVBGM1pBU0JadG9XUjFkbGdoRXZhZkRQT0x5R2NXV1A5QW5WUWxIZXQvOVphYkNQdzBRT0xOTklvUXhBL3lIQ2ZEam9nVVFJU1Y1ZmdNWDA1TG4zamJQUzl0NENFVEVJWVdYVnBRMmVuM0hQVDNXbTk1WXBZNGtMaFBzQmFiRElvL2c4VXM4OU9PeFN4LzFERGJTTWdNVUpDUC95QWVBLzJnWEFhcjA0aHFaMUJrcG51L0VWc2hQUWhjMjY1dnJUaVhSUjZ4dmJjbjdISjlnV3RXWVlMTW93QXBBSWtWZ2NCQVpzKzd6NmZBd3lnUUFjanlQRENGNE1nbXNXaC8yQmhrQXhpR0lBSDRoY1hnNWptZlFoMGtsSEF0Z0VNN0lVRVhBcUNDOXpnQWlSMElGWnVjWlZwQ3JpdG8zVFFJOHZhbTdnU1NNTEtRRXNoMGtLaGVFSklrUk55WkZ2OUtpSGRZZ2d2OElUb1lIYzcxazhTZ2htdmhDUm1IY3lXM2Yvc0prTU9pWVdITUdRTVVaSkNSTTZnOElWRVJGZENCbkNUOHZpckxVWDBqclNxbFJLY1dLdUQ1RW1KR0VjNGxSS2x5MTcyUXBzTGJUaXROajZuYkczTDRrU3FxTEFYYWlVb0xrbGhRdEFEZ0FNQVVTUm9nUURNbWpNMkVDYUdLUkZ6MWZyaUVyYkVWSWRpWlhOUVpONFd5YlkxVDQ1ekZHTy9PcU5IcWxDUmlqL2NsSkFRMHg2N21QSUJLRmdCQzFnUW5CVm9EVURDVVNVS1dJQ0N1OXlGQUFSd1ZRQWdzQlkwb3ZHU2NUUWJuZ2lHU1ljY0VTZFZ5Z3JOemhNWG9BRU5OSE1wekN4SlVBSWMrRzVIcmtHUk5lV3ptOTlnYlpYRndVdktRck9CbFVIc2ovRWlaa2VLZExhTlZJYzdXZHlJenBBU3JuK0V5eXhTb2xoeFRwUC9tbjlZckRBTElFSGxrSUNFeS8zdUh5alNqVzVJOE1wWENtY3doYmtMYVNJR0ZUaU9MU2wzd21oQzRtYWRoQmlvT3NCMFg3dFNpTVB4TE9jc0l4b1JJOTNDUUZ2TzhoOVpNNTlDWGZPUDJWeE5hMXJqR21BaXNJSi85QlJYeWdrWUVIMEpuV0hHTVpKMWlvN05CR0FuQ3VGSkFCbENRQkVieHJQTUxDVW5ZZW1aV1pqU21YREpCVEN1bEk4T1BsQUR3UTJ1SUNyS3owRndRSUovWUExcnZ3T0JYSGt3QlJKa3JDOGQySXZGUmhtd3AxSm9NVTd0S1BNU3NLUU1GZk1sOXRyaDJBSXBNWXRGSUdTeklXc05adlNQdytXZ0lFSG9BWDZ1OEEvZmJla2ZIeUJyanU1VDFoNHdqV25tWTRHVTVxVzI2eENTcVJIYTZHRmpRa1Y3LzJFSmkxaU1ra2Zra2hmNnhHWkdaZmhIR1hDSDJjdjJ3RWE5WTZqVVlvT2Z5dWxvQ2lsWXdLdGVOY2tpU1VnZ2VacXRDWGNtSWtTV2hUa0VnWXRxL3NFMStjU3VTMUs0blhCYnhGN2FzWmR3NTYyc0RDNVFndzlNSVFKMFFRdGtCTm1nRFduWFdXU3hFbGMrYVU5L0tzQzNueTJERzdiWGhUT1l5a3hxZ3NJWkpEeW04RlZXTmlSUXpnS2xzajVjcnUrL01neVdRQVNRcVFLZ1lBbzFJRldraU1EaVNCVUVVa1E0Z3hJTUlnVVh1S0FHOTNYS0l0bkhQaEFmbGcxa1VjOEFBQ0MvSEdUUHhVVFlIeUllaFNnak5Lb0xidldBQndBQWdRT3N0SDArenZKYlBJQ0JDT2lnREY5QTFCWnlzWVV0Wk9FZlo0YXlQY1hTbEZsbCtmKy96MXpwL0g2Z0ppa0l3Y0ZFS0lNT1RNTmpzTW5sellBV3IxeGFoUUdEc0lBL0pORExQenp3ekZqOUk4Q0FqdlJCQ3EyQUJ4UmFKalE4b3FRM2pVUk5oOGVZeVB6S1ZqZ3RRMC9MRE5Sa1ZKaDVkZ0tTaGgyTDFKN0t0REcxd3BWYTk2eFlXN1IxcU4wRjY2dTRVRnZEcWlOR1dPZ1F6ZHh0Mkp3SmtiRjdEUk5UODFvc091dGlza3BDUTVHSUpaMGVaTFpGWkgzcm0zUlJzVjF4ZFhtNFplcFpwZXVPNWFxMnBILzl3YjNwNU5YcjRpN0NRUGd1VTMvTG50N3FsdDZxRFJsdDg3cU4zbDYxVXJSMWJIVkY4ZFJzOGFvVlZhSzNoNFFVaVpPTStNT3orT29RZ25DSFJORzBEc240TGFoQTVVTytqRXh6ekFORnlqVDhpby8vS2VyRVMxZ3RpTSs3WjA5ME43RzR1eEVCQkJrcXZPeUlIOUVESWZSdzVJUTBRMUppaHA0NkVRbjFPaXJ2aUdUVVRVS2J3TnVPbUhGaWxKQ0ZKYmZzc2kxck9VQWdiVnVXQkJWRUFRVndsUWJ4VXB6Um9FeGl5M21uUWl3NmNLQ3dYWTQrSExVS0Y4YkVyb05RSUx5TVN6MjNucDdsRU8yVWUwRmxYL29DSCtIUWNrQ0VLY3p5bm5KYkt5NVJLcUdENDlzVHVMQXh5alB1U2FHaWxNQzFsc1E0QmFVVVU4ejZ5cm1Yd2ZOMGxZZkdhV3Zva3pVQnBhQ1d0cFF1anlWbTI1QXpiOFJIcmFTRS9rdnRKNHF0TXpjWlVZa2tGamF0VjNrRFpCK01YUUZVMS9uZ1FHclE3MTFkZjJQWEZkaWxsb1hKWUNOOS9rZGtOVWhzU25mei84cmZwKzRCTzJjNVRGR2tCdm1KSzY2aGdLSFlwSTM4RCtyTittY01CbjA3cFZ3UUF6R1luVHBKVmlRZEVtY3oyVlZFT0VGZzk4Und6VEV4NWZSUGZhTWFwblJvVTNBYnQxRlF0UEVQSlZCVEl2TXhPTVV4cXpSTFpUY2FZY05MK3ZWLzNaYzIzTFVrRlFKYkFRTlA3N05GUVlRMzA0SjJLR05LQlNFYWNyRUF3aUVmSXdBYnNDRWJidlVmTlRVZnU2RmNiMlZYcVhReUkwaFJlOE4yUllXQ0EyZEpvNk9DdS9jNVQ0VkE0WFpDK3lZaWJxRUFMRE1YaktZY28xRXh0b1JLYlVVZk4yVStUcU1iM1lRRXIxUUNHcEFDdzlFWGhuY3lHc1lnU05WT0tyRjBkMkpSdTJjZy9oVVpEQkFaR1RKK3ByTnNrekZVSCtGVlovRVdqdjhvTVY1ek5LNzBWaHJ3T3dkbGlYNHdHd3lWTmFxMWd5U2dTaEZnRUhIeElIZXlIVlNCTmtVU1NZL2hSMVo0SVFjUVZYRERjcnkyaFJBWE16OXhKU29SS2dUaWlUaXlKYkx4aTVxbEgxTERWZzNWZlBFeEJTaVFBUTVnZmFjMEFIUnhGaTd4R0gwVk41TGhYMGlCQUJjQ2R6LzBmMXFCVDBPbUh0OUZHbmJSTWZSUkF6WFFBekp3WEpyVkk2YjFXYk5CaVJyZ1ZnSVZXcUdsVU4rRWhJZlJYOU5JSjh2VElBSnhBQWtBS0lZbFZmNEdjeVBSRk91amRhN1RHa2lnQXoyZ0ErWm9qc056SHptUU9BVnhCVmZRT3hwQVVFZ0FXcUcxSmZVVk9MKzROTHJCQXlzUU5sV1lKOXpuVndVUmlBVlpTQ1p4VzEzbkZIVHhXQVB5T2gvL0lEanR4VjRHb1ZscEJaS0FBNUZvRlFRZlFKUkRHSS9La1JxWEJIbCtWQjB1K1pMUEVTSWZNbStjMUhjRTREZXRvUU9aWlZsZFVsbEJnRHMwOGdNYStESHY2QnBFZVNQMlJRSUdzRGtTWWhRcTZCU1BrU25TUVFCUENaVlpZVVhqQVM3bE1pSVBCRHRvSWx4Z0lpTTVVQVlzWWlPb3RaSDE4UStHYVZvaFdWZXAwV1lXMGhRd1EySTJCNVVPSVpOTlVTVlZRa1ZYVXBYT3VBS1VvMW1ISTF4L0dWeGdtVm1hbFpxeFUxbUpjMTQvY0FFZllKSnpBWmR1STBpUkJDR1FacGtWTVNVWWdTVUlNeVZtRVhZOHBRTXdraWJCSlQ2bWlUdGdHVHRlZ2p0ZUlsOHlVRjhzOEpnUUlpRk5wWnRXRVJaRFJCSXlhUmV0OFFOdk1wai8vMEFvcGdJbXN3TW02VVU3QmFGbUJlRUN3YVVET0lBQytmaFVnbVJsZEltZDNZRWVtdWN1aUxRQkJGSUdNOUFGYnRBRlVMWmdaSEtnRGJhZTV2a202WmhvR3JaNUJnRW8rT2trTFFFeGpDR2N2MU1HMmhOanBuSVFEbVlRWndBbTVOTUQ5eVVYUmhONkJlS0NFNm9uZjJJZEYxTlpMSFlvaXZJUGplSmlOZnFocHVJR1c4SUNkeUVsV3FkMUswb3JiUEJ4UkRZQUdCQWJaVUFFWDNBb1cxQXEvMkFFaU9Jb1RWWXFYU0FEZjRBQkVNQkJQQmFrNTJJZ21SSXVreVVEcE9La2cxQm1Vb3BtcGlJRFBtQlBIcUFTbTRKbFhHb3VjckVCQ2hBQlNDQURaNUFGVWtxbS9QTVBZb0FCQk1GSWNmbzhjaUVYQ29BQkxJQUVTVm9Fa1hZQ0tXV21LRExBQWxmbUZvTnFPb2tSSzZuUlpTTlFCaC82b2FWU0E4b2hKYUZhcWFhelVxUFJRQkZRUDdZakJXZndBajJnQVpWV3FBd2tYYVI2TGhEZ2hSWVRLdjZFQVIzd04xd3lBaEdBQVdBWEZ4NVFBTGhhcTNTVFFVNWhhUnNRaXUvUk5ROVFUNjZDckNYa1FBMVVFQWRVRVFFQkFDSDVCQVVIQVA4QUxCTUF2d0N5QUZNQVFBai9BQUg4Qy9Edm44Q0NDQk1xWE1pd29jT0hFQ05LbkVpeG9zV0xBeGNTZEJqZ0lFUUFIVFdDOURpU0lFaURKa05pWE1teXBjdVBCVTB5OUlqeUlFMkVHek1xRkJneUowcURRSEVpQkZDZ0lVbWdQWC9xTEVyZ1g5R1hVS05LRmRteDZzMmZKVThPMUZxQUpFRUlCQWNVRVB0Z3c0TUZEeDVFVUJ1QkJRc05ibGV3UU1GaVJVRzFhUjhjMEF0aFFRRUNFUDRXQ0JCQVFBRUJDaEVqemtpdzhVREZCQVg0bkVyWm90YUVZUXNPY0ZydzZUOEltcDBXZ1BEZzM0TVZHa2hvbUZLQ3hCUWNHdjVwS0tGaGhBWU5TRmlUb0syaExZdTJFVkRrZlZDQStPakRnUU1jSUR5UUFNR21oeFU2ZDZnWVlmV0NBZ2dzcnN4OVo4YURWYmZLLzlSbzBMTm4wZ3Zha2lBeG92MklHdjk2OVBqM29lQ0grUjlVcDBBUlBNSUtFdlNOOElHQTdvMkF3d2NmZ0RBRkNIU3NVTnBqT2hXR25YV1kvWE1BUWhkMnA2RlVBUXkyVlVLZUJaWFFCdjlOOGQ0L1Fmd2pRNG9yQnBIRGZQTzFod1J0T0NBeGdnNGYxQUFmSHozVTBKNXNhL25WMUQrU0xiWllaQUljWUZoMjJmMHo1SVpRVnNaR1FSNE41bUdIV0hKV0hBa2ZCQ0ZER1dWMDBZVVVYZndqeFJsaVNtRW1GR1dvK0E4VS83UlpVQmt6dURDRERETG9NRUlFR3hTMUhBSE9JUWJCazFFV2F1aExCQlNnNkQ4RGREQ0NEUDk4Z1lnUmt4THhqNlgvYlBHUEVRVnh5bW1jZTJJd0dnRVhBa2Jvb2FpbUt0VUJCU3hnMmdvZnlQOEFSUmViYkhKcExtY0U0UU1HR3dSRzNJTUVQS2pxc01SaXRNRS94NlpWRUFZTGphYkFST0NKT0pST1NuM28wRW5ZcWxUc3RvZnlST1ZISFdXRlZFbENHVFZlVEFJZHhWbEdYWFdXa0UwaWVzdnR2TmNPTmRLNzRZbW5GVTFhNVFSdnVncDVXR0dFUWdGQWxGaG1wUVhEV1dtaGhWWUJyQzZxVUU2U0RlUVl2Y1JxcSszRUlCSzFycnZKcHBVQ2FxcE5vWnB0cXNVMnhUOVR4S2FCWEhXUklKZGNLQ3ljRmdRYlJOeVRjMWhHSnVHRVJGTDRNNUVkVWhzMHhoaGw1Wk5IT1RsbUpVRUZlREJXWUlxT2hyTnBhckd3M3NxMXVYemJiU213a01MSSsvM0RuM0FMSEZ1YzJoOVh2V2lJalRVVkFNOFZieVRBZG84cDZlVGVlQ1AvWFpGajV6WlUxR1lCYkdZbHpndjh0b0tKL3l6eGp4L3d5VmVEZlBHOStJT1BJL3p6WTNzNDZCWmI1Z091ckpwci96Z0F3d0lRM0UyMGtuWWJ5ZENRaUdYb2Q2RWRGV1ZsUkVRVmpleHBPTlNRdzV0enFoaEVHUzRHOFlQeFAvU1EvQStReWpDZjg1ZkRWeEFNZlJha0hYYUZmVFg3OWl4MUtQRlRBeFQrd0dwZnp2QUNFWmorODBKQ1oxeTZmaGN2a1BtUEN6NXFRRnpPRUVNOEtHamM5NjloWUp0QlZnUnE0SVlrSUNJTGs5cUNwUVlSaFVGZ2lnVWUyRXhnK05jcS8xbndmKzRxemRVaU1BTDV5RUFLa1BySHM5eDF0UTFNS1NiazRjaE5OSGJCRms1RlhsY1JpYjQyOXBDVUFJVW1HN0hLWkZ3NHUyakZVRno0cWdtNi96NlVyMjhOeFY5Tmk2RlFkc2pERGUyUWlmZUtsMEd1VXNScDJaQmMwNUtXVTBiU2xhVk5TMTA1bEZmZm12aVNrWmh4WTB3c21FcldtTVViSXNRekFKdUpHOU9WRTl2WjBXMmNRVXlJaEZJeG81R3hYa0lVVDcwdWd4bCtCVVYzVXhMSWxUejBOczZVWlRoNVdkZ0svQ09jdFpSbEFkQ0pDZUNJZEJpZlpJODVqMG5qSDJ1aVF6cUNKNGFGQzRuSGJPY1VMQ21LYW5scHl3cGdJSmZWVE1GRXQ3eGxhdjVobDkvNE1pOW8yY3RmQm5XOUkyV2tPb2pKWVV5dVV5UjNOV21VUi9SanZ3Sm91NktCNWlrRlNCaGRYRk1nRTVYQVFFZ295R3JHT2JyMTlIS1NLMEJMdzE2WnU4SE1EVXVTR2RyUm5pSTN1U1VUTWZaTXpDanBxUDhUbXV6eEtWQTdEbWo2ZEN6VFlDMW10OUZjUVhLVG10dTRCVGdSaUNnTHptTEp0RkdOYWhacnpPM1dkVStCRFNsN1JBUGFNcTkzS2hjR0RpY25BZHhneElLdW9raXRPQVhBd0FOUThCOWJsb0J4bVdNWkRuYXpIaExzSndYQlFjcy9YRlc2RmRBRk9EV0x3QUpPdDRDSFpiU2pDVW5tMFVhNkdMMzlVU2J5RW1SRG1ETVkvbjNHYW1sWmo0QnFrS1BKeVNkek9sTG9qMlpEQWh3SVNIUHQwY0UvYXFBREhaRlZRUG1aZ2x4S0U1MjdOWWFaVTkwaDdLQUpGWm1ZSnpBR1RVRnRDaks1RVFRQlJtODZubnptRXg4a0lPRnJEVFZSNWdnMG9QcU1RSzhUYlVxaXN2T3pld1l0T2txeTZ0NEl1NUtpSGNSd1VCdElVYkMwbVFIL2JHQUIveEZRRC9qZ3BUZVZBUW90ZXV4ajQ5UEJIdlhnUHZCeFhscnI4NEYwYmlCUnl4a2paSzYzSE5teE5pcUdhd2hzY1hMTnU2eWd1Q2txZ3hUVVpDYUVsQ0VINTgxQjhWYjBPeG44TGlGOHVNQS9BRVFjUUJFSk5FdGF6blhuVllBcGRmVXJpakxMNk9yekQ3Zit3M3d2T0YrWnh0c21NRWxCQ0dNNnd3em01QUtFcE1DaTYxS09oVWkxWHg3ZVRsRXI0TUVGeXVBR0luaXFJTGt3c2FYUWQ2bUNyRThJVWlpRERPeFhFRlpadDhPajNDT2pHS1dCSG56d0JWa29DQkd5b0tsUGJZRlRidmlIR0o0bFFjRDhCY2RRL294VE5yQ0JBVVRnZzJkQ1h5NHkxZUkyWVFBREFTd0lhRGdjNVE3dmhRQ3VTbHNFTkZBRFdVRUIvd3J0TzhNUFdLQUFuT0hzS2RVck00NnB6Q3VaM2lVQ0xBTVFRaERiSzFicStkQUdmUUFHUnRnU0g1S0hhVXBFTkd0aGlEdVphQXlWaEpUMDlwNzRrTXZ3Sk5NN1lTTUtqeGhwVFVQSjBSeUQ5SGNzblMyc3BKQksybXExcWJ0RDZaY1VjVEpadGRZTVFlMmRVcythSTY5T2RXTStmY1dOb1ZLYS90S2lISlhvNjFtanVwQ2tORmhQbEhZVUtJNzYyamdjcEJHSElyQmZ2NnVmTUxtaERoY0Nyd3FCMnRvWk5tSzdESm5GU1AvVjFLS1VvaHUvM2NZaFJuUFk5SDZqU1dZYnh4OHFlMkE2WmtqRnhuaFZab2NMSmsrTW95aVZxUm1ySEpJNUprbFgxUTZ3bDcwRWM0S0pXcFIwUThreGFKb3gzeUR2T0ttaDNTekNmRG9tNi8vdWRrQWhNQURTa09Zc05WdHF6RkdIU1NjSjdJbUVpU2RqcEVwd01wWnlxOUdNZGtpb21lSGNTWnZmdDNPNXEySUpITGEwNWFocFVWczJxVGFhblFQMGFGS2RLa09pczg5U1ZoR2xQMGU1N3NKM1E3QndCajJ4ckl0YlV1T2EyNkNtTHJFQkppUkpNeXBGS1dhMjE2YVFRd0lWSFhrU2RqeGVyMUpub0xZUmdmQ3ZWeHVRNkhwdVk3TGJ0S2RsNDV3Q0MvNmh0YmpNaFFYcFdhZGZxdFl6a1BxUjRmQ2N6blI2M3NSOU9TU0FJQ0c4Mk1XY3piUDhwNjJjczQyQkRNVDRoRFlVc3pTYnkya2VrSEczTVpJd1BGdm11a0lFR1p4c1oyNzc5VGUrMjlXMG92QXZMVFRWckh0d2s1dkxUcUg2bmt1WllpZjVHeGhFd0diWmZCci94QnBEbUUvdUVHOUZ5cDdjanZZazJKWFVnZzUzRjBMQ045dU5NbXFDYWNQdFEwa2dOcExkZExPNFFRS1hCVFlQOVVzTTR6QjM1bnVBNHh6WTlFWU5zUmdOcUIxTm9TUVNpQjN2NXpkZWhDNG45Vm9FSVRWaWdWaTJJelZtb1g4a1l4dlZwMlF2MHh1KzlIUW9jRGFuY3hiSFVYVWhZanNNaUJONEYxaE5rbHBOSW9GSkVsVmFaMEgzZ20vdGRrTmpVWVJGK0ZXalVXV3RKeHNwVXhDc1lTS0xGeHZyOFE4and4OUxsekFMMElJRllSYUFZU0VRNHhjSEFDZ2RVbEtGNFNkTzBvTTZPQ1FYa2dBRndRQUZkeTdxNG1vcHRTNWlnVEJxOFhwd1JXQUtBWVhyRVRaSHBWUW93RXUzMUZPRWFFNHJNRXVieHhuSWwwek9VU283Lzhna3NqTWtDWENCM0FNd1FpaEZjYlJ0alBJMGQ1R0ZpOU1lUHNJakJLSW54MFZXMG5NYi9QZDZ1alVnUGZBZVkrVWpDY0lESUpCT3l4RVp6ZkZPRjVKYUZvSVFUZEZIVTBXSi9aTnNRUUV3TWRRVmpJUnlyM0pMNzRFamxJVTVQVklRUDFBUXJhZ25DQkZYc1pkVHZaTTVJR0JPRG1NY1RUSm16N0dER0NKUzdNZUczaVovVDBOLys1T0ZMSU1RbEJNZnU0VWl4NU1EUHhDTk5uS1BYa015bmZNQks4TTRVNEFnZW9VV3ZaZ1FTcEk2RkFnaDFqV0JwSGRvdHVNeDZzWXVDUEVnS01BZXhiVWlLQUpjd0RWY1BhQW5Bd2dYVGRnZUE4SUhjaVVqYnZFQXhIUTlmSU1jc1NOLzUrZ1F4amg4a3hGbVRyRVpyc2NlT1pJaWNmL3dKckxpSXZEWVdEK0NBM09GSDBId0FUeWlVTGZrSURWSEpMMTRHTTR4Z1hNakFJT0NUd3M1YS9aM2RmL1VHUzhIQTVNWEczSENKbXlpSWhqcFBNcHpPY2JWQThhREo5RElXSzhSaU05MWJmcEZaZ0hYa3VSaGxWemxTb1VqRkszeUFBQ0NKNUNTQTNEaVc4RFZKam1BSnltU0luQXltRzd5RDhtVFZpQVFHbnVqSEpLaEhZV1JPbko1RVlvRU9HQlJUZUwzRHhFd0JUeUNYakZHSnVSVkVPTVZKd2pCay8vUVhqSW1BenN3VjVwREFzcHlpMGtDbVNoWm1iWjJUUUdRbVFGMUdteUdKKzBWUWttR0psMEFZNmFKWHI4elh2SlRKMUx3SWlPUUFzWXhnZGJqSkdGb20vK2ptVGF4R1FxZ0FJRG1BbVdRWVArQUp1QTVuRjMvMEQ3ZitROUM0QVpDWUNZdUFFTE5pU3hmWlNISVI1MkdZbWlxWnhxeDRnWnVjRDR0WmlsS29CQmcwSjhGMFQ1bFFEOGZRR2VEd251REVwZnlXU2hWeHhrZDhBSGRpUWdLdEFWYmtFQW90aW4va0dJcnBqNHlNQUtLWmp1QllXTUxTaXpIa1JBS3dKWGkxVDVFMEo5R1FBUUtsS0ZDUnBwQkFFRUJORUVIQUFFbk5LTDg5UURheVFKVE1COUY4QVdkVWhCYlFHUkVsaEFlQUNLZGNXTTZPaThKOHdDWm81OWE5ZzlIR21TNkVrSDNweVZNMnFUYkVpeWprUllZb0FIdWxXVXdTZ1M1Z2dRUllGc2dZcElGeGFYY29oZUlOMlVQd0FMS0kxN2o2YUtwU1dmSUFoaUlGeGhFNWFiejhpdDJKbUEza2p4eElGNHVzQ2Q5MnFlQUw0bzBHOEFzZzJvYUViVVFIZkFzQlJWVHhaR2pqUnFvb0JGMXU0TVEvakY1Q1NFc20rby96REpDaXRhbUZoRVFBQ0g1QkFVSEFQOEFMQWtBdmdDOEFGUUFRQWovQVAvOUF5Q3dvTUdEQ0JNcVhNaXdvY09IRUNOS25FZ3hJc0dDQkFNSTFJaFJZY2FCQVFCb0ZBbnlYMGlCSWdFUUZNbXhKY21OTHl2S25FbXo1c3lXTUUxdTNIa3haQUNmTGptbTFNZ1JZOUdpSFZNV0VGaWc1VktFR3BjV0lOaVU0QUFJQXdwQTBGcWdxOWFCQmdNSStEZDJyTTJ6YU5OQ05jbFNaOEtZQWdkWVJia3pnTlFDYk5oczJQQmd3WU1IS0NKRVlERjRoZURERWY0OVNLd1k4TisvQ3lCc0pmQ3Zhd0FDUDRtYS9FbTJvQUN4blVFbk5LdTJ0R21ER1ZPQ1ZaMnhxZDEvSHJoQzRMc0J3d2JGS0ZhUTBFQmlTb2twR29DVCtNZWlPT0VJaXg5MCtMdjNBZGNDQkRaSTFjd1pLZEtEcndWU3ZpeFdOTm51SnMySy82Vjh1anpONnp5TnFxNDg0QUZmd0N0MFQ4RXhvcjdBRVFML0NCdytZcjVBRmltd2dBSUtMT2oyRHdramdEQUNmUVd0OEkrRC84Q3dBQXdGaWRYVVo1UUpvQ0ZaQlFod3dHVmprVWRXaGdlTWFONkpKL3JrRmxQL1FDQ1FBZ0toOEk4Ry8rZ3dBaDlCOUNCUUhQOEU4WU9PTmZ3emdnNENJZkhQRkVpTVlPUjlmM3d3eFpNcnNQQ1hWOThKTkpaWUVKQTJWb21kSFVBYWltQ0dXZG1ZTE43MVduc1ByREJGRFIvMEVHUU9RZnhUaHB4MHppbG5HVkJBSVFNVVFlUWdadzV6bHBHREMvL0lJRkNRR2tSd0d3RUVlRGlpb3lLS0tlbWthVFUxd0Q4RFlEQ0NERks4UU1RTC8yU1J4UlpGR0xURlAwWUlSSVFTUk5DSjNGWVFIUDhnR2FXMDFucWlYaEJRdGdFRUNneVFRcEJFbk5FcUVhZEtFUVFHWGYxemdITUxGSERBVTdaR0srMU1zLzJqd0ZZdE5oWkJsQ2gwWUMybUdEeUUwMEVYN2FUVFN6R05wTzVIYklHbDNyVHdTam9TYW5TUld5OUNLOUYxMFVzbjlWVGhkZGNOeFZDNVJPVWJscnZ4SnV6UVNVZWx1eFpkSnlGY3JyN29HVFNkVjdKSnA3RnpqejBHd1FPS1pTc3JkSlUxQlFGNDJKbTcwNWNLVTZvaXZxajFDNUsvSzNIbFZ3UURDaGpsQ3J3RmQ2QnZBZ0UzUllGRUl3ZkRZN3RLeDlWUEhicFdYVm1nYlZpV1F0MngvQTltVjdkTUswZFNWVVlTU1F6TE5VQUFXVFVHTWdzRjdlYWdCandYaDF4aXlIVWNnVjhML0NNakNuMnRBSmlBa1BYL0hka0d6eTRWdFpXZ2lmVlpaMHNKa0dYVHlqYXU5V2tBczFXeFhRQXNOZlpXa0JuMFFYMGo1UGpCUHpvV1pLT05TV3FBd3hSSFRyR2dCdmdKS2VRSE9QQzJ3dEV0RXZEaFR4OWVxYmlIbjVYSXUwRWJPczdsNDdYdUcxVm5kVlgyMmxJZlI5RGJDRzdHQ1FXZWNUTDBBK2o0OWFDamp6OEt0UG5uU3J2VmFKWlpCay84K1RTeGtXeFRkLzNEVndRajFDQkRHVzU0MnNVWi8rQ3YveG1nQ2xIUUdWMzRSd0FOUW9JSWRDMVhYbm9XK2hZWUpqYVFLVGJTaVlBR1pOQ0VUaEdCQ0VZWTFqKzJNQ29pR0lzRkhyZ1dWNjRHTFFhYWtGSUxxSnUxSktpakhoaktVQjFRd0s2ODRod1hkYVFqNDdxWHZZb0NseFA2c0RUenVpRzcvOVJWa25PaEoySW84WWxLSXNiRGRmM3dpUlZTMlEzZnNoQ0dUV3c5S21FSjJBUW11U0pPTVNHYWdTS1lydWdXblBBclBUODVJM1lFOWhHRHVlUmVCR01Sekx3SVJqblNhMkppVE11K3d0SkRvRVJ1SlRuRVNVaW1naW5yMk9zcGxTdFp5UUNRbFl6Tlppdk4yZ3Ewb0RVMXMxZ3lqQlhMSTBNQ0NSTWxhc1o0cTBHaXZzYVVTSVMwandCYThjdGo2Q2EzeFlSTUlDRHJpeXdmOEt3U05TMlRoT3NNMUtLb1NZbFVwNGQ0bkZrbzQxZ3lTQzVtQWJraFVHNUl3QUlTN0laR3c2RlJjRFJRbk1EQUlBSzBjeGJHTU9PMDZwaWtVYm9NcDBNc2FhVkk5Zkl0UWxIWHBSaEpNWXRCWUFIditZdGdDTU96dGMySUJFaVlqM0NNTS8rWTVIVE1QYzdSQ2lydFFwVE1GRlNLSm1tSzhzaEVIa3RtcUVNQ0VOeDJzSGJPS2ZKUVlJUWNaSGJHUnNpckZFQ2UyRXhNUFluRHpDZ1Y1eCtEZVJ0QW1WTUFqWGtGbGFZc21WZnMwaFR5V0VnN0ZZTGE0VDV6cFlLVWFIZ1YzYVJSNmpLVW9tcWtQUmo0UzN5YU9jMGpGVVFEVUlWcUNuUXoxUlRrYkFXNWtROEplSEE2RXBnVWIzMTdRSzZ3Rlo2QzJGUWpaZmxRb3o2azF2RnNhVXRCZmRpS0FpYk1NUVhBUmU5TWsyNVk5NDgyYlE1NitBRnNEVnA0SUlHa3dHNW9RNURxYXVTNkVXd09CS2lMangzdHN0TU5CZUJEWStLcGxhNzJWbVdaTTY0eUdTUll1dkxUdnFEQUFRZFNrcEFHRzdvYTVFaDdQMUt0UUdnRXRCSC85T1owbjV0UmNXQ1ExUVVjQUthYXZXeFAwUnE4cVhtcE01OEZiV2paZHhEMkhhVXlFQ0FRZ2diN0F5ajhZRTh5aUZOMmUvQ0Q3b1hPRC9qWm5QZjQwSU1QQk9sQldDMklzd3lYd0p1U1JRRGd0QklEbEd1YXFSeFBKNEp6cm1XdzhvQm1EcWtIZklBQ29LWlhCaWtJcEF2WTFSTkNlcEFER2ZoSlVJV1NnYUZzVzdlV0VxQjh2ZnVNRFlGS1gwbzVNS0V5MDByZWRJT2crUEZCZm5UcXdndk80QWIvU1FFS0w4NkJGS1JRNEM0SXdYOHorSWNVWEdBb0pCU1FoSUhEMmxoSzJPRUZhbVlwR3hoQUJLYmd3am05d0EzNUF4V3JMcGhCVmYxalZmKzRzVUF1VUlNVTdPVlpzVHFaRFl1Y3h3UEtSU0FZS0xFTHl2Q0NGOXdQLzFTcDJnSUdONWlxTHBUQkR3OUFGcXd1ZkdFeUY5bEZUeUhCQitabllGUVo0VlFidkxJTXhDQVFzcExRejBVdVFMTWVRQUN4dWs4RFJQcEhucTZNUHgrNEoxbks0aGlSSVYzUjJYaGdWOWRLR2dhY3Q5b2FhTUJiTUlMUnBXNURhbElqeTMyS1FSYU1ib0pRaEpXeDFzQU9ZcjJHNks1Z2xzU29kUVgyQ2NtWVExOTd4SW1kWEUreTAyVnNaY3VyMTlWMjl0YzhPVE5Qc2liWjZhR2l0WUhvNnoyYWtZaEczRGJCSnNaRUx2NzZYU216MTdobHdteHpvYnZadkp3cnVxeFlJVFZDaGQxMVRCbDE1azAxYkMra0ovNE9ZOHpxeFVNK2RuU1FWbUhZVXpRek5rVk9ITDhySWpnWm5WMXNQcjRzaXQ0K2RnN1pYYm1JU3pzaDl2OHRZYittY2hjcVZRaGF1S3kxc1J1V3hxQVV0WWhWa1ZqRWJvNGFJbk5idlNHNVZDTzFzcXNhUG1mTUhWSUlPZjFzeGs0Q1JZdWlUR0pDalFkSWcySGtLZXUwMkgyWklrbFlZWTQ1ZnhtcnMzSUZjaEEzSk9hZy9Uak43VVVTUWw1UlptTXJlYjlIYlJKWXRUU2UvNnpOUC9zaWtMcnhmVXpRRWR6WlBUTndwZ3NNaWZseXV6RDMyTVpvSzY4cEpXS0RpOElxb0d2K2hYWVlDRmVFQ2hKTHZkVnRBL0RVcGs2eWM3RG51a1d6aExNYW1TUEg3MjRuc3VSa3UrdlY4dklYdk0ydE9GR2laa2xQaWphRG9PQm9ZQzJaZEFqYVRZUCtxNUpWZXdpR1ZDOUdGWEg3NHdXSk95SHRXM0htdGFqMjE4VHF0alNBQXJiMWpEZXpkU2IvalFvVVVsVmlqS2JFWjVwQmY0SjhudUx5UXBpcDVHYlBlVVJnS3RIWFpXUGVPOThYR01ONEZmdytCbjY3TVJ6R0lTVlM4aGRKNVI3dmRINnVrWE5QVTFiNWxsTXIweUhnNFg2OUZsZFVKek9BZENuUDRSNjBBVElHUVNOUGhTQWxzQnNGaUUzK2hCeXNCRGd6NUJwYkpFaS9KaDQ5ZFRpNmhCUmZBaDRLcDBucUZCY0RRVWdsNFJwbFlqa2ZVeERiZ2pZQ09Cd21kWUxIZ1J3ZFVCdDd3UmRjMFdjMjVGeDJoRi9jNFNLa0VUVm85UlFuMHpnbFFoa2k0aDE1OUcwSUJ4WWE5WGpzRVh1VkV4dUtKQkNDY1NETnRFL1VSQmhTc2h3SnVFcXlwRUlMQ0dpVDkwaVNWanZyb3hPZnNZVkRaaEFKSkJBbGdsYWl3WHdtOUhOSi81UXZNUUZLbWFGSUJERWJrQkVmUGdOTk0xSVFhSU1ZT0lNemhtRTNkb05WWHVWVlM1VWJma05MSlpSMFNYYzRpU01XUUdXRDVjU0k1OFJHTWpONm04RVpsMUlabDlnekN3STBCWUU2d0JGVnUwRWNkN01mOHNFRFBEQUZ6dFNNYUZNZ0tCVXlYYk4wYUlXSXlETjZjS1VzSVRJMXlvVkgrTll3eVpJVnRSY2Z2YkZZQlFGWWdiVmErSUVEQjZJQlU3VWZhSU02N0RpUC85QlZ6aFFmRGhBWks4SlRsb1JaYnVFN2gyaFcybGhrQU9kclljUnliUGgxQzdBdHJzTW01RlZlclFNOXI5TTZoZ1ZWdTFFQytaUWtRcklnT29BRHc5RWI4ZUVYMk1JWmoyS05sMldOYStVbzJnaGYxMGhtVmFkREJzRlJsY09Ga2dZZnczRWZRdjlTUGE1bEVHN1NBL2dCVmFqVE92ZzBsT2ZvVlhHekFDeVFRdEJCRkd3Rk5TWGlJbUJJRmlVeVh3SXdYd0tSQUFUM0VENW9qYmlHVXM1VWovVnhYdFlGSktIRE9mV0JKTUpvV3hUNUR6elFqS2JJQXBKVUhaamhqN2FVTFYzQ093andEM2xKaTFtWlgwd0JWTHVJS1pqQ0dEcXdQUUtSSTZDVEE5b0RPZ2RoSDBGWlhtM2lXUGhobE5JaEloaXlXUkdsSVZqWUtPUkJsVm5KRUFxbFgxRVVtc2ZqSXJvUlAwR0FJMzZpSjMxaUVOWHpENE1WV0lBRllOejFEeWNtSk16NEY5cVJPRjFpalFyMFczejVtVUNIY2lER1VUUjFmYzdET3RwaktCQm1FQXAybU5yRFhabFdLSVdpWGR6bGs3bjVBTHU0Uzd5VEpjSTVFNk9XZnVyL0pWTnhHSlo4b0duek16MEZBUVZkQUFVQ0lXQVNwaWVyNldBQzBaei93R1V6c2lpQ3h4MitZejdmV1JGRTRZRDBNbm54b1Rwcm9qMTgwR0RxV1dnQlJHTjBJbUR1S1JBelZoQUdOaWM2VWdKOTF4Vno2U0dNd21IL1dWOVVNUlhZQW9MTnBCdm05UU1GWmo5bmdEOVoxZ1UwTm1NRFpHTTJwbU4rVWlNLzloUjF5VmtmT2lrT2hGZDJ1UmhyTWo5dThDbXRBaXIvb0FRc2FoQkllcVJDY0FZVCtnTzU1Unc0MWFISnRhTmlFcUFEMFI2Q2xxQnpva0dvY21WVjlxV2N0cVE0R1M1MXN6dS9aYVh3SW50WUlZNEl3Z2Rsb0dKRWdBaEc4QVdjaGtHbmtrRVp0Q3Bkb0FOb2N4dGFRWU1mcHFieE1nQlpBV2pXb2dBZHNDa3V4eUFGOVFPbWRCWXFxRUlFWmNBSHZWY1pYS0pBaFBvNGt0Y1ZOclFwWlRBRG5uSmxwN0lGZzhCQlc5QUZRWENwN3ZNcytyaXA1OE1HWEdLSmE4SUhoVFpuWDlvRk5kQUJzUkdGVjBOMnNFbzhzdkdIdGFFQlBTQUZLMG9FdVpCQk9jQUVqTkVzWU1abndVbzhzM0VBemJJQmxWWWJKUEFERGFaai8vQUNNbUFDVTBKTFhqaXQ2Rk4wekVNYk0wSWs4cE1EcmlZUXRJWlhJMlN1V3NNR292WVh1NllZemZRZnlGRWJzdkVQZzBxdnhBTXlOblFidHdFeTJRZExvQ2F3VUZRdGZFRVRBUUVBSWZrRUJRY0Evd0FzUndERkFINEFUUUJBQ1A4QS93a2MrQzhBZ0FBRUV5cGN5TENodzRjUUkwcWMyTkNnd1g4RkJpSWM4Ty9nZ0FJZklReUFrQkVDUm9VWk1TSk1LSUNpeTVjd0ZRSVl5SkhrZ2cwUGNtNVlnU0lDQ3hRb2VMSllzV0xvUHhZREkrVDhCK0ZCQVpJa0N3U1FLblZxZ0tzRUNtcHRpYkJyeks4VUxjNlVxT0FCem44UmxPYU1zTUtuVHhRc1lPUjhFTlhEMUlOWElRUTRBSUhBVmFzYXRVNFZtUFZmeTVRSkF3aklPRmdBd3F5SEhiY3NLRm14WW9rSE13dlVUREN6eFk2Z0FhUk1PVGRDVUJJNFJuekE4V0hFbEJFa1JtajRoMlFnaVlGdDAwYXcvZm8xaVNuL05CUk51eFRDaGdKUFZ5cjI2MWpnU29JSEZFNG1QQjNzeTRQUUp5OFErQURwYngzL2V2VC9rQ0grUjVBZUJORUxIREVDQ2Z0L0kvNTlFSWdET05FVi8xQTgyTTQwWTRISlhBa2t3QUhQR1hiQWdBSWxFSjExTUZGVm9GUUNTVVVTVXpuOTlrRU5mRURCUnhCQnlKQ0RER1ZJVVVhSUkrYndEeFF5UURHUWlUbVUwV0laS2hKVXd6OVQ2SGNjQWYvdE5SbENDekxvNDQ4b0pjUkNiQ1AwVUVZWFo3Z2hFQkZHL0VQRVAyZmt3aVFSWnd6MFFoZFN5REFDQ3h2MEJjR0Fld0VwNXBnUkVUQWhkeEdNVU1ZWEFrWDVUeTVPL3ZBUEJreVpHU0dPWk9hcDUwQmRidUJCbjA3OXM4QnVBczFHNTU4ZUNMU0JSQmVOMWRtZWtFYjYwRlZVVFlnY0JDVE4xZFJjbkM2MTJ3TUM4ZlZVQVh3VjVKVnpxRVpVbmFRU0ZlRFJSZjBaLzRjQlRqZ051a0lLSk9TS2EzQURzVENVV3crbzVWUlVWbDFGbVZSWm5mcmNqczJsS3VCQ2w3SHFxR2N6RFdDUXF4MHhKdG8vTlEyUTB3SkRyVURDa0JyYzVxdCtuZjRES3FqOExiQ2ZRREQ4c3dJTVBibjdnSDVvNWRRVVZQOFVKdDEvMFBhcm8wYk45Z2prY3pOVm0rMVlKaTA2S0FvQ1RkRWFlK3oxY09GNjZNMkd4QlJJa0RCYmNHTDhWdTRVNWViYTFseklIV0RtWDRFVnFOR0JoZzNVMG9IUkljaXFWaERLN0Y5Q2ZRVzdnZ1lhRk5sRGhpbitFOFNIUVFoa29rQnlEaFFmZk9qVlFKNmNQOHpvR3NRYSthdFl6UVdwUENBQnE5NE1WZ0FqVGZVVWR4dXdOWVhVTG5UeHdobFZWb2trM0djSVVmZmJjQXNFUlJjcnl2OVF3M3dFbVVrQUFRY2NnSmpZaUNmRUJocFFJUmZoQS9qSmhrUU5VcnhnQkJGYkVBSG5GbGtzMlFVU2RQYnJwWjJKbC82UVV3dVFsanBhR3RUZ1FnNUpWNW1EQnFGM2FhYmhCcHV1KytrUmtvbmQ3c0RuaVpDakJTRTIwMkNVQml4VDhMcHZaRFp5SHcwZ3ZVakdVYStBQjJldlc3Mi8vVUhJTW9ETWkrbnFVNmtmVjhCY0M5aXJIOFM3RWNvZHFBT0o2bVZWZjlWL3FrTUJocStSWnh3bDJyTlp3UUpYVDNKRmdoU0l5MlA0R1FvTGlCTXNBQTVyVk1YS21WWVlJcFZWV1VabWt4SkEySHdrRm90WWEwSW1NWTY3ME5LK0JZNHJWME1od1Z2YUlwZWNJT2VGQWRBTFhpalZGV1ZOa0dDVXVlSGhJQVF3SFZhbU9jMkNDZkgvRXNJWjRuMEVlOVhiajJsNGtzRGhvQXdrR0xqVWpRcUFJOGVwYTE5TXdkU29jRGNxSy9Kd0s4NUp5V0s0c3FDV21DU0hDTmtnUTRhNFBNK3NaQ1k1ZzBENmdoVUJBc0xtQTFQQXdiZ0VncFRnK0FvLzdJTEJvQ0NYd2x6QlpncTVrbGRSdURQQ1JaMGtaNUlwVEZlcUF4azBVb2Q3aVRuZVpqckl4b0U0aWlNbkdjbCtGa0NVWEwyR1BzQlp6eDhTSWh1ZzhlcG5HbUFCME1xbEFaS1JZRGdyME5jTDZlZXNHMzRKSVdKODFzd0NBTGFZSk93eisxUElTcXhWRStRODRBQm5PV0F0aS9RMGdvQm5CRHBvRDhkb1E3SnR4aWMrd1BuTlQwRFZGSlV0eUh1T0lWRE1NQWcrQWlTZ21BSmhnS1FBZzUwNFJ1aU1HUUVWeDlBVC80UVp4VUVHNFlFZDA5THp0UGVraG1JRW1RSWlUeWFnLzB6blZKTXhHQUlFZ01ubXFVUkMvempBZm9ZQ05DVDA0R2dnK2tmUlF2U1BNcFFVUmVYNVI5WFF3MDhUQVZTa1BhZ2FueENUUnVVMEozZjZDMlB5QUlNUitKRmdQdXhwVFE5bXREU0NTQUZMQXBHQ1VwY3FFQ0dZVkVRdStnY2ZhS1NCbXdnTWJEUWpURTRaaEppVWJDQm9GeWlEa3R6Z3Rpb3Q2UjlLVUlKQXdBQ2xKMUZwSUdXUXdROWdneFFxa3Nwd1c0V1VxNDdJbEFFb1FBRWRhTjBNWnZDQ0YvempCVytkVXBPMjRLUVhsQ0VJVTJBQnFWS0MwN3l5aWlQUk1jNERNRUFDR2J5QVRmOVk3RDhZUzRReTFJWXdEN0RUNFN6TEtqWnN3RXhub3hWQmtJUzVFLzh0Z1FVS2VBb0JGdEN6MWJKV1VoNEkxSmtFb29BMEZha0djU1hCckJUQXJYc1dnQTIvTloxVGhEc1FETUNQVUk1MENheWl5OTJLL0k0Z3c5dU1lTHZMdk84bUJqUXRVeDU1SVFYSEc0cDNlT01EeVM0eDhoK1N1RXd3Ni8zUlFYWVdJZEdRN1lYcVVsZEpRbksrNnZGSHE2djF5bjN6MnhEL0lNZDJ4M2xnaFA5eGxrdTVTNk1Qa0l1QThYcVNDVjRsaUF4MnlMWjJlWlBVNHFSVEtGN0t1OXlIWU9UWXoxajNjMGdhdVd1VnFCUWdmUnM0c1g1KzhwT2U2R1pkQkZsWGx4eE12eGZYTDRPc0JXYnZwTGlCUVEwU0tHMHA1WkNPOHJQM3JXdFdmN0p4Qkx2aWwxNFNoQ3MvakZZT2xibmdNWG1GS3YxeG9MdVdpSUp4OGVUL1k3Y1VUdnZVWXQxWlJjVys5dldlY3M1clV6RS90TUZpN3BjYVkzTG01MDNveEtBeWpieUNJaHdTbk9hV0JqUWdXMURtRkJkYnk4VjZWbzZ4dnV6bkdVK0tJQUJiVHFBSnJSTFB6RmRkU3hFSW9kclhrNkxBUlRmanBFc0JzTWZNR0lMRWJEV0VzWHVmMWJ0MTRtelBrc2tJbUZIVlpaYUVaZFBuVGNrWmoraW43RzZVTFd6NWliMzBGVDNvZldTWGkrSmhWd0hzdUYzeTE5YzNiRWx6TEJNZ1lWK0dSNk91Q0xUMmpLcTdnTEs1N3FLWEFwdUlGSDNsMkN5TEltZW81UGl0L2ZqYlhieWxpNkF5Q2w2QmZXbUNsVkVtZ2dBRU5xeFNkTkNCVWFaZ2xIUE1qM0RyS1UyK1Z5eC93M0UrS3JDRUtJZ1gvTFlUQVhDUk1pajMveEZYeW51Y24zZUp5cjJoQnJITnFrTWdmMEhjT2VZdGVHZVVQSmdYZW1wSXY4bmphMGFneDBMZHhqNnorVWxhL2tFdmVkRUlCRHhZRFEvcWM4dHg4U2RlcWJPdmRDNXo4R1U5cGw4RWh5ZDFHQUtyK3k3NGZobVpDUUFWK1J2VkVHUmp3ZmxES3hVNm02U2pSVjVBNzZZdEVUaE9nSGN4aHBKMGpOaWRreXdFWVpYZ00wdThkUnoxbWE1WUN5UGVFdFM5SW5hYjlSUlVxdkNCRDN1MmVSdVBWWjZXVXlnQjBIekZxVXZCc0RBNUVydWZNMHBSclZMU1p0b2RMd1dkdzVGUnlaRTdwUXo2UDdJNVZJSDBBSnRJQ0JyY2crTXhvSEdNQkNXdzVVSVhLQmZrREs0dk1sdjQxblRVZW9KYjMwQUR1amxYTzdJU1padXB4Q2YvQi8rUndqT1E4elN0QnRrTWp2RmxvODJCZk9BMmVrU0tVZ0N1c3RHQUhZY2RMa3lQSmxQSlBWbUZJNE1CYWdGSVlUaVJGaVRnSHVnaEEwSHdUejBBQlQ4UU5laVJUUlNEVU5XRVI5VjBTd3hFWDhrU1A0dFJKNEVqSU5HUkFLd0NUQVBZWWRueVNFMGhTMEh6VVVaVE5BbkJndW1SZVRLNEhqVXdJMy9qR2lTd0hZN1VnZG5YSTlDWEVPNGtOaEdFTXlneElScEZMaXM0SGpuUUlpY0NJMUR3V0RDaWdFWWpIak1pRURXWU5ES1FoVUVnSjFYSUF2eVJGUTRGTmw4U0hjbFNiS2FERnhneEdZeUJHQ1NoVVFzUUZBcWxBeC8xQTB2emhDcnloQ2YxV0ZKNEhocnlEeDlpVWxCUVZFa0RIZ0VXUHgvNEpjeVJVMUpCUEhsV0lCNy9JQzZxd1FjeWRSNGVralFEZ1ZRbXBUU1pXRkl0a2dOU2NDSW1zb1cvbHkvOFVUTmhJbWlWdFZVRklocnRCVDhDZ1IrUWlDRXRRbFpYOGc5WUlnVC9nSXRDOElsbjhJa0VzUW1mdUlUd2dRTURCeXBtS0dnaGxoQWxjWDhFRnl5eEVWWmlaVmhvNVNRRW9RUlVRaVZxMVNabTlZa3VNQ01zQUVxamc0ckpLR01PMGpzZDhBOHpBaUltSlkxbjhGYlU2Q1JSQWpkS0FEZEtKVmZ2SjNBQ1V6ampDQk1XSnhBRHNBR3hNUjVCMEk1RXdDUm5KUkNNQlNkRW9GWXZRQjRzSUd0blZHYjcrQkRNQkQzV293QXNJRFVqNGdKU2NBYUlsVG1aMHlSZmtEa05xUUV3MEV4bmxJb1RDUkVnOFEvK0UyRDNKa3MvNEFhSWRUbVprd1ZiblRBSW1XTmFHRUJnSUxTU1BzSUdaNU02RDFBV0d1QlpUcUk1VC9JUG5WTUdQa0Fub3pJUVp3U1VQMElxUFFVNUpSVTNtaU1saGNKYzFVTVFVMG1WTWZFVTdISmorUlFCT05BaVVyQUpWVkphU1BBcGp3TmJyaWlXWDlFbHF6TVFvR0lDQkRFaU9sQnZaNE5hZE1sVkQrQXQ1N011QUZRdW1WZE5GSFlTWVJtWTFsRmdYYktZa2lrdkVXQmQxNU5kamtrbUVLQUFUY0Vka1FjVEFRRUFJZmtFQlFjQS93QXNDUUMrQUx3QVZBQkFDUDhBLy8wTElMQ2d3WU1JRXlwY3lMQ2h3NGNRSTBxY1NERWl3WUlFQVFqVWlGRmh4b0VjUVlJTUVKSWt3WXNjVTI0a0taS2x5WW93WThxY0tWSGxQd0FmYjI0Y3VOTG1UWklhVFlia1NkUW53UUgvQmhRbzhHOHBoS1lRbURKOWloVHBoZzMvSGl6WThLREFncXovb2tZTlFMWXNVWU1DL3FXbHliYXRXNFVBY01iVmFaQWp5NkFGTkNLRmdQUkIxZ1VSQXFPSXNDSkZZUklhU0tEUUVIakZnOGNGbENvdFM5bnN4Wk04TDZaZDIzR2dnQUNmUDE4OGE3QUE1N2VvVXd1OGpMT24wTTREQWpBTndQZXAzMzhSVVB4YndZSTNqQWQ4SXdlWXpCUkFBUWdYbnhLQXNHR0I4d1dQZ1ljbFVJREF2d1BYSVN4bmlwRzdkNEhjclFmL0lFQXc5RDhDYTYwTEVJQmR0WHVKZHgyT2xscndjVmJDdW5lVEFER0Z4RDhTT1B3enhRaFRDRGdDQ1NzUUZnRUxBdlhHNEQ4czlLWkJnZ2xDZHR4eHk0MUhrR25uQ1dBYWZSdDZHTlpCN0tWbFhRSUVJQ0FBQXUrMW1Gb0JHNjVXMEhGUVlmallnamlNY0VVUC93UWhVQTg1eUFCa2p6eit3eU1TR2lCWkFvQklGRFRDQ0I5RStXUi9MRVRRQVZZSGdWWWVhS2VsaFIxN0xvWXA1bXBQeVdabVU3TGQxSmR1SHhENDVBYzkxSkJER1ZKMEljVS9RdHo1anhSMzhza25uWHp1Q2NXY1VQd2pnd3ovZkVEbFB3c2NRSjFBcDFrMzVxU1Vvb2JaVXdVb3NFRUVHdmlnZ1E0eVNFR0VRVVpzUVVRdW94cEJoS3BFbEZHREJqQ0EveGRBZTVYV2FxdHFHRVpGNndNUjFDREZKbDFzUXNRbS8wQUJCUkpYQ3JRY1Z0emQ2dXl6TXJIUkZRWUZkQ1dkWDczcGRsdEVQblcyazA0c2liUVNRNjJGS3hlMDZGSWFsRUdYSWRSdVF1MitXMUJyWjJrMFYwaERuUVhVZDB0SnhSMUh6YVlyY0VWQjRmdHR2anF0TzY5UVFrbmx3VkpZYVNWeEJIN2xWdVdDR09NbUVBWWJZQ3JXaFpXUmhSQm5wekVVR21nRFF5c1hTcGlOZEJCU1lYSEZsUUwveU16Vlk1dFN6R3Qwa3NHSWs4aVVaWVpabXZTQnh5NVJsd0hkVUx4cGNTaHB5bS9aVzFkOENNK1kxSXdGY0lVQ2dpUjBQY0kvT1BpWFdBUzQ4WVpDYjRUdFJuYVZLN1ROSUc4Qy9tZjJiemhIQmVPWjVjRzRWcHBOS2Y5NzN0L1dIWkQzM3d4QUxTYTlvelcxbEd5VEZjUlZ6UUk5Z0VMYi9yVlpBNXg4L1BQMUNCcTRlU0FTVHo2Smd3WURkcjBDQ25ScjlROE1qc0hnbktNaWNuZ0FleEFJOE5RQjdhMlZGb3Yvc0ZnNDc0YmZtamlhOU5VT3dYTnRqNkNERGlNc01ZS1AvNVJSRUJUU0N5U0RqenorOEU4TlBjandnNUJCUW05b2tmL3A5cFZwa240NXUxcHEwUnI4K3hTeE1WeFRPQ25WSUE0MUlDcEREbDI0OGNML1p5Q0NFa1pGaERPQVFTQ2oyb1N3L25HR00zUkJDRE53QWZlbU1JVUVGUUE3NkVFUC9EWW9KcWJZN29MVjZrcFdOcUFCR2N6Z0gwcjR4NmtJS0pBY09BNDh6T0dnRENsVnJXckZzRmthK0FFZnJnQUZQc25BQnc5UVFGZi9uaEtXZ0NVdUowTVpYa2RLVXJVWk9yRXRDcE1SVDFUaUVpcmFxNG91eTFMQnZrV1hKM3F4TGx6MGxyczgwaHA2cldabFJlbml1WDZ5eFhBbFpGMHdrdUlYMzNORXVsanhZRk9jVjA5UzhoSjk1UkZjQU51UXZ4VFhyNlZJeGpoSjJjdUlybFBFdWdSc2puU1VJeHZkdUpPQzNhVmxla1FJakI1bU53ZzhCam95aTA1V291TVgrenp1SzhlN0VJenVGalMwd0NzdEtJT2tUT1N5eHA4YzVJcHNSSWhjOGlLYnFIQ3NPVm9Cak9RSVE0TCtrQ0FDSktoU3JCNndnUUVvWUNuUFBJNlpRall5U01WRWliS3NpUm9abHErWFZLVnYxUUpNWUFKem44QmNqR0xvaEV3emhXT1NvSWtzanF1WmpTdXpoRFRSWUpPZVp5bFpOdUVGLzY0enNvWnh6YXBLWkNJVEZlRGNqRkVDSWN4am5obVgySkFFbnJRUlpJejZ0Wnp0Uk9WUitscWZXcDd5R2FNMTVUUGs2ZEI0Q2tLeTg5d1RrcGpoSXhpUFppK21TSWFaa3BzYzEvNERJZWhnNEFFRHVBcFR1RUpFNkh3Rk9xaHIyK2xXd0RxaW91QXJLQ2psVjloMUVubVJGRFB3eEk3Ny9qYlZmWjVSbC95OEduMmFBeGplK0llbVVlcGFNYnRXb05LaExVRUNnVUVFWU1BZ3JxMEFRUW9DWmRiR29oMm9va3dxbjVHZGwwcUVIdFBNTG9PUTBxQlZSNk1TbTdUc0lubFpwUWZDNHB6bUFITUYveWxRb2laYmtBLzhRd01hRUFObUtRaTJ5N3BwQ2lDUUcxRzdjaUgxOENROEh2TFFwY0x5R1ZycERrVUNZUkdMRW1CVnR2K2NxU0JscXRGeGJzWUNFaUJCQndVSmd2Ymk5Q01laFc0RVNFQ1NCa2IzSDh5dVFBTUNHcXZwb0NNUVpqM1ZkbXJSblRWcjZ5S0lyaEtjMmpuZWpWZ3dCU1Q0b1FkWDZORS9nZ1NGNjBFaENPMDFVZzJjMUNTQjZJQjdJK0JEL2d6MWp4OU1NQVdNSW9CcFViWVp6eVFFZU54OUMySkh1akFpWG1jQmt4dFFtNGpiZ3lBY1NpQjNvcFAweWhBKy9lblBoUnplSDM5NzhJTWVSRWxqZlJzcGx6UlUxUVRiaWcwRmlZMk00MWt0clNWS0JtV1lnUkJlUUlRWE5GQWdEUXh5QTRYQVFDRVErUXhRQ0phR1pjQ0hIa3lCQnlSd1hYV3F3MWNYUDNHVmFScEFWWnlKZ1E2TVFBWXVrSUlidXZBUEhnTlpoUUVrQWhoR2hjSXp2SUQvVHpPUUFZRmdzSlRWdE5qS1hvVHhiUHpGSEE4SU1RVmZMb09aVjJVRUZaYnFINnJxUWcxWVFLMFpIUURHZUk1MGVEQzFBVCtYOEFzdllLQUsvN0dGTTF4QkF3cWdtVURFZ3FWSTQ5a3ZYOW5BQVZSZHN3ZjRvQWRTTUJhYlBkMEJqc1d3a1k4ME5YZjczREVGUElVNXZOTGM5bVF3WHd3MDVUYTMxcld5QmVMcmp0WHNwalBwbGlTbHZXeGRSeEZwZHNTMnU3Wlk3Y0d5Tkl3bnhZZ1pGNGJHU1E1RnBkMStGclZQT3J5WHJNeVM3eVkzSmJ2b3p5YW1HNHFrYWRjZHpUV1NOdUpTajBDWm1zR3lHa2FQM2hzbWRiUUp0Nm1kYlhKZmxkNE8xK0xSK01ZZDJkVDU0QVFyT0dud1NVdCthMXlOdGt6cFFONkpwcElvYmpoNy8wN3N4UXRadEdhTmU5bDEzTGkyZTNKTGRyM2JqVko3eVVjV0hCa3RSK1poaW92S0FPeW1GT2JJYkFITU9jQURKRFUwU1lveDNkZ2N1TlRNclhPcG9YRjRyZWxYeHpiZ2xLdHNCYVlISlNVcGxYNGUwdTZabXZoc04wbnhUTVU5ZWx6ZWZ4UTNOeDhhZEs1ZmhaaytUZXFOY0VPMmduRE1hRFVzWkVSYldjM3RhcmZBSFkzMDFDTk96NXpVbTJGV0s0Q3hKWWFid1F6R25BdTZmQ2xsNXN2RkRYU2Faa21JUHEySmVDV092cmJub3FVWk1TbWpsYjNFS1VvSklYVXRiMDcrTENpWmZJOE83RlhadU1wa1JvN2pvUStIRUM5NmpMdm1pbVpFSEU0S09lb0xhaVUzd1c3TWJ0eUdzWjBCWitoWU5na3JsVFp6OWpXK281YzUvZjlUcmZtMEJPZExZU2FQRVVHZTh2VWJXZi81ZzltWnpxNFBNcDlSTTVaTlBXM1RzclNaZHBFTW04MWlJbjVqZnErUlNTNmpmdGp4ZFVMa2F3TUFIRjhuTXhFQUdLbkRnSGZ6TStVQ1RxT1dHWmpTTCtkQkh5TFNFUU1HVVhKVVVtZ1JJd25tUnFPaE5Cc3lBQzBWR3dRMUlxcnpEMmN6ZzZQRWRjWmhnYnpFTnhGMUlSRGdTWStoSFZPMkZJRXpIdVJoSFJvMEdxSUJTK3pTVVNCRkVFK2pKWXkwVHlYUmRCdlNNTXVIU0VyaEFWd0JWTDN4VmpURkFzQkJMYkdIZlVUVUhNeFJVSjYwSUQ0bE1kQVJIVzNvVTVoaVlMRjBOSjVCWU42M0dkcmxiU08zaDc4M2QyVlVadzBZSFpNREFtS1ZHQnJBSU9QRUsyU3ppT1FVT1JEL2xpQ1RRem5UNXpZSWRWVG40M2xBSXhVcVZvUWR3ajU0cUU5NWlGTDhkQkl2dHhQMGdSVE9JVlBQZFZrRjhnRmhJellDQVYwQzhWV1Z0M2VROVZaVDhEWm9NMzljaDRrUlZScC9jeEdTa29jbEUwdTc4dyswZFlLWmNYTjZrUlRHZ1JSU3dVeURJWW5GTkZrNVFnSWpjSTFmVXlDOGtURU53aHZkbUNBV0F4bDI4eUY0UXg2YUtDS3AxWW5iMVJrb29pSldWVXNwK0VkSkpCQ3gwVGRONFJ5T0dJbGRBd0pQWWhCUUVqZkpkRXk5QVNFa0lBYUk0Ui9TMVkzQUFTTzFNeERJd1JTU01oc2ZLRGovVnhEdG9SNWc4amZLS0NPT3h5NFZGMGU5VkdxdEpqbHZCUUk4RUNDSmNqbjBkVm1ZUlRxY05RVTRNQ0FVMURXOThUb1gvM1E4a1NOZ0dHVWFJMFVlQmVaOXRQSWxhcUVlZDhaZEJUZ3VCMkYvUWxnZFNNZDFyUllZWGFNNTh3VW5SZElEeXJNNVNPQThtbk1naURFRmlkRTJDL0lBNENoVURyQUNDMkNFWDJJYTYyRk5GNEVkdkRNN0RMQ1JIR2w4RElGSkh2SWhORUlZU1RJQzVMTmV3aVVRODhVamYwazZpR0dZbTNWY2Y2QW94L1FZeGlhUkpOTmFkSGtkSlZJNGRXbVhTNmxWVmFnVzMzVnNiZGc1UzhBalFaQUQ3TlVqNzNVOVFmQ1hYL01QVFZJQ3d2WUJUZFlEY1ZJRFVFSWdKS0NQVHlOVkFpQXBSRFE3Nm9NaTRvZVp6WUpsd0hnY1hiVUNKZkFrNmVVanBNbGVoOUplOElVOTJ5TnNzbG1kMTZNOVJsSml4R1paYUxsVUc3aytvd0dFbC8rSm1STkJOTExDZmhFV091aGxLS1BwUXRSakxOTHpYdEQ1RDNIUUE0VUNKREl3S05JVEJJR1pBLzcxandzUUhuTUlLVVJVZnVRSkVXZFNOR2pTZ3pUaUZ5VFFKbCtUUDdKcFBkV3pKd1ZSQmk3QVlSb0tZdXRWQm9VaUJVRmlKRWJDQS84QVlFdm5LTE16SzdZVG5BY3FFMmxpSE1uaFNTaVFWTDN4b0RnbUJTL2dCa1RRQldSMlpuamlCa1FXcEZJZ0JIWlNMQmttbUY3Wk5pTmlQQ2JDb2kwNkU5bzNGZlR4QUNud0FUam1CbTVRSnppYWFRSWtRQ24wcFdkUUVFSndCc1JDcEhCR2JMYkpBaWh3QUJla0xJN3lwSlJ5RXY4Q0FBT0FURk5RQTNnS1ptWGdCZ3prWXdPMGFiT21hV1htUUh6aUF2NVZRZm1SSFhDYUxqNy9SMGdiUUY0MXdBZHpVZ1pkRUVCQVZrQ21JaENvZ2lvRjVBYXVVa0dxTmpzT3RxalFnamNRd0tZOUYyb0tZQUpmNWdadUprQ29rcW4vZ0FpcThnVm53QWRBUkNQSXdhYWtLakR5Z3h6QXVsTWhwQUFSOEdVcTlBVnNOaXBia0FVRndTUEZjMEVHMnFzQ1l6ZU8wcVlRRUdvYTRBSjhXa0JFd0dZTTVFSkN0RnRpRWEzU09qQzZvbXBNc1dvUE1BSjFFcWJDc2dYRjBnTk5ZbDBTT2FybG1qSlQ5cVlFc0dxU1Z3SkJFQ3pFSWhDYkVBUSs4QS9Vd3FDL2xtdjNtaTRFOEFBWUZLQUJ5aXNqNEtHRk1pcGRvQU1kRUs1OVl4MzJ1ckFDUXkzV0FoWUpCVjA4RWlwbGdBTVppMU44QVl3ZUN6VkQxekVoQ3preUtCQlVzb0MxSEZFQWtOYXk4TU4xQnNWTTFYVWJZRmd6SGF1elRtUnNJaHNUQVFFQUlma0VCUWNBL3dBc0V3Qy9BTElBVXdCQUNQOEFBL3dEOEsrZ3dZTUlFeXBjeUxDaHc0Y1FJMHFjU0xIaVFZSUZCUm9NUUZDZ1FBQWNOUjRVQ1JMa3lKSW5QM28waUJGamdRSUZCOEI4YWJHbXpaczRONDc4cDdFbnlKQTlFWnJNeUpNblNvSUZUQVlZQUFIQ2dnY29Ja1NJR3VGQjFRWC9IaGpjOEs4QWhBSUJ3QVlJKzNPczJhSVVSZXJNeWJZdFRvSndXWGJ0R3FCcFZvTVl2RExkY09BQmhBMWZYNzZVS2JOazBwNHdWeDZjS2VEQVB3aHppVFlVOEkreUFMV1ZNMU11dU5tdDU4OEQ1UUk0YkJJc3pLNFBOanhZc0NEQ2loVW9Wa1JnL1NCMUFjQWJicWRPdmFIM2hxZFpuN0oyVGFLNFZPQmRDeER3S3Rac2dNdEZUMjhXVU9BeTVlb0JDRHovUitCZkF1NEpFM1QvQjAwZW9kcWprakVUN1ZnUUFnRUNnUWtjZVBxYXhMOFA5cWZvTjRnRHlZai9BSTVBZ2daU1BTRFlnUWZBOUZWVGdZVTFrMGpqUFFmVFpRZFE1cGdBNC8zam1IamZmVmZlaHplRk5KUkdDdjZ6Z0ZNcmFLQ0JEMHZvME1NL1FjUWhBeFFHeVJCRURrSDBJTU0vT3ZoWFVBOUE5cEJqamxDOHVPTS9JMmpBQWdZR0t2Y1NCTmxweDFOMTFYVVhRSVV3RWRBWWlGeHlXV0ppWUEzd2o1aUNiUkFCQ1IvVUlJTUxaY3p3UWhjdm5DSG5uUC9JMlVVWFozVHhqNTVDU0NHRVFWMUlJVVVaYlpZaHd3VTExRURDVS9BMWRtV1hrRWJxRmxoTkVjYlRWMkwrRXdHZ1owZ2g1ejlFbkVIRVAxdHM4WThSUkxnd1FsV0NmU1hwcTdCKy93YVpxMTVCZ01FL0duUUJoWjZiRkVRRUZFdGdvTUJmLzNERkYxZXhKcXRzVFZwcDlZOENXaWxna0xPdVJxU1dZb29OeE5GR0hhR2tMVXVZaWJqc3VKRitoRmEyTzZXcmtFZWxlY3R0UWFmTjlHU1pZMnExUUFFbldsblVXSEVKQk5aYTVBWjhibEJHcVllUlpHUEd4RkZTTU1rRXdXb1JzSkNDYXl5Z2tCVUt6U293Z0dxNU5lY2NVRHlOaFpaREFuV20wMHJxOFdTeXdCL0N0VzFDbzhWRjBBQWlrdlZTczdOSmxWVnRCUXd3MmxJaS9qdnlUSTgxSEZod3ErVzJ3WEx2alNWZFJ0YXB6RmxscDQyczNXVlNkcmN5eXhNZFRCSzRSSVVGYjNvYW1qaGNmZitRTUlWOUJhbU5RM0gvdkxicHpqcmpxb0Y5S2E3d0Q4WXZoZjgxMW1YWVhtMlpaczl0NTY5QmprMU5HUUhmamJjMTE5WW1wTks2SU5GTWw5T3p0cTMyaTBicStNOFBRZndUWkVGSmFqQUZDN0xCVUZYRUJkMnR3UWg4OUZERENFRjhzTGFCN25FWGxIYmRFYTB2ZUFjbERqbWtCOE1yMEt3SGZLWFZDaVRnTU1VL05meFF3ejk4L0RPakRHWDhVNFlVMnBmaGdndzU0QWlGalRnR0VUcVFOUVNaYUE4ZmZMQUNDMVhWZG05aTBKVjhRTXJENS85UVdBSmszdk50RzJBQmpMQW5CZkp0TDA1MStvY1NmRVdFVVJsQmdYVlNBaEdVOElJWEZKQUhFWEJQN3ZUSFFSQ3hZVlpKZ2NETW1vS0JIdHlwSUp0bzRLK0NvSUhVS004cjkrcWdERDhFZ2IwOHpDdWEwb0FNWkhDRkhKemhDMTM0UVVIL2hGVUFEK0FHTW5KQm1GSDJCYmFoZk11Sk00d2lXOHdWbEd1QkM0b1hxZG0zQ29MRjBFanhpK2JaU1JXMTFVVW52aXdrWkN6SmVVU1NHREVocFN0a3V0bHZhQUpHU1hudEpPZjZ5WWpRYUI2bGdBUXNTSG1qUUh3R21kNVlSVFcxOFkyeHVvTVZKL2xOTEQ4N0MvN3FpQk4wcllXUEM4R0llakpWdFNmOXhpcFNxWmdvVzlPYWdoanJLeC9qVnlwRk5zbWRVSVpnS0JzWkpSc2lzcENSMFl0WExOakJ4RlNicW5RZ0FyL3NRQ0tmc29FQkxDQTNUQkVNMEZqWkVlZkljbjhvODRoMVVxWVdyQlVrUTdQTTVFWEl1SlRRMEd3QTN3UW53M0Q0QU9HdFpqVUhJbzBrbjVtY3JpVG9BSTRSVER0cGNockhFUTRoZzZ2TWRyUTAvN1hLWURPYjNIU1p6RUtqRkovZERDcXZTYWpGYXZNWHdaU21Ma1NMS0QyYnRZRGlnSUFFS3hET0FqS1VHSS9Vc2pwMG9jN1U5bGt5N0FqZ3BCZzZLWGRVS3NXam1JdUxBSnZKR3hOWkxOYjhBd2F4cVEwTWFxTTNqUDVEbEZYWm1iT3dnZ0g0R1hWVEtNQ1kvTXJaTjQ5aEMydURteVowaWlJbDRPWHpuMUxjMWt2RHhzNlFDQTB5cTZrWWJQNEJnckxpZ0huLzRNRS9udmMyRnBEQXJXNmRRb0ErSUtEWG9QTWwxS0VPbEM1RjFjcFlaek9HMDEyR3RLWVp4MkFUQWY5QUxCZ1AxcS85R1UrWkR2b0tWdGFLZ3hHUUxrM3BDOUlJZXVBSEFKVkFBN0tKWDhkdVJvQUh3QUFHRG5EQUZCeEFoOWRnYkRrbXRjeVc3SWRWNFA4cGxnRUFyUW5OWWthWGpFRGdBSWg4Z0FhUW9JTXJxQWxHT1FEZEQxNzB1UmNCU0VWM1M5dnJOcnRaSUExSkJyRkxFZ1l3SUpPTWxPd3hjOUVPWks0a0lRcjVWWGk1N1JyUUVHSWF4OHpuQVNzQWtBNUVKeVFjRlFSODJZTkNHWUpnbzg4MVYzU2hDekI5T1RzQ0pNajFickk1RVRyZncrRHNZRWlha0trT0V0UHJHYUdCTnl6ZDlRcFhXa09jRWN3WGZJRTZ3NXVFa0wwdTlFbFFVSkJDaW1tVWd6S01EN25ac3g0ZlpuY0IvS3hnTmU0cFFJVWcwRC9nVVhoYzhqUWV2QXFBZ2lta0NYdUUrbE9lNWhRcVVDWFFJR2ZZeEp5V0hDaEJlYThHT3JqeGNneFN0Ujl6TUY0d01lSUFGS0F4Y0E0QUF6cjh4d3NNTXFxQ0dDSC9GdzJFczZsUVJZUVh6T0FEdUpOUGw3ME1SaWhCNlY5MThVQU5BVURvQVVSZ0JDN29naExPQUtwY21Fb0tWL0RCcGdDaklQancyY3NmWkU1ZEF1Q0JvdllnQjdzNkNCR2tFSVFJU0tzckMzclBwWDljcStUVjZxY2FDSUlVYnJDSlh2MXFDUWRwVmlGWDdlVUNwS1pZdDFMTlZPenp1ZzlvNEZrR3lvdXplTTNzZzJCZ0E3ZXFKRXdWb3NrN052dlNWQ1FiZTh6b3RXNWxwTnZYbHFHMXc3Z1RrM1JMcTBOeG9ybHB5YzV3ZDhtS1hmVzJVTmpGUlhHaHNYaExsRnhMOE8zdUtZWUdsaW5CNWJ5M3FFYWxlQkdLbVhvWklMMzV2OXZrdU44MUdYY1lYelp3YzlzN1pwYjg5cllJYlpnaW9obzFnRmxOREFrRzhjaGRjbVI4LzRUM05xYzlsd2NSalV4L0FlNWZtbVhwUXY2RkFGenAyeC9Mc2t6dmxyd283RG5YdDdSSWJxRWNmTWk5cGVkQmE5TkxwajhsYWJpanRGaDJxMHFlLzF4eTYzcG15dVB0eGRPUXFDdWpRWFZ0cUNJVkFqV3JXRnNSRE0wWTlwUERPTE9WK0JRSnlYT0xzb0lEdkk4dnM3dmRtZUtVcWZnOUJhSFZ5bXdRV2F6QkxLeHlZNkhaeHlUeVNvaElGZTRjSEJHMzBOMUtvb3VwS2NLV2l1YmpoN1FiYnd5WlFGSGo0aUZ2a0trKzVQR1A4N0pIZGNLd2hMVytoazVCcEFVT1dTd1hwbVlCTWlsbU1SdU9jYXMvSkY3d0F1eS9nTStad3YzVklZMm5zTGh5V2JtWGc1TW5Edk0xdm56TjlML1VzSWhVZDZiV0Q5SVpTaFc5bnl0ajZmOUNNS1NaYTZaWG9BUzk0dUdETnBwaEVYNEJPNjBOcW52R0VjVmJHRFA5VzF4a2N1eVVKekVOUEx4VGVvOWpNckpsVWxLVEdZdDFTK2lYUlNYaExqdURBamdGRzBvMVB6NURkVUlIWGcwU1llMmhHZ3NRR3hsMVRFeERmRkxpVVZFREhZQ1RWOXVoVDYrVVQrSVhSWEhCY2pERFJRMXplMURoR2dtMU13dmlVUExDSEJFV0dCUUZGVEN3QWxQQUF5U0FBaXdnSEZzMlhxdWtHWmFoRVZaaWd2cGtmdjJVR1lUbGdyY2tGQTB6RndZMUdydnhHeVlDQXplRkFzT1JTRXVsS1V0MVRya1dBYXJ6R2dKVUlLeHhJb0hoTVNHVFY1YXhaMTJ4Z3FWSGhRaUlPSlhoSVJ5VUxXcjBUR0VIY3dkaVJQSXpGWHNEWHl5QU9tMlROc1gvZ1ZHZ3RTbE0xeXpDVkZRUmd6b1Y4M1JOWVJwbVVZSUlLRExhSVJCWE14NFRvaUhiQVZMWm9ZY0orRktNTlJDdEp5OEhnVVJRQVYrdlFWYlA4d0ZyQlFKeU5TQ2doWWsveFFMUTVUWWpRSVRQTXh0eHVHa281WWxpaElKWHd4bjNVeGs4cGlVVnNvZUtaWVZLSkJvS3dURCt3aHhNaDBpekFSVnNNd0xPTXdKVDREcDNJMWVWUlZkME5TRHhNei9La1NDUElTWXkwVlFoQTJqR1YzcVBJb3IrbEJrSnNEZ25OWTFnTkVZT2lJVmlJeERKQXg4OFNHUXJBQUtXWlZuUHMxWklnaVJJNEI4QWdnUEhWaUJOc2lBTDRuUUxBRS96a1JYeUJHR05KeDBwS0lBYVlpRmxjMzd0Wmt1bTBWdEFFUllad2dNalFGZlRJenM5c0Z6TC81VSttL1VQQnFZaUdCbGNxd0dCK3NFREgwQ1VIL0FIRndVRFdQRWVqcEVkSmFNbHovRks2TFVaQjVBQWhuVjFBc1V2ZE9Gcm1jY0MveUVrbjdOY0JxRWp6bFVRNWNpTGJtVTYrakVDZnlCWHNFT1dNbEFEZkNBR2R6RWhXektOM1pHWDBWRVFpU004Nk9WdUc1ZCtRWGRPRHpBZ1NPQUhvSE5jT1NBNjVZTWpZaW1SSmZBUGtRa2dzUk1FeXBVajFvVXIyeldQeGFjMVdzS0pVcEk3QjlBZG81bDY0YloybWlRV2x3SmM4S2MyU0xBRWZ1QWk1UE1QT1RBalFUQSsvR1UrTDZJRE9qQTlsemsrT29LWkJXWmdTQUEvQmdLUGdxRWxwS2s3L2VNM2o2Ri9WeWNYWGZaSVlxTmpjVE1GbFZVUTZVTStvUU1GaXhsakJWRUd0ZjhaT2pZQ09vdVpJemdKSkpzMU8rU0lVWlBvRkFqQlkwNWpGbjhablF3aE5rTjJHa3d4ZG1qU2tOUzFJOXNqQlZYMkQ5d3pLQzBHQmQ0Wlk3bHBQanRrbVRLd20xT1FBbFBRanIxakpmZWpIYzlvbnhEeFo1TFRNMlB6RXFwQkFyQkRRRzd3Sm1mZ0Jvd21vRS9HUFRTeVBiVHBvaTVtRUlTeVF6S3dBNHFDVVIySkhZbFJueG82RVNUeU0wSnpHdENDQW1pQ1BUT3dQU1VxWWdYQmFIdHlFR2V3UUhQU0oxUTJBMVhXSmpLQUgwR2xITnhoaHoyYUV3N3lvV09TZXhHakFUVndRSG5DUFc0d0txRVNLcWpDYUV3S1pYSVNKek1nQlROd3BWZnhqbHphcGVRQkpqU2hBQjB3WEVpd0lpeGdBckdXRUtKeUJuQUdLbUNnUWhML1JBUko0QVpsRUFPYk1wb2JwS2V3QWhuZzVBSC80QUdFY1dZUlFLWXl3S1NNMWtDbmNpcEVZQVJ6Tm1wODBFSmVzUndUWnFtdmdtR2N0cWxGVVVObjlnQXNRSlN4c3oyaVVpZUorbWc2MEFIUTFxcGZ3YU93R2lsczBCMDVPQkFpQkFFZW9HRXNVQVBjMDZ0RXNBV2JBQVZNWUFMQ3VpQmRVVnZIcWl4c01BRFB5aFIxSVJNWU1BSXowZ1c5WW12L2NBTWowQUdieWh6djlLMlFveUMxVWdCRnBRTjRjZ05Fa0VKYkVDcCtZR3J0WVNBS1JxOHN3NE9CZ1FFZFVBSXpVbXNGWWExQndBVFBBaGpYOUFDbFpiQUJnMFFicVFDM29nRTk0R0s3OGl0WDhBL3dpaHZ3TWxrWVN5Nis5a0szVWhzZFVGMDZVZ1lYWUFJYkdHSExIWmF5QWVNWE8vTVBMYXNwcVBOV0Q3QmRPQ3RGenlaL1dnRnROUkVRQUNINUJBVUhBUDhBTEJNQXZ3Q3lBRk1BUUFqL0FBSDhDL0N2b01HRENCTXFYTWl3b2NPSEVDTktuRWl4NGtHQ0JRVWFCRUJRb01BQUhEVWVGQWtTNDBlT0F3YjhVL212UUlBQ0JWb0NpTmt5cHN1WUFURG0zR214cDgrZlFEZU8vS2V4S01pUVJSR0NKSm94STh3Q0R3cEEyREQxUU5TclVoVkFVQ0Mxd0FBSVhtRUdHT0J5SUVHTVpvTTJGS0MyclZ1ZlowT1dKRXJ3S2RnSEQvNDlXUEJ2UTB1Vk1OR3dIT2p5Yk1HY0ErbUtMS0R4NWo4SUJDQzBuRXdBSWR0L2x3Y0tNR3d3d09hR0JESy9IUTAzOGVFQlkxOTJCY3U2SmRqSEN3b3NzR29WOWw2OHVQVnV2WXNYeFFvVUtGajhZNEZpK0FyaEM4RENOTHNaYldlMjBGOG1KcUR6SC9YTk9LRmpUaWlhdEhmVFRUa2oveFRKdFBQSm5WOGZvSmhDWWdTT0VTTnE2Qmp4Yi80SUpQVC9qR0EvWmNVS3ZCczhzSUZzL3l4ZzRBcFRUUEVCZlBCOTRDQjdDL2hWQUZ1VlVXY1RacEpOR01BQkFseFlVR1hRY2ZqZGlFRGRWTmRra3FuMFFBUWt0UGRCRFRYd0VjUS9PY2dBUlE4NUdJUmpFRDhFMFlNTVBmVHdqNUFqZlBEUEJ6MHdxT1FVR3BDd3dqOG9SQkFCWGdZV1VKbVZBb1NtWlpiV2RYa0FBMXlTS09hSUw1MUZVMGhlUGJaQkJCcU1JSU1NUCtSWXhneG51Q0ZFRjNkSzhVOFhCdVhaeFJtQUFpckVvSHIrSTRRVVVuUWhSUmxsdU9BQ2ZDaEVaU1ZrWTFacWFWc0JRRUFXUVJucTlZQ21HRVRBUW9JNjFQQ0RGRzZjUVFRWVJCamhLaEZTNlArZ0FRWXhTVllaRzVmbXFpdHBYYW1rUUFjOTZMa0pFZjlzUWV3bVY3Q2d3R0JRUVJEYnJ0Qkc2eE5OQmVXbDF6OFJ3RkFRQnRWR1JKNUhUWkhFMFVZZHpaWFJYT0NlTzY2MDdGYjZVWG5wamljdlErOFdKQlZWTU4wRjFiMkRGY1FzWVlpcFpwaE9pQjNXN3NFTEZaV1VZZ21aZEpCTEtZMkYybGN3UlRYVlZBSitpbTlZWkFIQWtYaEtBZVVaZDl0cHB4MW16aUhzM2JnNnliWHV3eXl4SnBYRmo0WDFWQUVEMm5RVFl6d0RrTkpLSzBuRkYxOStQYUNTY2plblZYQjFDZEZFM1dFWWJTYTExRkdyTEhKQ0lSbWNGR28yU2RjYXBaOHVBQU9MSzVEd2o0TC9qTkRlRk84aDhSNThPRFNwUVFxUkxvQlh2Z1JZYVJCWkVCei9VTUFCa0FWdVdJZUVFMVFaWld3ZDRDVmxCV1VwQUFOV1d5cVFTek9aMWRVQ0xNS25RNUl6OXVCamo1NFBXWU5CbzZmOU5vTUxGcmxra3l6OGhvTGRmbWNaQUhVVlRqMGhkWkkxWGhua1lYWVhPWWs0bFpWaW12bEN0UUFLN2RVWDVKQ2UyL2dQRkZDVUFjVS9RVlJmL1Q4eXpCZ0VIMi9Ld0gzMzRIY1A0L2dmckJDZ2xhRWRjRUNtdjdmZkUwNERFNlhBaW15U29NSDlHa3hSZ3d3enVQRUNzVWI0QnhHVThJOHpDUENBdVFnVXNZaVFoQmxNd1ZydWkrQ2xwRUlXRDBCbENoZVFnUlNFOEk5TklGQ0FRZ2lDQ1dnbHN3UDRSWUlvL002K290SVhER3lnQTBoNG5wQVNFcURIdEFTQ0Jtc0t1Wmdpcm9IMGNDa3BES0piLzk2VmxHK1pCNGdOVzlmTEZ0YVpscFRwSm9BaGp4Qi9aOFFpK2hDSjVpR1h5MjUyTTVrOWhTdzE4ZEJPUnBhVHNxUnNpbU5DeTdjNm9xNnNFY1dOU3RISVMvUVZHMmMxNjN4UkdjQUd5RElnc2p4bEoyWU1tR2tLaHNZeHhXc29ER01JRmlkakU4bGNSUzlkdWFGWE5IVXhtOTJNa0JkUnk4aElackpDUXNSalBQU2hRc1pTdVltRlVVMVQ2VXZHL0lhMEFRQmdqeVhoQ1ZyT2NrYUhMTWRlbDhrbHlxUldzb044Sm1BZzgrUkNuRk9TY2ZXTVo0KzVtOGJ5TXNuaWhXVmc0cEdpdlQ3ME53TVZTREo4cWN4WjJGSzFuUHp5SXA5cG5FNHljN2p0Q0ZPUlY1eEpLV0ZDc2RiWUJDdWY0cUpCV0FNV0Q1QkZKVFA1Q2xVR2dQOFh2ZndIQnJnQnk4UUdKaHB1aHZNeWlDbW5aZ2J5TkxSa3huZEJqSXNvQ1JNZWo4d3hRQ2U4MW0wS0JDWC9qT3BzdzlHQWNFUzZndnV4WUcxcVk4OC9WbUEzU1FXT2RwNjVDYmlvTmNqTndIU2FaZG9PaHlxanVKNCtya3NvNUF3Ym5mTXRaTTRFTFlDWkl6L3pFb0d5S1FnSFUxQ1NWS0dxZ1gvTWpUZ3N3TTNOQ0JBWkE4RmdCUTdvajM4Y3dGS3hHTTR6MHBuZFN3VEFwWjMrbzZlK1BFQUNRdlBXS1pMa2lvZzhsOE9XVWpCc1BzQkZPa0FTODRLMHZJUEE1MndhQUE1V3k3WUNIa2dWUGpWNGtZTjQ4THJseE5RNlphSXJCSDVKbloxbUtRRnZwWkFBRUhET2lvQUxNUzZCektjaUVGVWRiRzRFUWJpQ2o0S1FJK3oveGVGTk9Kcmg4bnFBSk1rV2FVRnBZMUtDVExxQ0NNVG1iOWJoS2xjSmtxWDBkZWs2bmtXQVhNMVoyb3FZcVlsZjRXZEwvTkxVL01XSER3WDVBZlp3NUx3Z1RHOUdQUnBTZk5LV3R2aDhnQTlGR2w4UHhrZStEemdKT0JHQ0NlRkFOS0hORWtCeDFWVmhHRDEwbDZiYTkwVzBaUlNpRklXb1FqSHFIMlg0aDU2Nm9PQXlMR3BST1lpd0M2U1FZVWZKd0FXNDNROUxIL0RmdWdJNHdDclRDV01PUW9MOVJiZ2dqSkplOXFMWGhSZjhUNEJLeUhHT2Nmd0NBNTRCVDNVU3dneWtJSU1QWkRVeUpVWnhDak5GRUpYODdHZFE4YzJMWkpDREhQd2dTQnAwQXhFTStBOGo1SUlJQ2VRd2Zxb3FLWVVxMlpOUEJMQkF1UVVWRnRVZy84TlM0TElCdDN3R0tmU0FCYlRxaXQvTWZPWUFGOENDRmx5V0FwWlFoaDRMa0ZnRk1RS2ZPaEF6UGZmNTBYMmh5UU1VZ0FFZlhFRUttNWplRmd3eXdyNnd4aTlVZ2JTUzJZQ3ZnMWdyQWxhTm9kb080Z0dxREVqVXNEYUlDekdBdzU3SWNaam5Fa3FzSDAxRUhmWWFpVXNzMTBYdUNwNWRXMDJOQ3BIaVNSSWpsMFFpa1duamlVbS9qSjBySTVabkpNS09vMkxVV0IxdUg5V1VKeUlZdFVuVGEzaGh1MTVKbkdneDY4TEZkdWN6TVdaTXpFNCt4cE54V3dUWnlhYkxLSmU5N3IxSkpUS3lBUXVTa1NiUXAwQU5tQ2FhbmIxOVl1MTR1ZEhheVFiSnZTNG1vRXJ5UlRrVWswcE42c0xrd3NneUxVMWNPTmFZN1d0UnVtemtEZjhUWmI2V0NSVklQZ0RBWDdSWnppNVpwcVVOc3RnUjJXYWZwUm5LYzRkcjN5ZEt6eDBoa0pma3VCb21YSm1memJLTFRGbldHNU01MTh3bU80bGljTGtNaUV6YzRWTFl5ZlZKVWdXZU9KdUtIdlBJc1EzNERINW1FZXE5RjlxNFhvWXNtR2pFdWhiTGhlNmdMWjJkZk51WHA2K0MwYTF3Y1NhRnVYa3RKN0pKYzBLVW9BNXQrNjdyUlJPTWlJVTFCSGc1QzIzWTZnRjRnQTJWQzJUYUU4TVNscXk0S1RiSlcwenlCcDYwNWxEZW1Td1oxUWZ2U2JuRXI1akhyTXBlV3A1SFpoYmNSR1dSQ2RBbUE3VEZKUGR2T0JNOTczMVpiR0sybmEyOVJDdnhxenRMZWN1RmEvNjZsNnZ4VXNIVi9ORXNjclQ2ejYwRWZLdEVKaStLNjF2LzR3UFAzT0liQlBsVEt4bE9VQllhaGJQZWZYTVJ6OEFBWHl2bFpDZ2xYa1FhVFc2V2twUndUQ0JnOUdvblJIUjVjUnRJSTNITVZUVks4VXNkSWs2RUExU1hVVTZIdzJjU0ZCZnh0emV1Y1M4YWFFRVhFeHQ0NFN5VUFvS2ZNb0lRb0NuOUJ4ajk5QURhNGg4RmNSd3RaVlpTNTNZSUZUekhaeEFhOGhuUUVTWVRpQmtVdUdUUDl4ZjVrb0dmcGpoRHN3RUdZazMrTkRiKzhTUXN3QmRTQWlWTjFUb2laVDhuMVlLMzBSVUpWM2dFNDAwakl4cFJVMzZHZDM0eWlFS0hORkVNOFdkLzlnOGVVRE1HMFZKTTlROHRVbFVGVVZWVlJRSWwwQ1lsTUFKNW1JY214UUpUTW50N0JuQU9BeGpNVmhhWk1TRXQwU0ZycFNHWVpWQ1kvNEY4aWhkRVVrUjNKakVXUCtjelRTWVZkNkVYZkxHRXllTWVPR0E2N3VFMmJqTUNkYmdDS1dDQWtFZDZCVUYwWXJNQUJwQUJzRGdiMnVRU0VhaHdHdEo0am5neW9GVVFjblZpN3RORERtY3U4QUpOTWhFV2VZRThMY0kyaCtWYWZyQUVTREFmU0tBQmQyZy93YUZWU1BOV0tvZ2dDZEtOVS9BSEpBQURPV01RVnpKTnZKY1owQ1lBb0RWZHBDV0pwcEV1emVad1dsTW1nRmNReDlNaUgvQWVCZkZhcnpWRDdRV0hKQ0FsQUZKMDZsRTJmN0FnTlpBa3ZNVUhrY1VETEtWTm5YRWRhelV5TWZGTkNFRmFvSlVBRUVXR0RTRVNwelYvOW9JemVORWVSVEpmdTNWbE9wS1FSbUlrYXRNaUpBQUNVd0FDK3pFQ1NSSWZTeklDSVAvZ2dwQmhSamFsVmx0U1YyeVZPd2VCQUtORlhhSUdqK0NoTTVHM0FDc0FXVFI1QmFGREl3VUJKRG5BSXo4QUk4dURPci8xSWpYd1cycURQeXpRT2l4MUFIbERPNlBYZ0JwU2ZwM1ZkaUxpT0NKWEZvUllKcTlSTnBvVEpENHlQZWRWRU9ZRkpPTTFJME1TV0x3Vkk3eWxPaVBnV04yb0FjY0JJQm1WWEYyU2crZzNJUUxBSVRuWWppSTNFRnd6T1RYUkZ3R3lJaWpBSVBOVlBkTWpBLzhRQjFQNUExQlFsVDBnWGxmR1cwZFNrelFwVmUzMUhsVGxrcjloVFllelZyTHpYeFFTaVpWcEwyaEJVN2xUbG5oUlVrT2lsNTVUQTNmNVBOSkRQZGRURUlUMW5PcDFQYUlKSkFrSkkxZnBJQTdpQUROWFl0ZmhscjJaTUU3a1JHbi9tQmgrZ3hGTk5RWC9rSkJEY3BkNHFTZ3dKajN3R1QweUVHRVJKZ05kTUo5eTRpZ2c5bUZ2d2lOODBBTTRJQ1ZHK0Y5Z3VKSGYyUkJQMUhGL1FSQUJFZ0U4NEdJWlptRnVrQ2djSkdFV3RpY0Z3U2NZaWlnRmNTZ045cUZTTUFPTkFpYzF3QU1DNGhJZ0Fvd0hPaEZDQ1lRSk1UK29kaHd1aGlvL2hxRjdraWlKY2hBdjhBOEVwQVJuUUVBK1prQkNVR2VJMGlnLzhBRlZ0WmdyT2hyVWNpSmc0VE1Qa0FMcmhaVWpZQi83NHdiK293UzVVQVJkUmtBOXBxSC9rQXNIMUdNdjRBWXpJQVAwVVd0TCtoMjRrbnNZNkJXVTlnQzB0bElmb0VGQ1FLWlM4QUpmUUFRN1drQ3RVaEIwaGlneVVBTWtZREYrczZiUTRrcE5kbmF1K1BoVjdRVWZlVmdETGxCakJOUXF4bEpBVURDTkdLQUFBOUtpaUFvdG1aSmEwckVjYTdnaUNKSkJFZ1lvVythblNsQUdRYUFzbnZjWXVQS3AwaUlWVEZZejJUVUFLL0FCRjdCaFE5b0ZIaFNtZk5vRlYvQVBKS1NKdEJvNUZNTjBMcVFCcC9JbmlMWnB4ZElGcjNxc1lIR295YW95M01JVmZqY0FJK0FDcXVwQlczQ3BWK0FEM0dJUUowUlQyVnFycm5ZWEEvQXJTNUFEd0NwQTQwb0VtZG9CV2lGSnNrRWc2OW91anlRaG05b0JPaUE5TnpBc0JkUUQrTHBDQm1GQy9hb3lyYWFHQWFJQUVXQUI2WGtRUHlBY0c3Q0dNV0ZCYXRxdzBjSUd0TFlCNStvWDNCS2pxRFpwR0tBU3MrcXg3ak5wTFJTeFBoRVFBRHM9XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hc3NldHMvaW1hZ2VzL2NpdHkuZ2lmXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdlcy9sb2dvLXZ1ZS5wbmc/MGVmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQ0FBaUMiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFaQUFBQUdRQ0FNQUFBQzNZY2IrQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUNCalNGSk5BQUI2SmdBQWdJUUFBUG9BQUFDQTZBQUFkVEFBQU9wZ0FBQTZtQUFBRjNDY3VsRThBQUFDTVZCTVZFVk1hWEZCdUlNOGRuQkJ1SU5CdUlNNFhHWkJ1SU03Y1c1QnVJTkJ1SU0zVkdNOGVuSkJ1SU02YTJ4QnVJTkJ1SU0xVFdBOGVIQkJ1SU01WTJsQnVJTThkRzlCdUlOQnVJTTRXbVU4ZW5KQnVJTTZiMjFCdUlOQnVJTTJVbUk3ZVhGQnVJTTZhR3BCdUlOQnVJTThkM0JCdUlNNVlHZEJ1SU03Y201QnVJTkJ1SU0zVjJROGVuSkJ1SU02Ykd4QnVJTkJ1SU04ZVhGQnVJTTVaR2xCdUlNN2RYQkJ1SU5CdUlOQnVJTThlbkpCdUlNNmFtdzhlSEJCdUlOQnVJTTVZV2hCdUlOQnVJTThkRzlCdUlNM1dHUkJ1SU03Ym0xQnVJTTJVR0ZCdUlOQnVJTkJ1SU5CdUlNOGRuQkJ1SU00WG1kQnVJTTdjVzVCdUlOQnVJTkJ1SU04ZUhGQnVJTkJ1SU5CdUlOQnVJTkJ1SU03YjIxQnVJTkJ1SU02YVdzOGQzQS9ubnhCdUlOQnVJTThjMjlCdUlOQnVJTTdiVzFCdUlOQnVJTkJ1SU02Wm1wQnVJTkJ1SU03Y1c5QnVJTkJ1SU5CdUlNNmEyeEJ1SU04ZVhGQnVJTkJ1SU04ZEc5QnVJTkJ1SU5CdUlOQnVJTThlbkpCdUlOQnVJTkJ1SU5CdUlOQnVJTkJ1SU5CdUlOQnVJTkJ1SU01WUdjMVNWNDFTbDVDdDRJL25udzdjRzVBcW44MlQyQTlnM1E4Z1hOQnRvSTNXR1ErbEhvNlptbzVaR2svbzMwMVMxNDdkbkJCcjRBMlUySTJVV0U5aVhZNFcyVTFURjgvbVhzNmEyeEJxSDQxVFdBOGZISkJzNEUzVldOQ3NZQStqM2c1WVdnL29IMUJySDg2WjJwQXBuNDdlSEE0WG1jK20zczdiVzA5Zm5NK2tYazhjMjlCcm9BL2wzbzZhR284ZW5JK2kzYzdibTA5aG5VK2pIZi8vLzhKTStiR0FBQUFoSFJTVGxNQXdrMHYvdStaaVJYdit3MXd1UVRXL2pGSTNMUmlKZnIwQW9xYkR1cjlHbUxIQXN3L091ZWxkeHIyK0FoOHJnamVJbFBXdjFiOGxoSVNiYncwMDBYaVJMQm5JZmFIbitiOUMxNEJ4MFkzNnFGODgzZ0hLbEM3dWl1U2srMXB3RGdEUUt4djk0U21nK1JhMERPZGdSZnlkYlhhTEV1M1hTajdqeEFXWnM4K3FCNkE0bGNIMnoybEFBQUFBV0pMUjBTNm83RkgyZ0FBQUFkMFNVMUZCK0VDQ0JFS0JxRFFuZkFBQUE1b1NVUkJWSGphN1owSm8xZlRIb1ozZzRnYzVKQ1NTaVJGR2h4TmRKVkVBMG1scXdqRmpRZ0hKM1NsOFZhR0tKZktFSkprbHNqMDdlNE4xUm4rd3g2ZXRkYTc5djQ5SCtDL2YydTk2NXpPT1c5N1BVbGlHSVpoR0laaEdJWmhHSVpoR0laaEdJWmhHSVpoR0laaEdJWmhHSVpoVkpWZS8ySFpzUk5pVjI5M2krNjlpNXB5eDJ2czl2VksrdlJsUC9GMWJLMW51UXZrTE96VXZNN3VYdDgrU2RJUC9oSjVnMXJzenJOZDVYRTJOdUliOE9iMSsvOTA1L1JuUC9QTjNkUnF6ejNQVFI3bm5VdE51UHROZHUvNm4zTnl2Z0Z3eW05aDUrOThONEdjanczNE5yeDFBLzZjcitVQzlsUDM3S1hXZStGRkx2SzQ2RUpxdnIxNzJKMjdvT1d2Q1FmQ09iK0RuY0NMWFFSeU1UYmVPL0RHRFR3MVlpdjh3Zi9GbG53Sm44Y2wySER2d3R2V2VuckdTd2V4bi96ZVBtck5sdzJtOHhoOEdUWGJ2dmZZWFJ0MDZaa3BoOEJaNzhkTzRlVjBJSmRqbysySE4yMUlweW1IWHNGKzlvSDNxVlVQRzg3bU1Yd1lOZGtIQjlnOXUySm81emxId0dsL2lKM0RLOWxBcnNRRyt4RGVzaEZkNWh4NUZmdnBlejZpMW4zd2FqS1BxdzlTYzMwRS84aDcxY2l1azQ2QzgvNFlPNG5Ya0lGY2c0MzFNYnhobzdxUE9ocCt3Q2ZZMHEvbDhyZ1dHK29UZUx0Rzk1aDF6RmoyQ1o4ZW90WiszZlZVSHRkZlI4MTA2Rk4ydDhhTzZUbnRPRGp6ejdEVGVBTVZ5QTNZU0ovQm16V3V4clRqSjdEUE9QdzV0ZnJkRTVrOEptSi9oLzc4Q0x0WEU4YlhtbmNTblBvWDJIbThrUW5rUm15Z0wrQ3RtbFI3NERiNE1VZXA5ZSs2aWNqakpxekxQQXB2VkZ1ZGlmdE1acC96cFZhYks5dmJUdTVUYitRcGNQSlNiYTV1Ynp1bDdzeFQ0VGIzSzY3Tm5WWTBqMmxjYi9zVnUwdjlwOWFmZWpxY1BkZm0zbHcwa0p1eFVkNkNOMmw2ZzZsMTI5eER0eFRMNHhiczkxUzZ0NTNSMG1qdWY4RHBjMjN1cmNVQ3VSVWJoTzV0WnpZZWZCYjh1Syt4amJpdFNCNjNZV044RFcvUXJDYVR6NGJiM0crd3YzZmYzcEkvajViYnFTa09mc1B1ejZEWnpXYWZBNStBYjdHemVVZitRTzdBaHZnVzNwNDVUV2NmZWlmN3hBTWZVSHN4TjNlYk8zd3VOUVBkMjk0NXIvbjA4K0V6SU5EbTZ2YTI4MU5NditBdTlwbXZmVWZ0eHI2NzgrVnhOL2Eva3I2RFh6NjRhMEdhK1JmQ3ArQjc3SHpla3krUWU3QUJ2b2UzWm1HNkJTeUNIL3NEdGlIMzVzbmpYdXp4UDhBYnN5amxDc1lzWnAvTHZhQ1FwODNsZXR2ZGNHKzdlRXphTlN5QlQ4SXg3SXptYUhPNTN2WVl2QzFMVXE5aHFXNmJlMS9XUE83amV0dkQ3SzVNV0pwK0ZjdmdzL0FqZGtvenQ3bTZ2ZTJ5TE12NEovendkNmxkeWRybWNyMHQvZkxCL1puV3NWeTN6YzMwZ3NKZ3JyZjlrdDJSeWN1em5hd1Y4SGs0am4zbmVDRExNaDdBSG5zYzNwQVZHYi8xVG4yUWZmNVAySiswaG1Wb2M2ZHhMeC84eE83SGcxT3ovbU80RWo0UlhKdjdVUHBGUElROWxPNXRWMmIrOGIxbEJqc0IrSUxDdzJuWDhMRHN5d2N6SHNuK0M5VXErRXo4akozVzFHMHUxOXYrREcvR3FqeC9BMW9ORDNFQzI1NUgweTNnVWV5QkorQ3RXSjBuajJUMlkrd1V2dHRjM2Q3MnNkbTVBa24rQlorTFg3QVR1eWJOK0d1d3g5Rzk3ZVA1OGtqbVBjSE9jUVI3TjNkdWloY1VKbUs5N2Z0SDJIMTRZbDdPUUpLMThNbjRGVHV6VHpZZi9rbnNZYi9DMjdBMmJ4N0tiVzdUNitaNlI5N2IxdWFwdnV3czNIVnpUZHRjckxmZEJmZTJmWjlLQ3JBTy9tcjlEZnMrOG5UandaL0dIdlFidkFYcml1U1JQUE1zTzQydjYrWjBMNDE3OXBsQ2dTVHQ4UGw0R3p1NXp6VWErem5zTVhSdjIxNHNqMlRwOCt3OGg3RVhGSGEvVUgvcUY3QXZ4TDF3Yi92ODBvS0JKQjN3Q2VIYTNBYlh6WEdYeHYwSUw3OGpLY3g2ZUNTdXpYMngzc2d2eXZhMjY0dm5rYnowTWp1VCsrdm1kQytOZS9rbElKQmtBM3hLOW1QZlQrcTB1YnE5N1FZaWorVGY4SFZ6WUp2N1NxMTVYNUh0YmJ0ZUdwZWZqZkE1K1IwN3dUVmZVT0JlUHZnZFh2aEdKbzlrNUt2c1hHNnZtOU85Tk83VmtWQWd5U2I0cERpOWJvN3JiZWxMNHpZbEdKdmgwYmpyNW5xMHVicTk3V1l1ajJRTGZOMGMxK1oyZjBHQmUvbUE3bTNIYmdFRFNiYkNwOFZabTdzRysrQmY0Q1Z2SmZOSXhtOWpwenZpNkxvNTNVdmp0bzFIQTBtMncrZmxEK3drZDJsenVkNzJEM2pCMjlrOGtnVlJ5TU9VWlY4MFVjakRwR1ZmTkJISXc3UmxYelQ2OGpCMTJSZU52RHhNWGZaRm95NFAwNWQ5MFlqTHd5S1FmZEcwd29PaThyQVlaRjgweXZLd09HUmZOTUx5c0Roa1h6UzRQSXhyY3lPUmZkSG95c013M01xK2FIVGxZUlN1WlY4MHV2SXdDT2V5THhwZGVSaUNlOWtYamE0OGpNQ0g3SXRHVng0RzRFUDJSYU1yRHl1T0g5a1hqYTQ4ckRDZVpGODBiZkRZUjFYeThDWDdvdEdWaHhYRG4reUxSbGNlVmdoL3NpOGFYWGxZRVh6S3ZtaDA1V0VGOENuN290RnRjL01UUzI5YkcxMTVXRzQ4eTc1b2RPVmhPZkV0KzZMUmxZZmx3Ny9zaTBaWEhwWUwvN0l2R2wxNVdCNXcyZGRRNzRFSXk4TnlFRUwyUmFONzNWeDJsQzZOeTQrdVBDd3pnV1JmTkxyeXNJeUVrbjNSNk1yRHNoRk85a1dqS3cvTFJEalpGNDJ1UEN3TElXVmZOTHJ5c0F3RWxYM1J5TXJEMGhOVzlrV2pLdzlMUzJqWkY0MnVQQ3dsb1dWZk5McnlzSFNFbDMzUjZNckRVaEZlOWtXakt3OUxnNExzaTBaWEhwWUNDZGtYamE0OHJDa240TkZYSytRaExBOXJob3JzaTBaWEh0WUVGZGtYamE0OHJERTZzaThhWFhsWVEzUmtYelJ4dHJubDZHMXJveXNQcTQrVzdJdEdWeDVXRnkzWkY0MnVQS3dlYXJJdkdsMTVXQjNVWkY4MHV2S3cydWpKdm1nNjRCUG51TTBWbEgzUnlNckRhcUVvKzZMUmxZZjFSRlAyUmFNckQrdUJwdXlMUmxjZTFoMVYyUmVOcmp5c0c2cXlMeHBkZVZoWGRHVmZOTHJ5c0M0SXk3NW9kT1ZoblRnQkQ3bFpOdzloZWRnWnRHVmZOTHJ5c05Ob3k3NW9kT1ZocDFDWGZkSG95c1ArUmwzMlJhTXJEL3VMSGZCNHZjVHpVSmFIblNRRzJSZU5yanhzWnh5eUx4cGRlVmdzc2k4YVhYa1kvdkxCZ0JqeUVMNXVMdTVMNC9Jakt3K0xSdlpGMHdvdkhKS0h4U1A3b3RHVWg4VWsrNktSbElmRkpQdWlVWlNIeFNYN29oR1VoOFVsKzZMUms0ZkZKdnVpa1pPSFJTZjdvaEdUaDhVbis2TFJrb2ZGS1B1aWtaS0h4U2o3b2xHU2grR1h4b24zdHJVUmtvZEZLdnVpYVlPMzRXamVQR0tWZmRHb3lNUGlsWDNSaU1qRDRwVjkwV2pJdzJLV2ZkRkl5TU5pbG4zUktMUzVWZTF0YXlNZ0Q0dGM5a1VUWEI0V3UreUxKclE4TEg3WkYwMWdlVmo4c2krYXNQS3dNc2krYUlMS3c4b2crNklKZWQxY21TK055MDlBZVZoSlpGODB3ZVJoWlpGOTBZU1NoOUV2SHl5T3NMZXRUU0I1V0hsa1h6Umg1R0Zsa24zUjBQS3dWRzF1cVdSZk5BSGtZZVdTZmRINGw0ZVZUZlpGNDEwZVZqYlpGNDF2ZVZqNVpGODBudVZoNVpOOTBmaVZoNVZSOWtYalZSNVdTdGtYalVkNTJBbjRVUnF5THhwLzhyQ3l5cjVvdk1uRDZFdmpWR1JmTkw3a1llV1ZmZEY0a29lVlYvWkY0NmZOdGQ0MlBUN2tZZmlsY1ZLeUx4b1A4ckJ5eTc1bzNNdkR5aTc3b3FIbFljZGM5N2J0NWM3RHVUeXMvTEl2bWc3NEJIZVRoMVZBOWtYalZCNVdCZGtYalV0NVdEVmtYelMwUE95NHU5NVdVL1pGTTlTWlBLd3FzaThhWi9Ld3FzaSthRnpKdzZvais2SnhKQStya095THhvazhqTDQwVGxuMlJlTkNIbFl0MlJlTkEzbFl0V1JmTkx3OHJHcXlMeHBjSGxZMTJSY09MUStEMFpkOTBkRHlNSllZWkY4MC9aUURpVUgyUlVQTHcwamlrSDNSRE5BTkpBN1pGdzE5M1J4SDNKZkc1V2VnYWlEUnlMNW9Xalh6aUVmMlJVUEx3eGhpa24zUkRGRU1KQ2JaRnczZDVoSlVwYmV0elFpOVFFWlVPUTljSGxhYzJHUmZOS1BVQW9sTzlrVXpXaXVQK0dSZk5MUThyQmd4eXI1b3hpa0ZFcVBzaTRhV2h4VWhUdGtYelNTZFFDS1ZmZEcwcWVRUnEreUxocGFINVNWZTJSZk5GSTFBNHBWOTBVeVZhSE5qbG4zUlRGY0lKR2JaRjQxQ20xdlYzclkyTThNSE10TlM2TXlzMEhuRUx2dWltUjI0elkxZjlrVXpKMndnOGN1K2FHaDVXRGJLSVB1aW1SOHlrRExJdm1qbzYrYXlVT1pMNC9Lek1Gd2dKWkY5MFN3S2xjY2kyL3VhMFBLd3RKUkg5a1d6SkV3ZzVaRjkwU3dOMHVhV1NmWkZzeXhFSUtXU2ZkSGM3eitQY3NtK2FKWjdiM1BMSnZ1aVdlRTdrTExKdm1ob2VWZ3p5aWY3b2xucE41RHl5YjVvSHBuaE00OHl5cjVvVnZrTXBKU3lMNXJWL3ZJb3AreUxocGFIMWFlc3NpK2F4MzBGVWxiWkZ3MHRENnRIZVdWZk5HdjlCRkplMlJlTm56YlhldHYwMFBLd1dwUmI5a1d6em4wZzVaWjkwZER5c0o2VVhmWkYwKzQ2a0hiYjQwelE4ckR1bEYvMlJkUGhOcEFLeUw1bzFydk1vd3F5THhwYUh0YVphc2krYURhNEM2UWFzaThhZDlmTlZmdlN1UHhzZEJWSVZXUmZOTFE4N0JUVmtYM1JiSElUU0lWa1h6U2JYZVJSSmRrWHpSWUgxODFWUy9aRnM1VVBwRnF5THhwYUhsWTkyUmNOTFErcm51eUxCcGFIVlUvMlJjUEt3Nm9vKzZKQjVXRlZsSDNSa1BLd2FzcSthRUI1V0RWbFh6VGNkWE4yYVJ3REpnK3JyT3lMcHBYSm83cXlMeHBHSGxabDJSY05JZytyc3V5TGhtaHpyYmNsQWVSaEkyd1hRWXJMdzZvdSs2SXBMQStydk95THBxQTh6R1JmTk1Ya1lTYjc0aWtrRHpQWkYwOFJlWmpKdmx4UVFCNW1zaThudE9YTncyUmZic2dyRHpQWmx5dHl5c05NOXVXS2ZQSXdrMzI1STVjOHpHUmY3c2pUNWxwdjY1SWM4ckNadG1zdXlTd1BNOW1YVzdMS3cwejI1WnFNOGpDVGZia21tenpNWkYvdXlTUVBNOW1YZTdKY04yZVh4dmtnZ3p6TVpGOWVTQzBQVzJSNzVZVzA4akNUZmZraXBUek1aRisrU0NjUE05bVhQMUxKdzB6MjVaRVU4akNUZmZta3VUek1aRjkrYVNvUE05bVhYNXJKdzB6MjVac204akNUZmZtbXNUek1aRi8rYVNnUE05bFhBQnJJdzB6MkZZTDY4akNUZllXaHJqek1aRjlocUNjUE05bFhLT3JJdzB6MkZZcmFiYTcxdHVHb0pROHoyVmRJYXNqRFRQWVZrcDd5TUpOOWhhV0hQS3pkOWlRbzNlVmhKdnNLVFVmWFFFejJGWnd1OGpDVGZZV25zenpNWkY4S2RKS0htZXhMZ1RQWHpkbWxjUnFjbG9lWjdFdURVL0l3azMycDhMYzh6R1JmTXZ3cER6UFpsdzRuNVdFbSsxSmlxOG0rdEJpL3pXUmZXbXczMlpkaEdJWmhHSVpoR0laaEdJWmhHSVpoR0laaEdJWmhHSVpoR0laaEdJWmhHQ1QvQTllbGdpck05c1BjQUFBQUpYUkZXSFJrWVhSbE9tTnlaV0YwWlFBeU1ERTNMVEF5TFRBNFZERTNPakV3T2pBMkt6QXdPakF3V2lYMTVRQUFBQ1YwUlZoMFpHRjBaVHB0YjJScFpua0FNakF4Tnkwd01pMHdPRlF4TnpveE1Eb3dOaXN3TURvd01DdDRUVmtBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXNzZXRzL2ltYWdlcy9sb2dvLXZ1ZS5wbmdcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n  * vue-class-component v6.1.2\n  * (c) 2015-2017 Evan You\n  * @license MIT\n  */\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar Vue = _interopDefault(__webpack_require__(2));\n\nvar hasProto = { __proto__: [] } instanceof Array;\nfunction createDecorator(factory) {\n    return function (target, key, index) {\n        var Ctor = typeof target === 'function'\n            ? target\n            : target.constructor;\n        if (!Ctor.__decorators__) {\n            Ctor.__decorators__ = [];\n        }\n        if (typeof index !== 'number') {\n            index = undefined;\n        }\n        Ctor.__decorators__.push(function (options) { return factory(options, key, index); });\n    };\n}\nfunction isPrimitive(value) {\n    var type = typeof value;\n    return value == null || (type !== \"object\" && type !== \"function\");\n}\nfunction warn(message) {\n    if (typeof console !== 'undefined') {\n        console.warn('[vue-class-component] ' + message);\n    }\n}\n\nfunction collectDataFromConstructor(vm, Component) {\n    var originalInit = Component.prototype._init;\n    Component.prototype._init = function () {\n        var _this = this;\n        var keys = Object.getOwnPropertyNames(vm);\n        if (vm.$options.props) {\n            for (var key in vm.$options.props) {\n                if (!vm.hasOwnProperty(key)) {\n                    keys.push(key);\n                }\n            }\n        }\n        keys.forEach(function (key) {\n            if (key.charAt(0) !== '_') {\n                Object.defineProperty(_this, key, {\n                    get: function () { return vm[key]; },\n                    set: function (value) { return vm[key] = value; },\n                    configurable: true\n                });\n            }\n        });\n    };\n    var data = new Component();\n    Component.prototype._init = originalInit;\n    var plainData = {};\n    Object.keys(data).forEach(function (key) {\n        if (data[key] !== undefined) {\n            plainData[key] = data[key];\n        }\n    });\n    if (process.env.NODE_ENV !== 'production') {\n        if (!(Component.prototype instanceof Vue) && Object.keys(plainData).length > 0) {\n            warn('Component class must inherit Vue or its descendant class ' +\n                'when class property is used.');\n        }\n    }\n    return plainData;\n}\n\nvar $internalHooks = [\n    'data',\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeDestroy',\n    'destroyed',\n    'beforeUpdate',\n    'updated',\n    'activated',\n    'deactivated',\n    'render',\n    'errorCaptured'\n];\nfunction componentFactory(Component, options) {\n    if (options === void 0) { options = {}; }\n    options.name = options.name || Component._componentTag || Component.name;\n    var proto = Component.prototype;\n    Object.getOwnPropertyNames(proto).forEach(function (key) {\n        if (key === 'constructor') {\n            return;\n        }\n        if ($internalHooks.indexOf(key) > -1) {\n            options[key] = proto[key];\n            return;\n        }\n        var descriptor = Object.getOwnPropertyDescriptor(proto, key);\n        if (typeof descriptor.value === 'function') {\n            (options.methods || (options.methods = {}))[key] = descriptor.value;\n        }\n        else if (descriptor.get || descriptor.set) {\n            (options.computed || (options.computed = {}))[key] = {\n                get: descriptor.get,\n                set: descriptor.set\n            };\n        }\n    });\n    (options.mixins || (options.mixins = [])).push({\n        data: function () {\n            return collectDataFromConstructor(this, Component);\n        }\n    });\n    var decorators = Component.__decorators__;\n    if (decorators) {\n        decorators.forEach(function (fn) { return fn(options); });\n        delete Component.__decorators__;\n    }\n    var superProto = Object.getPrototypeOf(Component.prototype);\n    var Super = superProto instanceof Vue\n        ? superProto.constructor\n        : Vue;\n    var Extended = Super.extend(options);\n    forwardStaticMembers(Extended, Component, Super);\n    return Extended;\n}\nvar reservedPropertyNames = [\n    'cid',\n    'super',\n    'options',\n    'superOptions',\n    'extendOptions',\n    'sealedOptions',\n    'component',\n    'directive',\n    'filter'\n];\nfunction forwardStaticMembers(Extended, Original, Super) {\n    Object.getOwnPropertyNames(Original).forEach(function (key) {\n        if (key === 'prototype') {\n            return;\n        }\n        var extendedDescriptor = Object.getOwnPropertyDescriptor(Extended, key);\n        if (extendedDescriptor && !extendedDescriptor.configurable) {\n            return;\n        }\n        var descriptor = Object.getOwnPropertyDescriptor(Original, key);\n        if (!hasProto) {\n            if (key === 'cid') {\n                return;\n            }\n            var superDescriptor = Object.getOwnPropertyDescriptor(Super, key);\n            if (!isPrimitive(descriptor.value)\n                && superDescriptor\n                && superDescriptor.value === descriptor.value) {\n                return;\n            }\n        }\n        if (process.env.NODE_ENV !== 'production'\n            && reservedPropertyNames.indexOf(key) >= 0) {\n            warn(\"Static property name '\" + key + \"' declared on class '\" + Original.name + \"' \" +\n                'conflicts with reserved property name of Vue internal. ' +\n                'It may cause unexpected behavior of the component. Consider renaming the property.');\n        }\n        Object.defineProperty(Extended, key, descriptor);\n    });\n}\n\nfunction Component(options) {\n    if (typeof options === 'function') {\n        return componentFactory(options);\n    }\n    return function (Component) {\n        return componentFactory(Component, options);\n    };\n}\n(function (Component) {\n    function registerHooks(keys) {\n        $internalHooks.push.apply($internalHooks, keys);\n    }\n    Component.registerHooks = registerHooks;\n})(Component || (Component = {}));\nvar Component$1 = Component;\n\nexports['default'] = Component$1;\nexports.createDecorator = createDecorator;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1jbGFzcy1jb21wb25lbnQvZGlzdC92dWUtY2xhc3MtY29tcG9uZW50LmNvbW1vbi5qcz82NDkyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYzs7QUFFNUQsK0JBQStCLGlGQUFpRjs7QUFFaEg7O0FBRUEsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHFDQUFxQyxFQUFFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixFQUFFO0FBQ3hELDJDQUEyQyx3QkFBd0IsRUFBRTtBQUNyRTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMENBQTBDLG9CQUFvQixFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7O0FBRUE7QUFDQSIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAqIHZ1ZS1jbGFzcy1jb21wb25lbnQgdjYuMS4yXG4gICogKGMpIDIwMTUtMjAxNyBFdmFuIFlvdVxuICAqIEBsaWNlbnNlIE1JVFxuICAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIFZ1ZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd2dWUnKSk7XG5cbnZhciBoYXNQcm90byA9IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXk7XG5mdW5jdGlvbiBjcmVhdGVEZWNvcmF0b3IoZmFjdG9yeSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIGluZGV4KSB7XG4gICAgICAgIHZhciBDdG9yID0gdHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyB0YXJnZXRcbiAgICAgICAgICAgIDogdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoIUN0b3IuX19kZWNvcmF0b3JzX18pIHtcbiAgICAgICAgICAgIEN0b3IuX19kZWNvcmF0b3JzX18gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgQ3Rvci5fX2RlY29yYXRvcnNfXy5wdXNoKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBmYWN0b3J5KG9wdGlvbnMsIGtleSwgaW5kZXgpOyB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCAodHlwZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlICE9PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWUtY2xhc3MtY29tcG9uZW50XSAnICsgbWVzc2FnZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb2xsZWN0RGF0YUZyb21Db25zdHJ1Y3Rvcih2bSwgQ29tcG9uZW50KSB7XG4gICAgdmFyIG9yaWdpbmFsSW5pdCA9IENvbXBvbmVudC5wcm90b3R5cGUuX2luaXQ7XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2bSk7XG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2bS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleS5jaGFyQXQoMCkgIT09ICdfJykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdm1ba2V5XTsgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZtW2tleV0gPSB2YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIGRhdGEgPSBuZXcgQ29tcG9uZW50KCk7XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5faW5pdCA9IG9yaWdpbmFsSW5pdDtcbiAgICB2YXIgcGxhaW5EYXRhID0ge307XG4gICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGxhaW5EYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIShDb21wb25lbnQucHJvdG90eXBlIGluc3RhbmNlb2YgVnVlKSAmJiBPYmplY3Qua2V5cyhwbGFpbkRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHdhcm4oJ0NvbXBvbmVudCBjbGFzcyBtdXN0IGluaGVyaXQgVnVlIG9yIGl0cyBkZXNjZW5kYW50IGNsYXNzICcgK1xuICAgICAgICAgICAgICAgICd3aGVuIGNsYXNzIHByb3BlcnR5IGlzIHVzZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBsYWluRGF0YTtcbn1cblxudmFyICRpbnRlcm5hbEhvb2tzID0gW1xuICAgICdkYXRhJyxcbiAgICAnYmVmb3JlQ3JlYXRlJyxcbiAgICAnY3JlYXRlZCcsXG4gICAgJ2JlZm9yZU1vdW50JyxcbiAgICAnbW91bnRlZCcsXG4gICAgJ2JlZm9yZURlc3Ryb3knLFxuICAgICdkZXN0cm95ZWQnLFxuICAgICdiZWZvcmVVcGRhdGUnLFxuICAgICd1cGRhdGVkJyxcbiAgICAnYWN0aXZhdGVkJyxcbiAgICAnZGVhY3RpdmF0ZWQnLFxuICAgICdyZW5kZXInLFxuICAgICdlcnJvckNhcHR1cmVkJ1xuXTtcbmZ1bmN0aW9uIGNvbXBvbmVudEZhY3RvcnkoQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICBvcHRpb25zLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgQ29tcG9uZW50Ll9jb21wb25lbnRUYWcgfHwgQ29tcG9uZW50Lm5hbWU7XG4gICAgdmFyIHByb3RvID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGludGVybmFsSG9va3MuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHByb3RvW2tleV07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIChvcHRpb25zLm1ldGhvZHMgfHwgKG9wdGlvbnMubWV0aG9kcyA9IHt9KSlba2V5XSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvci5nZXQgfHwgZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgICAgIChvcHRpb25zLmNvbXB1dGVkIHx8IChvcHRpb25zLmNvbXB1dGVkID0ge30pKVtrZXldID0ge1xuICAgICAgICAgICAgICAgIGdldDogZGVzY3JpcHRvci5nZXQsXG4gICAgICAgICAgICAgICAgc2V0OiBkZXNjcmlwdG9yLnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIChvcHRpb25zLm1peGlucyB8fCAob3B0aW9ucy5taXhpbnMgPSBbXSkpLnB1c2goe1xuICAgICAgICBkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdERhdGFGcm9tQ29uc3RydWN0b3IodGhpcywgQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBkZWNvcmF0b3JzID0gQ29tcG9uZW50Ll9fZGVjb3JhdG9yc19fO1xuICAgIGlmIChkZWNvcmF0b3JzKSB7XG4gICAgICAgIGRlY29yYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKG9wdGlvbnMpOyB9KTtcbiAgICAgICAgZGVsZXRlIENvbXBvbmVudC5fX2RlY29yYXRvcnNfXztcbiAgICB9XG4gICAgdmFyIHN1cGVyUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29tcG9uZW50LnByb3RvdHlwZSk7XG4gICAgdmFyIFN1cGVyID0gc3VwZXJQcm90byBpbnN0YW5jZW9mIFZ1ZVxuICAgICAgICA/IHN1cGVyUHJvdG8uY29uc3RydWN0b3JcbiAgICAgICAgOiBWdWU7XG4gICAgdmFyIEV4dGVuZGVkID0gU3VwZXIuZXh0ZW5kKG9wdGlvbnMpO1xuICAgIGZvcndhcmRTdGF0aWNNZW1iZXJzKEV4dGVuZGVkLCBDb21wb25lbnQsIFN1cGVyKTtcbiAgICByZXR1cm4gRXh0ZW5kZWQ7XG59XG52YXIgcmVzZXJ2ZWRQcm9wZXJ0eU5hbWVzID0gW1xuICAgICdjaWQnLFxuICAgICdzdXBlcicsXG4gICAgJ29wdGlvbnMnLFxuICAgICdzdXBlck9wdGlvbnMnLFxuICAgICdleHRlbmRPcHRpb25zJyxcbiAgICAnc2VhbGVkT3B0aW9ucycsXG4gICAgJ2NvbXBvbmVudCcsXG4gICAgJ2RpcmVjdGl2ZScsXG4gICAgJ2ZpbHRlcidcbl07XG5mdW5jdGlvbiBmb3J3YXJkU3RhdGljTWVtYmVycyhFeHRlbmRlZCwgT3JpZ2luYWwsIFN1cGVyKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT3JpZ2luYWwpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHRlbmRlZERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEV4dGVuZGVkLCBrZXkpO1xuICAgICAgICBpZiAoZXh0ZW5kZWREZXNjcmlwdG9yICYmICFleHRlbmRlZERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9yaWdpbmFsLCBrZXkpO1xuICAgICAgICBpZiAoIWhhc1Byb3RvKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnY2lkJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdXBlckRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFN1cGVyLCBrZXkpO1xuICAgICAgICAgICAgaWYgKCFpc1ByaW1pdGl2ZShkZXNjcmlwdG9yLnZhbHVlKVxuICAgICAgICAgICAgICAgICYmIHN1cGVyRGVzY3JpcHRvclxuICAgICAgICAgICAgICAgICYmIHN1cGVyRGVzY3JpcHRvci52YWx1ZSA9PT0gZGVzY3JpcHRvci52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgJiYgcmVzZXJ2ZWRQcm9wZXJ0eU5hbWVzLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgICAgICB3YXJuKFwiU3RhdGljIHByb3BlcnR5IG5hbWUgJ1wiICsga2V5ICsgXCInIGRlY2xhcmVkIG9uIGNsYXNzICdcIiArIE9yaWdpbmFsLm5hbWUgKyBcIicgXCIgK1xuICAgICAgICAgICAgICAgICdjb25mbGljdHMgd2l0aCByZXNlcnZlZCBwcm9wZXJ0eSBuYW1lIG9mIFZ1ZSBpbnRlcm5hbC4gJyArXG4gICAgICAgICAgICAgICAgJ0l0IG1heSBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9yIG9mIHRoZSBjb21wb25lbnQuIENvbnNpZGVyIHJlbmFtaW5nIHRoZSBwcm9wZXJ0eS4nKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXh0ZW5kZWQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRGYWN0b3J5KG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50RmFjdG9yeShDb21wb25lbnQsIG9wdGlvbnMpO1xuICAgIH07XG59XG4oZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVySG9va3Moa2V5cykge1xuICAgICAgICAkaW50ZXJuYWxIb29rcy5wdXNoLmFwcGx5KCRpbnRlcm5hbEhvb2tzLCBrZXlzKTtcbiAgICB9XG4gICAgQ29tcG9uZW50LnJlZ2lzdGVySG9va3MgPSByZWdpc3Rlckhvb2tzO1xufSkoQ29tcG9uZW50IHx8IChDb21wb25lbnQgPSB7fSkpO1xudmFyIENvbXBvbmVudCQxID0gQ29tcG9uZW50O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDb21wb25lbnQkMTtcbmV4cG9ydHMuY3JlYXRlRGVjb3JhdG9yID0gY3JlYXRlRGVjb3JhdG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1jbGFzcy1jb21wb25lbnQvZGlzdC92dWUtY2xhc3MtY29tcG9uZW50LmNvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

eval("/* globals __VUE_SSR_CONTEXT__ */\n\n// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gdGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICB2YXIgZnVuY3Rpb25hbCA9IG9wdGlvbnMuZnVuY3Rpb25hbFxuICAgIHZhciBleGlzdGluZyA9IGZ1bmN0aW9uYWxcbiAgICAgID8gb3B0aW9ucy5yZW5kZXJcbiAgICAgIDogb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICBpZiAoIWZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBleGlzdGluZyhoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"main\"\n  }, [_c('div', {\n    staticClass: \"control-group\"\n  }, [_c('div', {\n    staticClass: \"control-btn\",\n    on: {\n      \"click\": _vm.addBox\n    }\n  }, [_vm._v(\"\\n            Add Box \\n        \")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"control-btn\",\n    on: {\n      \"click\": _vm.clearAll\n    }\n  }, [_vm._v(\"\\n            Clear All\\n        \")])]), _vm._v(\" \"), _vm._m(0), _vm._v(\" \"), _vm._l((_vm.boxes), function(boxNumber) {\n    return _c('div', {\n      directives: [{\n        name: \"draggable\",\n        rawName: \"v-draggable\"\n      }],\n      key: boxNumber,\n      staticClass: \"draggable-container\"\n    }, [_vm._v(\"\\n        Simple Draggable\\n    \")])\n  }), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"draggable\",\n      rawName: \"v-draggable\",\n      value: (_vm.draggableWithHandler),\n      expression: \"draggableWithHandler\"\n    }],\n    staticClass: \"draggable-with-handler\"\n  }, [_vm._v(\"\\n            Use Handler To Drag Me\\n            \"), _c('div', {\n    ref: \"handler\",\n    staticClass: \"handler\"\n  }, [_vm._v(\"\\n                I am Handler\\n            \")])]), _vm._v(\" \"), _c('div', {\n    ref: \"bounder\",\n    staticClass: \"container-for-draggable\"\n  }, [_c('div', {\n    directives: [{\n      name: \"draggable\",\n      rawName: \"v-draggable\",\n      value: (_vm.draggableWithBoundries),\n      expression: \"draggableWithBoundries\"\n    }],\n    staticClass: \"draggable-container\"\n  }, [_vm._v(\"\\n                drag me within my boundries\\n            \")])]), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"draggable\",\n      rawName: \"v-draggable\",\n      value: (_vm.draggableWithResetPosition),\n      expression: \"draggableWithResetPosition\"\n    }],\n    staticClass: \"draggable-with-reset\",\n    on: {\n      \"dblclick\": _vm.onReset\n    }\n  }, [_vm._v(\"\\n                drag me and double click me to reset my position\\n            \")]), _vm._v(\" \"), _vm._m(1)], 2)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('img', {\n    attrs: {\n      \"src\": __webpack_require__(19),\n      \"alt\": \"Vue Logo\"\n    }\n  })])\n},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"autor\"\n  }, [_c('span', [_vm._v(\"Autor\")]), _vm._v(\"\\n            Israel Zablianov\\n        \")])\n}]}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-29ca5193\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9hcHAvYXBwLnZ1ZT81NWRhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQywrQkFBK0IsYUFBYSwwQkFBMEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLGFBQWEsYUFBYSwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtYWluXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29udHJvbC1ncm91cFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbnRyb2wtYnRuXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLmFkZEJveFxuICAgIH1cbiAgfSwgW192bS5fdihcIlxcbiAgICAgICAgICAgIEFkZCBCb3ggXFxuICAgICAgICBcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb250cm9sLWJ0blwiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5jbGVhckFsbFxuICAgIH1cbiAgfSwgW192bS5fdihcIlxcbiAgICAgICAgICAgIENsZWFyIEFsbFxcbiAgICAgICAgXCIpXSldKSwgX3ZtLl92KFwiIFwiKSwgX3ZtLl9tKDApLCBfdm0uX3YoXCIgXCIpLCBfdm0uX2woKF92bS5ib3hlcyksIGZ1bmN0aW9uKGJveE51bWJlcikge1xuICAgIHJldHVybiBfYygnZGl2Jywge1xuICAgICAgZGlyZWN0aXZlczogW3tcbiAgICAgICAgbmFtZTogXCJkcmFnZ2FibGVcIixcbiAgICAgICAgcmF3TmFtZTogXCJ2LWRyYWdnYWJsZVwiXG4gICAgICB9XSxcbiAgICAgIGtleTogYm94TnVtYmVyLFxuICAgICAgc3RhdGljQ2xhc3M6IFwiZHJhZ2dhYmxlLWNvbnRhaW5lclwiXG4gICAgfSwgW192bS5fdihcIlxcbiAgICAgICAgU2ltcGxlIERyYWdnYWJsZVxcbiAgICBcIildKVxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgbmFtZTogXCJkcmFnZ2FibGVcIixcbiAgICAgIHJhd05hbWU6IFwidi1kcmFnZ2FibGVcIixcbiAgICAgIHZhbHVlOiAoX3ZtLmRyYWdnYWJsZVdpdGhIYW5kbGVyKSxcbiAgICAgIGV4cHJlc3Npb246IFwiZHJhZ2dhYmxlV2l0aEhhbmRsZXJcIlxuICAgIH1dLFxuICAgIHN0YXRpY0NsYXNzOiBcImRyYWdnYWJsZS13aXRoLWhhbmRsZXJcIlxuICB9LCBbX3ZtLl92KFwiXFxuICAgICAgICAgICAgVXNlIEhhbmRsZXIgVG8gRHJhZyBNZVxcbiAgICAgICAgICAgIFwiKSwgX2MoJ2RpdicsIHtcbiAgICByZWY6IFwiaGFuZGxlclwiLFxuICAgIHN0YXRpY0NsYXNzOiBcImhhbmRsZXJcIlxuICB9LCBbX3ZtLl92KFwiXFxuICAgICAgICAgICAgICAgIEkgYW0gSGFuZGxlclxcbiAgICAgICAgICAgIFwiKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgcmVmOiBcImJvdW5kZXJcIixcbiAgICBzdGF0aWNDbGFzczogXCJjb250YWluZXItZm9yLWRyYWdnYWJsZVwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcImRyYWdnYWJsZVwiLFxuICAgICAgcmF3TmFtZTogXCJ2LWRyYWdnYWJsZVwiLFxuICAgICAgdmFsdWU6IChfdm0uZHJhZ2dhYmxlV2l0aEJvdW5kcmllcyksXG4gICAgICBleHByZXNzaW9uOiBcImRyYWdnYWJsZVdpdGhCb3VuZHJpZXNcIlxuICAgIH1dLFxuICAgIHN0YXRpY0NsYXNzOiBcImRyYWdnYWJsZS1jb250YWluZXJcIlxuICB9LCBbX3ZtLl92KFwiXFxuICAgICAgICAgICAgICAgIGRyYWcgbWUgd2l0aGluIG15IGJvdW5kcmllc1xcbiAgICAgICAgICAgIFwiKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgZGlyZWN0aXZlczogW3tcbiAgICAgIG5hbWU6IFwiZHJhZ2dhYmxlXCIsXG4gICAgICByYXdOYW1lOiBcInYtZHJhZ2dhYmxlXCIsXG4gICAgICB2YWx1ZTogKF92bS5kcmFnZ2FibGVXaXRoUmVzZXRQb3NpdGlvbiksXG4gICAgICBleHByZXNzaW9uOiBcImRyYWdnYWJsZVdpdGhSZXNldFBvc2l0aW9uXCJcbiAgICB9XSxcbiAgICBzdGF0aWNDbGFzczogXCJkcmFnZ2FibGUtd2l0aC1yZXNldFwiLFxuICAgIG9uOiB7XG4gICAgICBcImRibGNsaWNrXCI6IF92bS5vblJlc2V0XG4gICAgfVxuICB9LCBbX3ZtLl92KFwiXFxuICAgICAgICAgICAgICAgIGRyYWcgbWUgYW5kIGRvdWJsZSBjbGljayBtZSB0byByZXNldCBteSBwb3NpdGlvblxcbiAgICAgICAgICAgIFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfdm0uX20oMSldLCAyKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCBbX2MoJ2ltZycsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJzcmNcIjogcmVxdWlyZShcIi4uLy4uL2Fzc2V0cy9pbWFnZXMvbG9nby12dWUucG5nXCIpLFxuICAgICAgXCJhbHRcIjogXCJWdWUgTG9nb1wiXG4gICAgfVxuICB9KV0pXG59LGZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJhdXRvclwiXG4gIH0sIFtfYygnc3BhbicsIFtfdm0uX3YoXCJBdXRvclwiKV0pLCBfdm0uX3YoXCJcXG4gICAgICAgICAgICBJc3JhZWwgWmFibGlhbm92XFxuICAgICAgICBcIildKVxufV19XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTI5Y2E1MTkzXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMjljYTUxOTNcIixcImhhc1Njb3BlZFwiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvYXBwL2FwcC52dWVcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? factory(exports, __webpack_require__(2), __webpack_require__(20), __webpack_require__(11)) :\n\ttypeof define === 'function' && define.amd ? define(['exports', 'vue', 'vue-class-component', 'reflect-metadata'], factory) :\n\t(factory((global.VuePropertyDecorator = {}),global.Vue,global.VueClassComponent));\n}(this, (function (exports,vue,vueClassComponent) { 'use strict';\n\nvue = vue && vue.hasOwnProperty('default') ? vue['default'] : vue;\nvar vueClassComponent__default = 'default' in vueClassComponent ? vueClassComponent['default'] : vueClassComponent;\n\n/** vue-property-decorator verson 6.0.0 MIT LICENSE copyright 2017 kaorun343 */\n'use strict';\n/**\n * decorator of an inject\n * @param key key\n * @return PropertyDecorator\n */\nfunction Inject(key) {\n    return vueClassComponent.createDecorator(function (componentOptions, k) {\n        if (typeof componentOptions.inject === 'undefined') {\n            componentOptions.inject = {};\n        }\n        if (!Array.isArray(componentOptions.inject)) {\n            componentOptions.inject[k] = key || k;\n        }\n    });\n}\n/**\n * decorator of a provide\n * @param key key\n * @return PropertyDecorator | void\n */\nfunction Provide(key) {\n    return vueClassComponent.createDecorator(function (componentOptions, k) {\n        var provide = componentOptions.provide;\n        if (typeof provide !== 'function' || !provide.managed) {\n            var original_1 = componentOptions.provide;\n            provide = componentOptions.provide = function () {\n                var rv = Object.create((typeof original_1 === 'function' ? original_1.call(this) : original_1) || null);\n                for (var i in provide.managed)\n                    rv[provide.managed[i]] = this[i];\n                return rv;\n            };\n            provide.managed = {};\n        }\n        provide.managed[k] = key || k;\n    });\n}\n/**\n * decorator of model\n * @param  event event name\n * @return PropertyDecorator\n */\nfunction Model(event, options) {\n    if (options === void 0) { options = {}; }\n    return function (target, key) {\n        if (!Array.isArray(options) && typeof options.type === 'undefined') {\n            options.type = Reflect.getMetadata('design:type', target, key);\n        }\n        vueClassComponent.createDecorator(function (componentOptions, k) {\n            (componentOptions.props || (componentOptions.props = {}))[k] = options;\n            componentOptions.model = { prop: k, event: event || k };\n        })(target, key);\n    };\n}\n/**\n * decorator of a prop\n * @param  options the options for the prop\n * @return PropertyDecorator | void\n */\nfunction Prop(options) {\n    if (options === void 0) { options = {}; }\n    return function (target, key) {\n        if (!Array.isArray(options) && typeof options.type === 'undefined') {\n            options.type = Reflect.getMetadata('design:type', target, key);\n        }\n        vueClassComponent.createDecorator(function (componentOptions, k) {\n            (componentOptions.props || (componentOptions.props = {}))[k] = options;\n        })(target, key);\n    };\n}\n/**\n * decorator of a watch function\n * @param  path the path or the expression to observe\n * @param  WatchOption\n * @return MethodDecorator\n */\nfunction Watch(path, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.deep, deep = _a === void 0 ? false : _a, _b = options.immediate, immediate = _b === void 0 ? false : _b;\n    return vueClassComponent.createDecorator(function (componentOptions, handler) {\n        if (typeof componentOptions.watch !== 'object') {\n            componentOptions.watch = Object.create(null);\n        }\n        componentOptions.watch[path] = { handler: handler, deep: deep, immediate: immediate };\n    });\n}\n// Code copied from Vue/src/shared/util.js\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = function (str) { return str.replace(hyphenateRE, '-$1').toLowerCase(); };\n/**\n * decorator of an event-emitter function\n * @param  event The name of the event\n * @return MethodDecorator\n */\nfunction Emit(event) {\n    return function (target, key, descriptor) {\n        key = hyphenate(key);\n        var original = descriptor.value;\n        descriptor.value = function emitter() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            if (original.apply(this, args) !== false)\n                this.$emit.apply(this, [event || key].concat(args));\n        };\n    };\n}\n\nexports.Component = vueClassComponent__default;\nexports.Vue = vue;\nexports.Inject = Inject;\nexports.Provide = Provide;\nexports.Model = Model;\nexports.Prop = Prop;\nexports.Watch = Watch;\nexports.Emit = Emit;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1wcm9wZXJ0eS1kZWNvcmF0b3IvbGliL3Z1ZS1wcm9wZXJ0eS1kZWNvcmF0b3IudW1kLmpzP2EwNjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLENBQUMsa0RBQWtEOztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRSxzQ0FBc0M7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0RBQXNEO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7O0FBRTVELENBQUMiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3Z1ZScpLCByZXF1aXJlKCd2dWUtY2xhc3MtY29tcG9uZW50JyksIHJlcXVpcmUoJ3JlZmxlY3QtbWV0YWRhdGEnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3Z1ZScsICd2dWUtY2xhc3MtY29tcG9uZW50JywgJ3JlZmxlY3QtbWV0YWRhdGEnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLlZ1ZVByb3BlcnR5RGVjb3JhdG9yID0ge30pLGdsb2JhbC5WdWUsZ2xvYmFsLlZ1ZUNsYXNzQ29tcG9uZW50KSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyx2dWUsdnVlQ2xhc3NDb21wb25lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG52dWUgPSB2dWUgJiYgdnVlLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyB2dWVbJ2RlZmF1bHQnXSA6IHZ1ZTtcbnZhciB2dWVDbGFzc0NvbXBvbmVudF9fZGVmYXVsdCA9ICdkZWZhdWx0JyBpbiB2dWVDbGFzc0NvbXBvbmVudCA/IHZ1ZUNsYXNzQ29tcG9uZW50WydkZWZhdWx0J10gOiB2dWVDbGFzc0NvbXBvbmVudDtcblxuLyoqIHZ1ZS1wcm9wZXJ0eS1kZWNvcmF0b3IgdmVyc29uIDYuMC4wIE1JVCBMSUNFTlNFIGNvcHlyaWdodCAyMDE3IGthb3J1bjM0MyAqL1xuJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBkZWNvcmF0b3Igb2YgYW4gaW5qZWN0XG4gKiBAcGFyYW0ga2V5IGtleVxuICogQHJldHVybiBQcm9wZXJ0eURlY29yYXRvclxuICovXG5mdW5jdGlvbiBJbmplY3Qoa2V5KSB7XG4gICAgcmV0dXJuIHZ1ZUNsYXNzQ29tcG9uZW50LmNyZWF0ZURlY29yYXRvcihmdW5jdGlvbiAoY29tcG9uZW50T3B0aW9ucywgaykge1xuICAgICAgICBpZiAodHlwZW9mIGNvbXBvbmVudE9wdGlvbnMuaW5qZWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29tcG9uZW50T3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29tcG9uZW50T3B0aW9ucy5pbmplY3QpKSB7XG4gICAgICAgICAgICBjb21wb25lbnRPcHRpb25zLmluamVjdFtrXSA9IGtleSB8fCBrO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIGRlY29yYXRvciBvZiBhIHByb3ZpZGVcbiAqIEBwYXJhbSBrZXkga2V5XG4gKiBAcmV0dXJuIFByb3BlcnR5RGVjb3JhdG9yIHwgdm9pZFxuICovXG5mdW5jdGlvbiBQcm92aWRlKGtleSkge1xuICAgIHJldHVybiB2dWVDbGFzc0NvbXBvbmVudC5jcmVhdGVEZWNvcmF0b3IoZnVuY3Rpb24gKGNvbXBvbmVudE9wdGlvbnMsIGspIHtcbiAgICAgICAgdmFyIHByb3ZpZGUgPSBjb21wb25lbnRPcHRpb25zLnByb3ZpZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZSAhPT0gJ2Z1bmN0aW9uJyB8fCAhcHJvdmlkZS5tYW5hZ2VkKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxfMSA9IGNvbXBvbmVudE9wdGlvbnMucHJvdmlkZTtcbiAgICAgICAgICAgIHByb3ZpZGUgPSBjb21wb25lbnRPcHRpb25zLnByb3ZpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ2ID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIG9yaWdpbmFsXzEgPT09ICdmdW5jdGlvbicgPyBvcmlnaW5hbF8xLmNhbGwodGhpcykgOiBvcmlnaW5hbF8xKSB8fCBudWxsKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHByb3ZpZGUubWFuYWdlZClcbiAgICAgICAgICAgICAgICAgICAgcnZbcHJvdmlkZS5tYW5hZ2VkW2ldXSA9IHRoaXNbaV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByb3ZpZGUubWFuYWdlZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHByb3ZpZGUubWFuYWdlZFtrXSA9IGtleSB8fCBrO1xuICAgIH0pO1xufVxuLyoqXG4gKiBkZWNvcmF0b3Igb2YgbW9kZWxcbiAqIEBwYXJhbSAgZXZlbnQgZXZlbnQgbmFtZVxuICogQHJldHVybiBQcm9wZXJ0eURlY29yYXRvclxuICovXG5mdW5jdGlvbiBNb2RlbChldmVudCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucykgJiYgdHlwZW9mIG9wdGlvbnMudHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgdGFyZ2V0LCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZ1ZUNsYXNzQ29tcG9uZW50LmNyZWF0ZURlY29yYXRvcihmdW5jdGlvbiAoY29tcG9uZW50T3B0aW9ucywgaykge1xuICAgICAgICAgICAgKGNvbXBvbmVudE9wdGlvbnMucHJvcHMgfHwgKGNvbXBvbmVudE9wdGlvbnMucHJvcHMgPSB7fSkpW2tdID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbXBvbmVudE9wdGlvbnMubW9kZWwgPSB7IHByb3A6IGssIGV2ZW50OiBldmVudCB8fCBrIH07XG4gICAgICAgIH0pKHRhcmdldCwga2V5KTtcbiAgICB9O1xufVxuLyoqXG4gKiBkZWNvcmF0b3Igb2YgYSBwcm9wXG4gKiBAcGFyYW0gIG9wdGlvbnMgdGhlIG9wdGlvbnMgZm9yIHRoZSBwcm9wXG4gKiBAcmV0dXJuIFByb3BlcnR5RGVjb3JhdG9yIHwgdm9pZFxuICovXG5mdW5jdGlvbiBQcm9wKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMpICYmIHR5cGVvZiBvcHRpb25zLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPSBSZWZsZWN0LmdldE1ldGFkYXRhKCdkZXNpZ246dHlwZScsIHRhcmdldCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICB2dWVDbGFzc0NvbXBvbmVudC5jcmVhdGVEZWNvcmF0b3IoZnVuY3Rpb24gKGNvbXBvbmVudE9wdGlvbnMsIGspIHtcbiAgICAgICAgICAgIChjb21wb25lbnRPcHRpb25zLnByb3BzIHx8IChjb21wb25lbnRPcHRpb25zLnByb3BzID0ge30pKVtrXSA9IG9wdGlvbnM7XG4gICAgICAgIH0pKHRhcmdldCwga2V5KTtcbiAgICB9O1xufVxuLyoqXG4gKiBkZWNvcmF0b3Igb2YgYSB3YXRjaCBmdW5jdGlvblxuICogQHBhcmFtICBwYXRoIHRoZSBwYXRoIG9yIHRoZSBleHByZXNzaW9uIHRvIG9ic2VydmVcbiAqIEBwYXJhbSAgV2F0Y2hPcHRpb25cbiAqIEByZXR1cm4gTWV0aG9kRGVjb3JhdG9yXG4gKi9cbmZ1bmN0aW9uIFdhdGNoKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuZGVlcCwgZGVlcCA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hLCBfYiA9IG9wdGlvbnMuaW1tZWRpYXRlLCBpbW1lZGlhdGUgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcbiAgICByZXR1cm4gdnVlQ2xhc3NDb21wb25lbnQuY3JlYXRlRGVjb3JhdG9yKGZ1bmN0aW9uIChjb21wb25lbnRPcHRpb25zLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50T3B0aW9ucy53YXRjaCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudE9wdGlvbnMud2F0Y2ggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudE9wdGlvbnMud2F0Y2hbcGF0aF0gPSB7IGhhbmRsZXI6IGhhbmRsZXIsIGRlZXA6IGRlZXAsIGltbWVkaWF0ZTogaW1tZWRpYXRlIH07XG4gICAgfSk7XG59XG4vLyBDb2RlIGNvcGllZCBmcm9tIFZ1ZS9zcmMvc2hhcmVkL3V0aWwuanNcbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpOyB9O1xuLyoqXG4gKiBkZWNvcmF0b3Igb2YgYW4gZXZlbnQtZW1pdHRlciBmdW5jdGlvblxuICogQHBhcmFtICBldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAqIEByZXR1cm4gTWV0aG9kRGVjb3JhdG9yXG4gKi9cbmZ1bmN0aW9uIEVtaXQoZXZlbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICB2YXIgb3JpZ2luYWwgPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdC5hcHBseSh0aGlzLCBbZXZlbnQgfHwga2V5XS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG59XG5cbmV4cG9ydHMuQ29tcG9uZW50ID0gdnVlQ2xhc3NDb21wb25lbnRfX2RlZmF1bHQ7XG5leHBvcnRzLlZ1ZSA9IHZ1ZTtcbmV4cG9ydHMuSW5qZWN0ID0gSW5qZWN0O1xuZXhwb3J0cy5Qcm92aWRlID0gUHJvdmlkZTtcbmV4cG9ydHMuTW9kZWwgPSBNb2RlbDtcbmV4cG9ydHMuUHJvcCA9IFByb3A7XG5leHBvcnRzLldhdGNoID0gV2F0Y2g7XG5leHBvcnRzLkVtaXQgPSBFbWl0O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1wcm9wZXJ0eS1kZWNvcmF0b3IvbGliL3Z1ZS1wcm9wZXJ0eS1kZWNvcmF0b3IudW1kLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(7);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(25)(\"1874da9a\", content, false, {});\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-29ca5193\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../../node_modules/sass-loader/lib/loader.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./app.vue\", function() {\n     var newContent = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-29ca5193\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../../node_modules/sass-loader/lib/loader.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./app.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9hcHAvYXBwLnZ1ZT81NTk1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsbUNBQW9OO0FBQ3BOO0FBQ0E7QUFDQTtBQUNBLG1FQUFxSDtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdJQUFnSSxtRkFBbUY7QUFDbk4seUlBQXlJLG1GQUFtRjtBQUM1TjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMjljYTUxOTNcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2FwcC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjE4NzRkYTlhXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTI5Y2E1MTkzXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9hcHAudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMjljYTUxOTNcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2FwcC52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0yOWNhNTE5M1wiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9hcHAvYXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(26)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcz82YjJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG52YXIgbGlzdFRvU3R5bGVzID0gcmVxdWlyZSgnLi9saXN0VG9TdHlsZXMnKVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cbnZhciBvcHRpb25zID0gbnVsbFxudmFyIHNzcklkS2V5ID0gJ2RhdGEtdnVlLXNzci1pZCdcblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGFyZW50SWQsIGxpc3QsIF9pc1Byb2R1Y3Rpb24sIF9vcHRpb25zKSB7XG4gIGlzUHJvZHVjdGlvbiA9IF9pc1Byb2R1Y3Rpb25cblxuICBvcHRpb25zID0gX29wdGlvbnMgfHwge31cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBsaXN0KVxuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICAgIGRvbVN0eWxlLnJlZnMtLVxuICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpXG4gICAgfVxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIG5ld0xpc3QpXG4gICAgICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcyA9IFtdXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV1cbiAgICAgIGlmIChkb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXSgpXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzIC8qIEFycmF5PFN0eWxlT2JqZWN0PiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrK1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKVxuICAgICAgfVxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBpZiAoZG9tU3R5bGUucGFydHMubGVuZ3RoID4gaXRlbS5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMubGVuZ3RoID0gaXRlbS5wYXJ0cy5sZW5ndGhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW11cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7IGlkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHMgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKCkge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2NzcydcbiAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpXG4gIHJldHVybiBzdHlsZUVsZW1lbnRcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgdmFyIHVwZGF0ZSwgcmVtb3ZlXG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVsnICsgc3NySWRLZXkgKyAnfj1cIicgKyBvYmouaWQgKyAnXCJdJylcblxuICBpZiAoc3R5bGVFbGVtZW50KSB7XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgIC8vIHNpbXBseSBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG5vb3BcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYnV0IGluIGRldiBtb2RlLlxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIENocm9tZSBjYW4ndCBoYW5kbGUgc291cmNlIG1hcCBpbiBzZXJ2ZXItcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlIHRhZ3MgLSBzb3VyY2UgbWFwcyBpbiA8c3R5bGU+IG9ubHkgd29ya3MgaWYgdGhlIHN0eWxlIHRhZyBpc1xuICAgICAgLy8gY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgZHluYW1pY2FsbHkuIFNvIHdlIHJlbW92ZSB0aGUgc2VydmVyIHJlbmRlcmVkXG4gICAgICAvLyBzdHlsZXMgYW5kIGluamVjdCBuZXcgb25lcy5cbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICBpZiAoaXNPbGRJRSkge1xuICAgIC8vIHVzZSBzaW5nbGV0b24gbW9kZSBmb3IgSUU5LlxuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrXG4gICAgc3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKVxuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpXG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIG11bHRpLXN0eWxlLXRhZyBtb2RlIGluIGFsbCBvdGhlciBjYXNlc1xuICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpXG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudClcbiAgICByZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKG9iailcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuICAgICAgICAgIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG4gICAgICAgICAgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpXG4gICAgfVxuICB9XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJylcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzXG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1xuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlRWxlbWVudCwgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzXG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcFxuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpXG4gIH1cbiAgaWYgKG9wdGlvbnMuc3NySWQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKHNzcklkS2V5LCBvYmouaWQpXG4gIH1cblxuICBpZiAoc291cmNlTWFwKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG4gICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJ1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgJyAqLydcbiAgfVxuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, exports) {

eval("/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qcz9lNmFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n");

/***/ })
/******/ ]);